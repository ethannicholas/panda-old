{
    uses org.pandalanguage.pandac.ast.ASTBitLiteral
    uses org.pandalanguage.pandac.ast.ASTExpression
    uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
    uses org.pandalanguage.pandac.ast.ASTStringLiteral
    uses org.pandalanguage.pandac.tree.BinaryOperationType
    uses org.pandalanguage.pandac.tree.Position
    uses org.pandalanguage.pandac.tree.UnaryOperationType
    uses org.pandalanguage.pandac.tree.VariableType

    class Util {
        constant position := new Position(new File("<internal>"), 0)
    
        @class
        @pre(base >= 2 & base <= 36)
        function parseInt(s:String, base:UInt):UInt64? {
            var result:UInt64 := 0
            constant DIGITS := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            constant DIGITS_LOWER := "0123456789abcdefghijklmnopqrstuvwxyz"
            for i in 0 .. s.length {
                var digit := DIGITS.indexOf(s[i])
                if digit = null {
                    digit := DIGITS_LOWER.indexOf(s[i])
                }
                if digit = null | digit >= base {
                    return null
                }
                result := result * base + digit->(UInt64)
            }
            return result
        }

        @class
        function unescape(text:String):String {
            return text.replace("\\n", "\n").replace("\\r", "\r").replace("\\t", 
                    "\t").replace("\\[", "[").replace("\\]", "]").
                    replace("\\\\", "\\").replace("\\'", "'")
        }

        @class
        function isExternal():Bit {
            return false
        }

        @class
        method main(args:PrimitiveArray<String>) {
            def text := new File(args[0]).readAsString()
            def parser := Test.createParser(text)
            def result := parser.parse()
            Console.writeLine(Parser.getPosition(result[0], text) + ": " + result[1])
        }
    }
}
start:Object = file
    { result := file }
file:Array<ASTNode> = file bodyEntry
    { 
        result := []
        result.addAll(file)
        result.add(bodyEntry)
    }
file:Object = bodyEntry
    { result := [bodyEntry] }
file:Object = WS
    { result := [] }

temp:ASTExpression = NEW type parameters
    { result := new ASTNew(Util.position, type, parameters) }

bodyEntry:ASTNode = usesStatement 
    { result := usesStatement }
bodyEntry:ASTNode = classDeclaration 
    { result := classDeclaration }
bodyEntry:ASTNode = interfaceDeclaration 
    { result := interfaceDeclaration }
bodyEntry:ASTNode = enumDeclaration
    { result := enumDeclaration }
bodyEntry:ASTNode = methodDeclaration
    { result := methodDeclaration }
bodyEntry:ASTNode = functionDeclaration
    { result := functionDeclaration }
bodyEntry:ASTNode = packageDeclaration 
    { result := packageDeclaration }
bodyEntry:ASTNode = instanceDeclaration 
    { result := instanceDeclaration }
bodyEntry:ASTNode = statement
    { result := statement }

packageDeclaration:ASTPackageDeclaration = PACKAGE ^ dottedName
    { result := new ASTPackageDeclaration(Util.position, dottedName) }
dottedName:String = dottedName DOT IDENTIFIER
    { result := dottedName + "." + IDENTIFIER }
dottedName:String = IDENTIFIER
    { result := IDENTIFIER }
usesStatement:ASTUsesDeclaration = USES ^ usesName
    { result := new ASTUsesDeclaration(Util.position, usesName, null) }
usesStatement:ASTUsesDeclaration = USES ^ id:dottedName AS alias:dottedName
    { result := new ASTUsesDeclaration(Util.position, id, alias) }
usesName:String = dottedName DOT STAR
    { result := dottedName + ".*" }
usesName:String = dottedName
    { result := dottedName }
instanceDeclaration:ASTInstanceDeclaration = INSTANCE ^ t:type
    { result := new ASTInstanceDeclaration(new Position(file, pos), t) }

classDeclaration:ASTClass = optionalDoccomment optionalAnnotations CLASS ^ 
        IDENTIFIER optionalGenericsDeclaration optionalTypeDeclaration
        optionalInterfaces LBRACE classMembers RBRACE
    { 
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        for m in body {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := new ASTClass(Util.position, IDENTIFIER, false, 
                optionalDoccomment, optionalAnnotations, 
                optionalTypeDeclaration, optionalInterfaces, 
                optionalGenericsDeclaration, methods, fields, invariants, 
                Util.isExternal())
    }
interfaceDeclaration:ASTClass = optionalDoccomment optionalAnnotations 
        INTERFACE ^ IDENTIFIER optionalGenericsDeclaration 
        optionalTypeDeclarations LBRACE classMembers RBRACE
    { 
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        for m in body {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := new ASTClass(Util.position, IDENTIFIER, true, 
                optionalDoccomment, optionalAnnotations, 
                null, optionalTypeDeclarations, optionalGenericsDeclaration, 
                methods, fields, invariants, Util.isExternal())
    }
enumDeclaration:ASTEnum = optionalDoccomment optionalAnnotations ENUM ^ 
        IDENTIFIER LBRACE enumValues RBRACE
    {
        result := new ASTEnum(Util.position, IDENTIFIER, optionalDoccomment, 
                optionalAnnotations, enumValues, Utils.isExternal())
    }
enumValues:Array<ASTEnumValue> = enumValues enumValue
    {
        result := []
        result.addAll(enumValues)
        result.add(enumValue)
    }
enumValues:Array<ASTEnumValue> = enumValue
    { result := [enumValue] }
enumValue:ASTEnumValue = optionalDoccomment IDENTIFIER
    { 
        result := new ASTEnumValue(Util.position, IDENTIFIER, 
                optionalDoccomment) 
    }
optionalDoccomment:String? = DOCCOMMENT
    { result := DOCCOMMENT }
optionalDoccomment:String? =
    { result := null }
optionalAnnotations:Array<ASTAnnotation>? = annotations
    { result := annotations }
optionalAnnotations:Array<ASTAnnotation>? =
    { result := null }
optionalTypeDeclarations:Array<ASTType>? = COLON typeList
    { result := typeList }
optionalTypeDeclarations:Array<ASTType>? =
    { result := null }
optionalTypeDeclaration:ASTType? = typeDeclaration 
    { result := typeDeclaration }
optionalTypeDeclaration:ASTType? =
    { result := null }
typeDeclaration:ASTType = COLON type
    { result := type }
optionalGenericsDeclaration:Array<ASTType>? = LT genericsDeclarations GT
    { result := typeList }
optionalGenericsDeclaration:Array<ASTType>? =
    { result := null }
genericsDeclarations:Array<ASTTypedIdentifier> = genericsDeclarations COMMA
        optionallyTypedIdentifier
    { 
        result := []
        result.addAll(genericsDeclarations)
        result.add(optionallyTypedIdentifier)
    }
genericsDeclarations:Array<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := optionallyTypedIdentifier }
optionalInterfaces:Array<ASTType>? = LPAREN typeList RPAREN
    { result := typeList }
optionalInterfaces:Array<ASTType>? =
    { result := null }
classMembers:Array<ASTNode> = classMemberList
    { result := classMemberList }
classMembers:Array<ASTNode> =
    { result := null }
classMemberList:Array<ASTNode> = classMemberList classMember
    { 
        result := []
        result.addAll(classMemberList)
        result.add(classMember)
    }
classMemberList:Array<ASTNode> =
    { result := [] }
classMember:ASTNode = invariant 
    { result := invariant }
classMember:ASTNode = methodDeclaration 
    { result := methodDeclaration }
classMember:ASTNode = functionDeclaration 
    { result := functionDeclaration }
classMember:ASTNode = constructorDeclaration 
    { result := constructorDeclaration }
classMember:ASTNode = fieldDeclaration 
    { result := fieldDeclaration }
annotations:Array<ASTAnnotation> = annotations annotation
    {
        result := []
        result.addAll(annotations)
        result.add(annotation)
    }
annotations:Array<ASTAnnotation> = annotation
    { result := [annotation] }
annotation:ASTAnnotation = PROTECTED 
    { result := new ASTSimpleAnnotation(Util.position, "protected") }
annotation:ASTAnnotation = PRIVATE 
    { result := new ASTSimpleAnnotation(Util.position, "private") }
annotation:ASTAnnotation = ATCLASS 
    { result := new ASTSimpleAnnotation(Util.position, "class") }
annotation:ASTAnnotation = THREAD 
    { result := new ASTSimpleAnnotation(Util.position, "thread") }
annotation:ASTAnnotation = ABSTRACT 
    { result := new ASTSimpleAnnotation(Util.position, "abstract") }
annotation:ASTAnnotation = EXTERNAL 
    { result := new ASTSimpleAnnotation(Util.position, "external") }
annotation:ASTAnnotation = OVERRIDE 
    { result := new ASTSimpleAnnotation(Util.position, "override") }
annotation:ASTAnnotation = READONLY 
    { result := new ASTSimpleAnnotation(Util.position, "readonly") }
annotation:ASTAnnotation = LIMITED 
    { result := new ASTSimpleAnnotation(Util.position, "limited") }
annotation:ASTAnnotation = ATSELF 
    { result := new ASTSimpleAnnotation(Util.position, "self") }
annotation:ASTAnnotation = SAFERETURN 
    { result := new ASTSimpleAnnotation(Util.position, "safeReturn") }
annotation:ASTAnnotation = UNSAFEFUNCTION 
    { result := new ASTSimpleAnnotation(Util.position, "unsafeFunction") }
annotation:ASTAnnotation = FINAL 
    { result := new ASTSimpleAnnotation(Util.position, "final") }
annotation:ASTAnnotation = WRAPPER_METHOD 
    { result := new ASTSimpleAnnotation(Util.position, "$wrapperMethod") }
annotation:ASTAnnotation = MATH LPAREN OVERFLOW RPAREN
    { result := new ASTSimpleAnnotation(Util.position, "math(overflow)") }
annotation:ASTAnnotation = PRE LPAREN expression RPAREN
    { result := new ASTPrecondition(Util.position, expression, false) }
annotation:ASTAnnotation = PRE_OR LPAREN expression RPAREN
    { result := new ASTPrecondition(Util.position, expression, true) }
postcondition:ASTAnnotation = POST LPAREN expression RPAREN
    { result := new ASTPostcondition(Util.position, expression, false) }
postcondition:ASTAnnotation = POST_AND LPAREN expression RPAREN
    { result := new ASTPostcondition(Util.position, expression, true) }
postconditions:Array<ASTAnnotation> = postconditions postcondition
    {
        result := []
        result.addAll(postconditions)
        rsult.add(postcondition)
    }
postconditions:Array<ASTAnnotation> = postcondition
    { result := [postcondition] }
optionalPostconditions:Array<ASTAnnotation>? = postconditions
    { result := postconditions }
optionalPostconditions:Array<ASTAnnotation>? = 
    { result := null }

invariant:ASTInvariant = INVARIANT LPAREN expression RPAREN
    { result := new ASTInvariant(Util.position, expression) }

methodDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        METHOD ^ methodName formalParameters optionalTypeDeclaration 
        optionalBlock optionalPostconditions
    {
        result := new ASTMethod(Util.position, methodName, 
                MethodNodeType.METHOD, optionalDoccomment, 
                optionalAnnotations, formalParameters, optionalTypeDeclaration, 
                optionalBlock, optionalPostconditions)
    }
methodName:String = IDENTIFIER 
    { result := IDENTIFIER }
methodName:String = IDENTIFIER ASSIGNMENT
    { result := IDENTIFIER + ":=" }
methodName:String = CONVERT
    { result := "->>" }
methodName:String = SHIFTLEFT
    { result := "<<" }
methodName:String = SHIFTRIGHT
    { result := ">>" }
methodName:String = ADD
    { result := "+" }
methodName:String = SUB
    { result := "-" }
methodName:String = MUL
    { result := "*" }
methodName:String = DIV
    { result := "/" }
methodName:String = INTDIV
    { result := "//" }
methodName:String = REM
    { result := "%" }
methodName:String = AND
    { result := "&" }
methodName:String = OR
    { result := "|" }
methodName:String = XOR
    { result := "~" }
methodName:String = BITWISEAND
    { result := "&&" }
methodName:String = BITWISEOR
    { result := "||" }
methodName:String = BITWISEXOR
    { result := "~~" }
methodName:String = POW
    { result := "^" }
methodName:String = NOT
    { result := "!" }
methodName:String = BITWISENOT
    { result := "!!" }
methodName:String = '[]' WS
    { result := "[]" }
methodName:String = '[..]' WS
    { result := "[..]" }
methodName:String = '[...]' WS
    { result := "[...]" }
methodName:String = '[]:=' WS
    { result := "[]:=" }
methodName:String = '[..]:=' WS
    { result := "[..]:=" }
methodName:String = '[...]:=' WS
    { result := "[...]:=" }
methodName:String = EQ
    { result := "=" }
methodName:String = GT
    { result := ">" }
methodName:String = LT
    { result := "<" }
methodName:String = GTEQ
    { result := ">=" }
methodName:String = LTEQ
    { result := "<=" }
formalParameters:Array<ASTParameter> = LPAREN parameterList RPAREN
    { result := parameterList }
formalParameters:Array<ASTParameter> = LPAREN RPAREN
    { result := [] }
parameterList:Array<ASTParameter> = parameterList COMMA parameter
    {
        result := []
        result.addAll(parameterList)
        result.add(parameter)
    }
parameterList:Array<ASTParameter> = parameter
    { result := [parameter] }
parameter:ASTParameter = optionalVar IDENTIFIER optionalConvert type 
        optionalEllipsis
    { 
        result := new ASTParameter(Util.position, IDENTIFIER, type, optionalVar, 
                optionalConvert, optionalEllipsis)
    }
optionalVar:Bit = VAR
    { result := true }
optionalVar:Bit =
    { result := false }
optionalConvert:Bit = CONVERT
    { result := true }
optionalConvert:Bit = COLON
    { result := false }
optionalEllipsis:Bit = ELLIPSIS
    { result := true }
optionalEllipsis:Bit =
    { result := false }
optionalBlock:Block? = block
    { result := block }
optionalBlock:Block? = 
    { result := null }

functionDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        FUNCTION ^ methodName formalParameters typeDeclaration optionalBlock
        optionalPostconditions
    {
        result := new ASTMethod(Util.position, methodName, 
                MethodNodeType.FUNCTION, optionalDoccomment, 
                optionalAnnotations, formalParameters, typeDeclaration, 
                optionalBlock, optionalPostconditions)
    }

constructorDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        CONSTRUCTOR ^ formalParameters optionalBlock optionalPostconditions
    {
        result := new ASTMethod(Util.position, MethodNode.CONSTRUCTOR_NAME, 
                MethodNodeType.CONSTRUCTOR, optionalDoccomment, 
                optionalAnnotations, formalParameters, null, 
                block, optionalPostconditions)
    }

fieldDeclaration:ASTField = optionalDoccomment optionalAnnotations 
        varDeclaration
    { 
        result := new ASTField(optionalDoccomment, optionalAnnotations, 
                varDeclaration) 
    }

statement:ASTStatement = varDeclaration
    { result := varDeclaration }
statement:ASTStatement = ifStatement
    { result := ifStatement }
statement:ASTStatement = forLoop 
    { result := forLoop }
statement:ASTStatement = whileLoop 
    { result := whileLoop }
statement:ASTStatement = doLoop 
    { result := doLoop }
statement:ASTStatement = loopLoop
    { result := loopLoop }
statement:ASTStatement = expressionOrAssignment
    { result := expressionOrAssignment }
statement:ASTStatement = assertStatement 
    { result := assertStatement }
statement:ASTStatement = switchStatement
    { result := switchStatement }
statement:ASTStatement = tryStatement 
    { result := tryStatement }
statement:ASTStatement = block
    { result := block }

statementOrBlock:ASTStatement = statement 
    { result := statement }
statementOrBlock:ASTStatement = terminalStatement 
    { result := terminalStatement }

varDeclaration:ASTVarDeclaration = VAR varDeclarations
    { 
        result := new ASTVarDeclaration(Util.position, VariableType.VAR, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = DEF varDeclarations
    { 
        result := new ASTVarDeclaration(Util.position, VariableType.DEF, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = PROPERTY varDeclarations
    { 
        result := new ASTVarDeclaration(Util.position, VariableType.PROPERTY, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = CONSTANT varDeclarations
    { 
        result := new ASTVarDeclaration(Util.position, VariableType.CONSTANT, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = VAR varDeclarations ASSIGNMENT expression
    { 
        result := new ASTVarDeclaration(Util.position, VariableType.VAR, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = DEF varDeclarations ASSIGNMENT expression
    { 
        result := new ASTVarDeclaration(Util.position, VariableType.DEF, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = PROPERTY varDeclarations ASSIGNMENT expression
    { 
        result := new ASTVarDeclaration(Util.position, VariableType.PROPERTY, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = CONSTANT varDeclarations ASSIGNMENT expression
    { 
        result := new ASTVarDeclaration(Util.position, VariableType.CONSTANT, 
                varDeclarations, expression) 
    }
varDeclarations:Array<ASTTypedIdentifier> = varDeclarations COMMA 
        optionallyTypedIdentifier
    { 
        result := [] 
        result.addAll(varDeclarations)
        result.add(optionallyTypedIdentifier)
    }
varDeclarations:Array<ASTTypedIdentifier> = optionallyTypedIdentifier
    { resut := optionallyTypedIdentifier }
optionallyTypedIdentifier:ASTTypedIdentifier = IDENTIFIER
    { result := new ASTTypedIdentifier(Util.position, IDENTIFIER, null) }
optionallyTypedIdentifier:ASTTypedIdentifier = IDENTIFIER COLON type
    { result := new ASTTypedIdentifier(Util.position, IDENTIFIER, type) }

ifStatement:ASTIf = IF ^ expression e1:statement optionalElse
    { result := new ASTIf(Util.position, expression, e1, e2) }
optionalElse:ASTStatement? = ELSE statement
    { result := statement }
optionalElse:ASTStatement? =
    { result := null }

forLoop:ASTFor = optionalLabel FOR ^ forTarget IN ^ expression 
        statementOrBlock
    { 
        result := new ASTFor(Util.position, optionalLabel, null, 
                optionallyTypedIdentifier, [expression], statementOrBlock) 
    }
optionalLabel:String? = IDENTIFIER COLON
    { result := IDENTIFIER }
optionalLabel:String? =
    { result := null }
forTarget:ForTarget = optionallyTypedIdentifier
forTarget:ForTarget = optionallyTypedIdentifier COMMA optionallyTypedIdentifier
forTarget:ForTarget = forTuple
forTarget:ForTarget = optionallyTypedIdentifier COMMA forTuple
forTuple:Array<ASTTypedIdentifier> = LPAREN varDeclarations RPAREN
    { result := varDeclarations }

whileLoop:ASTWhile = optionalLabel WHILE ^ expression statementOrBlock
    { 
        result := new ASTWhile(Util.position, optionalLabel, expression, 
                statementOrBlock)
    }

doLoop:ASTDo = optionalLabel DO ^ statementOrBlock WHILE expression
    { 
        result := new ASTWhile(Util.position, optionalLabel, expression, 
                statementOrBlock)
    }

loopLoop:ASTLoop = optionalLabel LOOP ^ statementOrBlock
    { result := new ASTLoop(Util.position, optionalLabel, statementOrBlock) }

expressionOrAssignment:ASTStatement = expression 
    { result := new ASTExpressionStatement(expression) }
expressionOrAssignment:ASTStatement = left:expression assignmentOperator ^
        right:expression
    { result := new ASTAssignment(left, assignmentOperator, right) }
assignmentOperator:BinaryOperationType? = ASSIGNMENT
    { result := null }
assignmentOperator:BinaryOperationType? = ADDEQ
    { result := BinaryOperationType.ADD }
assignmentOperator:BinaryOperationType? = SUBEQ
    { result := BinaryOperationType.SUBTRACT }
assignmentOperator:BinaryOperationType? = MULEQ 
    { result := BinaryOperationType.MULTIPLY }
assignmentOperator:BinaryOperationType? = DIVEQ 
    { result := BinaryOperationType.DIVIDE }
assignmentOperator:BinaryOperationType? = INTDIVEQ 
    { result := BinaryOperationType.INT_DIVIDE }
assignmentOperator:BinaryOperationType? = POWEQ 
    { result := BinaryOperationType.POWER }
assignmentOperator:BinaryOperationType? = REMEQ 
    { result := BinaryOperationType.REMAINDER }
assignmentOperator:BinaryOperationType? = ANDEQ 
    { result := BinaryOperationType.AND }
assignmentOperator:BinaryOperationType? = BITWISEANDEQ 
    { result := BinaryOperationType.BITWISE_AND }
assignmentOperator:BinaryOperationType? = OREQ 
    { result := BinaryOperationType.OR }
assignmentOperator:BinaryOperationType? = BITWISEOREQ 
    { result := BinaryOperationType.BITWISE_OR }
assignmentOperator:BinaryOperationType? = XOREQ 
    { result := BinaryOperationType.XOR }
assignmentOperator:BinaryOperationType? = BITWISEXOREQ 
    { result := BinaryOperationType.BITWISE_OR }
assignmentOperator:BinaryOperationType? = SHIFTLEFTEQ 
    { result := BinaryOperationType.SHIFT_LEFT }
assignmentOperator:BinaryOperationType? = SHIFTRIGHTEQ
    { result := BinaryOperationType.SHIFT_RIGHT }

assertStatement:ASTAssert = ASSERT expression
    { result := new ASTAssert(Util.position, expression, null) }
assertStatement:ASTAssert = ASSERT test:expression COLON ^ msg:expression
    { result := new ASTAssert(Util.position, test, msg) }

switchStatement:ASTSwitch = SWITCH expression LBRACE switchCases RBRACE ^
    { result := new ASTSwitch(Util.position, expression, switchCases, null) }
switchStatement:ASTSwitch = SWITCH expression LBRACE switchCases defaultCase 
        RBRACE ^
    { 
        result := new ASTSwitch(Util.position, expression, switchCases, 
                defaultCase) 
    }
switchCases:Array<ASTSwitchCase> = switchCases switchCase
    { 
        result := []
        result.addAll(switchCases)
        result.add(switchCase)
    }
switchCases:Array<ASTSwitchCase> = switchCase
    { result := [switchCase] }
switchCase:ASTSwitchCase = CASE ^ expressionList COLON statementOrBlock
    {
        result := new ASTSwitchCase(Util.position, expressionList, 
                statementOrBlock)
    }
defaultCase:ASTStatement = DEFAULT COLON statement
    { result := statement }

tryStatement:ASTStatement = TRY ^ statementOrBlock catchBlocks
    { result := new ASTTry(Util.position, statementOrBlock, catchBlocks, null) }
catchBlocks:Array<ASTCatch> = catchBlocks catchBlock
    { 
        result := []
        result.addAll(catchBlocks)
        result.add(catchBlock)
    }
catchBlocks:Array<ASTCatch> = catchBlock
    { result := [catchBlock] }
catchBlock:Array<ASTCatch> = CATCH IDENTIFIER type:typeDeclaration
        statement:statementOrBlock
    { result := new ASTCatch(Util.position, IDENTIFIER, type, statement) }

block:Array<ASTStatement> = LBRACE statements RBRACE
    { result := statements }
block:Array<ASTStatement> = LBRACE RBRACE
    { result := [] }
statements:Array<ASTStatement> = statements statement
    {
        result := []
        result.addAll(statements)
        result.add(statement)
    }
statements:Array<ASTStatement> = statement
    { result := [statement] }

terminalStatement:ASTStatement = returnStatement 
    { result := returnStatement }
terminalStatement:ASTStatement = breakStatement 
    { result := breakStatement }
terminalStatement:ASTStatement = continueStatement 
    { result := continueStatement }
terminalStatement:ASTStatement = throwStatement 
    { result := throwStatement }
terminalStatement:ASTStatement = unreachableStatement 
    { result := unreachableStatement }

returnStatement:ASTReturn = 'return' WS
    { result := new ASTReturn(Util.position, null) }
returnStatement:ASTReturn = 'return' WS_SAMELINE expression ^
    { result := new ASTReturn(Util.position, expression) }

breakStatement:ASTBreak = 'break' 
    { result := new ASTBreak(Util.position, null) }
breakStatement:ASTBreak = 'break' WS_SAMELINE IDENTIFIER ^
    { result := new ASTBreak(Util.position, IDENTIFIER) }

continueStatement:ASTContinue = 'continue' 
    { result := new ASTContinue(Util.position, null) }
continueStatement:ASTContinue = 'continue' WS_SAMELINE IDENTIFIER ^
    { result := new ASTContinue(Util.position, IDENTIFIER) }

throwStatement:ASTThrow = THROW ^ expression
    { result := new ASTThrow(Util.position, expression) }

unreachableStatement:ASTUnreachable = UNREACHABLE
    { result := new ASTUnreachable(Util.position) }

type:ASTType = dottedName optionalQuestion
    { 
        result := new ASTClassType(Util.position, IDENTIFIER, null,
                optionalQuestion) 
    }
type:ASTType = dottedName genericParameters optionalQuestion
    { 
        result := new ASTClassType(Util.position, IDENTIFIER,
                genericParameters, optionalQuestion) 
    }
type:ASTType = LPAREN optionalTypeList RPAREN optionalQuestion
    { result := new ASTTupleType(Util.position, typeList, optionalQuestion) }
type:ASTType = LPAREN optionalTypeList RPAREN YIELDS methodReturnType 
        optionalQuestion
    { 
        result := new ASTMethodType(Util.position, typeList, methodReturnType, 
                true, true, false) 
    }
type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_METHOD methodReturnType 
        optionalQuestion
    { 
        result := new ASTMethodType(Util.position, typeList, methodReturnType, 
                optionalQuestion, false, false) 
    }
type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_IMMUTABLE methodReturnType
        optionalQuestion
    { 
        result := new ASTMethodType(Util.position, typeList, methodReturnType, 
                optionalQuestion, true, true) 
    }
type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_METHOD_IMMUTABLE 
        methodReturnType optionalQuestion
    { 
        result := new ASTMethodType(Util.position, typeList, methodReturnType, 
                optionalQuestion, false, true) 
    }
genericParameters:Array<ASTType> = LT typeList GT
    { result := typeList }
typeList:Array<ASTType> = typeList COMMA type
    { 
        result := []
        result.addAll(typeList)
        result.add(type)
    }
typeList:Array<ASTType> = type
    { result := [type] }
optionalTypeList:Array<ASTType> = typeList
    { result := typeList }
optionalTypeList:Array<ASTType> =
    { result := [] }
optionalQuestion:Bit = QUESTION
    { result := true }
optionalQuestion:Bit = 
    { result := false }
methodReturnType:ASTType? = LPAREN RPAREN
    { result := null }
methodReturnType:ASTType? = LPAREN type RPAREN
    { result := type }

expression:ASTExpression = orExpression
    { result := orExpression }
orExpression:ASTExpression = andExpression 
    { result := comparisonExpression }
orExpression:ASTExpression = orExpression OR andExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.OR, orExpression,
                andExpression)
    }
andExpression:ASTExpression = comparisonExpression 
    { result := comparisonExpression }
andExpression:ASTExpression = andExpression AND comparisonExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.AND, orExpression,
                andExpression)
    }

comparisonExpression:ASTExpression = rangeExpression
    { result := rangeExpression }
comparisonExpression:ASTExpression = comparisonExpression EQ rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression NEQ rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.NOT_EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression IDENTITY 
        rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.IDENTITY, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression NIDENTITY 
        rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.NOT_IDENTITY, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression GT rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.GREATER_THAN, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression LT rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.LESS_THAN, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression GTEQ rangeExpression 
    { 
        result := new ASTBinaryExpression(
                BinaryOperationType.GREATER_THAN_OR_EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression LTEQ rangeExpression 
    { 
        result := new ASTBinaryExpression(
                BinaryOperationType.LESS_THAN_OR_EQUAL, 
                comparisonExpression, rangeExpression)
    }

rangeExpression:ASTExpression = additiveExpression
    { result := additiveExpression }
rangeExpression:ASTExpression = DOTDOT
    { result := new ASTRangeExpression(Util.position, null, null, null, false) }
rangeExpression:ASTExpression = ELLIPSIS
    { result := new ASTRangeExpression(Util.position, null, null, null, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT
    { result := new ASTRangeExpression(Util.position, l, null, null, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS
    { result := new ASTRangeExpression(Util.position, l, null, null, true) }
rangeExpression:ASTExpression = DOTDOT r:additiveExpression
    { result := new ASTRangeExpression(Util.position, null, r, null, false) }
rangeExpression:ASTExpression = ELLIPSIS r:additiveExpression
    { result := new ASTRangeExpression(Util.position, null, r, null, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT r:additiveExpression
    { result := new ASTRangeExpression(Util.position, l, r, null, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS 
        r:additiveExpression
    { result := new ASTRangeExpression(Util.position, l, r, null, true) }
rangeExpression:ASTExpression = DOTDOT BY s:additiveExpression
    { result := new ASTRangeExpression(Util.position, null, null, s, false) }
rangeExpression:ASTExpression = ELLIPSIS BY s:additiveExpression
    { result := new ASTRangeExpression(Util.position, null, null, s, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT BY 
        s:additiveExpression
    { result := new ASTRangeExpression(Util.position, l, null, s, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS BY 
        s:additiveExpression
    { result := new ASTRangeExpression(Util.position, l, null, s, true) }
rangeExpression:ASTExpression = DOTDOT r:additiveExpression BY 
        s:additiveExpression
    { result := new ASTRangeExpression(Util.position, null, r, s, false) }
rangeExpression:ASTExpression = ELLIPSIS r:additiveExpression BY 
        s:additiveExpression
    { result := new ASTRangeExpression(Util.position, null, r, s, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT r:additiveExpression
        BY s:additiveExpression
    { result := new ASTRangeExpression(Util.position, l, r, s, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS 
        r:additiveExpression BY s:additiveExpression
    { result := new ASTRangeExpression(Util.position, l, r, s, true) }

additiveExpression:ASTExpression = multiplicativeExpression
    { result := multiplicativeExpression }
additiveExpression:ASTExpression = additiveExpression ADD 
        multiplicativeExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.ADD, 
                additiveExpression, multiplicativeExpression) 
    }
additiveExpression:ASTExpression = additiveExpression SUB 
        multiplicativeExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.SUBTRACT, 
                additiveExpression, multiplicativeExpression) 
    }
additiveExpression:ASTExpression = additiveExpression BITWISEOR
        multiplicativeExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.BITWISEOR, 
                additiveExpression, multiplicativeExpression) 
    }

multiplicativeExpression:ASTExpression = unaryExpression
    { result := unaryExpression }
multiplicativeExpression:ASTExpression = multiplicativeExpression MUL
        unaryExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.MULTIPLY, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression DIV
        unaryExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.DIVIDE, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression INTDIV
        unaryExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.INT_DIVIDE, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression REM
        unaryExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.REMAINDER, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression SHIFTLEFT
        unaryExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.SHIFT_LEFT, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression SHIFTRIGHT
        unaryExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.SHIFT_RIGHT, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression BITWISEAND
        unaryExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.BITWISE_AND, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression BITWISEXOR
        unaryExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.BITWISE_XOR, 
                multiplicativeExpression, unaryExpression) 
    }

unaryExpression:ASTExpression = exponentExpression
    { result := exponentExpression }
unaryExpression:ASTExpression = SUB exponentExpression
    { 
        result := new ASTUnaryExpression(Util.position, 
                UnaryOperationType.MINUS, exponentExpression) 
    }
unaryExpression:ASTExpression = NOT exponentExpression
    { 
        result := new ASTUnaryExpression(Util.position, UnaryOperationType.NOT,
                exponentExpression) 
    }
unaryExpression:ASTExpression = BITWISENOT exponentExpression
    { 
        result := new ASTUnaryExpression(Util.position, 
                UnaryOperationType.BITWISE_NOT, exponentExpression) 
    }

exponentExpression:ASTExpression = callExpression
    { result := callExpression }
exponentExpression:ASTExpression = callExpression POW exponentExpression
    { 
        result := new ASTBinaryOperation(BinaryOperationType.POWER, 
                callExpression, exponentExpression)
    }

callExpression:ASTExpression = term
callExpression:ASTExpression = callExpression parameters
    { result := new ASTCallExpression(callExpression, parameters) }
callExpression:ASTExpression = callExpression LBRACKET expression RBRACKET
    { result := new ASTIndex(callExpression, parameters) }
callExpression:ASTExpression = callExpression LBRACKET expression RBRACKET
    { result := new ASTIndex(callExpression, expression) }
callExpression:ASTExpression = callExpression DOT IDENTIFIER
    { result := new ASTDotExpression(callExpression, IDENTIFIER) }
callExpression:ASTExpression = callExpression DOT IDENTIFIER
    { result := new ASTDotExpression(callExpression, IDENTIFIER) }
callExpression:ASTExpression = callExpression DOT CLASS
    { result := new ASTDotExpression(callExpression, "$class") }
callExpression:ASTExpression = callExpression DOT CONSTRUCTOR
    { result := new ASTDotExpression(callExpression, "constructor") }
callExpression:ASTExpression = callExpression INSTANCEOF typeExpression
    { 
        result := new ASTArrowExpression(ArrowOperationType.INSTANCE_OF,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression NINSTANCEOF typeExpression
    { 
        result := new ASTArrowExpression(ArrowOperationType.NOT_INSTANCE_OF,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression CAST typeExpression
    { 
        result := new ASTArrowExpression(ArrowOperationType.CAST,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression CONVERT typeExpression
    { 
        result := new ASTArrowExpression(ArrowOperationType.CONVERT,
                callExpression, typeExpression) 
    }
typeExpression:ASTType = type
    { result := type }
typeExpression:ASTType = LPAREN type RPAREN
    { result := type }

parameters:Array<ASTExpression> = LPAREN expressionList RPAREN
    { result := expressionList }
parameters:Array<ASTExpression> = LPAREN RPAREN
    { result := [] }
expressionList:Array<ASTExpression> = expressionList COMMA expression
    { 
        result := [] 
        result.addAll(expressionList)
        result.add(expression)
    }
expressionList:Array<ASTExpression> = expression
    { result := [expression] }

term:ASTExpression = IDENTIFIER
    { result := new ASTIdentifier(Util.position, IDENTIFIER) }
term:ASTExpression = INTEGER
    { result := INTEGER }
term:ASTExpression = STRING
    { result := STRING }
term:ASTExpression = REAL
    { result := REAL }
term:ASTExpression = TRUE
    { result := new ASTBitLiteral(Util.position, true) }
term:ASTExpression = FALSE
    { result := new ASTBitLiteral(Util.position, true) }
term:ASTExpression = NULL
    { result := new ASTNullLiteral(Util.position) }
term:ASTExpression = SELF
    { result := new ASTSelf(Util.position) }
term:ASTExpression = SUPER
    { result := new ASTSuper(Util.position) }
term:ASTExpression = CLASS
    { result := new ASTDotExpression(new ASTSelf(Util.position), "$class") }
term:ASTExpression = LPAREN expressionList RPAREN
    {  
        if expressionList.length = 1
            result := expressionList[0]
        else
            result := new ASTTupleExpression(position, expressionList)
    }
term:ASTExpression = NEW type parameters
    { result := new ASTNew(Util.position, type, parameters) }
term:ASTExpression = LBRACKET expressionList RBRACKET
    { result := new ASTArrayLiteral(Util.position, expressionList) }
term:ASTExpression = LBRACKET RBRACKET
    { result := new ASTArrayLiteral(Util.position, []) }
term:ASTExpression = lambda
    { result := lambda }

lambda:ASTExpression = lambdaParameters YIELDS expression
    { result := new ASTLambda(Util.position, lambdaParameters, expression) }
lambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER
    { 
        result := [new ASTTypedIdentifier(Util.position, IDENTIFIER,
                null)]
    }
lambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER COLON type
    { 
        result := [new ASTTypedIdentifier(Util.position, IDENTIFIER,
                type)]
    }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN RPAREN
    { result := [] }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN untypedLambdaParameters 
        RPAREN
    { result := untypedLambdaParameters }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN typedLambdaParameters RPAREN
    { result := untypedLambdaParameters }
untypedLambdaParameters:Array<ASTTypedIdentifier> = untypedLambdaParameters 
        COMMA IDENTIFIER
    { 
        result := []
        result.addAll(untypedLambdaParameters)
        result.add(new ASTTypedIdentifier(Util.position, IDENTIFIER,
                null))
    }
untypedLambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER
    {  
        result := [new ASTTypedIdentifier(Util.position, IDENTIFIER,
                null)]
    }
typedLambdaParameters:Array<ASTTypedIdentifier> = typedLambdaParameters 
        COMMA IDENTIFIER COLON type
    { 
        result := []
        result.addAll(untypedLambdaParameters)
        result.add(new ASTTypedIdentifier(Util.position, IDENTIFIER,
                type))
    }
typedLambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER COLON type
    {  
        result := [new ASTTypedIdentifier(Util.position, IDENTIFIER,
                type)]
    }

IDENTIFIER:String = identifierText WS
    { result := identifierText }
identifierText:String = identifierStart identifierChars
    { result := identifierStart + identifierChars }
identifierText:String = identifierStart
    { result := identifierStart }
identifierStart:String = char:[a-zA-Z_$]
    { result := char }
identifierChars:String = chars:identifierChars identifierChar
    { result := chars + identifierChar }
identifierChars:String = identifierChar
    { result := identifierChar }
identifierChar:String = char:[a-zA-Z_$0-9]
    { result := identifierChar }

INTEGER:ASTIntegerLiteral = DECIMAL_CHARS WS
    { result := new ASTIntegerLiteral(Util.position, DECIMAL_CHARS->>(UInt64)) }
INTEGER:ASTIntegerLiteral = '0x' HEX_CHARS WS
    { result := new ASTIntegerLiteral(Util.position, Util.parseInt(HEX_CHARS, 16)) }
INTEGER:ASTIntegerLiteral = '0b' BINARY_CHARS WS
    { 
        result := new ASTIntegerLiteral(Util.position, Util.parseInt(BINARY_CHARS, 
                2)) 
    }
DECIMAL_CHARS:String = DECIMAL_CHARS DECIMAL_CHAR
    { result := DECIMAL_CHARS + DECIMAL_CHAR }
DECIMAL_CHARS:String = DECIMAL_CHAR
    { result := DECIMAL_CHAR }
DECIMAL_CHAR:String = digit:[0-9]
    { result := digit }
HEX_CHARS:String = HEX_CHARS HEX_CHAR
    { result := HEX_CHARS + HEX_CHAR }
HEX_CHARS:String = HEX_CHAR
    { result := HEX_CHAR }
HEX_CHAR:String = digit:[0-9A-Fa-f]
    { result := digit }
BINARY_CHARS:String = BINARY_CHARS BINARY_CHAR
    { result := BINARY_CHARS + BINARY_CHAR }
BINARY_CHARS:String = BINARY_CHAR
    { result := BINARY_CHAR }
BINARY_CHAR:String = digit:[01]
    { result := digit }

REAL:ASTRealLiteral = '.' DECIMAL_CHARS WS
    { 
        result := new ASTRealLiteral(Util.position, ("." + 
            DECIMAL_CHARS)->>(Real64))
    }
REAL:ASTRealLiteral = '.' DECIMAL_CHARS EXPONENT WS
    { 
        result := new ASTRealLiteral(Util.position, ("." + 
            DECIMAL_CHARS + EXPONENT)->>(Real64))
    }
REAL:ASTRealLiteral = d1:DECIMAL_CHARS '.' d2:DECIMAL_CHARS WS
    { result := new ASTRealLiteral(Util.position, (d1 + "." + d2)->>(Real64)) }
REAL:ASTRealLiteral = DECIMAL_CHARS EXPONENT WS
    { 
        result := new ASTRealLiteral(Util.position, (DECIMAL_CHARS + 
                EXPONENT)->>(Real64)) 
    }
REAL:ASTRealLiteral = d1:DECIMAL_CHARS '.' d2:DECIMAL_CHARS EXPONENT WS
    { 
        result := new ASTRealLiteral(Util.position, (d1 + "." + d2 + 
                EXPONENT)->>(Real64))
    }
EXPONENT:String = [eE] DECIMAL_CHARS
    { result := "e" + DECIMAL_CHARS }
EXPONENT:String = [eE] sign:[+-] DECIMAL_CHARS
    { result := "e" + sign + DECIMAL_CHARS }

STRING:ASTStringLiteral = STRING_SINGLE WS
    { result := STRING_SINGLE }
STRING:ASTStringLiteral = STRING_DOUBLE WS
    { result := STRING_DOUBLE }
STRING_SINGLE:ASTStringLiteral = ['] STRING_CHARS_SINGLE [']
    { result := new ASTStringLiteral(Util.position, STRING_CHARS_SINGLE) }
STRING_CHARS_SINGLE:String = STRING_CHARS_SINGLE STRING_CHAR_SINGLE
    { result := STRING_CHARS_SINGLE + STRING_CHAR_SINGLE }
STRING_CHARS_SINGLE:String = 
    { result := "" }
STRING_CHAR_SINGLE:String = char:[^'\\]
    { result := char }
STRING_CHAR_SINGLE:String = ESCAPE
    { result := ESCAPE }
STRING_DOUBLE:ASTStringLiteral = ["] STRING_CHARS_DOUBLE ["]
    { result := new ASTStringLiteral(Util.position, STRING_CHARS_DOUBLE) }
STRING_CHARS_DOUBLE:String = STRING_CHARS_DOUBLE STRING_CHAR_DOUBLE
    { result := STRING_CHARS_DOUBLE + STRING_CHAR_DOUBLE }
STRING_CHARS_DOUBLE:String = 
    { result := "" }
STRING_CHAR_DOUBLE:String = char:[^"\\]
    { result := char }
STRING_CHAR_DOUBLE:String = ESCAPE
    { result := ESCAPE }
ESCAPE:String = '\\' char:[nrt'"\]\\]
    { result := Util.unescape('\\' + char) }
ESCAPE:String = '\\{' expression '}'
    { result := '\\' + expression }

PACKAGE = 'package' WS
CLASS = 'class' WS
INTERFACE = 'interface' WS
ENUM = 'enum' WS
USES = 'uses' WS
AS = 'as' WS
METHOD = 'method' WS
FUNCTION = 'function' WS
CONSTRUCTOR = 'constructor' WS
VAR:VariableType = 'var' WS
    { result := VariableType.VAR }
DEF:VariableType = 'def' WS
    { result := VariableType.DEF }
CONSTANT:VariableType = 'constant' WS
    { result := VariableType.CONSTANT }
PROPERTY:VariableType = 'property' WS 
    { result := VariableType.PROPERTY }
PROTECTED = '@protected' WS
PRIVATE = '@private' WS
ATCLASS = '@class' WS
THREAD = '@thread' WS
ABSTRACT = '@abstract' WS
EXTERNAL = '@external' WS
OVERRIDE = '@override' WS
READONLY = '@readonly' WS
LIMITED = '@limited' WS
ATSELF = '@self' WS
SAFERETURN = '@safeReturn' WS
UNSAFEFUNCTION = '@unsafeFunction' WS
FINAL = '@final' WS
WRAPPER_METHOD = '@$wrapperMethod' WS
MATH = '@math' WS
OVERFLOW = 'overflow' WS
INVARIANT = '@invariant' WS
INSTANCE = '@$instance' WS
PRE = '@pre' WS
POST = '@post' WS
PRE_OR = '@preOr' WS
POST_AND = '@postAnd' WS
ATRETURN = '@return' WS
TRUE = 'true' WS
FALSE = 'false' WS
NULL = 'null' WS
SELF = 'self' WS
SUPER = 'super' WS
NEW = 'new' WS
BY = 'by' WS
FOR = 'for' WS
IN = 'in' WS
WHILE = 'while' WS
DO = 'do' WS
LOOP = 'loop' WS
IF = 'if' WS
ELSE = 'else' WS
SWITCH = 'switch' WS
CASE = 'case' WS
DEFAULT = 'default' WS
ASSERT = 'assert' WS
RETURN = 'return' WS
BREAK = 'break' WS
CONTINUE = 'continue' WS
UNREACHABLE = 'unreachable' WS
TRY = 'try' WS
CATCH = 'catch' WS
THROW = 'throw' WS
COLON = ':' WS
LBRACKET = '[' WS
RBRACKET = ']' WS
LBRACE = '{' WS
RBRACE = '}' WS
LPAREN = '(' WS
RPAREN = ')' WS
ADD = '+' WS
SUB = '-' WS
MUL = '*' WS
DIV = '/' WS
REM = '%' WS
INTDIV = '//' WS
AND = '&' WS
OR = '|' WS
XOR = '~' WS
SHIFTLEFT = '<<' WS
SHIFTRIGHT = '>>' WS
BITWISEAND = '&&' WS
BITWISEOR = '||' WS
BITWISEXOR = '~~' WS
POW = '^' WS
EQ = '=' WS
NEQ = '!=' WS
LT = '<' WS
GT = '>' WS
LTEQ = '<=' WS
GTEQ = '>=' WS
IDENTITY = '==' WS
NIDENTITY = '!==' WS
NOT = '!' WS
BITWISENOT = '!!' WS
UNARY_MINUS = '-' WS
ASSIGNMENT = ':=' WS
ADDEQ = '+=' WS 
SUBEQ = '-=' WS
MULEQ = '*=' WS 
DIVEQ = '/=' WS 
INTDIVEQ = '//=' WS 
POWEQ = '^=' WS 
REMEQ = '%=' WS 
ANDEQ = '&=' WS 
BITWISEANDEQ = '&&=' WS 
OREQ = '|=' WS 
BITWISEOREQ = '||=' WS 
XOREQ = '~=' WS 
BITWISEXOREQ = '~~=' WS 
SHIFTLEFTEQ = '<<=' WS 
SHIFTRIGHTEQ = '>>=' WS 
CAST = '->' WS
INSTANCEOF = '-?>' WS
NINSTANCEOF = '-!>' WS
CONVERT = '->>' WS
COMMA  = ',' WS
STAR = '*' WS
DOT = '.' WS
DOTDOT = '..' WS
ELLIPSIS = '...' WS
QUESTION = '?' WS
YIELDS = '=>' WS
YIELDS_METHOD = '=&>' WS
YIELDS_IMMUTABLE = '=>*' WS
YIELDS_METHOD_IMMUTABLE = '=&>*' WS

WS = WS WS_CHAR
WS =
WS_CHAR = [ \r\n\t]
WS_CHAR = COMMENT
WS_SAMELINE = WS_SAMELINE WS_SAMELINE_CHAR
WS_SAMELINE =
WS_SAMELINE_CHAR = [ \t]
WS_SAMELINE_CHAR = SINGLE_LINE_BLOCK_COMMENT
COMMENT = LINE_COMMENT
COMMENT = BLOCK_COMMENT
LINE_COMMENT = '--' LINE_COMMENT_CHARS
LINE_COMMENT_CHARS = LINE_COMMENT_CHARS [^\n]
LINE_COMMENT_CHARS =
BLOCK_COMMENT = '-*' BLOCK_COMMENT_CHARS '*-'
BLOCK_COMMENT_CHARS = BLOCK_COMMENT_CHARS BLOCK_COMMENT_CHAR
BLOCK_COMMENT_CHARS =
BLOCK_COMMENT_CHAR = [^*]
BLOCK_COMMENT_CHAR = '*' [^-]
BLOCK_COMMENT_CHAR = BLOCK_COMMENT
SINGLE_LINE_BLOCK_COMMENT = '-*' SINGLE_LINE_BLOCK_COMMENT_CHARS '*-'
SINGLE_LINE_BLOCK_COMMENT_CHARS = SINGLE_LINE_BLOCK_COMMENT_CHARS 
        SINGLE_LINE_BLOCK_COMMENT_CHAR
SINGLE_LINE_BLOCK_COMMENT_CHARS =
SINGLE_LINE_BLOCK_COMMENT_CHAR = [^*\n\r]
SINGLE_LINE_BLOCK_COMMENT_CHAR = '*' [^-]
SINGLE_LINE_BLOCK_COMMENT_CHAR = SINGLE_LINE_BLOCK_COMMENT
DOCCOMMENT:String = '===' TRAILING_EQUALS DOCCOMMENT_CHARS '===' TRAILING_EQUALS
        WS
    { result := DOCCOMMENT_CHARS }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHARS DOCCOMMENT_CHAR
    { result := DOCCOMMENT_CHARS + DOCCOMMENT_CHAR }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHAR
    { result := DOCCOMMENT_CHAR }
DOCCOMMENT_CHAR:String = char:[^=]
    { result := char }
DOCCOMMENT_CHAR:String = '=' char:[^=]
    { result := "=" + char }
DOCCOMMENT_CHAR:String = '==' char:[^=]
    { result := "==" + char }
TRAILING_EQUALS = TRAILING_EQUALS_CHARS
TRAILING_EQUALS =
TRAILING_EQUALS_CHARS = TRAILING_EQUALS_CHARS '='
TRAILING_EQUALS_CHARS = '='
