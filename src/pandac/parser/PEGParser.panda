
	class Grammar {
		def definitions:ListView<Definition>

		def code:String?

		constructor(definitions:ListView<Definition>, code:String?) {
			self.definitions := definitions
			if code != null
				self.code := code.trim()
			else
				self.code := null
		}@override
		function format(fmt:String):String {
			def code:String
			if self.code != null
				code := "{ \{self.code}}\n"
			else
				code := ""
			return code + definitions.join("\n")
		}}@abstract
	class Term {
		var name:String?

		constructor() {
		}constructor(name:String) {
			self.name := name
		}}class Identifier : Term {
		def text:String

		constructor(text:String) {
			self.text := text
		}constructor(text:Array<String>) {
			self.text := text.join("")
		}@override
		function format(fmt:String):String {
			return text
		}}class Definition {
		def name:String

		def type:String?

		def definition:Options

		constructor(name:String, type:String?, definition:Options) {
			self.name := name
			self.type := type
			self.definition := definition
		}@override
		function format(fmt:String):String {
			def type:String
			if self.type != null
				type := ":" + self.type
			else
				type := ""
			return "\{name}\{type}= \{definition}"
		}}class Options : Term {
		def sequences:ListView<Sequence>

		constructor(sequences:ListView<Sequence>) {
			self.sequences := sequences
		}@override
		function format(fmt:String):String {
			return "(" + sequences.join(" / ") + ")"
		}}class Sequence {
		def terms:ListView<Term>

		def code:String?

		constructor(terms:ListView<Term>, code:String?) {
			self.terms := terms
			if code != null
				self.code := code.trim()
			else
				self.code := null
		}@override
		function format(fmt:String):String {
			def code:String
			if self.code != null
				code := " { \{self.code}}"
			else
				code := ""
			return terms.join(" ") + code
		}}class Range {
		def start:Char

		def end:Char

		constructor(start:Char, end:Char) {
			self.start := start
			self.end := end
		}@override
		function format(fmt:String):String {
			if start = end
				return start->>(String)
			else
				return "\{start}-\{end}"
		}}class CharClass : Term {
		def ranges:ListView<Range>

		constructor(ranges:ListView<Range>) {
			self.ranges := ranges
		}@override
		function format(fmt:String):String {
			return "[" + ranges.join("") + "]"
		}}class Quantifier : Term {
		def term:Term

		constructor(term:Term) {
			self.term := term
		}}class And : Quantifier {
		constructor(name:Identifier?, term:Term) {
			super.constructor(term)
			if name != null
				self.name := name.text
		}@override
		function format(fmt:String):String {
			return "&" + term
		}}class Not : Quantifier {
		constructor(name:Identifier?, term:Term) {
			super.constructor(term)
			if name != null
				self.name := name.text
		}@override
		function format(fmt:String):String {
			return "!" + term
		}}class Optional : Quantifier {
		constructor(term:Term) {
			super.constructor(term)
		}@override
		function format(fmt:String):String {
			return term + "?"
		}}class Star : Quantifier {
		constructor(term:Term) {
			super.constructor(term)
		}@override
		function format(fmt:String):String {
			return term + "*"
		}}class Plus : Quantifier {
		constructor(term:Term) {
			super.constructor(term)
		}@override
		function format(fmt:String):String {
			return term + "+"
		}}class Literal : Term {
		def text:String

		constructor(text:String) {
			self.text := text
		}@override
		function format(fmt:String):String {
			return text
		}}class Cut : Term {
		@override
		function format(fmt:String):String {
			return "^"
		}}class Dot : Term {
		@override
		function format(fmt:String):String {
			return "."
		}}class Util {
		@class
		function unescape(text:String):String {
			return text.replace("\\n", "\n").replace("\\r", "\r").replace("\\t", 
					"\t").replace("\\[", "[").replace("\\]", "]").replace("\\\\", "\\")
		}}
class PEGParser {
def fileName:String
def text:String
def cutStack := new Stack<Bit>()
var maxPos := -1
var maxLiterals := new HashSet<String>()
constructor(file:File) {
    fileName := file.name
    text := file.readAsString()
}
function literal(pos:Int, c:Char):Bit {
    if pos > maxPos { maxPos := pos    maxLiterals.clear() }
    if pos = maxPos maxLiterals.add(escape(c))
	   return pos < text.length & text[pos] = c
}
function literal(pos:Int, start:Char, end:Char):Bit {
    if pos > maxPos { maxPos := pos    maxLiterals.clear() }
    if pos = maxPos maxLiterals.add('[\{escape(start)}-\{escape(end)}]')
	   return pos < text.length & text[pos] >= start & text[pos] <= end
}
function literal(pos:Int, s:String):Bit {
    if pos > maxPos { maxPos := pos    maxLiterals.clear() }
    if pos = maxPos maxLiterals.add(escape(s))
	   return pos + s.length <= text.length & text[pos .. pos + s.length] = s
}
function getPosition(pos:Int):String {
    def stream := new LineNumberInputStream(new MemoryInputStream(text))
    for i in 0 .. pos
        stream.readInt8()
    return stream.line + ':' + stream.column
}
function escape(c:Char):String {
	if c = '\''
		return "\\'"
	if c = '\n'
		return '\\n'
	if c = '\r'
		return '\\r'
	if c = '\t'
		return '\\t'
	if c = '\\'
		return '\\\\'
	if c = '\"'
		return '\\"'
	return c->>(String)
}
function escape(s:String):String {
	def result := new MutableString()
	for c in s
		result.append(escape(c))
	return result->>(String)
}
def stack := new Stack<String>()
-* Spacing Code? Definition+ EndOfFile { { result := new Grammar(definitions, code) }} *-
function Grammar_seq1(pos:Int):(Int, Grammar) {
var code:String? := null
var definitions:Array<Definition> := new Array<Definition>()
var currentPos := pos
def term0 := _Spacing(currentPos)
if term0 = null
return null
currentPos := term0
def term1 := _Code(currentPos)
if term1 != null {
currentPos := term1[0]
code := term1[1]
    }
def term2_temp := _Definition(currentPos)
def term2:(Int, ListView<Definition>)?
if term2_temp != null
term2 := (term2_temp[0], [term2_temp[1]])
else
term2 := null
if term2 = null
return null
currentPos := term2[0]
definitions.addAll(term2[1])
loop {
def term2_temp := _Definition(currentPos)
def term2:(Int, ListView<Definition>)?
if term2_temp != null
term2 := (term2_temp[0], [term2_temp[1]])
else
term2 := null
if term2 = null
break
currentPos := term2[0]
definitions.addAll(term2[1])
    }
def term3 := _EndOfFile(currentPos)
if term3 = null
return null
currentPos := term3
def result:Grammar
{ result := new Grammar(definitions, code) }
return (currentPos, result)
}
-* (Spacing Code? Definition+ EndOfFile { { result := new Grammar(definitions, code) }}) *-
function Grammar_opt0(pos:Int):(Int, Grammar) {
def seq0 := Grammar_seq1(pos    )
if seq0 != null {
return seq0
    }
return null
    }
-* Grammar:Grammar= (Spacing Code? Definition+ EndOfFile { { result := new Grammar(definitions, code) }}) *-
def Grammar_cache := new HashMap<Int, (Int, Grammar)?>()
-- @unsafeFunction
function _Grammar(pos:Int):(Int, Grammar)? {
def cached := Grammar_cache[pos]
if cached != null return cached
def result := Grammar_opt0(pos)
if result != null
Grammar_cache[pos] := result
return result
    }
-* Code *-
function Code_seq2(pos:Int, c_in:Array<String>):(Int, Array<String>)? {
var c:Array<String> := new Array<String>(c_in)
var currentPos := pos
def term0_temp := _Code(currentPos)
def term0:(Int, ListView<String>)?
if term0_temp != null
term0 := (term0_temp[0], [term0_temp[1]])
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
c.addAll(term0[1])
return (currentPos, c        )
    }
-* !} . *-
function Code_seq3(pos:Int, c_in:Array<String>):(Int, Array<String>)? {
var c:Array<String> := new Array<String>(c_in)
var currentPos := pos
def term0:Int?
if literal(currentPos, '}')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1:(Int, Array<String>)?
if currentPos < text.length
term1 := (currentPos + 1, [text[currentPos]->>(String)])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
c.addAll(term1[1])
return (currentPos, c        )
    }
-* (Code / !} .) *-
function Code_opt1(pos:Int, c:Array<String>):(Int, Array<String>) {
def seq0 := Code_seq2(pos, c        )
if seq0 != null {
return seq0 -- equal!
        }
def seq1 := Code_seq3(pos, c        )
if seq1 != null {
return seq1 -- equal!
        }
return null
        }
-* { (Code / !} .)* } Spacing { { result := c.join("") }} *-
function Code_seq4(pos:Int):(Int, String) {
var c:Array<String> := new Array<String>()
var currentPos := pos
def term0:(Int, Array<String>)?
if literal(currentPos, '{')
term0 := (currentPos + 1, ['{'->>(String)])
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
c.addAll(term0[1])
loop {
def term1:(Int, Array<String>)?
term1 := Code_opt1(currentPos, c            )
if term1 = null
break
currentPos := term1[0]
c := new Array<String>(term1[1])
            }
def term2:(Int, Array<String>)?
if literal(currentPos, '}')
term2 := (currentPos + 1, ['}'->>(String)])
else
term2 := null
if term2 = null
return null
currentPos := term2[0]
c.addAll(term2[1])
def term3 := _Spacing(currentPos)
if term3 = null
return null
currentPos := term3
def result:String
{ result := c.join("") }
return (currentPos, result)
        }
-* ({ (Code / !} .)* } Spacing { { result := c.join("") }}) *-
function Code_opt0(pos:Int):(Int, String) {
def seq0 := Code_seq4(pos            )
if seq0 != null {
return seq0
            }
return null
            }
-* Code:String= ({ (Code / !} .)* } Spacing { { result := c.join("") }}) *-
def Code_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _Code(pos:Int):(Int, String)? {
def cached := Code_cache[pos]
if cached != null return cached
def result := Code_opt0(pos)
if result != null
Code_cache[pos] := result
return result
            }
-* COLON Type *-
function Definition_seq2(pos:Int):(Int, String?)? {
var expr:Options
var type:String? := null
var id:Identifier
var currentPos := pos
def term0 := _COLON(currentPos)
if term0 = null
return null
currentPos := term0
def term1 := _Type(currentPos)
if term1 = null
return null
currentPos := term1[0]
type := term1[1]
return (currentPos, type                )
            }
-* (COLON Type) *-
function Definition_opt1(pos:Int):(Int, String?) {
def seq0 := Definition_seq2(pos                )
if seq0 != null {
return seq0 -- equal!
                }
return null
                }
-* Identifier (COLON Type)? EQUAL Expression { { result := new Definition(id.text, type, expr) }} *-
function Definition_seq3(pos:Int):(Int, Definition) {
var expr:Options
var type:String? := null
var id:Identifier
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
id := term0[1]
def term1:(Int, String?)?
term1 := Definition_opt1(currentPos                    )
if term1 != null {
currentPos := term1[0]
type := term1[1]
                    }
def term2 := _EQUAL(currentPos)
if term2 = null
return null
currentPos := term2
def term3 := _Expression(currentPos)
if term3 = null
return null
currentPos := term3[0]
expr := term3[1]
def result:Definition
{ result := new Definition(id.text, type, expr) }
return (currentPos, result)
                }
-* (Identifier (COLON Type)? EQUAL Expression { { result := new Definition(id.text, type, expr) }}) *-
function Definition_opt0(pos:Int):(Int, Definition) {
def seq0 := Definition_seq3(pos                    )
if seq0 != null {
return seq0
                    }
return null
                    }
-* Definition:Definition= (Identifier (COLON Type)? EQUAL Expression { { result := new Definition(id.text, type, expr) }}) *-
def Definition_cache := new HashMap<Int, (Int, Definition)?>()
-- @unsafeFunction
function _Definition(pos:Int):(Int, Definition)? {
def cached := Definition_cache[pos]
if cached != null return cached
def result := Definition_opt0(pos)
if result != null
Definition_cache[pos] := result
return result
                    }
-* COMMA Type *-
function Type_seq2(pos:Int, t_in:Array<String>?):(Int, Array<String>?)? {
var t:Array<String> := new Array<String>(t_in)
var nullable:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _COMMA(currentPos)
if term0 = null
return null
currentPos := term0
def term1_temp := _Type(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
t.addAll(term1[1])
return (currentPos, t                        )
                    }
-* (COMMA Type) *-
function Type_opt1(pos:Int, t:Array<String>?):(Int, Array<String>?) {
def seq0 := Type_seq2(pos, t                        )
if seq0 != null {
return seq0 -- equal!
                        }
return null
                        }
-* COMMA Type *-
function Type_seq5(pos:Int, t_in:Array<String>?):(Int, Array<String>?)? {
var t:Array<String> := new Array<String>(t_in)
var nullable:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _COMMA(currentPos)
if term0 = null
return null
currentPos := term0
def term1_temp := _Type(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
t.addAll(term1[1])
return (currentPos, t                            )
                        }
-* (COMMA Type) *-
function Type_opt4(pos:Int, t:Array<String>?):(Int, Array<String>?) {
def seq0 := Type_seq5(pos, t                            )
if seq0 != null {
return seq0 -- equal!
                            }
return null
                            }
-* LT Type (COMMA Type)* GT *-
function Type_seq6(pos:Int):(Int, Array<String>?)? {
var t:Array<String> := new Array<String>()
var nullable:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _LT(currentPos)
if term0 = null
return null
currentPos := term0
def term1_temp := _Type(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
t.addAll(term1[1])
loop {
def term2:(Int, Array<String>?)?
term2 := Type_opt4(currentPos, t                                )
if term2 = null
break
currentPos := term2[0]
t := new Array<String>?(term2[1])
                                }
def term3 := _GT(currentPos)
if term3 = null
return null
currentPos := term3
return (currentPos, t                                )
                            }
-* (LT Type (COMMA Type)* GT) *-
function Type_opt3(pos:Int):(Int, Array<String>?) {
def seq0 := Type_seq6(pos                                )
if seq0 != null {
return seq0 -- equal!
                                }
return null
                                }
-* Identifier (LT Type (COMMA Type)* GT)? QUESTION? { {
 		var text := id.text.trim 
 		if t.length > 0
 			text += "<\{t.join(',')}>"
 		if nullable != null
 			text += "?"
 		result := text
 	}} *-
function Type_seq7(pos:Int):(Int, String) {
var t:Array<String> := new Array<String>()
var nullable:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
id := term0[1]
def term1:(Int, Array<String>?)?
term1 := Type_opt3(currentPos                                    )
if term1 != null {
currentPos := term1[0]
t.addAll(term1[1])
                                    }
def term2 := _QUESTION(currentPos)
if term2 != null {
currentPos := term2[0]
nullable := term2[1]
                                    }
def result:String
{
 		var text := id.text.trim 
 		if t.length > 0
 			text += "<\{t.join(',')}>"
 		if nullable != null
 			text += "?"
 		result := text
 	}
return (currentPos, result)
                                }
-* (Identifier (LT Type (COMMA Type)* GT)? QUESTION? { {
 		var text := id.text.trim 
 		if t.length > 0
 			text += "<\{t.join(',')}>"
 		if nullable != null
 			text += "?"
 		result := text
 	}}) *-
function Type_opt0(pos:Int):(Int, String) {
def seq0 := Type_seq7(pos                                    )
if seq0 != null {
return seq0
                                    }
return null
                                    }
-* Type:String= (Identifier (LT Type (COMMA Type)* GT)? QUESTION? { {
 		var text := id.text.trim 
 		if t.length > 0
 			text += "<\{t.join(',')}>"
 		if nullable != null
 			text += "?"
 		result := text
 	}}) *-
def Type_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _Type(pos:Int):(Int, String)? {
def cached := Type_cache[pos]
if cached != null return cached
def result := Type_opt0(pos)
if result != null
Type_cache[pos] := result
return result
                                    }
-* SLASH Sequence *-
function Expression_seq2(pos:Int, seq_in:Array<Sequence>):(Int, Array<Sequence>)? {
var seq:Array<Sequence> := new Array<Sequence>(seq_in)
var currentPos := pos
def term0 := _SLASH(currentPos)
if term0 = null
return null
currentPos := term0
def term1_temp := _Sequence(currentPos)
def term1:(Int, ListView<Sequence>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
seq.addAll(term1[1])
return (currentPos, seq                                        )
                                    }
-* (SLASH Sequence) *-
function Expression_opt1(pos:Int, seq:Array<Sequence>):(Int, Array<Sequence>) {
def seq0 := Expression_seq2(pos, seq                                        )
if seq0 != null {
return seq0 -- equal!
                                        }
return null
                                        }
-* Sequence (SLASH Sequence)* { { result := new Options(seq) }} *-
function Expression_seq3(pos:Int):(Int, Options) {
var seq:Array<Sequence> := new Array<Sequence>()
var currentPos := pos
def term0_temp := _Sequence(currentPos)
def term0:(Int, ListView<Sequence>)?
if term0_temp != null
term0 := (term0_temp[0], [term0_temp[1]])
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
seq.addAll(term0[1])
loop {
def term1:(Int, Array<Sequence>)?
term1 := Expression_opt1(currentPos, seq                                            )
if term1 = null
break
currentPos := term1[0]
seq := new Array<Sequence>(term1[1])
                                            }
def result:Options
{ result := new Options(seq) }
return (currentPos, result)
                                        }
-* (Sequence (SLASH Sequence)* { { result := new Options(seq) }}) *-
function Expression_opt0(pos:Int):(Int, Options) {
def seq0 := Expression_seq3(pos                                            )
if seq0 != null {
return seq0
                                            }
return null
                                            }
-* Expression:Options= (Sequence (SLASH Sequence)* { { result := new Options(seq) }}) *-
def Expression_cache := new HashMap<Int, (Int, Options)?>()
-- @unsafeFunction
function _Expression(pos:Int):(Int, Options)? {
def cached := Expression_cache[pos]
if cached != null return cached
def result := Expression_opt0(pos)
if result != null
Expression_cache[pos] := result
return result
                                            }
-* Prefix* Code? { { result := new Sequence(terms, code) }} *-
function Sequence_seq1(pos:Int):(Int, Sequence) {
var code:String? := null
var terms:Array<Term> := new Array<Term>()
var currentPos := pos
loop {
def term0_temp := _Prefix(currentPos)
def term0:(Int, ListView<Term>)?
if term0_temp != null
term0 := (term0_temp[0], [term0_temp[1]])
else
term0 := null
if term0 = null
break
currentPos := term0[0]
terms.addAll(term0[1])
                                                }
def term1 := _Code(currentPos)
if term1 != null {
currentPos := term1[0]
code := term1[1]
                                                }
def result:Sequence
{ result := new Sequence(terms, code) }
return (currentPos, result)
                                            }
-* (Prefix* Code? { { result := new Sequence(terms, code) }}) *-
function Sequence_opt0(pos:Int):(Int, Sequence) {
def seq0 := Sequence_seq1(pos                                                )
if seq0 != null {
return seq0
                                                }
return null
                                                }
-* Sequence:Sequence= (Prefix* Code? { { result := new Sequence(terms, code) }}) *-
def Sequence_cache := new HashMap<Int, (Int, Sequence)?>()
-- @unsafeFunction
function _Sequence(pos:Int):(Int, Sequence)? {
def cached := Sequence_cache[pos]
if cached != null return cached
def result := Sequence_opt0(pos)
if result != null
Sequence_cache[pos] := result
return result
                                                }
-* Identifier COLON *-
function Prefix_seq2(pos:Int):(Int, Identifier?)? {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
id1 := term0[1]
def term1 := _COLON(currentPos)
if term1 = null
return null
currentPos := term1
return (currentPos, id1                                                    )
                                                }
-* (Identifier COLON) *-
function Prefix_opt1(pos:Int):(Int, Identifier?) {
def seq0 := Prefix_seq2(pos                                                    )
if seq0 != null {
return seq0 -- equal!
                                                    }
return null
                                                    }
-* (Identifier COLON)? AND Suffix { { result := new And(id1, s2) }} *-
function Prefix_seq3(pos:Int):(Int, Term) {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0:(Int, Identifier?)?
term0 := Prefix_opt1(currentPos                                                        )
if term0 != null {
currentPos := term0[0]
id1 := term0[1]
                                                        }
def term1 := _AND(currentPos)
if term1 = null
return null
currentPos := term1[0]
a := term1[1]
def term2 := _Suffix(currentPos)
if term2 = null
return null
currentPos := term2[0]
s1 := term2[1]
def result:Term
{ result := new And(id1, s2) }
return (currentPos, result)
                                                    }
-* Identifier COLON *-
function Prefix_seq5(pos:Int):(Int, Identifier?)? {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
id2 := term0[1]
def term1 := _COLON(currentPos)
if term1 = null
return null
currentPos := term1
return (currentPos, id2                                                        )
                                                    }
-* (Identifier COLON) *-
function Prefix_opt4(pos:Int):(Int, Identifier?) {
def seq0 := Prefix_seq5(pos                                                        )
if seq0 != null {
return seq0 -- equal!
                                                        }
return null
                                                        }
-* (Identifier COLON)? NOT Suffix { { result := new Not(id2, s2) }} *-
function Prefix_seq6(pos:Int):(Int, Term) {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0:(Int, Identifier?)?
term0 := Prefix_opt4(currentPos                                                            )
if term0 != null {
currentPos := term0[0]
id2 := term0[1]
                                                            }
def term1 := _NOT(currentPos)
if term1 = null
return null
currentPos := term1[0]
n := term1[1]
def term2 := _Suffix(currentPos)
if term2 = null
return null
currentPos := term2[0]
s2 := term2[1]
def result:Term
{ result := new Not(id2, s2) }
return (currentPos, result)
                                                        }
-* Identifier COLON *-
function Prefix_seq8(pos:Int):(Int, Identifier?)? {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
id3 := term0[1]
def term1 := _COLON(currentPos)
if term1 = null
return null
currentPos := term1
return (currentPos, id3                                                            )
                                                        }
-* (Identifier COLON) *-
function Prefix_opt7(pos:Int):(Int, Identifier?) {
def seq0 := Prefix_seq8(pos                                                            )
if seq0 != null {
return seq0 -- equal!
                                                            }
return null
                                                            }
-* (Identifier COLON)? Suffix { { 
		if id3 != null
			s3.name := id3.text
		result := s3
	}} *-
function Prefix_seq9(pos:Int):(Int, Term) {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0:(Int, Identifier?)?
term0 := Prefix_opt7(currentPos                                                                )
if term0 != null {
currentPos := term0[0]
id3 := term0[1]
                                                                }
def term1 := _Suffix(currentPos)
if term1 = null
return null
currentPos := term1[0]
s3 := term1[1]
def result:Term
{ 
		if id3 != null
			s3.name := id3.text
		result := s3
	}
return (currentPos, result)
                                                            }
-* CUT { { result := new Cut() }} *-
function Prefix_seq10(pos:Int):(Int, Term) {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0 := _CUT(currentPos)
if term0 = null
return null
currentPos := term0
def result:Term
{ result := new Cut() }
return (currentPos, result)
                                                            }
-* ((Identifier COLON)? AND Suffix { { result := new And(id1, s2) }} / (Identifier COLON)? NOT Suffix { { result := new Not(id2, s2) }} / (Identifier COLON)? Suffix { { 
		if id3 != null
			s3.name := id3.text
		result := s3
	}} / CUT { { result := new Cut() }}) *-
function Prefix_opt0(pos:Int):(Int, Term) {
def seq0 := Prefix_seq3(pos                                                                )
if seq0 != null {
return seq0
                                                                }
def seq1 := Prefix_seq6(pos                                                                )
if seq1 != null {
return seq1
                                                                }
def seq2 := Prefix_seq9(pos                                                                )
if seq2 != null {
return seq2
                                                                }
def seq3 := Prefix_seq10(pos                                                                )
if seq3 != null {
return seq3
                                                                }
return null
                                                                }
-* Prefix:Term= ((Identifier COLON)? AND Suffix { { result := new And(id1, s2) }} / (Identifier COLON)? NOT Suffix { { result := new Not(id2, s2) }} / (Identifier COLON)? Suffix { { 
		if id3 != null
			s3.name := id3.text
		result := s3
	}} / CUT { { result := new Cut() }}) *-
def Prefix_cache := new HashMap<Int, (Int, Term)?>()
-- @unsafeFunction
function _Prefix(pos:Int):(Int, Term)? {
def cached := Prefix_cache[pos]
if cached != null return cached
def result := Prefix_opt0(pos)
if result != null
Prefix_cache[pos] := result
return result
                                                                }
-* QUESTION *-
function Suffix_seq2(pos:Int):(Int, Bit?)? {
var q:Bit? := null
var p:Bit? := null
var st:Bit? := null
var value:Term
var currentPos := pos
def term0 := _QUESTION(currentPos)
if term0 = null
return null
currentPos := term0[0]
q := term0[1]
return (currentPos, q                                                                    )
                                                                }
-* STAR *-
function Suffix_seq3(pos:Int):(Int, Bit?)? {
var q:Bit? := null
var p:Bit? := null
var st:Bit? := null
var value:Term
var currentPos := pos
def term0 := _STAR(currentPos)
if term0 = null
return null
currentPos := term0[0]
st := term0[1]
return (currentPos, st                                                                    )
                                                                }
-* PLUS *-
function Suffix_seq4(pos:Int):(Int, Bit?)? {
var q:Bit? := null
var p:Bit? := null
var st:Bit? := null
var value:Term
var currentPos := pos
def term0 := _PLUS(currentPos)
if term0 = null
return null
currentPos := term0[0]
p := term0[1]
return (currentPos, p                                                                    )
                                                                }
-* (QUESTION / STAR / PLUS) *-
function Suffix_opt1(pos:Int):(Int, Bit?, Bit?, Bit?) {
def seq0 := Suffix_seq2(pos                                                                    )
if seq0 != null {
return (seq0[0], seq0[1], null, null                                                                        )
                                                                    }
def seq1 := Suffix_seq3(pos                                                                    )
if seq1 != null {
return (seq1[0], null, seq1[1], null                                                                        )
                                                                    }
def seq2 := Suffix_seq4(pos                                                                    )
if seq2 != null {
return (seq2[0], null, null, seq2[1]                                                                        )
                                                                    }
return null
                                                                    }
-* Primary (QUESTION / STAR / PLUS)? { {
		if q != null
			result := new Optional(value)
		else if st != null
			result := new Star(value)
		else if p != null
			result := new Plus(value)
		else
			result := value
	}} *-
function Suffix_seq5(pos:Int):(Int, Term) {
var q:Bit? := null
var p:Bit? := null
var st:Bit? := null
var value:Term
var currentPos := pos
def term0 := _Primary(currentPos)
if term0 = null
return null
currentPos := term0[0]
value := term0[1]
def term1:(Int, Bit?, Bit?, Bit?)?
term1 := Suffix_opt1(currentPos                                                                        )
if term1 != null {
currentPos := term1[0]
q := term1[1]
st := term1[2]
p := term1[3]
                                                                        }
def result:Term
{
		if q != null
			result := new Optional(value)
		else if st != null
			result := new Star(value)
		else if p != null
			result := new Plus(value)
		else
			result := value
	}
return (currentPos, result)
                                                                    }
-* (Primary (QUESTION / STAR / PLUS)? { {
		if q != null
			result := new Optional(value)
		else if st != null
			result := new Star(value)
		else if p != null
			result := new Plus(value)
		else
			result := value
	}}) *-
function Suffix_opt0(pos:Int):(Int, Term) {
def seq0 := Suffix_seq5(pos                                                                        )
if seq0 != null {
return seq0
                                                                        }
return null
                                                                        }
-* Suffix:Term= (Primary (QUESTION / STAR / PLUS)? { {
		if q != null
			result := new Optional(value)
		else if st != null
			result := new Star(value)
		else if p != null
			result := new Plus(value)
		else
			result := value
	}}) *-
def Suffix_cache := new HashMap<Int, (Int, Term)?>()
-- @unsafeFunction
function _Suffix(pos:Int):(Int, Term)? {
def cached := Suffix_cache[pos]
if cached != null return cached
def result := Suffix_opt0(pos)
if result != null
Suffix_cache[pos] := result
return result
                                                                        }
-* Identifier !EQUAL { { result := i }} *-
function Primary_seq1(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
i := term0[1]
def term1 := _EQUAL(currentPos)
if term1 != null
return null
def result:Term
{ result := i }
return (currentPos, result)
                                                                        }
-* OPEN Expression CLOSE { { result := e }} *-
function Primary_seq2(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _OPEN(currentPos)
if term0 = null
return null
currentPos := term0
def term1 := _Expression(currentPos)
if term1 = null
return null
currentPos := term1[0]
e := term1[1]
def term2 := _CLOSE(currentPos)
if term2 = null
return null
currentPos := term2
def result:Term
{ result := e }
return (currentPos, result)
                                                                        }
-* Literal { { result := l }} *-
function Primary_seq3(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _Literal(currentPos)
if term0 = null
return null
currentPos := term0[0]
l := term0[1]
def result:Term
{ result := l }
return (currentPos, result)
                                                                        }
-* Class { { result := cl }} *-
function Primary_seq4(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _Class(currentPos)
if term0 = null
return null
currentPos := term0[0]
cl := term0[1]
def result:Term
{ result := cl }
return (currentPos, result)
                                                                        }
-* DOT { { result := d }} *-
function Primary_seq5(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _DOT(currentPos)
if term0 = null
return null
currentPos := term0[0]
d := term0[1]
def result:Term
{ result := d }
return (currentPos, result)
                                                                        }
-* (Identifier !EQUAL { { result := i }} / OPEN Expression CLOSE { { result := e }} / Literal { { result := l }} / Class { { result := cl }} / DOT { { result := d }}) *-
function Primary_opt0(pos:Int):(Int, Term) {
def seq0 := Primary_seq1(pos                                                                            )
if seq0 != null {
return seq0
                                                                            }
def seq1 := Primary_seq2(pos                                                                            )
if seq1 != null {
return seq1
                                                                            }
def seq2 := Primary_seq3(pos                                                                            )
if seq2 != null {
return seq2
                                                                            }
def seq3 := Primary_seq4(pos                                                                            )
if seq3 != null {
return seq3
                                                                            }
def seq4 := Primary_seq5(pos                                                                            )
if seq4 != null {
return seq4
                                                                            }
return null
                                                                            }
-* Primary:Term= (Identifier !EQUAL { { result := i }} / OPEN Expression CLOSE { { result := e }} / Literal { { result := l }} / Class { { result := cl }} / DOT { { result := d }}) *-
def Primary_cache := new HashMap<Int, (Int, Term)?>()
-- @unsafeFunction
function _Primary(pos:Int):(Int, Term)? {
def cached := Primary_cache[pos]
if cached != null return cached
def result := Primary_opt0(pos)
if result != null
Primary_cache[pos] := result
return result
                                                                            }
-* IdentStart IdentCont* Spacing { { result := new Identifier(text.join("")) }} *-
function Identifier_seq1(pos:Int):(Int, Identifier) {
var text:Array<String> := new Array<String>()
var currentPos := pos
def term0_temp := _IdentStart(currentPos)
def term0:(Int, ListView<String>)?
if term0_temp != null
term0 := (term0_temp[0], [term0_temp[1]])
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
text.addAll(term0[1])
loop {
def term1_temp := _IdentCont(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
break
currentPos := term1[0]
text.addAll(term1[1])
                                                                                }
def term2 := _Spacing(currentPos)
if term2 = null
return null
currentPos := term2
def result:Identifier
{ result := new Identifier(text.join("")) }
return (currentPos, result)
                                                                            }
-* (IdentStart IdentCont* Spacing { { result := new Identifier(text.join("")) }}) *-
function Identifier_opt0(pos:Int):(Int, Identifier) {
def seq0 := Identifier_seq1(pos                                                                                )
if seq0 != null {
return seq0
                                                                                }
return null
                                                                                }
-* Identifier:Identifier= (IdentStart IdentCont* Spacing { { result := new Identifier(text.join("")) }}) *-
def Identifier_cache := new HashMap<Int, (Int, Identifier)?>()
-- @unsafeFunction
function _Identifier(pos:Int):(Int, Identifier)? {
def cached := Identifier_cache[pos]
if cached != null return cached
def result := Identifier_opt0(pos)
if result != null
Identifier_cache[pos] := result
return result
                                                                                }
-* Char - Char { { result := new Range(start[0], end[0]) }} *-
function Range_seq1(pos:Int):(Int, Range) {
var single:String? := null
var end:String? := null
var start:String? := null
var currentPos := pos
def term0 := _Char(currentPos)
if term0 = null
return null
currentPos := term0[0]
start := term0[1]
def term1:Int?
if literal(currentPos, '-')
term1 := currentPos + 1
else
term1 := null
if term1 = null
return null
currentPos := term1
def term2 := _Char(currentPos)
if term2 = null
return null
currentPos := term2[0]
end := term2[1]
def result:Range
{ result := new Range(start[0], end[0]) }
return (currentPos, result)
                                                                                }
-* Char { { result := new Range(single[0], single[0]) }} *-
function Range_seq2(pos:Int):(Int, Range) {
var single:String? := null
var end:String? := null
var start:String? := null
var currentPos := pos
def term0 := _Char(currentPos)
if term0 = null
return null
currentPos := term0[0]
single := term0[1]
def result:Range
{ result := new Range(single[0], single[0]) }
return (currentPos, result)
                                                                                }
-* (Char - Char { { result := new Range(start[0], end[0]) }} / Char { { result := new Range(single[0], single[0]) }}) *-
function Range_opt0(pos:Int):(Int, Range) {
def seq0 := Range_seq1(pos                                                                                    )
if seq0 != null {
return seq0
                                                                                    }
def seq1 := Range_seq2(pos                                                                                    )
if seq1 != null {
return seq1
                                                                                    }
return null
                                                                                    }
-* Range:Range= (Char - Char { { result := new Range(start[0], end[0]) }} / Char { { result := new Range(single[0], single[0]) }}) *-
def Range_cache := new HashMap<Int, (Int, Range)?>()
-- @unsafeFunction
function _Range(pos:Int):(Int, Range)? {
def cached := Range_cache[pos]
if cached != null return cached
def result := Range_opt0(pos)
if result != null
Range_cache[pos] := result
return result
                                                                                    }
-* !] Range *-
function Class_seq2(pos:Int, ranges_in:Array<Range>):(Int, Array<Range>)? {
var ranges:Array<Range> := new Array<Range>(ranges_in)
var currentPos := pos
def term0:Int?
if literal(currentPos, ']')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1_temp := _Range(currentPos)
def term1:(Int, ListView<Range>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
ranges.addAll(term1[1])
return (currentPos, ranges                                                                                        )
                                                                                    }
-* (!] Range) *-
function Class_opt1(pos:Int, ranges:Array<Range>):(Int, Array<Range>) {
def seq0 := Class_seq2(pos, ranges                                                                                        )
if seq0 != null {
return seq0 -- equal!
                                                                                        }
return null
                                                                                        }
-* [ (!] Range)* ] Spacing { { result := new CharClass(ranges) }} *-
function Class_seq3(pos:Int):(Int, CharClass) {
var ranges:Array<Range> := new Array<Range>()
var currentPos := pos
def term0:Int?
if literal(currentPos, '[')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
loop {
def term1:(Int, Array<Range>)?
term1 := Class_opt1(currentPos, ranges                                                                                            )
if term1 = null
break
currentPos := term1[0]
ranges := new Array<Range>(term1[1])
                                                                                            }
def term2:Int?
if literal(currentPos, ']')
term2 := currentPos + 1
else
term2 := null
if term2 = null
return null
currentPos := term2
def term3 := _Spacing(currentPos)
if term3 = null
return null
currentPos := term3
def result:CharClass
{ result := new CharClass(ranges) }
return (currentPos, result)
                                                                                        }
-* ([ (!] Range)* ] Spacing { { result := new CharClass(ranges) }}) *-
function Class_opt0(pos:Int):(Int, CharClass) {
def seq0 := Class_seq3(pos                                                                                            )
if seq0 != null {
return seq0
                                                                                            }
return null
                                                                                            }
-* Class:CharClass= ([ (!] Range)* ] Spacing { { result := new CharClass(ranges) }}) *-
def Class_cache := new HashMap<Int, (Int, CharClass)?>()
-- @unsafeFunction
function _Class(pos:Int):(Int, CharClass)? {
def cached := Class_cache[pos]
if cached != null return cached
def result := Class_opt0(pos)
if result != null
Class_cache[pos] := result
return result
                                                                                            }
-* [a-zA-Z_] { { result := c }} *-
function IdentStart_seq1(pos:Int):(Int, String) {
var c:String
var currentPos := pos
def term0:(Int, String)?
if literal(currentPos, 'a', 'z') | literal(currentPos, 'A', 'Z') | literal(currentPos, '_')
term0 := (currentPos + 1, text[currentPos]->>(String))
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
c := term0[1]
def result:String
{ result := c }
return (currentPos, result)
                                                                                            }
-* ([a-zA-Z_] { { result := c }}) *-
function IdentStart_opt0(pos:Int):(Int, String) {
def seq0 := IdentStart_seq1(pos                                                                                                )
if seq0 != null {
return seq0
                                                                                                }
return null
                                                                                                }
-* IdentStart:String= ([a-zA-Z_] { { result := c }}) *-
def IdentStart_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _IdentStart(pos:Int):(Int, String)? {
def cached := IdentStart_cache[pos]
if cached != null return cached
def result := IdentStart_opt0(pos)
if result != null
IdentStart_cache[pos] := result
return result
                                                                                                }
-* IdentStart { { result := c1 }} *-
function IdentCont_seq1(pos:Int):(Int, String) {
var c1:String? := null
var c2:String? := null
var currentPos := pos
def term0 := _IdentStart(currentPos)
if term0 = null
return null
currentPos := term0[0]
c1 := term0[1]
def result:String
{ result := c1 }
return (currentPos, result)
                                                                                                }
-* [0-9] { { result := c2 }} *-
function IdentCont_seq2(pos:Int):(Int, String) {
var c1:String? := null
var c2:String? := null
var currentPos := pos
def term0:(Int, String?)?
if literal(currentPos, '0', '9')
term0 := (currentPos + 1, text[currentPos]->>(String))
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
c2 := term0[1]
def result:String
{ result := c2 }
return (currentPos, result)
                                                                                                }
-* (IdentStart { { result := c1 }} / [0-9] { { result := c2 }}) *-
function IdentCont_opt0(pos:Int):(Int, String) {
def seq0 := IdentCont_seq1(pos                                                                                                    )
if seq0 != null {
return seq0
                                                                                                    }
def seq1 := IdentCont_seq2(pos                                                                                                    )
if seq1 != null {
return seq1
                                                                                                    }
return null
                                                                                                    }
-* IdentCont:String= (IdentStart { { result := c1 }} / [0-9] { { result := c2 }}) *-
def IdentCont_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _IdentCont(pos:Int):(Int, String)? {
def cached := IdentCont_cache[pos]
if cached != null return cached
def result := IdentCont_opt0(pos)
if result != null
IdentCont_cache[pos] := result
return result
                                                                                                    }
-* !['] Char *-
function Literal_seq2(pos:Int, text_in:Array<String>?):(Int, Array<String>?)? {
var text:Array<String> := new Array<String>(text_in)
var currentPos := pos
def term0:Int?
if literal(currentPos, '\'')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1_temp := _Char(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
text.addAll(term1[1])
return (currentPos, text                                                                                                        )
                                                                                                    }
-* (!['] Char) *-
function Literal_opt1(pos:Int, text:Array<String>?):(Int, Array<String>?) {
def seq0 := Literal_seq2(pos, text                                                                                                        )
if seq0 != null {
return seq0 -- equal!
                                                                                                        }
return null
                                                                                                        }
-* ['] (!['] Char)* ['] Spacing { { result := new Literal(Util.unescape(text.join(""))) }} *-
function Literal_seq3(pos:Int):(Int, Literal) {
var text:Array<String> := new Array<String>()
var currentPos := pos
def term0:Int?
if literal(currentPos, '\'')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
loop {
def term1:(Int, Array<String>?)?
term1 := Literal_opt1(currentPos, text                                                                                                            )
if term1 = null
break
currentPos := term1[0]
text := new Array<String>?(term1[1])
                                                                                                            }
def term2:Int?
if literal(currentPos, '\'')
term2 := currentPos + 1
else
term2 := null
if term2 = null
return null
currentPos := term2
def term3 := _Spacing(currentPos)
if term3 = null
return null
currentPos := term3
def result:Literal
{ result := new Literal(Util.unescape(text.join(""))) }
return (currentPos, result)
                                                                                                        }
-* !["] Char *-
function Literal_seq5(pos:Int, text_in:Array<String>?):(Int, Array<String>?)? {
var text:Array<String> := new Array<String>(text_in)
var currentPos := pos
def term0:Int?
if literal(currentPos, '\"')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1_temp := _Char(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
text.addAll(term1[1])
return (currentPos, text                                                                                                            )
                                                                                                        }
-* (!["] Char) *-
function Literal_opt4(pos:Int, text:Array<String>?):(Int, Array<String>?) {
def seq0 := Literal_seq5(pos, text                                                                                                            )
if seq0 != null {
return seq0 -- equal!
                                                                                                            }
return null
                                                                                                            }
-* ["] (!["] Char)* ["] Spacing { { result := new Literal(Util.unescape(text.join(""))) }} *-
function Literal_seq6(pos:Int):(Int, Literal) {
var text:Array<String> := new Array<String>()
var currentPos := pos
def term0:Int?
if literal(currentPos, '\"')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
loop {
def term1:(Int, Array<String>?)?
term1 := Literal_opt4(currentPos, text                                                                                                                )
if term1 = null
break
currentPos := term1[0]
text := new Array<String>?(term1[1])
                                                                                                                }
def term2:Int?
if literal(currentPos, '\"')
term2 := currentPos + 1
else
term2 := null
if term2 = null
return null
currentPos := term2
def term3 := _Spacing(currentPos)
if term3 = null
return null
currentPos := term3
def result:Literal
{ result := new Literal(Util.unescape(text.join(""))) }
return (currentPos, result)
                                                                                                            }
-* (['] (!['] Char)* ['] Spacing { { result := new Literal(Util.unescape(text.join(""))) }} / ["] (!["] Char)* ["] Spacing { { result := new Literal(Util.unescape(text.join(""))) }}) *-
function Literal_opt0(pos:Int):(Int, Literal) {
def seq0 := Literal_seq3(pos                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                }
def seq1 := Literal_seq6(pos                                                                                                                )
if seq1 != null {
return seq1
                                                                                                                }
return null
                                                                                                                }
-* Literal:Literal= (['] (!['] Char)* ['] Spacing { { result := new Literal(Util.unescape(text.join(""))) }} / ["] (!["] Char)* ["] Spacing { { result := new Literal(Util.unescape(text.join(""))) }}) *-
def Literal_cache := new HashMap<Int, (Int, Literal)?>()
-- @unsafeFunction
function _Literal(pos:Int):(Int, Literal)? {
def cached := Literal_cache[pos]
if cached != null return cached
def result := Literal_opt0(pos)
if result != null
Literal_cache[pos] := result
return result
                                                                                                                }
-* . Spacing { { result := new Dot() }} *-
function DOT_seq1(pos:Int):(Int, Dot) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '.')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Dot
{ result := new Dot() }
return (currentPos, result)
                                                                                                                }
-* (. Spacing { { result := new Dot() }}) *-
function DOT_opt0(pos:Int):(Int, Dot) {
def seq0 := DOT_seq1(pos                                                                                                                    )
if seq0 != null {
return seq0
                                                                                                                    }
return null
                                                                                                                    }
-* DOT:Dot= (. Spacing { { result := new Dot() }}) *-
def DOT_cache := new HashMap<Int, (Int, Dot)?>()
-- @unsafeFunction
function _DOT(pos:Int):(Int, Dot)? {
def cached := DOT_cache[pos]
if cached != null return cached
def result := DOT_opt0(pos)
if result != null
DOT_cache[pos] := result
return result
                                                                                                                    }
-* \ [nrt'"[]\] { { result := Util.unescape("\\" + char1) }} *-
function Char_seq1(pos:Int):(Int, String) {
var char2:String? := null
var char1:String? := null
var currentPos := pos
def term0:Int?
if literal(currentPos, '\\')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1:(Int, String?)?
if literal(currentPos, 'n') | literal(currentPos, 'r') | literal(currentPos, 't') | literal(currentPos, '\'') | literal(currentPos, '\"') | literal(currentPos, '[') | literal(currentPos, ']') | literal(currentPos, '\\')
term1 := (currentPos + 1, text[currentPos]->>(String))
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
char1 := term1[1]
def result:String
{ result := Util.unescape("\\" + char1) }
return (currentPos, result)
                                                                                                                    }
-* !\ . { { result := char2 }} *-
function Char_seq2(pos:Int):(Int, String) {
var char2:String? := null
var char1:String? := null
var currentPos := pos
def term0:Int?
if literal(currentPos, '\\')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1:(Int, String?)?
if currentPos < text.length
term1 := (currentPos + 1, text[currentPos]->>(String))
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
char2 := term1[1]
def result:String
{ result := char2 }
return (currentPos, result)
                                                                                                                    }
-* (\ [nrt'"[]\] { { result := Util.unescape("\\" + char1) }} / !\ . { { result := char2 }}) *-
function Char_opt0(pos:Int):(Int, String) {
def seq0 := Char_seq1(pos                                                                                                                        )
if seq0 != null {
return seq0
                                                                                                                        }
def seq1 := Char_seq2(pos                                                                                                                        )
if seq1 != null {
return seq1
                                                                                                                        }
return null
                                                                                                                        }
-* Char:String= (\ [nrt'"[]\] { { result := Util.unescape("\\" + char1) }} / !\ . { { result := char2 }}) *-
def Char_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _Char(pos:Int):(Int, String)? {
def cached := Char_cache[pos]
if cached != null return cached
def result := Char_opt0(pos)
if result != null
Char_cache[pos] := result
return result
                                                                                                                        }
-* = Spacing *-
function EQUAL_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '=')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                        }
-* (= Spacing) *-
function EQUAL_opt0(pos:Int):Int? {
def seq0 := EQUAL_seq1(pos                                                                                                                            )
if seq0 != null {
return seq0 -- equal!
                                                                                                                            }
return null
                                                                                                                            }
-* EQUAL= (= Spacing) *-
def EQUAL_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _EQUAL(pos:Int):Int? {
def cached := EQUAL_cache[pos]
if cached != null return cached
def result := EQUAL_opt0(pos)
if result != null
EQUAL_cache[pos] := result
return result
                                                                                                                            }
-* / Spacing *-
function SLASH_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '/')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                            }
-* (/ Spacing) *-
function SLASH_opt0(pos:Int):Int? {
def seq0 := SLASH_seq1(pos                                                                                                                                )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                }
return null
                                                                                                                                }
-* SLASH= (/ Spacing) *-
def SLASH_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _SLASH(pos:Int):Int? {
def cached := SLASH_cache[pos]
if cached != null return cached
def result := SLASH_opt0(pos)
if result != null
SLASH_cache[pos] := result
return result
                                                                                                                                }
-* & Spacing { { result := true }} *-
function AND_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '&')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                }
-* (& Spacing { { result := true }}) *-
function AND_opt0(pos:Int):(Int, Bit) {
def seq0 := AND_seq1(pos                                                                                                                                    )
if seq0 != null {
return seq0
                                                                                                                                    }
return null
                                                                                                                                    }
-* AND:Bit= (& Spacing { { result := true }}) *-
def AND_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _AND(pos:Int):(Int, Bit)? {
def cached := AND_cache[pos]
if cached != null return cached
def result := AND_opt0(pos)
if result != null
AND_cache[pos] := result
return result
                                                                                                                                    }
-* ! Spacing { { result := true }} *-
function NOT_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '!')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                    }
-* (! Spacing { { result := true }}) *-
function NOT_opt0(pos:Int):(Int, Bit) {
def seq0 := NOT_seq1(pos                                                                                                                                        )
if seq0 != null {
return seq0
                                                                                                                                        }
return null
                                                                                                                                        }
-* NOT:Bit= (! Spacing { { result := true }}) *-
def NOT_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _NOT(pos:Int):(Int, Bit)? {
def cached := NOT_cache[pos]
if cached != null return cached
def result := NOT_opt0(pos)
if result != null
NOT_cache[pos] := result
return result
                                                                                                                                        }
-* ^ Spacing *-
function CUT_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '^')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                        }
-* (^ Spacing) *-
function CUT_opt0(pos:Int):Int? {
def seq0 := CUT_seq1(pos                                                                                                                                            )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                            }
return null
                                                                                                                                            }
-* CUT= (^ Spacing) *-
def CUT_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _CUT(pos:Int):Int? {
def cached := CUT_cache[pos]
if cached != null return cached
def result := CUT_opt0(pos)
if result != null
CUT_cache[pos] := result
return result
                                                                                                                                            }
-* < Spacing *-
function LT_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '<')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                            }
-* (< Spacing) *-
function LT_opt0(pos:Int):Int? {
def seq0 := LT_seq1(pos                                                                                                                                                )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                }
return null
                                                                                                                                                }
-* LT= (< Spacing) *-
def LT_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _LT(pos:Int):Int? {
def cached := LT_cache[pos]
if cached != null return cached
def result := LT_opt0(pos)
if result != null
LT_cache[pos] := result
return result
                                                                                                                                                }
-* > Spacing *-
function GT_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '>')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                }
-* (> Spacing) *-
function GT_opt0(pos:Int):Int? {
def seq0 := GT_seq1(pos                                                                                                                                                    )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                    }
return null
                                                                                                                                                    }
-* GT= (> Spacing) *-
def GT_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _GT(pos:Int):Int? {
def cached := GT_cache[pos]
if cached != null return cached
def result := GT_opt0(pos)
if result != null
GT_cache[pos] := result
return result
                                                                                                                                                    }
-* , Spacing *-
function COMMA_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, ',')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                    }
-* (, Spacing) *-
function COMMA_opt0(pos:Int):Int? {
def seq0 := COMMA_seq1(pos                                                                                                                                                        )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                        }
return null
                                                                                                                                                        }
-* COMMA= (, Spacing) *-
def COMMA_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _COMMA(pos:Int):Int? {
def cached := COMMA_cache[pos]
if cached != null return cached
def result := COMMA_opt0(pos)
if result != null
COMMA_cache[pos] := result
return result
                                                                                                                                                        }
-* * Spacing { { result := true }} *-
function STAR_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '*')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                                        }
-* (* Spacing { { result := true }}) *-
function STAR_opt0(pos:Int):(Int, Bit) {
def seq0 := STAR_seq1(pos                                                                                                                                                            )
if seq0 != null {
return seq0
                                                                                                                                                            }
return null
                                                                                                                                                            }
-* STAR:Bit= (* Spacing { { result := true }}) *-
def STAR_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _STAR(pos:Int):(Int, Bit)? {
def cached := STAR_cache[pos]
if cached != null return cached
def result := STAR_opt0(pos)
if result != null
STAR_cache[pos] := result
return result
                                                                                                                                                            }
-* + Spacing { { result := true }} *-
function PLUS_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '+')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                                            }
-* (+ Spacing { { result := true }}) *-
function PLUS_opt0(pos:Int):(Int, Bit) {
def seq0 := PLUS_seq1(pos                                                                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                                                                }
return null
                                                                                                                                                                }
-* PLUS:Bit= (+ Spacing { { result := true }}) *-
def PLUS_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _PLUS(pos:Int):(Int, Bit)? {
def cached := PLUS_cache[pos]
if cached != null return cached
def result := PLUS_opt0(pos)
if result != null
PLUS_cache[pos] := result
return result
                                                                                                                                                                }
-* ( Spacing *-
function OPEN_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '(')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                                }
-* (( Spacing) *-
function OPEN_opt0(pos:Int):Int? {
def seq0 := OPEN_seq1(pos                                                                                                                                                                    )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                    }
return null
                                                                                                                                                                    }
-* OPEN= (( Spacing) *-
def OPEN_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _OPEN(pos:Int):Int? {
def cached := OPEN_cache[pos]
if cached != null return cached
def result := OPEN_opt0(pos)
if result != null
OPEN_cache[pos] := result
return result
                                                                                                                                                                    }
-* ) Spacing *-
function CLOSE_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, ')')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                                    }
-* () Spacing) *-
function CLOSE_opt0(pos:Int):Int? {
def seq0 := CLOSE_seq1(pos                                                                                                                                                                        )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                        }
return null
                                                                                                                                                                        }
-* CLOSE= () Spacing) *-
def CLOSE_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _CLOSE(pos:Int):Int? {
def cached := CLOSE_cache[pos]
if cached != null return cached
def result := CLOSE_opt0(pos)
if result != null
CLOSE_cache[pos] := result
return result
                                                                                                                                                                        }
-* : Spacing *-
function COLON_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, ':')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                                        }
-* (: Spacing) *-
function COLON_opt0(pos:Int):Int? {
def seq0 := COLON_seq1(pos                                                                                                                                                                            )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                            }
return null
                                                                                                                                                                            }
-* COLON= (: Spacing) *-
def COLON_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _COLON(pos:Int):Int? {
def cached := COLON_cache[pos]
if cached != null return cached
def result := COLON_opt0(pos)
if result != null
COLON_cache[pos] := result
return result
                                                                                                                                                                            }
-* ? Spacing { { result := true }} *-
function QUESTION_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '?')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                                                            }
-* (? Spacing { { result := true }}) *-
function QUESTION_opt0(pos:Int):(Int, Bit) {
def seq0 := QUESTION_seq1(pos                                                                                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                                                                                }
return null
                                                                                                                                                                                }
-* QUESTION:Bit= (? Spacing { { result := true }}) *-
def QUESTION_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _QUESTION(pos:Int):(Int, Bit)? {
def cached := QUESTION_cache[pos]
if cached != null return cached
def result := QUESTION_opt0(pos)
if result != null
QUESTION_cache[pos] := result
return result
                                                                                                                                                                                }
-* Space *-
function Spacing_seq2(pos:Int):Int? {
var currentPos := pos
def term0 := _Space(currentPos)
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                }
-* Comment *-
function Spacing_seq3(pos:Int):Int? {
var currentPos := pos
def term0 := _Comment(currentPos)
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                }
-* (Space / Comment) *-
function Spacing_opt1(pos:Int):Int? {
def seq0 := Spacing_seq2(pos                                                                                                                                                                                    )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                                    }
def seq1 := Spacing_seq3(pos                                                                                                                                                                                    )
if seq1 != null {
return seq1 -- equal!
                                                                                                                                                                                    }
return null
                                                                                                                                                                                    }
-* (Space / Comment)* *-
function Spacing_seq4(pos:Int):Int? {
var currentPos := pos
loop {
def term0:Int?
term0 := Spacing_opt1(currentPos                                                                                                                                                                                        )
if term0 = null
break
currentPos := term0
                                                                                                                                                                                        }
return currentPos
                                                                                                                                                                                    }
-* ((Space / Comment)*) *-
function Spacing_opt0(pos:Int):Int? {
def seq0 := Spacing_seq4(pos                                                                                                                                                                                        )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                                        }
return null
                                                                                                                                                                                        }
-* Spacing= ((Space / Comment)*) *-
def Spacing_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _Spacing(pos:Int):Int? {
def cached := Spacing_cache[pos]
if cached != null return cached
def result := Spacing_opt0(pos)
if result != null
Spacing_cache[pos] := result
return result
                                                                                                                                                                                        }
-* !EndOfLine . *-
function Comment_seq2(pos:Int):Int? {
var currentPos := pos
def term0 := _EndOfLine(currentPos)
if term0 != null
return null
def term1:Int?
if currentPos < text.length
term1 := currentPos + 1
else
term1 := null
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                                                        }
-* (!EndOfLine .) *-
function Comment_opt1(pos:Int):Int? {
def seq0 := Comment_seq2(pos                                                                                                                                                                                            )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                                            }
return null
                                                                                                                                                                                            }
-* # (!EndOfLine .)* EndOfLine *-
function Comment_seq3(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '#')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
loop {
def term1:Int?
term1 := Comment_opt1(currentPos                                                                                                                                                                                                )
if term1 = null
break
currentPos := term1
                                                                                                                                                                                                }
def term2 := _EndOfLine(currentPos)
if term2 = null
return null
currentPos := term2
return currentPos
                                                                                                                                                                                            }
-* (# (!EndOfLine .)* EndOfLine) *-
function Comment_opt0(pos:Int):Int? {
def seq0 := Comment_seq3(pos                                                                                                                                                                                                )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                                                }
return null
                                                                                                                                                                                                }
-* Comment= (# (!EndOfLine .)* EndOfLine) *-
def Comment_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _Comment(pos:Int):Int? {
def cached := Comment_cache[pos]
if cached != null return cached
def result := Comment_opt0(pos)
if result != null
Comment_cache[pos] := result
return result
                                                                                                                                                                                                }
-*   *-
function Space_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, ' ')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                }
-* 	 *-
function Space_seq2(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '\t')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                }
-* EndOfLine *-
function Space_seq3(pos:Int):Int? {
var currentPos := pos
def term0 := _EndOfLine(currentPos)
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                }
-* (  / 	 / EndOfLine) *-
function Space_opt0(pos:Int):Int? {
def seq0 := Space_seq1(pos                                                                                                                                                                                                    )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                                                    }
def seq1 := Space_seq2(pos                                                                                                                                                                                                    )
if seq1 != null {
return seq1 -- equal!
                                                                                                                                                                                                    }
def seq2 := Space_seq3(pos                                                                                                                                                                                                    )
if seq2 != null {
return seq2 -- equal!
                                                                                                                                                                                                    }
return null
                                                                                                                                                                                                    }
-* Space= (  / 	 / EndOfLine) *-
def Space_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _Space(pos:Int):Int? {
def cached := Space_cache[pos]
if cached != null return cached
def result := Space_opt0(pos)
if result != null
Space_cache[pos] := result
return result
                                                                                                                                                                                                    }
-* 
 *-
function EndOfLine_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '\r\n')
term0 := currentPos + 2
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                    }
-* 
 *-
function EndOfLine_seq2(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '\n')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                    }
-* 
 *-
function EndOfLine_seq3(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '\r')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                    }
-* (
 / 
 / 
) *-
function EndOfLine_opt0(pos:Int):Int? {
def seq0 := EndOfLine_seq1(pos                                                                                                                                                                                                        )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                                                        }
def seq1 := EndOfLine_seq2(pos                                                                                                                                                                                                        )
if seq1 != null {
return seq1 -- equal!
                                                                                                                                                                                                        }
def seq2 := EndOfLine_seq3(pos                                                                                                                                                                                                        )
if seq2 != null {
return seq2 -- equal!
                                                                                                                                                                                                        }
return null
                                                                                                                                                                                                        }
-* EndOfLine= (
 / 
 / 
) *-
def EndOfLine_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _EndOfLine(pos:Int):Int? {
def cached := EndOfLine_cache[pos]
if cached != null return cached
def result := EndOfLine_opt0(pos)
if result != null
EndOfLine_cache[pos] := result
return result
                                                                                                                                                                                                        }
-* !. *-
function EndOfFile_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if currentPos < text.length
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
return currentPos
                                                                                                                                                                                                        }
-* (!.) *-
function EndOfFile_opt0(pos:Int):Int? {
def seq0 := EndOfFile_seq1(pos                                                                                                                                                                                                            )
if seq0 != null {
return seq0 -- equal!
                                                                                                                                                                                                            }
return null
                                                                                                                                                                                                            }
-* EndOfFile= (!.) *-
def EndOfFile_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _EndOfFile(pos:Int):Int? {
def cached := EndOfFile_cache[pos]
if cached != null return cached
def result := EndOfFile_opt0(pos)
if result != null
EndOfFile_cache[pos] := result
return result
                                                                                                                                                                                                            }
} -- class
