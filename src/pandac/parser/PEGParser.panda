
	class Grammar {
		def definitions:ListView<Definition>

		def code:String?

		constructor(definitions:ListView<Definition>, code:String?) {
			self.definitions := definitions
			if code != null
				self.code := code.trim()
			else
				self.code := null
		}@override
		function format(fmt:String):String {
			def code:String
			if self.code != null
				code := "{ \{self.code}}\n"
			else
				code := ""
			return code + definitions.join("\n")
		}}@abstract
	class Term {
		var name:String?

		constructor() {
		}constructor(name:String) {
			self.name := name
		}}class Identifier : Term {
		def text:String

		constructor(text:String) {
			self.text := text
		}constructor(text:Array<String>) {
			self.text := text.join("")
		}@override
		function format(fmt:String):String {
			return text
		}}class Definition {
		def name:String

		def type:String?

		def definition:Options

		constructor(name:String, type:String?, definition:Options) {
			self.name := name
			self.type := type
			self.definition := definition
		}@override
		function format(fmt:String):String {
			def type:String
			if self.type != null
				type := ":" + self.type
			else
				type := ""
			return "\{name}\{type}= \{definition}"
		}}class Options : Term {
		def sequences:ListView<Sequence>

		constructor(sequences:ListView<Sequence>) {
			self.sequences := sequences
		}@override
		function format(fmt:String):String {
			return "(" + sequences.join(" / ") + ")"
		}}class Sequence {
		def terms:ListView<Term>

		var code:String?

		constructor(terms:ListView<Term>, code:String?) {
			self.terms := terms
			if code != null
				self.code := code.trim()
			else
				self.code := null
		}@override
		function format(fmt:String):String {
			def code:String
			if self.code != null
				code := " { \{self.code}}"
			else
				code := ""
			return terms.join(" ") + code
		}}class Range {
		def start:Char

		def end:Char

		constructor(start:Char, end:Char) {
			self.start := start
			self.end := end
		}@override
		function format(fmt:String):String {
			if start = end
				return start->>(String)
			else
				return "\{start}-\{end}"
		}}class CharClass : Term {
		def ranges:ListView<Range>

		constructor(ranges:ListView<Range>) {
			self.ranges := ranges
		}@override
		function format(fmt:String):String {
			return "[" + ranges.join("") + "]"
		}}class Quantifier : Term {
		def term:Term

		constructor(term:Term) {
			self.term := term
		}}class And : Quantifier {
		constructor(name:Identifier?, term:Term) {
			super.constructor(term)
			assert term != null
			if name != null
				self.name := name.text
		}@override
		function format(fmt:String):String {
			return "&" + term
		}}class Not : Quantifier {
		constructor(name:Identifier?, term:Term) {
			super.constructor(term)
			if name != null
				self.name := name.text
		}@override
		function format(fmt:String):String {
			return "!" + term
		}}class Optional : Quantifier {
		constructor(term:Term) {
			super.constructor(term)
		}@override
		function format(fmt:String):String {
			return term + "?"
		}}class Star : Quantifier {
		constructor(term:Term) {
			super.constructor(term)
		}@override
		function format(fmt:String):String {
			return term + "*"
		}}class Plus : Quantifier {
		constructor(term:Term) {
			super.constructor(term)
		}@override
		function format(fmt:String):String {
			return term + "+"
		}}class Literal : Term {
		def text:String

		constructor(text:String) {
			self.text := text
		}@override
		function format(fmt:String):String {
			return text
		}}class Cut : Term {
		@override
		function format(fmt:String):String {
			return "^"
		}}class Dot : Term {
		@override
		function format(fmt:String):String {
			return "."
		}}class Util {
		@class
		function unescape(text:String):String {
			return text.replace("\\n", "\n").replace("\\r", "\r").replace("\\t", 
					"\t").replace("\\[", "[").replace("\\]", "]").
					replace("\\\\", "\\").replace("\\'", "'")
		}}
class PEGParser {
def fileName:String
def text:String
def cutStack := new Stack<Bit>()
var maxPos := -1
var maxLiterals := new HashSet<String>()
constructor(file:File) {
    self.constructor(file.name, file.readAsString())
}
constructor(fileName:String, text:String) {
    self.fileName := fileName
    self.text := text
}
function literal(pos:Int, c:Char):Bit {
    if pos > maxPos { maxPos := pos    maxLiterals.clear() }
    if pos = maxPos maxLiterals.add(escape(c))
	   return pos < text.length & text[pos] = c
}
function literal(pos:Int, start:Char, end:Char):Bit {
    if pos > maxPos { maxPos := pos    maxLiterals.clear() }
    if pos = maxPos maxLiterals.add('[\{escape(start)}-\{escape(end)}]')
	   return pos < text.length & text[pos] >= start & text[pos] <= end
}
function literal(pos:Int, s:String):Bit {
    if pos > maxPos { maxPos := pos    maxLiterals.clear() }
    if pos = maxPos maxLiterals.add(escape(s))
	   return pos + s.length <= text.length & text[pos .. pos + s.length] = s
}
function getPosition(pos:Int):String {
    def stream := new LineNumberInputStream(new MemoryInputStream(text))
    for i in 0 .. pos
        stream.readInt8()
    return stream.line + ':' + stream.column
}
function escape(c:Char):String {
	if c = '\''
		return "\\'"
	if c = '\n'
		return '\\n'
	if c = '\r'
		return '\\r'
	if c = '\t'
		return '\\t'
	if c = '\\'
		return '\\\\'
	if c = '\"'
		return '\\"'
	return c->>(String)
}
function escape(s:String):String {
	def result := new MutableString()
	for c in s
		result.append(escape(c))
	return result->>(String)
}
def stack := new Stack<String>()
function Grammar_seq1(pos:Int):(Int, Grammar) {
var code:String? := null
var definitions:Array<Definition> := new Array<Definition>()
var currentPos := pos
def term0 := _Spacing(currentPos)
if term0 = null
return null
currentPos := term0
def term1 := _Code(currentPos)
if term1 != null {
currentPos := term1[0]
code := term1[1]
    }
def term2_temp := _Definition(currentPos)
def term2:(Int, ListView<Definition>)?
if term2_temp != null
term2 := (term2_temp[0], [term2_temp[1]])
else
term2 := null
if term2 = null
return null
currentPos := term2[0]
if term2[1] != null
definitions.addAll(term2[1])
loop {
def term2_temp := _Definition(currentPos)
def term2:(Int, ListView<Definition>)?
if term2_temp != null
term2 := (term2_temp[0], [term2_temp[1]])
else
term2 := null
if term2 = null
break
currentPos := term2[0]
if term2[1] != null
definitions.addAll(term2[1])
    }
def term3 := _EndOfFile(currentPos)
if term3 = null
return null
currentPos := term3
def result:Grammar
{ result := new Grammar(definitions, code) }
return (currentPos, result)
}
function Grammar_opt0(pos:Int):(Int, Grammar) {
def seq0 := Grammar_seq1(pos    )
if seq0 != null {
return seq0
    }
return null
    }
def Grammar_cache := new HashMap<Int, (Int, Grammar)?>()
-- @unsafeFunction
function _Grammar(pos:Int):(Int, Grammar)? {
def cached := Grammar_cache[pos]
if cached != null return cached
def result := Grammar_opt0(pos)
if result != null
Grammar_cache[pos] := result
return result
    }
function Code_seq2(pos:Int, c_in:Array<String>):(Int, Array<String>)? {
var c:Array<String> := new Array<String>()if c_in != null
c.addAll(c_in)

var currentPos := pos
def term0_temp := _Code(currentPos)
def term0:(Int, ListView<String>)?
if term0_temp != null
term0 := (term0_temp[0], [term0_temp[1]])
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
if term0[1] != null
c.addAll(term0[1])
return (currentPos, c        )
    }
function Code_seq3(pos:Int, c_in:Array<String>):(Int, Array<String>)? {
var c:Array<String> := new Array<String>()if c_in != null
c.addAll(c_in)

var currentPos := pos
def term0:Int?
if literal(currentPos, '}')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1:(Int, Array<String>)?
if currentPos < text.length
term1 := (currentPos + 1, [text[currentPos]->>(String)])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
if term1[1] != null
c.addAll(term1[1])
return (currentPos, c        )
    }
function Code_opt1(pos:Int, c:Array<String>):(Int, Array<String>) {
def seq0 := Code_seq2(pos, c        )
if seq0 != null {
return seq0
        }
def seq1 := Code_seq3(pos, c        )
if seq1 != null {
return seq1
        }
return null
        }
function Code_seq4(pos:Int):(Int, String) {
var c:Array<String> := new Array<String>()
var currentPos := pos
def term0:(Int, Array<String>)?
if literal(currentPos, '{')
term0 := (currentPos + 1, ['{'->>(String)])
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
if term0[1] != null
c.addAll(term0[1])
loop {
def term1:(Int, Array<String>)?
term1 := Code_opt1(currentPos, c            )
if term1 = null
break
currentPos := term1[0]
if term1[1] != null
c := new Array<String>(term1[1])
else
c := null
            }
def term2:(Int, Array<String>)?
if literal(currentPos, '}')
term2 := (currentPos + 1, ['}'->>(String)])
else
term2 := null
if term2 = null
return null
currentPos := term2[0]
if term2[1] != null
c.addAll(term2[1])
def term3 := _Spacing(currentPos)
if term3 = null
return null
currentPos := term3
def result:String
{ result := c.join("") }
return (currentPos, result)
        }
function Code_opt0(pos:Int):(Int, String) {
def seq0 := Code_seq4(pos            )
if seq0 != null {
return seq0
            }
return null
            }
def Code_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _Code(pos:Int):(Int, String)? {
def cached := Code_cache[pos]
if cached != null return cached
def result := Code_opt0(pos)
if result != null
Code_cache[pos] := result
return result
            }
function Definition_seq2(pos:Int):(Int, String?)? {
var expr:Options
var type:String? := null
var id:Identifier
var currentPos := pos
def term0 := _COLON(currentPos)
if term0 = null
return null
currentPos := term0
def term1 := _Type(currentPos)
if term1 = null
return null
currentPos := term1[0]
type := term1[1]
return (currentPos, type                )
            }
function Definition_opt1(pos:Int):(Int, String?) {
def seq0 := Definition_seq2(pos                )
if seq0 != null {
return seq0
                }
return null
                }
function Definition_seq3(pos:Int):(Int, Definition) {
var expr:Options
var type:String? := null
var id:Identifier
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
id := term0[1]
def term1:(Int, String?)?
term1 := Definition_opt1(currentPos                    )
if term1 != null {
currentPos := term1[0]
type := term1[1]
                    }
def term2 := _EQUAL(currentPos)
if term2 = null
return null
currentPos := term2
def term3 := _Expression(currentPos)
if term3 = null
return null
currentPos := term3[0]
expr := term3[1]
def result:Definition
{ result := new Definition(id.text, type, expr) }
return (currentPos, result)
                }
function Definition_opt0(pos:Int):(Int, Definition) {
def seq0 := Definition_seq3(pos                    )
if seq0 != null {
return seq0
                    }
return null
                    }
def Definition_cache := new HashMap<Int, (Int, Definition)?>()
-- @unsafeFunction
function _Definition(pos:Int):(Int, Definition)? {
def cached := Definition_cache[pos]
if cached != null return cached
def result := Definition_opt0(pos)
if result != null
Definition_cache[pos] := result
return result
                    }
function Type_seq2(pos:Int, t_in:Array<String>?):(Int, Array<String>?)? {
var t:Array<String> := new Array<String>()if t_in != null
t.addAll(t_in)

var nullable:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _COMMA(currentPos)
if term0 = null
return null
currentPos := term0
def term1_temp := _Type(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
if term1[1] != null
t.addAll(term1[1])
return (currentPos, t                        )
                    }
function Type_opt1(pos:Int, t:Array<String>?):(Int, Array<String>?) {
def seq0 := Type_seq2(pos, t                        )
if seq0 != null {
return seq0
                        }
return null
                        }
function Type_seq5(pos:Int, t_in:Array<String>?):(Int, Array<String>?)? {
var t:Array<String> := new Array<String>()if t_in != null
t.addAll(t_in)

var nullable:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _COMMA(currentPos)
if term0 = null
return null
currentPos := term0
def term1_temp := _Type(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
if term1[1] != null
t.addAll(term1[1])
return (currentPos, t                            )
                        }
function Type_opt4(pos:Int, t:Array<String>?):(Int, Array<String>?) {
def seq0 := Type_seq5(pos, t                            )
if seq0 != null {
return seq0
                            }
return null
                            }
function Type_seq6(pos:Int):(Int, Array<String>?)? {
var t:Array<String> := new Array<String>()
var nullable:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _LT(currentPos)
if term0 = null
return null
currentPos := term0
def term1_temp := _Type(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
if term1[1] != null
t.addAll(term1[1])
loop {
def term2:(Int, Array<String>?)?
term2 := Type_opt4(currentPos, t                                )
if term2 = null
break
currentPos := term2[0]
if term2[1] != null
t := new Array<String>?(term2[1])
else
t := null
                                }
def term3 := _GT(currentPos)
if term3 = null
return null
currentPos := term3
return (currentPos, t                                )
                            }
function Type_opt3(pos:Int):(Int, Array<String>?) {
def seq0 := Type_seq6(pos                                )
if seq0 != null {
return seq0
                                }
return null
                                }
function Type_seq7(pos:Int):(Int, String) {
var t:Array<String> := new Array<String>()
var nullable:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
id := term0[1]
def term1:(Int, Array<String>?)?
term1 := Type_opt3(currentPos                                    )
if term1 != null {
currentPos := term1[0]
if term1[1] != null
t.addAll(term1[1])
                                    }
def term2 := _QUESTION(currentPos)
if term2 != null {
currentPos := term2[0]
nullable := term2[1]
                                    }
def result:String
{
 		var text := id.text.trim 
 		if t.length > 0
 			text += "<\{t.join(',')}>"
 		if nullable != null
 			text += "?"
 		result := text
 	}
return (currentPos, result)
                                }
function Type_opt0(pos:Int):(Int, String) {
def seq0 := Type_seq7(pos                                    )
if seq0 != null {
return seq0
                                    }
return null
                                    }
def Type_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _Type(pos:Int):(Int, String)? {
def cached := Type_cache[pos]
if cached != null return cached
def result := Type_opt0(pos)
if result != null
Type_cache[pos] := result
return result
                                    }
function Expression_seq2(pos:Int, seq_in:Array<Sequence>):(Int, Array<Sequence>)? {
var seq:Array<Sequence> := new Array<Sequence>()if seq_in != null
seq.addAll(seq_in)

var currentPos := pos
def term0 := _SLASH(currentPos)
if term0 = null
return null
currentPos := term0
def term1_temp := _Sequence(currentPos)
def term1:(Int, ListView<Sequence>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
if term1[1] != null
seq.addAll(term1[1])
return (currentPos, seq                                        )
                                    }
function Expression_opt1(pos:Int, seq:Array<Sequence>):(Int, Array<Sequence>) {
def seq0 := Expression_seq2(pos, seq                                        )
if seq0 != null {
return seq0
                                        }
return null
                                        }
function Expression_seq3(pos:Int):(Int, Options) {
var seq:Array<Sequence> := new Array<Sequence>()
var currentPos := pos
def term0_temp := _Sequence(currentPos)
def term0:(Int, ListView<Sequence>)?
if term0_temp != null
term0 := (term0_temp[0], [term0_temp[1]])
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
if term0[1] != null
seq.addAll(term0[1])
loop {
def term1:(Int, Array<Sequence>)?
term1 := Expression_opt1(currentPos, seq                                            )
if term1 = null
break
currentPos := term1[0]
if term1[1] != null
seq := new Array<Sequence>(term1[1])
else
seq := null
                                            }
def result:Options
{ result := new Options(seq) }
return (currentPos, result)
                                        }
function Expression_opt0(pos:Int):(Int, Options) {
def seq0 := Expression_seq3(pos                                            )
if seq0 != null {
return seq0
                                            }
return null
                                            }
def Expression_cache := new HashMap<Int, (Int, Options)?>()
-- @unsafeFunction
function _Expression(pos:Int):(Int, Options)? {
def cached := Expression_cache[pos]
if cached != null return cached
def result := Expression_opt0(pos)
if result != null
Expression_cache[pos] := result
return result
                                            }
function Sequence_seq1(pos:Int):(Int, Sequence) {
var code:String? := null
var terms:Array<Term> := new Array<Term>()
var currentPos := pos
loop {
def term0_temp := _Prefix(currentPos)
def term0:(Int, ListView<Term>)?
if term0_temp != null
term0 := (term0_temp[0], [term0_temp[1]])
else
term0 := null
if term0 = null
break
currentPos := term0[0]
if term0[1] != null
terms.addAll(term0[1])
                                                }
def term1 := _Code(currentPos)
if term1 != null {
currentPos := term1[0]
code := term1[1]
                                                }
def result:Sequence
{ result := new Sequence(terms, code) }
return (currentPos, result)
                                            }
function Sequence_opt0(pos:Int):(Int, Sequence) {
def seq0 := Sequence_seq1(pos                                                )
if seq0 != null {
return seq0
                                                }
return null
                                                }
def Sequence_cache := new HashMap<Int, (Int, Sequence)?>()
-- @unsafeFunction
function _Sequence(pos:Int):(Int, Sequence)? {
def cached := Sequence_cache[pos]
if cached != null return cached
def result := Sequence_opt0(pos)
if result != null
Sequence_cache[pos] := result
return result
                                                }
function Prefix_seq1(pos:Int):(Int, Term) {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0 := _Label(currentPos)
if term0 != null {
currentPos := term0[0]
id1 := term0[1]
                                                    }
def term1 := _AND(currentPos)
if term1 = null
return null
currentPos := term1[0]
a := term1[1]
def term2 := _Suffix(currentPos)
if term2 = null
return null
currentPos := term2[0]
s1 := term2[1]
def result:Term
{ result := new And(id1, s1) }
return (currentPos, result)
                                                }
function Prefix_seq2(pos:Int):(Int, Term) {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0 := _Label(currentPos)
if term0 != null {
currentPos := term0[0]
id2 := term0[1]
                                                    }
def term1 := _NOT(currentPos)
if term1 = null
return null
currentPos := term1[0]
n := term1[1]
def term2 := _Suffix(currentPos)
if term2 = null
return null
currentPos := term2[0]
s2 := term2[1]
def result:Term
{ result := new Not(id2, s2) }
return (currentPos, result)
                                                }
function Prefix_seq3(pos:Int):(Int, Term) {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0 := _Label(currentPos)
if term0 != null {
currentPos := term0[0]
id3 := term0[1]
                                                    }
def term1 := _Suffix(currentPos)
if term1 = null
return null
currentPos := term1[0]
s3 := term1[1]
def result:Term
{ 
		if id3 != null
			s3.name := id3.text
		result := s3
	}
return (currentPos, result)
                                                }
function Prefix_seq4(pos:Int):(Int, Term) {
var s1:Term? := null
var s2:Term? := null
var s3:Term? := null
var id2:Identifier? := null
var id1:Identifier? := null
var a:Bit? := null
var n:Bit? := null
var id3:Identifier? := null
var currentPos := pos
def term0 := _CUT(currentPos)
if term0 = null
return null
currentPos := term0
def result:Term
{ result := new Cut() }
return (currentPos, result)
                                                }
function Prefix_opt0(pos:Int):(Int, Term) {
def seq0 := Prefix_seq1(pos                                                    )
if seq0 != null {
return seq0
                                                    }
def seq1 := Prefix_seq2(pos                                                    )
if seq1 != null {
return seq1
                                                    }
def seq2 := Prefix_seq3(pos                                                    )
if seq2 != null {
return seq2
                                                    }
def seq3 := Prefix_seq4(pos                                                    )
if seq3 != null {
return seq3
                                                    }
return null
                                                    }
def Prefix_cache := new HashMap<Int, (Int, Term)?>()
-- @unsafeFunction
function _Prefix(pos:Int):(Int, Term)? {
def cached := Prefix_cache[pos]
if cached != null return cached
def result := Prefix_opt0(pos)
if result != null
Prefix_cache[pos] := result
return result
                                                    }
function Suffix_seq2(pos:Int):(Int, Bit?)? {
var q:Bit? := null
var p:Bit? := null
var st:Bit? := null
var value:Term
var currentPos := pos
def term0 := _QUESTION(currentPos)
if term0 = null
return null
currentPos := term0[0]
q := term0[1]
return (currentPos, q                                                        )
                                                    }
function Suffix_seq3(pos:Int):(Int, Bit?)? {
var q:Bit? := null
var p:Bit? := null
var st:Bit? := null
var value:Term
var currentPos := pos
def term0 := _STAR(currentPos)
if term0 = null
return null
currentPos := term0[0]
st := term0[1]
return (currentPos, st                                                        )
                                                    }
function Suffix_seq4(pos:Int):(Int, Bit?)? {
var q:Bit? := null
var p:Bit? := null
var st:Bit? := null
var value:Term
var currentPos := pos
def term0 := _PLUS(currentPos)
if term0 = null
return null
currentPos := term0[0]
p := term0[1]
return (currentPos, p                                                        )
                                                    }
function Suffix_opt1(pos:Int):(Int, Bit?, Bit?, Bit?) {
def seq0 := Suffix_seq2(pos                                                        )
if seq0 != null {
return (seq0[0], seq0[1], null, null                                                            )
                                                        }
def seq1 := Suffix_seq3(pos                                                        )
if seq1 != null {
return (seq1[0], null, seq1[1], null                                                            )
                                                        }
def seq2 := Suffix_seq4(pos                                                        )
if seq2 != null {
return (seq2[0], null, null, seq2[1]                                                            )
                                                        }
return null
                                                        }
function Suffix_seq5(pos:Int):(Int, Term) {
var q:Bit? := null
var p:Bit? := null
var st:Bit? := null
var value:Term
var currentPos := pos
def term0 := _Primary(currentPos)
if term0 = null
return null
currentPos := term0[0]
value := term0[1]
def term1:(Int, Bit?, Bit?, Bit?)?
term1 := Suffix_opt1(currentPos                                                            )
if term1 != null {
currentPos := term1[0]
q := term1[1]
st := term1[2]
p := term1[3]
                                                            }
def result:Term
{
		if q != null
			result := new Optional(value)
		else if st != null
			result := new Star(value)
		else if p != null
			result := new Plus(value)
		else
			result := value
	}
return (currentPos, result)
                                                        }
function Suffix_opt0(pos:Int):(Int, Term) {
def seq0 := Suffix_seq5(pos                                                            )
if seq0 != null {
return seq0
                                                            }
return null
                                                            }
def Suffix_cache := new HashMap<Int, (Int, Term)?>()
-- @unsafeFunction
function _Suffix(pos:Int):(Int, Term)? {
def cached := Suffix_cache[pos]
if cached != null return cached
def result := Suffix_opt0(pos)
if result != null
Suffix_cache[pos] := result
return result
                                                            }
function Primary_seq1(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _Identifier(currentPos)
if term0 = null
return null
currentPos := term0[0]
i := term0[1]
def term1 := _EQUAL(currentPos)
if term1 != null
return null
def result:Term
{ result := i }
return (currentPos, result)
                                                            }
function Primary_seq2(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _OPEN(currentPos)
if term0 = null
return null
currentPos := term0
def term1 := _Expression(currentPos)
if term1 = null
return null
currentPos := term1[0]
e := term1[1]
def term2 := _CLOSE(currentPos)
if term2 = null
return null
currentPos := term2
def result:Term
{ result := e }
return (currentPos, result)
                                                            }
function Primary_seq3(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _Literal(currentPos)
if term0 = null
return null
currentPos := term0[0]
l := term0[1]
def result:Term
{ result := l }
return (currentPos, result)
                                                            }
function Primary_seq4(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _Class(currentPos)
if term0 = null
return null
currentPos := term0[0]
cl := term0[1]
def result:Term
{ result := cl }
return (currentPos, result)
                                                            }
function Primary_seq5(pos:Int):(Int, Term) {
var cl:CharClass? := null
var d:Dot? := null
var e:Options? := null
var l:Literal? := null
var i:Identifier? := null
var currentPos := pos
def term0 := _DOT(currentPos)
if term0 = null
return null
currentPos := term0[0]
d := term0[1]
def result:Term
{ result := d }
return (currentPos, result)
                                                            }
function Primary_opt0(pos:Int):(Int, Term) {
def seq0 := Primary_seq1(pos                                                                )
if seq0 != null {
return seq0
                                                                }
def seq1 := Primary_seq2(pos                                                                )
if seq1 != null {
return seq1
                                                                }
def seq2 := Primary_seq3(pos                                                                )
if seq2 != null {
return seq2
                                                                }
def seq3 := Primary_seq4(pos                                                                )
if seq3 != null {
return seq3
                                                                }
def seq4 := Primary_seq5(pos                                                                )
if seq4 != null {
return seq4
                                                                }
return null
                                                                }
def Primary_cache := new HashMap<Int, (Int, Term)?>()
-- @unsafeFunction
function _Primary(pos:Int):(Int, Term)? {
def cached := Primary_cache[pos]
if cached != null return cached
def result := Primary_opt0(pos)
if result != null
Primary_cache[pos] := result
return result
                                                                }
function Identifier_seq1(pos:Int):(Int, Identifier) {
var text:Array<String> := new Array<String>()
var currentPos := pos
def term0_temp := _IdentStart(currentPos)
def term0:(Int, ListView<String>)?
if term0_temp != null
term0 := (term0_temp[0], [term0_temp[1]])
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
if term0[1] != null
text.addAll(term0[1])
loop {
def term1_temp := _IdentCont(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
break
currentPos := term1[0]
if term1[1] != null
text.addAll(term1[1])
                                                                    }
def term2 := _Spacing(currentPos)
if term2 = null
return null
currentPos := term2
def result:Identifier
{ result := new Identifier(text.join("")) }
return (currentPos, result)
                                                                }
function Identifier_opt0(pos:Int):(Int, Identifier) {
def seq0 := Identifier_seq1(pos                                                                    )
if seq0 != null {
return seq0
                                                                    }
return null
                                                                    }
def Identifier_cache := new HashMap<Int, (Int, Identifier)?>()
-- @unsafeFunction
function _Identifier(pos:Int):(Int, Identifier)? {
def cached := Identifier_cache[pos]
if cached != null return cached
def result := Identifier_opt0(pos)
if result != null
Identifier_cache[pos] := result
return result
                                                                    }
function Label_seq1(pos:Int):(Int, Identifier) {
var a:Bit? := null
var id:Identifier
var currentPos := pos
def term0 := _AT(currentPos)
if term0 != null {
currentPos := term0[0]
a := term0[1]
                                                                        }
def term1 := _Identifier(currentPos)
if term1 = null
return null
currentPos := term1[0]
id := term1[1]
def term2 := _COLON(currentPos)
if term2 = null
return null
currentPos := term2
def result:Identifier
{ 
		if a != null 
			result := new Identifier(id.text)
		else
			result := id
	}
return (currentPos, result)
                                                                    }
function Label_opt0(pos:Int):(Int, Identifier) {
def seq0 := Label_seq1(pos                                                                        )
if seq0 != null {
return seq0
                                                                        }
return null
                                                                        }
def Label_cache := new HashMap<Int, (Int, Identifier)?>()
-- @unsafeFunction
function _Label(pos:Int):(Int, Identifier)? {
def cached := Label_cache[pos]
if cached != null return cached
def result := Label_opt0(pos)
if result != null
Label_cache[pos] := result
return result
                                                                        }
function Range_seq1(pos:Int):(Int, Range) {
var single:String? := null
var end:String? := null
var start:String? := null
var currentPos := pos
def term0 := _Char(currentPos)
if term0 = null
return null
currentPos := term0[0]
start := term0[1]
def term1:Int?
if literal(currentPos, '-')
term1 := currentPos + 1
else
term1 := null
if term1 = null
return null
currentPos := term1
def term2 := _Char(currentPos)
if term2 = null
return null
currentPos := term2[0]
end := term2[1]
def result:Range
{ result := new Range(start[0], end[0]) }
return (currentPos, result)
                                                                        }
function Range_seq2(pos:Int):(Int, Range) {
var single:String? := null
var end:String? := null
var start:String? := null
var currentPos := pos
def term0 := _Char(currentPos)
if term0 = null
return null
currentPos := term0[0]
single := term0[1]
def result:Range
{ result := new Range(single[0], single[0]) }
return (currentPos, result)
                                                                        }
function Range_opt0(pos:Int):(Int, Range) {
def seq0 := Range_seq1(pos                                                                            )
if seq0 != null {
return seq0
                                                                            }
def seq1 := Range_seq2(pos                                                                            )
if seq1 != null {
return seq1
                                                                            }
return null
                                                                            }
def Range_cache := new HashMap<Int, (Int, Range)?>()
-- @unsafeFunction
function _Range(pos:Int):(Int, Range)? {
def cached := Range_cache[pos]
if cached != null return cached
def result := Range_opt0(pos)
if result != null
Range_cache[pos] := result
return result
                                                                            }
function Class_seq2(pos:Int, ranges_in:Array<Range>):(Int, Array<Range>)? {
var ranges:Array<Range> := new Array<Range>()if ranges_in != null
ranges.addAll(ranges_in)

var currentPos := pos
def term0:Int?
if literal(currentPos, ']')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1_temp := _Range(currentPos)
def term1:(Int, ListView<Range>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
if term1[1] != null
ranges.addAll(term1[1])
return (currentPos, ranges                                                                                )
                                                                            }
function Class_opt1(pos:Int, ranges:Array<Range>):(Int, Array<Range>) {
def seq0 := Class_seq2(pos, ranges                                                                                )
if seq0 != null {
return seq0
                                                                                }
return null
                                                                                }
function Class_seq3(pos:Int):(Int, CharClass) {
var ranges:Array<Range> := new Array<Range>()
var currentPos := pos
def term0:Int?
if literal(currentPos, '[')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
loop {
def term1:(Int, Array<Range>)?
term1 := Class_opt1(currentPos, ranges                                                                                    )
if term1 = null
break
currentPos := term1[0]
if term1[1] != null
ranges := new Array<Range>(term1[1])
else
ranges := null
                                                                                    }
def term2:Int?
if literal(currentPos, ']')
term2 := currentPos + 1
else
term2 := null
if term2 = null
return null
currentPos := term2
def term3 := _Spacing(currentPos)
if term3 = null
return null
currentPos := term3
def result:CharClass
{ result := new CharClass(ranges) }
return (currentPos, result)
                                                                                }
function Class_opt0(pos:Int):(Int, CharClass) {
def seq0 := Class_seq3(pos                                                                                    )
if seq0 != null {
return seq0
                                                                                    }
return null
                                                                                    }
def Class_cache := new HashMap<Int, (Int, CharClass)?>()
-- @unsafeFunction
function _Class(pos:Int):(Int, CharClass)? {
def cached := Class_cache[pos]
if cached != null return cached
def result := Class_opt0(pos)
if result != null
Class_cache[pos] := result
return result
                                                                                    }
function IdentStart_seq1(pos:Int):(Int, String) {
var c:String
var currentPos := pos
def term0:(Int, String)?
if literal(currentPos, 'a', 'z') | literal(currentPos, 'A', 'Z') | literal(currentPos, '_')
term0 := (currentPos + 1, text[currentPos]->>(String))
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
c := term0[1]
def result:String
{ result := c }
return (currentPos, result)
                                                                                    }
function IdentStart_opt0(pos:Int):(Int, String) {
def seq0 := IdentStart_seq1(pos                                                                                        )
if seq0 != null {
return seq0
                                                                                        }
return null
                                                                                        }
def IdentStart_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _IdentStart(pos:Int):(Int, String)? {
def cached := IdentStart_cache[pos]
if cached != null return cached
def result := IdentStart_opt0(pos)
if result != null
IdentStart_cache[pos] := result
return result
                                                                                        }
function IdentCont_seq1(pos:Int):(Int, String) {
var c1:String? := null
var c2:String? := null
var currentPos := pos
def term0 := _IdentStart(currentPos)
if term0 = null
return null
currentPos := term0[0]
c1 := term0[1]
def result:String
{ result := c1 }
return (currentPos, result)
                                                                                        }
function IdentCont_seq2(pos:Int):(Int, String) {
var c1:String? := null
var c2:String? := null
var currentPos := pos
def term0:(Int, String?)?
if literal(currentPos, '0', '9')
term0 := (currentPos + 1, text[currentPos]->>(String))
else
term0 := null
if term0 = null
return null
currentPos := term0[0]
c2 := term0[1]
def result:String
{ result := c2 }
return (currentPos, result)
                                                                                        }
function IdentCont_opt0(pos:Int):(Int, String) {
def seq0 := IdentCont_seq1(pos                                                                                            )
if seq0 != null {
return seq0
                                                                                            }
def seq1 := IdentCont_seq2(pos                                                                                            )
if seq1 != null {
return seq1
                                                                                            }
return null
                                                                                            }
def IdentCont_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _IdentCont(pos:Int):(Int, String)? {
def cached := IdentCont_cache[pos]
if cached != null return cached
def result := IdentCont_opt0(pos)
if result != null
IdentCont_cache[pos] := result
return result
                                                                                            }
function Literal_seq2(pos:Int, text_in:Array<String>?):(Int, Array<String>?)? {
var text:Array<String> := new Array<String>()if text_in != null
text.addAll(text_in)

var currentPos := pos
def term0:Int?
if literal(currentPos, '\'')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1_temp := _Char(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
if term1[1] != null
text.addAll(term1[1])
return (currentPos, text                                                                                                )
                                                                                            }
function Literal_opt1(pos:Int, text:Array<String>?):(Int, Array<String>?) {
def seq0 := Literal_seq2(pos, text                                                                                                )
if seq0 != null {
return seq0
                                                                                                }
return null
                                                                                                }
function Literal_seq3(pos:Int):(Int, Literal) {
var text:Array<String> := new Array<String>()
var currentPos := pos
def term0:Int?
if literal(currentPos, '\'')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
loop {
def term1:(Int, Array<String>?)?
term1 := Literal_opt1(currentPos, text                                                                                                    )
if term1 = null
break
currentPos := term1[0]
if term1[1] != null
text := new Array<String>?(term1[1])
else
text := null
                                                                                                    }
def term2:Int?
if literal(currentPos, '\'')
term2 := currentPos + 1
else
term2 := null
if term2 = null
return null
currentPos := term2
def term3 := _Spacing(currentPos)
if term3 = null
return null
currentPos := term3
def result:Literal
{ result := new Literal(Util.unescape(text.join(""))) }
return (currentPos, result)
                                                                                                }
function Literal_seq5(pos:Int, text_in:Array<String>?):(Int, Array<String>?)? {
var text:Array<String> := new Array<String>()if text_in != null
text.addAll(text_in)

var currentPos := pos
def term0:Int?
if literal(currentPos, '\"')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1_temp := _Char(currentPos)
def term1:(Int, ListView<String>)?
if term1_temp != null
term1 := (term1_temp[0], [term1_temp[1]])
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
if term1[1] != null
text.addAll(term1[1])
return (currentPos, text                                                                                                    )
                                                                                                }
function Literal_opt4(pos:Int, text:Array<String>?):(Int, Array<String>?) {
def seq0 := Literal_seq5(pos, text                                                                                                    )
if seq0 != null {
return seq0
                                                                                                    }
return null
                                                                                                    }
function Literal_seq6(pos:Int):(Int, Literal) {
var text:Array<String> := new Array<String>()
var currentPos := pos
def term0:Int?
if literal(currentPos, '\"')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
loop {
def term1:(Int, Array<String>?)?
term1 := Literal_opt4(currentPos, text                                                                                                        )
if term1 = null
break
currentPos := term1[0]
if term1[1] != null
text := new Array<String>?(term1[1])
else
text := null
                                                                                                        }
def term2:Int?
if literal(currentPos, '\"')
term2 := currentPos + 1
else
term2 := null
if term2 = null
return null
currentPos := term2
def term3 := _Spacing(currentPos)
if term3 = null
return null
currentPos := term3
def result:Literal
{ result := new Literal(Util.unescape(text.join(""))) }
return (currentPos, result)
                                                                                                    }
function Literal_opt0(pos:Int):(Int, Literal) {
def seq0 := Literal_seq3(pos                                                                                                        )
if seq0 != null {
return seq0
                                                                                                        }
def seq1 := Literal_seq6(pos                                                                                                        )
if seq1 != null {
return seq1
                                                                                                        }
return null
                                                                                                        }
def Literal_cache := new HashMap<Int, (Int, Literal)?>()
-- @unsafeFunction
function _Literal(pos:Int):(Int, Literal)? {
def cached := Literal_cache[pos]
if cached != null return cached
def result := Literal_opt0(pos)
if result != null
Literal_cache[pos] := result
return result
                                                                                                        }
function DOT_seq1(pos:Int):(Int, Dot) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '.')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Dot
{ result := new Dot() }
return (currentPos, result)
                                                                                                        }
function DOT_opt0(pos:Int):(Int, Dot) {
def seq0 := DOT_seq1(pos                                                                                                            )
if seq0 != null {
return seq0
                                                                                                            }
return null
                                                                                                            }
def DOT_cache := new HashMap<Int, (Int, Dot)?>()
-- @unsafeFunction
function _DOT(pos:Int):(Int, Dot)? {
def cached := DOT_cache[pos]
if cached != null return cached
def result := DOT_opt0(pos)
if result != null
DOT_cache[pos] := result
return result
                                                                                                            }
function Char_seq1(pos:Int):(Int, String) {
var char2:String? := null
var char1:String? := null
var currentPos := pos
def term0:Int?
if literal(currentPos, '\\')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1:(Int, String?)?
if literal(currentPos, 'n') | literal(currentPos, 'r') | literal(currentPos, 't') | literal(currentPos, '\'') | literal(currentPos, '\"') | literal(currentPos, '[') | literal(currentPos, ']') | literal(currentPos, '\\')
term1 := (currentPos + 1, text[currentPos]->>(String))
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
char1 := term1[1]
def result:String
{ result := Util.unescape("\\" + char1) }
return (currentPos, result)
                                                                                                            }
function Char_seq2(pos:Int):(Int, String) {
var char2:String? := null
var char1:String? := null
var currentPos := pos
def term0:Int?
if literal(currentPos, '\\')
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
def term1:(Int, String?)?
if currentPos < text.length
term1 := (currentPos + 1, text[currentPos]->>(String))
else
term1 := null
if term1 = null
return null
currentPos := term1[0]
char2 := term1[1]
def result:String
{ result := char2 }
return (currentPos, result)
                                                                                                            }
function Char_opt0(pos:Int):(Int, String) {
def seq0 := Char_seq1(pos                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                }
def seq1 := Char_seq2(pos                                                                                                                )
if seq1 != null {
return seq1
                                                                                                                }
return null
                                                                                                                }
def Char_cache := new HashMap<Int, (Int, String)?>()
-- @unsafeFunction
function _Char(pos:Int):(Int, String)? {
def cached := Char_cache[pos]
if cached != null return cached
def result := Char_opt0(pos)
if result != null
Char_cache[pos] := result
return result
                                                                                                                }
function EQUAL_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '=')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                }
function EQUAL_opt0(pos:Int):Int? {
def seq0 := EQUAL_seq1(pos                                                                                                                    )
if seq0 != null {
return seq0
                                                                                                                    }
return null
                                                                                                                    }
def EQUAL_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _EQUAL(pos:Int):Int? {
def cached := EQUAL_cache[pos]
if cached != null return cached
def result := EQUAL_opt0(pos)
if result != null
EQUAL_cache[pos] := result
return result
                                                                                                                    }
function SLASH_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '/')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                    }
function SLASH_opt0(pos:Int):Int? {
def seq0 := SLASH_seq1(pos                                                                                                                        )
if seq0 != null {
return seq0
                                                                                                                        }
return null
                                                                                                                        }
def SLASH_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _SLASH(pos:Int):Int? {
def cached := SLASH_cache[pos]
if cached != null return cached
def result := SLASH_opt0(pos)
if result != null
SLASH_cache[pos] := result
return result
                                                                                                                        }
function AND_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '&')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                        }
function AND_opt0(pos:Int):(Int, Bit) {
def seq0 := AND_seq1(pos                                                                                                                            )
if seq0 != null {
return seq0
                                                                                                                            }
return null
                                                                                                                            }
def AND_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _AND(pos:Int):(Int, Bit)? {
def cached := AND_cache[pos]
if cached != null return cached
def result := AND_opt0(pos)
if result != null
AND_cache[pos] := result
return result
                                                                                                                            }
function NOT_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '!')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                            }
function NOT_opt0(pos:Int):(Int, Bit) {
def seq0 := NOT_seq1(pos                                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                                }
return null
                                                                                                                                }
def NOT_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _NOT(pos:Int):(Int, Bit)? {
def cached := NOT_cache[pos]
if cached != null return cached
def result := NOT_opt0(pos)
if result != null
NOT_cache[pos] := result
return result
                                                                                                                                }
function CUT_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '^')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                }
function CUT_opt0(pos:Int):Int? {
def seq0 := CUT_seq1(pos                                                                                                                                    )
if seq0 != null {
return seq0
                                                                                                                                    }
return null
                                                                                                                                    }
def CUT_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _CUT(pos:Int):Int? {
def cached := CUT_cache[pos]
if cached != null return cached
def result := CUT_opt0(pos)
if result != null
CUT_cache[pos] := result
return result
                                                                                                                                    }
function LT_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '<')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                    }
function LT_opt0(pos:Int):Int? {
def seq0 := LT_seq1(pos                                                                                                                                        )
if seq0 != null {
return seq0
                                                                                                                                        }
return null
                                                                                                                                        }
def LT_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _LT(pos:Int):Int? {
def cached := LT_cache[pos]
if cached != null return cached
def result := LT_opt0(pos)
if result != null
LT_cache[pos] := result
return result
                                                                                                                                        }
function GT_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '>')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                        }
function GT_opt0(pos:Int):Int? {
def seq0 := GT_seq1(pos                                                                                                                                            )
if seq0 != null {
return seq0
                                                                                                                                            }
return null
                                                                                                                                            }
def GT_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _GT(pos:Int):Int? {
def cached := GT_cache[pos]
if cached != null return cached
def result := GT_opt0(pos)
if result != null
GT_cache[pos] := result
return result
                                                                                                                                            }
function COMMA_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, ',')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                            }
function COMMA_opt0(pos:Int):Int? {
def seq0 := COMMA_seq1(pos                                                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                                                }
return null
                                                                                                                                                }
def COMMA_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _COMMA(pos:Int):Int? {
def cached := COMMA_cache[pos]
if cached != null return cached
def result := COMMA_opt0(pos)
if result != null
COMMA_cache[pos] := result
return result
                                                                                                                                                }
function AT_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '@')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                                }
function AT_opt0(pos:Int):(Int, Bit) {
def seq0 := AT_seq1(pos                                                                                                                                                    )
if seq0 != null {
return seq0
                                                                                                                                                    }
return null
                                                                                                                                                    }
def AT_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _AT(pos:Int):(Int, Bit)? {
def cached := AT_cache[pos]
if cached != null return cached
def result := AT_opt0(pos)
if result != null
AT_cache[pos] := result
return result
                                                                                                                                                    }
function STAR_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '*')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                                    }
function STAR_opt0(pos:Int):(Int, Bit) {
def seq0 := STAR_seq1(pos                                                                                                                                                        )
if seq0 != null {
return seq0
                                                                                                                                                        }
return null
                                                                                                                                                        }
def STAR_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _STAR(pos:Int):(Int, Bit)? {
def cached := STAR_cache[pos]
if cached != null return cached
def result := STAR_opt0(pos)
if result != null
STAR_cache[pos] := result
return result
                                                                                                                                                        }
function PLUS_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '+')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                                        }
function PLUS_opt0(pos:Int):(Int, Bit) {
def seq0 := PLUS_seq1(pos                                                                                                                                                            )
if seq0 != null {
return seq0
                                                                                                                                                            }
return null
                                                                                                                                                            }
def PLUS_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _PLUS(pos:Int):(Int, Bit)? {
def cached := PLUS_cache[pos]
if cached != null return cached
def result := PLUS_opt0(pos)
if result != null
PLUS_cache[pos] := result
return result
                                                                                                                                                            }
function OPEN_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '(')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                            }
function OPEN_opt0(pos:Int):Int? {
def seq0 := OPEN_seq1(pos                                                                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                                                                }
return null
                                                                                                                                                                }
def OPEN_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _OPEN(pos:Int):Int? {
def cached := OPEN_cache[pos]
if cached != null return cached
def result := OPEN_opt0(pos)
if result != null
OPEN_cache[pos] := result
return result
                                                                                                                                                                }
function CLOSE_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, ')')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                                }
function CLOSE_opt0(pos:Int):Int? {
def seq0 := CLOSE_seq1(pos                                                                                                                                                                    )
if seq0 != null {
return seq0
                                                                                                                                                                    }
return null
                                                                                                                                                                    }
def CLOSE_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _CLOSE(pos:Int):Int? {
def cached := CLOSE_cache[pos]
if cached != null return cached
def result := CLOSE_opt0(pos)
if result != null
CLOSE_cache[pos] := result
return result
                                                                                                                                                                    }
function COLON_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, ':')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                                    }
function COLON_opt0(pos:Int):Int? {
def seq0 := COLON_seq1(pos                                                                                                                                                                        )
if seq0 != null {
return seq0
                                                                                                                                                                        }
return null
                                                                                                                                                                        }
def COLON_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _COLON(pos:Int):Int? {
def cached := COLON_cache[pos]
if cached != null return cached
def result := COLON_opt0(pos)
if result != null
COLON_cache[pos] := result
return result
                                                                                                                                                                        }
function QUESTION_seq1(pos:Int):(Int, Bit) {
var currentPos := pos
def term0:Int?
if literal(currentPos, '?')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
def term1 := _Spacing(currentPos)
if term1 = null
return null
currentPos := term1
def result:Bit
{ result := true }
return (currentPos, result)
                                                                                                                                                                        }
function QUESTION_opt0(pos:Int):(Int, Bit) {
def seq0 := QUESTION_seq1(pos                                                                                                                                                                            )
if seq0 != null {
return seq0
                                                                                                                                                                            }
return null
                                                                                                                                                                            }
def QUESTION_cache := new HashMap<Int, (Int, Bit)?>()
-- @unsafeFunction
function _QUESTION(pos:Int):(Int, Bit)? {
def cached := QUESTION_cache[pos]
if cached != null return cached
def result := QUESTION_opt0(pos)
if result != null
QUESTION_cache[pos] := result
return result
                                                                                                                                                                            }
function Spacing_seq2(pos:Int):Int? {
var currentPos := pos
def term0 := _Space(currentPos)
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                            }
function Spacing_seq3(pos:Int):Int? {
var currentPos := pos
def term0 := _Comment(currentPos)
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                            }
function Spacing_opt1(pos:Int):Int? {
def seq0 := Spacing_seq2(pos                                                                                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                                                                                }
def seq1 := Spacing_seq3(pos                                                                                                                                                                                )
if seq1 != null {
return seq1
                                                                                                                                                                                }
return null
                                                                                                                                                                                }
function Spacing_seq4(pos:Int):Int? {
var currentPos := pos
loop {
def term0:Int?
term0 := Spacing_opt1(currentPos                                                                                                                                                                                    )
if term0 = null
break
currentPos := term0
                                                                                                                                                                                    }
return currentPos
                                                                                                                                                                                }
function Spacing_opt0(pos:Int):Int? {
def seq0 := Spacing_seq4(pos                                                                                                                                                                                    )
if seq0 != null {
return seq0
                                                                                                                                                                                    }
return null
                                                                                                                                                                                    }
def Spacing_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _Spacing(pos:Int):Int? {
def cached := Spacing_cache[pos]
if cached != null return cached
def result := Spacing_opt0(pos)
if result != null
Spacing_cache[pos] := result
return result
                                                                                                                                                                                    }
function Comment_seq2(pos:Int):Int? {
var currentPos := pos
def term0 := _EndOfLine(currentPos)
if term0 != null
return null
def term1:Int?
if currentPos < text.length
term1 := currentPos + 1
else
term1 := null
if term1 = null
return null
currentPos := term1
return currentPos
                                                                                                                                                                                    }
function Comment_opt1(pos:Int):Int? {
def seq0 := Comment_seq2(pos                                                                                                                                                                                        )
if seq0 != null {
return seq0
                                                                                                                                                                                        }
return null
                                                                                                                                                                                        }
function Comment_seq3(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '#')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
loop {
def term1:Int?
term1 := Comment_opt1(currentPos                                                                                                                                                                                            )
if term1 = null
break
currentPos := term1
                                                                                                                                                                                            }
def term2 := _EndOfLine(currentPos)
if term2 = null
return null
currentPos := term2
return currentPos
                                                                                                                                                                                        }
function Comment_opt0(pos:Int):Int? {
def seq0 := Comment_seq3(pos                                                                                                                                                                                            )
if seq0 != null {
return seq0
                                                                                                                                                                                            }
return null
                                                                                                                                                                                            }
def Comment_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _Comment(pos:Int):Int? {
def cached := Comment_cache[pos]
if cached != null return cached
def result := Comment_opt0(pos)
if result != null
Comment_cache[pos] := result
return result
                                                                                                                                                                                            }
function Space_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, ' ')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                            }
function Space_seq2(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '\t')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                            }
function Space_seq3(pos:Int):Int? {
var currentPos := pos
def term0 := _EndOfLine(currentPos)
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                            }
function Space_opt0(pos:Int):Int? {
def seq0 := Space_seq1(pos                                                                                                                                                                                                )
if seq0 != null {
return seq0
                                                                                                                                                                                                }
def seq1 := Space_seq2(pos                                                                                                                                                                                                )
if seq1 != null {
return seq1
                                                                                                                                                                                                }
def seq2 := Space_seq3(pos                                                                                                                                                                                                )
if seq2 != null {
return seq2
                                                                                                                                                                                                }
return null
                                                                                                                                                                                                }
def Space_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _Space(pos:Int):Int? {
def cached := Space_cache[pos]
if cached != null return cached
def result := Space_opt0(pos)
if result != null
Space_cache[pos] := result
return result
                                                                                                                                                                                                }
function EndOfLine_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '\r\n')
term0 := currentPos + 2
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                }
function EndOfLine_seq2(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '\n')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                }
function EndOfLine_seq3(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if literal(currentPos, '\r')
term0 := currentPos + 1
else
term0 := null
if term0 = null
return null
currentPos := term0
return currentPos
                                                                                                                                                                                                }
function EndOfLine_opt0(pos:Int):Int? {
def seq0 := EndOfLine_seq1(pos                                                                                                                                                                                                    )
if seq0 != null {
return seq0
                                                                                                                                                                                                    }
def seq1 := EndOfLine_seq2(pos                                                                                                                                                                                                    )
if seq1 != null {
return seq1
                                                                                                                                                                                                    }
def seq2 := EndOfLine_seq3(pos                                                                                                                                                                                                    )
if seq2 != null {
return seq2
                                                                                                                                                                                                    }
return null
                                                                                                                                                                                                    }
def EndOfLine_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _EndOfLine(pos:Int):Int? {
def cached := EndOfLine_cache[pos]
if cached != null return cached
def result := EndOfLine_opt0(pos)
if result != null
EndOfLine_cache[pos] := result
return result
                                                                                                                                                                                                    }
function EndOfFile_seq1(pos:Int):Int? {
var currentPos := pos
def term0:Int?
if currentPos < text.length
term0 := currentPos + 1
else
term0 := null
if term0 != null
return null
return currentPos
                                                                                                                                                                                                    }
function EndOfFile_opt0(pos:Int):Int? {
def seq0 := EndOfFile_seq1(pos                                                                                                                                                                                                        )
if seq0 != null {
return seq0
                                                                                                                                                                                                        }
return null
                                                                                                                                                                                                        }
def EndOfFile_cache := new HashMap<Int, Int?>()
-- @unsafeFunction
function _EndOfFile(pos:Int):Int? {
def cached := EndOfFile_cache[pos]
if cached != null return cached
def result := EndOfFile_opt0(pos)
if result != null
EndOfFile_cache[pos] := result
return result
                                                                                                                                                                                                        }
                                                                                                                                                                                                        }
