package org.pandalanguage.peg

class Variable {
	def name:String

	def type:String

	def nullable:Bit

	var repeated:Bit

	constructor(name:String, type:String, repeated:Bit, nullable:Bit) {
		self.name := name
		self.type := type
		self.repeated := repeated
		self.nullable := nullable
	}

	function effectiveType():String {
		var result := type
		if repeated
			result := "Array<" + result + ">"
		if nullable & !type.endsWith("?")
			result += "?"
		return result
	}

	@override
	function format(fmt:String):String {
		return name
	}
}

================================================================================
Parser generator which reads a Parsing Expression Grammar file containing
embedded Panda code and creates a Panda parser which recognizes the grammar.

As this is intended solely for internal use by the compiler, no effort is made 
to be user friendly or report nice errors, the feature set is fairly minimal,
and there are plenty of sharp edges for the unwary to cut themselves on. Sorry!
================================================================================
class PEGGenerator {
	def out := new IndentedOutputStream(Console.outputStream)

	var varCount := 0

	def grammar:Grammar

	def definitions := new HashMap<String, Definition>()

	var currentDefinition := new Definition("<dummy>", "<dummy>", 
			new Options([]))

	-- maps variable names to variables
	var variablesByName := new HashMap<String, Variable>()

	def varLevels := new HashMap<String, Int>()

	var currentSequence := new Stack<Sequence>()

	def inVars := new HashMap<Term, List<Variable>>()

	def outVars := new HashMap<Term, List<Variable>>()

	def optionNames := new HashMap<Options, String>()

	var count := 0

	constant SUCCESS_TOKEN := "@@SUCCESS@@"
	
	constructor(grammar:Grammar	) {
		self.grammar := grammar
		for d in grammar.definitions
			definitions[d.name] := d
	}

	function escape(c:Char):String {
		if c = "'"
			return "\\'"
		if c = "\n"
			return "\\n"
		if c = "\r"
			return "\\r"
		if c = "\t"
			return "\\t"
		if c = "\\"
			return "\\\\"
		if c = "\""
			return "\\\""
		return c->>(String)
	}

	function escape(s:String):String {
		def result := new MutableString()
		for c in s
			result.append(escape(c))
		return result->>(String)
	}

	function getType(term:Term):String? {
		if term-?>(Identifier) {
			def name := term->(Identifier).text
			def definition := definitions[name]
			if definition = null {
				Console.writeLine("unknown definition '\{name}' in \{definitions.keys}")
				System.exit(1)
			}
			return definition.type
		}
		else if term-?>(CharClass)
			return "String"
		else if term-?>(Dot)
			return "String"
		else if term-?>(Literal)
			return "String"
		else if term-?>(And)
			return getType(term->(And).term)
		else if term-?>(Plus)
			return getType(term->(Plus).term)
		else if term-?>(Optional) {
			def base := getType(term->(Optional))
			if base.endsWith("?")
				return base
			return base + "?"
		}
		unreachable
	}

	method addInVar(term:Term, v:Variable) {
		var list := inVars[term]
		if list = null {
			list := new Array<Variable>()
			inVars[term] := list
		}
		if !list.contains(v)
			list.add(v)
	}

	method addOutVar(term:Term, v:Variable) {
		var list := outVars[term]
		if list = null {
			list := new Array<Variable>()
			outVars[term] := list
		}
		if !list.contains(v)
			list.add(v)
	}

	method findVariables(var term:Term, repeatedContext:Bit, 
			var nullable:Bit):Map<String, Variable> {
		Console.writeLine("looking for vars in \{term}")
		def result := new HashMap<String, Variable>()
		def name:String?
		if term-?>(Cut)
			return result
		var repeatedTerm := repeatedContext
		if term-?>(Plus) {
			repeatedTerm := true
			name := term.name
			term := term->(Plus).term
		}
		else if term-?>(Star) {
			repeatedTerm := true
			name := term.name
			term := term->(Star).term
		}
		else if term-?>(Optional) {
			nullable := true
			name := term.name
			term := term->(Optional).term
		}
		else
			name := term.name


		if term-?>(Options) {
			def vars := findVariables(term->(Options), repeatedTerm, 
						nullable)
			result.addAll(vars)
		}
		else if name != null {
			Console.writeLine("found term: \{name}")
			def type := getType(term)
			if type = null {
				Console.writeLine("term '\{name}' has no type")
				System.exit(1)
			}
			def old := variablesByName[name]
			if old != null {
				old.repeated := true
				addInVar(term, old)
				addOutVar(term, old)
			}
			else {
				def v := new Variable(name, type, repeatedTerm, nullable)
				result[name] := v
				variablesByName[name] := v
				if repeatedContext
					addInVar(term, v)
				addOutVar(term, v)
			}
		}
		return result
	}

	function findVariables(seq:Sequence, repeated:Bit, 
			nullable:Bit):Map<String, Variable>  {
		def result := new HashMap<String, Variable>()
		for term in seq.terms
			result.addAll(findVariables(term, repeated, nullable))
		return result
	}

	method findVariables(opt:Options, repeated:Bit, 
			nullable:Bit):Map<String, Variable> {
		def result := new HashMap<String, Variable>()
		for seq in opt.sequences {
			result.addAll(findVariables(seq, repeated, 
					nullable | opt.sequences.length > 1))
		}
		return result
	}

	method findVariables(definition:Definition):Map<String, Variable> {
		return findVariables(definition.definition, false, false)
	}

	function getInVars(opt:Options):ListView<Variable> {
		def currentOuts := new HashSet<Variable>()
		def result := new Array<Variable>()
		for seq in opt.sequences {
			def vars := getInVars(seq)
			if vars != null {
				for v in vars {
					if currentOuts.contains(v)
						continue
					if !result.contains(v)
						result.add(v)
				}
			}
			currentOuts.addAll(getOutVars(seq))
		}
		return result
	}

	function getOutVars(opt:Options):ListView<Variable> {
		def result := new Array<Variable>()
		for seq in opt.sequences {
			for v in getOutVars(seq) {
				if !result.contains(v)
					result.add(v)
			}
		}
		return result
	}

	function getInVars(seq:Sequence):ListView<Variable> {
		def currentOuts := new HashSet<Variable>()
		def result := new Array<Variable>()
		for t in seq.terms {
			def vars := inVars[t]
			if vars != null {
				for v in vars {
					if currentOuts.contains(v)
						continue
					if !result.contains(v)
						result.add(v)
				}
			}
			currentOuts.addAll(getOutVars(t))
		}
		return result
	}

	function getOutVars(seq:Sequence):ListView<Variable> {
		if seq.code != null
			return []
		def result := new Array<Variable>()
		for t in seq.terms {
			def vars := getOutVars(t)
			for v in vars {
				if !result.contains(v)
					result.add(v)
			}
		}
		return result
	}

	function getInVars(t:Term):ListView<Variable> {
		if t-?>(Quantifier)
			return getInVars(t->(Quantifier).term)
		if t-?>(Options)
			return getInVars(t->(Options))
		def result := inVars[t]
		if result = null
			return []
		return result
	}

	function getOutVars(t:Term):ListView<Variable> {
		if t-?>(Quantifier)
			return getOutVars(t->(Quantifier).term)
		if t-?>(Options)
			return getOutVars(t->(Options))
		def result := outVars[t]
		if result = null
			return []
		return result
	}

	function wrapChar(code:String, type:String):String {
		if type.startsWith("Char")
			return code
		if type.startsWith("String")
			return code + "->>(String)"
		if type.startsWith("Array<")
			return "[" + wrapChar(code, type["Array<".length..]) + "]"
		unreachable
	}

	function wrapString(code:String, type:String):String {
		if type.startsWith("String")
			return code
		if type.startsWith("Array<")
			return "[" + wrapChar(code, type["Array<".length..]) + "]"
		unreachable
	}

	method writeTermMatchCode(term:Term, target:String, 
			position:String) {
		out.write("def \{target}")
		def outs := getOutVars(term)
		if term-!>(Identifier) {
			if outs.length > 0 {
				out.write(":(Int")
				for i, v in outs
					out.write(", \{v.effectiveType}")
				out.writeLine(")?")
			}
			else
				out.writeLine(":Int?")
		}
		if term-?>(Literal) {
			def text := term->(Literal).text
			out.writeLine("if literal(\{position}, '\{escape(text)}')")
			out.level += 1
			if outs.length = 1 {
				def wrapped := wrapString("'\{escape(text)}'", 
						outs[0].effectiveType)
				out.writeLine("\{target} := (\{position} + 1, \{wrapped})")
			}
			else
				out.writeLine("\{target} := \{position} + \{text.length}")
			out.level -= 1
			out.writeLine("else")
			out.level += 1
			out.writeLine("\{target} := null")
			out.level -= 1
		}
		else if term-?>(CharClass) {
			def cc := term->(CharClass)
			def test := new MutableString()
			for i, r in cc.ranges {
				if i > 0
					test.append(" | ")
				if r.start = r.end
					test.append("literal(\{position}, '\{escape(r.start)}')")
				else {
					test.append("literal(\{position}, '\{escape(r.start)}', " +
							"'\{escape(r.end)}')")
				}
			}
			out.writeLine("if \{test}")
			out.level += 1
			if outs.length = 1 {
				def wrapped := wrapChar("text[\{position}]", 
						outs[0].effectiveType)
				out.writeLine("\{target} := (\{position} + 1, \{wrapped})")
			}
			else
				out.writeLine("\{target} := \{position} + 1")
			out.level -= 1
			out.writeLine("else")
			out.level += 1
			out.writeLine("\{target} := null")
			out.level -= 1
		}
		else if term-?>(Identifier) {
			def name := term->(Identifier).text
			def definition := definitions[name]
			if outs.length > 0 {
				assert outs.length = 1 : "sending \{definition.type} into \{outs}"
				assert definition != null : "no definition named '\{name}'"
				assert definition.type != null : "definition '\{name}' has no type"
				if outs[0].repeated & !definition.type.startsWith("Array<") &
						!definition.type.startsWith("ListView<") {
					out.writeLine("_temp := _\{name}(\{position})")
					out.writeLine("def \{target}:(Int, ListView<\{definition.type}>)?")
					out.writeLine("if \{target}_temp != null")
					out.level += 1
					out.writeLine("\{target} := (\{target}_temp[0], " +
							"[\{target}_temp[1]])")
					out.level -= 1
					out.writeLine("else")
					out.level += 1
					out.writeLine("\{target} := null")
					out.level -= 1
					return
				}
			}
			out.writeLine(" := _\{name}(\{position})")
		}
		else if term-?>(Options) {
			def opt := term->(Options)
			def name := optionNames[opt]
			assert name != null
			out.write("\{target} := \{name}(\{position}")
			def ins := getInVars(opt)
			if ins != null {
				for v in ins
					out.write(", \{v.name}")
			}
			out.writeLine(")")
		}
		else if term-?>(Dot) {
			out.writeLine("if \{position} < text.length")
			out.level += 1
			if outs.length = 1 {
				def wrapped := wrapChar("text[\{position}]", 
						outs[0].effectiveType)
				out.writeLine("\{target} := (\{position} + 1, \{wrapped})")
			}
			else
				out.writeLine("\{target} := \{position} + 1")
			out.level -= 1
			out.writeLine("else")
			out.level += 1
			out.writeLine("\{target} := null")
			out.level -= 1
		}
		else
			assert false : "unknown type: \{term} - '\{term.class.name}'"
	}

	method writeStarCode(term:Term, name:String?, target:String, position:String) {
		out.writeLine("loop {")
		writeTermMatchCode(term, target, position)
		out.writeLine("if \{target} = null")
		out.level += 1
		out.writeLine("break")
		out.level -= 1
		out.write("currentPos := \{target}")
		def outs := getOutVars(term)
		if outs.length > 0 {
			out.writeLine("[0]")
			for i, v in outs {
				if v.effectiveType.startsWith("Array<") {
					if !getInVars(term).contains(v) | name = v.name
						out.writeLine("\{v.name}.addAll(\{target}[\{i + 1}])")
					else
						out.writeLine("\{v.name} := new \{v.effectiveType}(\{target}[\{i + 1}])")
				}
				else
					out.writeLine("\{v.name} := \{target}[\{i + 1}]")
			}
		}
		else
			out.writeLine()
		out.writeLine("}")
	}	

	method writeTermCode(term:Term, target:String, position:String) {
		if term-?>(Not) {
			writeTermMatchCode(term->(Not).term, target, position)
			out.writeLine("if \{target} != null")
			out.level += 1
			out.writeLine("return null")
			out.level -= 1
			return
		}
		if term-?>(And) {
			writeTermMatchCode(term->(And).term, target, position)
			out.writeLine("if \{target} = null")
			out.level += 1
			out.writeLine("return null")
			out.level -= 1
			return
		}
		if term-?>(Star) {
			writeStarCode(term->(Star).term, term.name, target, position)
			return
		}
		if term-?>(Plus) {
			writeTermCode(term->(Plus).term, target, position)
			writeStarCode(term->(Plus).term, term.name, target, position)
			return
		}
		if term-?>(Optional) {
			writeTermMatchCode(term->(Optional).term, target, position)
			out.writeLine("if \{target} != null {")
			out.level += 1
			def termOut := getOutVars(term)
			out.write("currentPos := \{target}")
			if termOut.length > 0 {
				out.writeLine("[0]")
				for i, v in termOut {
					if v.effectiveType.startsWith("Array<") {
						out.writeLine("\{v.name}.addAll(\{target}[\{i + 1}])")
					}
					else
						out.writeLine("\{v.name} := \{target}[\{i + 1}]")
				}
			}
			else
				out.writeLine()
			out.level -= 1
			out.writeLine("}")
			return
		}
		writeTermMatchCode(term, target, position)
		out.writeLine("if \{target} = null")
		out.level += 1
		out.writeLine("return null")
		out.level -= 1
		def termOut := getOutVars(term)
		out.write("currentPos := \{target}")
		if termOut.length > 0 {
			out.writeLine("[0]")
			for i, v in termOut {
				if v.effectiveType.startsWith("Array<") {
					out.writeLine("\{v.name}.addAll(\{target}[\{i + 1}])")
				}
				else
					out.writeLine("\{v.name} := \{target}[\{i + 1}]")
			}
		}
		else
			out.writeLine()
	}

	method writeSequence(seq:Sequence):String {
		out.writeLine("-* \{seq} *-")
		def name := "\{currentDefinition.name}_seq\{count}"
		count += 1
		def seqIns := getInVars(seq)
		def seqOuts := getOutVars(seq)
		out.write("function \{name}(pos:Int")
		for v in seqIns {
			if v.repeated
				out.write(", \{v.name}_in:\{v.effectiveType}")
			else
				out.write(", \{v.name}:\{v.effectiveType}")
		}
		out.write("):")
		if seq.code != null
			out.writeLine("(Int, \{currentDefinition.type}) {")
		else if seqOuts.length > 0 {
			out.write("(Int")
			for v in seqOuts
				out.write(", \{v.effectiveType}")
			out.writeLine(")? {")
		}
		else
			out.writeLine("Int? {")
		out.level += 1
		for v in variablesByName.values {
			out.write("var \{v.name}:")
			if v.repeated {
				out.write("Array<\{v.type}> := new Array<\{v.type}>(")
				if seqIns.contains(v)
					out.write("\{v.name}_in")
				out.write(")")
			}
			else {
				out.write(v.effectiveType)
				if v.nullable
					out.write(" := null")
			}
			out.writeLine()
		}
		out.writeLine("var currentPos := pos")
		for i, t in seq.terms
			writeTermCode(t, "term\{i}", "currentPos")
		if seq.code != null {
			out.writeLine("def result:\{currentDefinition.type}")
			out.writeLine(seq.code)
			out.writeLine("return (currentPos, result)")
		}
		else if seqOuts.length > 0 {
			out.write("return (currentPos")
			for v in seqOuts
				out.write(", \{v.name}")
			out.writeLine(")")
		}
		else
			out.writeLine("return currentPos")
		out.level -= 1
		out.writeLine("}")
		return name
	}

	method writeEmbeddedOptions(t:Term) {
		if t-?>(Options)
			writeEmbeddedOptions(t->(Options))
		else if t-?>(Quantifier)
			writeEmbeddedOptions(t->(Quantifier).term)
	}

	method writeEmbeddedOptions(seq:Sequence) {
		for t in seq.terms
			writeEmbeddedOptions(t)
	}

	method writeEmbeddedOptions(opt:Options) {
		for seq in opt.sequences
			writeEmbeddedOptions(seq)
		writeOptions(opt)
	}

	function equal(l1:ListView<Variable>, l2:ListView<Variable>):Bit {
		if l1.length != l2.length
			return false
		for i, v in l1 {
			if v != l2[i]
				return false
		}
		return true
	}

	method writeOptions(options:Options):String {
		def name := "\{currentDefinition.name}_opt\{count}"
		count += 1
		optionNames[options] := name
		def inVars := getInVars(options)
		def outVars := getOutVars(options)
		def sequences := new Array<String>()
		for s in options.sequences {
			writeEmbeddedOptions(s)
			sequences.add(writeSequence(s))
		}
		out.writeLine("-* \{options} *-")
		out.write("function \{name}(pos:Int")
		for v in inVars
			out.write(", \{v.name}:\{v.effectiveType}")
		out.write("):")
		var codeCount := 0
		for s in options.sequences {
			if s.code != null
				codeCount += 1
		}
		var returnType:String
		if outVars.length = 0 & codeCount = 0
			returnType := "Int?"
		else {
			returnType := "(Int"
			if codeCount = options.sequences.length {
				if currentDefinition.type = null {
					Console.writeLine("cannot have code in definition with " +
							"no return type (in \{currentDefinition.name})")
					System.exit(1)
				}
				returnType += ", \{currentDefinition.type})"
			}
			else if codeCount = 0 {
				for v in outVars
					returnType += ", \{v.effectiveType}"
				returnType += ")"
			}
			else {
				Console.writeLine("either all options must have code, or " +
						"none must (in \{currentDefinition.name})")
				System.exit(1)
			}
		}
		out.writeLine("\{returnType} {")
		out.level += 1
		for i, seq in options.sequences {
			out.write("def seq\{i} := \{sequences[i]}(pos")
			for v in getInVars(seq)
				out.write(", \{v.name}")
			out.writeLine(")")
			out.writeLine("if seq\{i} != null {")
			out.level += 1
			if seq.code != null
				out.writeLine("return seq\{i}")
			else {
				def seqOut := getOutVars(seq)
				if equal(seqOut, outVars)
					out.writeLine("return seq\{i} -- equal!")
				else {
					out.write("return (seq\{i}[0]")
					for v in outVars {
						var found := false
						for j, v2 in seqOut {
							if v2 = v {
								found := true
								out.write(", seq\{i}[\{j + 1}]")
							}
						}
						if !found
							out.write(", null")
					}
					out.writeLine(")")
				}
			}
			out.level -= 1
			out.writeLine("}")
		}
		out.writeLine("return null")
		out.writeLine("}")
		return name
	}

	method writeDefinition(definition:Definition) {
		currentDefinition := definition
		variablesByName.clear()
		count := 0
		def vars := findVariables(definition)
		def options := writeOptions(definition.definition)
		def returnType:String
		if definition.type != null
			returnType := "(Int, \{definition.type})?"
		else
			returnType := "Int?"
		out.writeLine("-* \{definition} *-")
		def cache := "\{definition.name}_cache"
		out.writeLine("def \{cache} := " +
				"new HashMap<Int, \{returnType}>()")
		out.writeLine("-- @unsafeFunction")
		out.writeLine("function _\{definition.name}(pos:Int):\{returnType} {")
		out.level += 1
		out.writeLine("def cached := \{cache}[pos]")
		out.writeLine("if cached != null return cached")
		out.writeLine("def result := \{options}(pos)")
		out.writeLine("if result != null")
		out.level += 1
		out.writeLine("\{cache}[pos] := result")
		out.level -= 1
		out.writeLine("return result")
		out.level -= 1
		out.writeLine("}")
	}

	method writeGrammar(dest:File) {
		out := new IndentedOutputStream(dest.openOutputStream())
		if grammar.code != null
			out.writeLine(grammar.code[1 .. grammar.code.length - 1])
		out.writeLine("class \{dest.simpleName} {")
		out.writeLine("def fileName:String")
		out.writeLine("def text:String")
		out.writeLine("def cutStack := new Stack<Bit>()")
		out.writeLine("var maxPos := -1")
		out.writeLine("var maxLiterals := new HashSet<String>()")
		out.writeLine("constructor(file:File) {")
		out.writeLine("    fileName := file.name")
		out.writeLine("    text := file.readAsString()")
		out.writeLine("}")
		out.writeLine("function literal(pos:Int, c:Char):Bit {")
		out.writeLine("    if pos > maxPos { maxPos := pos    maxLiterals.clear() }")
		out.writeLine("    if pos = maxPos maxLiterals.add(escape(c))")
		out.writeLine("	   return pos < text.length & text[pos] = c")
		out.writeLine("}")
		out.writeLine("function literal(pos:Int, start:Char, end:Char):Bit {")
		out.writeLine("    if pos > maxPos { maxPos := pos    maxLiterals.clear() }")
		out.writeLine("    if pos = maxPos maxLiterals.add('[\\{escape(start)}-\\{escape(end)}]')")
		out.writeLine("	   return pos < text.length & text[pos] >= start & " +
				"text[pos] <= end")
		out.writeLine("}")
		out.writeLine("function literal(pos:Int, s:String):Bit {")
		out.writeLine("    if pos > maxPos { maxPos := pos    maxLiterals.clear() }")
		out.writeLine("    if pos = maxPos maxLiterals.add(escape(s))")
		out.writeLine("	   return pos + s.length <= text.length & " +
				"text[pos .. pos + s.length] = s")
		out.writeLine("}")
		out.writeLine("function getPosition(pos:Int):String {")
		out.writeLine("    def stream := new LineNumberInputStream(new MemoryInputStream(text))")
		out.writeLine("    for i in 0 .. pos")
		out.writeLine("        stream.readInt8()")
		out.writeLine("    return stream.line + ':' + stream.column")
		out.writeLine("}")
		out.writeLine("function escape(c:Char):String {")
		out.writeLine("	if c = '\\''")
		out.writeLine("		return \"\\\\'\"")
		out.writeLine("	if c = '\\n'")
		out.writeLine("		return '\\\\n'")
		out.writeLine("	if c = '\\r'")
		out.writeLine("		return '\\\\r'")
		out.writeLine("	if c = '\\t'")
		out.writeLine("		return '\\\\t'")
		out.writeLine("	if c = '\\\\'")
		out.writeLine("		return '\\\\\\\\'")
		out.writeLine("	if c = '\\\"'")
		out.writeLine("		return '\\\\\"'")
		out.writeLine("	return c->>(String)")
		out.writeLine("}")
		out.writeLine("function escape(s:String):String {")
		out.writeLine("	def result := new MutableString()")
		out.writeLine("	for c in s")
		out.writeLine("		result.append(escape(c))")
		out.writeLine("	return result->>(String)")
		out.writeLine("}")
		out.writeLine("def stack := new Stack<String>()")
		for d in grammar.definitions
			writeDefinition(d)
		out.writeLine("} -- class")
	}

	@class
	function getPosition(name:String, text:String, pos:Int):String {
		def stream := new LineNumberInputStream(new MemoryInputStream(text))
		for i in 0 .. pos
			stream.readInt8()
		return "\{name}:\{stream.line}:\{stream.column}"
	}

	@class
	method main(args:PrimitiveArray<String>) {
		def path := new File(args[0])
		def parser := new PEGParser(path)
		def r0 := parser._Grammar(0) 
		if r0 != null
			new PEGGenerator(r0[1]).writeGrammar(new File(args[1]))
		else
			Console.writeLine("Error parsing at \{getPosition(path.name, parser.text, parser.maxPos)}: expected one of \{parser.maxLiterals}, but found '\{parser.text[parser.maxPos]}'")
	}
}