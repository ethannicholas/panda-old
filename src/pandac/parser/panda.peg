{
    package org.pandalanguage.pandac.parser

    uses org.pandalanguage.pandac.ast.ArrowOperationType
    uses org.pandalanguage.pandac.ast.ASTAnnotation
    uses org.pandalanguage.pandac.ast.ASTArrayLiteral
    uses org.pandalanguage.pandac.ast.ASTArrowExpression
    uses org.pandalanguage.pandac.ast.ASTAssert
    uses org.pandalanguage.pandac.ast.ASTAssignment
    uses org.pandalanguage.pandac.ast.ASTAtReturn
    uses org.pandalanguage.pandac.ast.ASTBinaryExpression
    uses org.pandalanguage.pandac.ast.ASTBitLiteral
    uses org.pandalanguage.pandac.ast.ASTBlock
    uses org.pandalanguage.pandac.ast.ASTBreak
    uses org.pandalanguage.pandac.ast.ASTCallExpression
    uses org.pandalanguage.pandac.ast.ASTCatch
    uses org.pandalanguage.pandac.ast.ASTClass
    uses org.pandalanguage.pandac.ast.ASTClassLiteral
    uses org.pandalanguage.pandac.ast.ASTClassType
    uses org.pandalanguage.pandac.ast.ASTContinue
    uses org.pandalanguage.pandac.ast.ASTDo
    uses org.pandalanguage.pandac.ast.ASTDotExpression
    uses org.pandalanguage.pandac.ast.ASTEnum
    uses org.pandalanguage.pandac.ast.ASTEnumValue
    uses org.pandalanguage.pandac.ast.ASTExpression
    uses org.pandalanguage.pandac.ast.ASTExpressionStatement
    uses org.pandalanguage.pandac.ast.ASTField
    uses org.pandalanguage.pandac.ast.ASTFor
    uses org.pandalanguage.pandac.ast.ASTIdentifier
    uses org.pandalanguage.pandac.ast.ASTIf
    uses org.pandalanguage.pandac.ast.ASTIndex
    uses org.pandalanguage.pandac.ast.ASTInstanceDeclaration
    uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
    uses org.pandalanguage.pandac.ast.ASTInvariant
    uses org.pandalanguage.pandac.ast.ASTLambdaExpression
    uses org.pandalanguage.pandac.ast.ASTLoop
    uses org.pandalanguage.pandac.ast.ASTNew
    uses org.pandalanguage.pandac.ast.ASTNode
    uses org.pandalanguage.pandac.ast.ASTNullLiteral
    uses org.pandalanguage.pandac.ast.ASTMethod
    uses org.pandalanguage.pandac.ast.ASTMethodType
    uses org.pandalanguage.pandac.ast.ASTMethodValue
    uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
    uses org.pandalanguage.pandac.ast.ASTParameter
    uses org.pandalanguage.pandac.ast.ASTPlugin
    uses org.pandalanguage.pandac.ast.ASTPostcondition
    uses org.pandalanguage.pandac.ast.ASTPre
    uses org.pandalanguage.pandac.ast.ASTPrecondition
    uses org.pandalanguage.pandac.ast.ASTRangeExpression
    uses org.pandalanguage.pandac.ast.ASTRealLiteral
    uses org.pandalanguage.pandac.ast.ASTReturn
    uses org.pandalanguage.pandac.ast.ASTSelf
    uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
    uses org.pandalanguage.pandac.ast.ASTStatement
    uses org.pandalanguage.pandac.ast.ASTStringLiteral
    uses org.pandalanguage.pandac.ast.ASTSuper
    uses org.pandalanguage.pandac.ast.ASTSwitch
    uses org.pandalanguage.pandac.ast.ASTSwitchCase
    uses org.pandalanguage.pandac.ast.ASTThrow
    uses org.pandalanguage.pandac.ast.ASTTry
    uses org.pandalanguage.pandac.ast.ASTTupleExpression
    uses org.pandalanguage.pandac.ast.ASTTupleType
    uses org.pandalanguage.pandac.ast.ASTType
    uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
    uses org.pandalanguage.pandac.ast.ASTUnaryExpression
    uses org.pandalanguage.pandac.ast.ASTUnreachable
    uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
    uses org.pandalanguage.pandac.ast.ASTVarDeclaration
    uses org.pandalanguage.pandac.ast.ASTWhile
    uses org.pandalanguage.pandac.tree.BinaryOperationType
    uses org.pandalanguage.pandac.tree.MethodNodeType
    uses org.pandalanguage.pandac.tree.Position
    uses org.pandalanguage.pandac.tree.UnaryOperationType
    uses org.pandalanguage.pandac.tree.VariableType

    class ForTuple {
        def ids:ListView<String>

        def types:ListView<ASTType?>

        constructor(ids:ListView<String>, types:ListView<ASTType?>) {
            self.ids := ids
            self.types := types
        }
    }

    enum SuffixType {
        CALL,
        INDEX,
        DOT,
        INSTANCEOF,
        NINSTANCEOF,
        CAST,
        CONVERT
    }

    class Suffix {
        def suffixType:SuffixType
        
        def type:ASTType?

        def parameters:ListView<ASTExpression>

        def member:String

        constructor(suffixType:SuffixType, parameters:ListView<ASTExpression>) {
            self.suffixType := suffixType
            self.parameters := parameters
        }

        constructor(suffixType:SuffixType, type:ASTType) {
            self.suffixType := suffixType
            self.type := type
        }

        constructor(suffixType:SuffixType, member:String) {
            self.suffixType := suffixType
            self.member := member
        }

        @override
        function format(fmt:String):String {
            switch suffixType {
                case SuffixType.CALL: return "(" + parameters.join(", ") + ")"
                case SuffixType.INDEX: return "[" + parameters.join(", ") + "]"
                case SuffixType.DOT: return "." + member
                case SuffixType.INSTANCEOF: return "-?>" + type
                case SuffixType.NINSTANCEOF: return "-!>" + type
                case SuffixType.CAST: return "->" + type
                case SuffixType.CONVERT: return "->>" + type
                default: unreachable
            }
        }
    }

    class Utils {
        @class
        function position():Position {
            return Position.INTERNAL
        }

        @class
        function isExternal(f:File):Bit {
            return f.path.endsWith(".plink")
        }

        @class
        function combineExpressions(expr:ListView<ASTExpression>,
                op:BinaryOperationType):ASTExpression {
            if expr.length = 1
                return expr[0]
            var result := expr[expr.length - 1]
            for i in expr.length - 2 ... 0 by -1
                result := new ASTBinaryExpression(op, expr[i], result)
            return result
        }

        @class
        function combineExpressions(expr:ListView<ASTExpression>,
                op:ListView<BinaryOperationType>):ASTExpression {
            if expr.length = 1
                return expr[0]
            var result := expr[expr.length - 1]
            for i in expr.length - 2 ... 0 by -1
                result := new ASTBinaryExpression(op[i], expr[i], result)
            return result
        }

        @class
        function callExpression(term:ASTExpression, 
                suffixes:ListView<Suffix>):ASTExpression {
            var result := term
            for s in suffixes {
                switch s.suffixType {
                    case SuffixType.CALL: {
                        assert s.parameters != null
                        result := new ASTCallExpression(result, s.parameters)
                    }
                    case SuffixType.INDEX: {
                        assert s.parameters != null & s.parameters.length = 1
                        result := new ASTIndex(result, s.parameters[0])
                    }
                    case SuffixType.DOT: {
                        assert s.member != null
                        result := new ASTDotExpression(result, s.member)
                    }
                    case SuffixType.INSTANCEOF: {
                        assert s.type != null
                        result := new ASTArrowExpression(
                                ArrowOperationType.INSTANCE_OF, result, s.type)
                    }
                    case SuffixType.NINSTANCEOF: {
                        assert s.type != null
                        result := new ASTArrowExpression(
                                ArrowOperationType.NOT_INSTANCE_OF, result, 
                                s.type)
                    }
                    case SuffixType.CAST: {
                        assert s.type != null
                        result := new ASTArrowExpression(
                                ArrowOperationType.CAST, result, s.type)
                    }
                    case SuffixType.CONVERT: {
                        assert s.type != null
                        result := new ASTArrowExpression(
                                ArrowOperationType.CONVERT, result, s.type)
                    }
                    default:
                        unreachable
                }
            }
            return result
        }

        @class
        @pre(base >= 2 & base <= 36)
        function parseInt(s:String, base:UInt):UInt64? {
            var result:UInt64 := 0
            constant DIGITS := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            constant DIGITS_LOWER := "0123456789abcdefghijklmnopqrstuvwxyz"
            for i in 0 .. s.length {
                var digit := DIGITS.indexOf(s[i])->(UInt?)
                if digit = null {
                    digit := DIGITS_LOWER.indexOf(s[i])->(UInt?)
                }
                if digit = null | digit >= base {
                    return null
                }
                result := result * base + digit
            }
            return result
        }
    }
}

file:ListView<ASTNode> = WS? e:bodyEntry* EOF
    { result := e }
bodyEntry:ASTNode = u:usesStatement 
    { result := u }
/ 
    c:classDeclaration 
    { result := c }
/ 
    i:interfaceDeclaration 
    { result := i }
/ 
    e:enum 
    { result := e }
/ 
    m:methodDeclaration
    { result := m }
/ 
    f:functionDeclaration
    { result := f }
/ 
    p:packageDeclaration 
    { result := p }
/ 
    instance:instanceDeclaration 
    { result := instance }
/ 
    s:statement
    { result := s }

packageDeclaration:ASTPackageDeclaration = PACKAGE ^ @t:IDENTIFIER (@t:DOT 
        @t:IDENTIFIER)*
    { 
        result := new ASTPackageDeclaration(new Position(file, pos), 
                t.join("")) 
    }
usesStatement:ASTUsesDeclaration = USES ^ @i:IDENTIFIER (@i:DOT @i:IDENTIFIER)* 
        (@i:DOT @i:STAR)?
        (AS alias:IDENTIFIER)?
    { 
        result := new ASTUsesDeclaration(new Position(file, pos), 
                i.join(""), alias) 
    }
instanceDeclaration:ASTInstanceDeclaration = INSTANCE ^ t:type
    { result := new ASTInstanceDeclaration(new Position(file, pos), t) }


annotation:ASTAnnotation = &'@' a:simpleAnnotation 
    { result := a }
/ 
    p:precondition
    { result := p }
annotations:ListView<ASTAnnotation> = a:annotation+
    { result := a }
simpleAnnotation:ASTAnnotation = PROTECTED 
    { 
        result := new ASTSimpleAnnotation(new Position(file, pos), 
                "protected") 
    }
/ 
    PRIVATE 
    { 
        result := new ASTSimpleAnnotation(new Position(file, pos), 
                "private") 
    }
/ 
    ATCLASS 
    { 
        result := new ASTSimpleAnnotation(new Position(file, pos), "class") 
    }
/ 
    THREAD 
    { result := new ASTSimpleAnnotation(new Position(file, pos), "thread") }
/ 
    ABSTRACT 
    { 
        result := new ASTSimpleAnnotation(new Position(file, pos), 
                "abstract") 
    }
/ 
    EXTERNAL 
    { 
        result := new ASTSimpleAnnotation(new Position(file, pos), 
                "external") 
    }
/ 
    OVERRIDE 
    { 
        result := new ASTSimpleAnnotation(new Position(file, pos), 
                "override") 
    }
/ 
    READONLY 
    { 
        result := new ASTSimpleAnnotation(new Position(file, pos), 
                "readonly") 
    }
/ 
    LIMITED 
    { 
        result := new ASTSimpleAnnotation(new Position(file, pos), 
                "limited") 
    }
/ 
    ATSELF 
    { result := new ASTSimpleAnnotation(new Position(file, pos), "self") }
/ 
    SAFERETURN 
    { result := new ASTSimpleAnnotation(new Position(file, pos), "safeReturn") }
/ 
    UNSAFEFUNCTION 
    { result := new ASTSimpleAnnotation(new Position(file, pos), "unsafeFunction") }
/ 
    FINAL 
    { result := new ASTSimpleAnnotation(new Position(file, pos), "final") }
/ 
    WRAPPER_METHOD 
    { result := new ASTSimpleAnnotation(new Position(file, pos), "$wrapperMethod") }
/ 
    MATH ^ LPAREN OVERFLOW RPAREN
    { result := new ASTSimpleAnnotation(new Position(file, pos), "math(overflow)") }
precondition:ASTAnnotation = PRE ^ LPAREN expr1:expression RPAREN
    { result := new ASTPrecondition(new Position(file, pos), expr1, false) }
/
    PRE_OR ^ LPAREN expr2:expression RPAREN
    { result := new ASTPrecondition(new Position(file, pos), expr2, true) }

classDeclaration:ASTClass = dc:DOCCOMMENT? a:annotations? CLASS ^ 
        name:IDENTIFIER gp:genericParametersDeclaration? (COLON s:classType)? 
        i:interfaces? LBRACE body:classMembers RBRACE
    {
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        for m in body {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := new ASTClass(new Position(file, pos), name, false, dc, a, s, 
                i, gp, methods, fields, invariants, Utils.isExternal(file))
    }
interfaces:ListView<ASTType> = LPAREN t:type (COMMA t:type)* RPAREN
    { result := t }
genericParametersDeclaration:ListView<ASTTypedIdentifier> = LT t:typedIdentifier
         (COMMA t:typedIdentifier)* GT
    { result := t }
classMembers:ListView<ASTNode> = m:classMember*
    { result := m }
classMember:ASTNode = i:invariant 
    { result := i }
/ 
    m:methodDeclaration 
    { result := m }
/ 
    f:functionDeclaration 
    { result := f }
/ 
    c:constructorDeclaration 
    { result := c }
/ 
    field:fieldDeclaration
    { result := field }
invariant:ASTInvariant = INVARIANT LPAREN expr:expression RPAREN
    { result := new ASTInvariant(new Position(file, pos), expr) }

interfaceDeclaration:ASTClass = dc:DOCCOMMENT? a:annotations? INTERFACE ^ 
        name:IDENTIFIER gp:genericParametersDeclaration? 
        (COLON s:classType (COMMA s:classType)*)? LBRACE body:classMembers 
        RBRACE
    {
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        for m in body {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := new ASTClass(new Position(file, pos), name, true, dc, a, null, s, gp, 
                methods, fields, invariants, Utils.isExternal(file))
    }

enum:ASTEnum = dc:DOCCOMMENT? a:annotations? ENUM ^ name:IDENTIFIER LBRACE 
        (v:enumValue (COMMA v:enumValue)*)? RBRACE
    {
        result := new ASTEnum(new Position(file, pos), name, dc, a, v, 
                Utils.isExternal(file))
    }
enumValue:ASTEnumValue = dc:DOCCOMMENT? name:IDENTIFIER
    { result := new ASTEnumValue(new Position(file, pos), name, dc) }

typeDeclaration:ASTType = COLON ^ type:type
    { result := type }
type:ASTType = m:methodOrTupleType 
    { result := m }
/ 
    cl:classType
    { result := cl }
methodOrTupleType:ASTType = LPAREN (type:type (COMMA type:type)*)? RPAREN 
        ((ymi:YIELDS_METHOD_IMMUTABLE / yi:YIELDS_IMMUTABLE / y:YIELDS / 
        ym:YIELDS_METHOD) LPAREN ret:type? RPAREN)? 
        nullable:QUESTION?
    {
        if y != null {
            result := new ASTMethodType(new Position(file, pos), type, ret,
                    nullable != null, true, false)
        }
        else if yi != null {
            result := new ASTMethodType(new Position(file, pos), type, ret,
                    nullable != null, true, true)
        }
        else if ym != null {
            result := new ASTMethodType(new Position(file, pos), type, ret,
                    nullable != null, false, false)
        }
        else if ymi != null {
            result := new ASTMethodType(new Position(file, pos), type, ret,
                    nullable != null, false, true)
        }
        else {
            result := new ASTTupleType(new Position(file, pos), type, 
                    nullable != null)
        }
    }
classType:ASTType = @name:IDENTIFIER (@name:DOT @name:IDENTIFIER)* 
        params:genericParameters? nullable:QUESTION?
    {
        result := new ASTClassType(new Position(file, pos), name.join(""), params, 
                nullable != null)
    }
genericParameters:ListView<ASTType> = LT type:type (COMMA type:type)* GT
    { result := type }

methodDeclaration:ASTMethod = dc:DOCCOMMENT? a:annotations? METHOD ^ 
        name:methodName gp:genericParametersDeclaration? 
        params:formalParameterList t:typeDeclaration? b:block? 
        post:postcondition*
    {
        result := new ASTMethod(new Position(file, pos), name, MethodNodeType.METHOD, 
                dc, a, params, t, b, post)
    }
functionDeclaration:ASTMethod = dc:DOCCOMMENT? a:annotations? FUNCTION ^ 
        name:methodName gp:genericParametersDeclaration? 
        params:formalParameterList t:typeDeclaration b:block? 
        post:postcondition*
    {
        result := new ASTMethod(new Position(file, pos), name, MethodNodeType.FUNCTION, 
                dc, a, params, t, b, post)
    }
methodOrFunction:ASTMethod = m:methodDeclaration
    { result := m }
/ f:functionDeclaration
    { result := f }
constructorDeclaration:ASTMethod = dc:DOCCOMMENT? a:annotations? CONSTRUCTOR ^ 
        gp:genericParametersDeclaration? params:formalParameterList 
        t:typeDeclaration? b:block? post:postcondition*
    {
        result := new ASTMethod(new Position(file, pos), "constructor", 
                MethodNodeType.CONSTRUCTOR, dc, a, params, t, b, post)
    }
methodName:String = IDENTIFIER ASSIGNMENT? / CONVERT / SHIFTLEFT / SHIFTRIGHT / 
        ADD / SUB / MUL /  INTDIV / DIV / POW / EQ / GTEQ / LTEQ / GT / LT / 
        REM / BITWISEAND / AND / BITWISEOR / OR / BITWISEXOR / XOR / 
        BITWISENOT / NOT / (LBRACKET (ELLIPSIS / DOTDOT)? RBRACKET ASSIGNMENT?)
formalParameter:ASTParameter = v:VAR? n:IDENTIFIER (c:COLON / cnv:CONVERT) 
        t:type e:ELLIPSIS?
    {
        result := new ASTParameter(new Position(file, pos), n, t, v != null,
            cnv != null, e != null)
    }
formalParameterList:ListView<ASTParameter> = LPAREN (p:formalParameter 
        (COMMA p:formalParameter)*)? RPAREN
    { result := p }
postcondition:ASTPostcondition = POST ^ LPAREN expr1:expression RPAREN
    { result := new ASTPostcondition(new Position(file, pos), expr1, false) }
/
    POST_AND ^ LPAREN expr2:expression RPAREN
    { result := new ASTPostcondition(new Position(file, pos), expr2, true) }

varType:VariableType = v:VAR 
    { result := v }
/ 
    d:DEF
    { result := d }
/ 
    c:CONSTANT 
    { result := c }
/ 
    p:PROPERTY
    { result := p }

varName:String = IDENTIFIER / UNDERSCORE

varDeclaration:ASTVarDeclaration = varType:varType ^ t:typedIdentifier 
        (COMMA t:typedIdentifier)* (ASSIGNMENT expr:expression)?
    { result := new ASTVarDeclaration(new Position(file, pos), varType, t, expr) }
typedIdentifier:ASTTypedIdentifier = i:IDENTIFIER t:optionalTypeDeclaration
    { result := new ASTTypedIdentifier(new Position(file, pos), i, t) }
optionalTypeDeclaration:ASTType? = (COLON type:type)?
    { result := type }
fieldDeclaration:ASTField = dc:DOCCOMMENT? a:annotations? v:varDeclaration
    { result := new ASTField(dc, a, v) }

suffix:Suffix = p:parameters 
    { result := new Suffix(SuffixType.CALL, p) }
/
    LBRACKET expr:expression RBRACKET 
    { result := new Suffix(SuffixType.INDEX, [expr]) }
/
    LBRACKET ELLIPSIS ^ (right1:expression (BY step1:expression)?)? RBRACKET 
    { 
        def range := new ASTRangeExpression(new Position(file, pos), null, right1,
                    step1, true)
        result := new Suffix(SuffixType.INDEX, [range]) 
    }
/
    LBRACKET DOTDOT ^ (right2:expression (BY step2:expression)?)? RBRACKET 
    { 
        def range := new ASTRangeExpression(new Position(file, pos), null, right2,
                    step2, false)
        result := new Suffix(SuffixType.INDEX, [range]) 
    }
/
    DOT id:IDENTIFIER 
    { result := new Suffix(SuffixType.DOT, id) }
/
    DOT CLASS
    { result := new Suffix(SuffixType.DOT, "$class") }
/
    DOT CONSTRUCTOR
    { result := new Suffix(SuffixType.DOT, "constructor") }
/
    INSTANCEOF LPAREN t1:type RPAREN
    {  result := new Suffix(SuffixType.INSTANCEOF, t1) }
/
    NINSTANCEOF LPAREN t2:type RPAREN
    {  result := new Suffix(SuffixType.NINSTANCEOF, t2) }
/
    CAST LPAREN t3:type RPAREN
    {  result := new Suffix(SuffixType.CAST, t3) }
/
    CONVERT LPAREN t4:type RPAREN
    {  result := new Suffix(SuffixType.CONVERT, t4) }
callExpression:ASTExpression = t:term s:suffix*
    { result := Utils.callExpression(t, s) }
exponentExpression:ASTExpression = expr:callExpression 
        (POW expr:callExpression)*
    {
        result := Utils.combineExpressions(expr, BinaryOperationType.POWER)
    }
unaryExpression:ASTExpression = SUB expr1:exponentExpression
    {
        result := new ASTUnaryExpression(new Position(file, pos), 
                UnaryOperationType.MINUS, expr1)
    }
/ 
    n:NOT expr2:exponentExpression
    {
        result := new ASTUnaryExpression(new Position(file, pos), 
                UnaryOperationType.NOT, expr2)
    }
/ 
    BITWISENOT expr3:exponentExpression
    {
        result := new ASTUnaryExpression(new Position(file, pos), 
                UnaryOperationType.BITWISE_NOT, expr3)
    }
/ 
    expr4:exponentExpression
    { result := expr4 }
multiplicativeOperator:BinaryOperationType = m:MUL
    { result := m }
/
    i:INTDIV
    { result := i }
/
    d:DIV
    { result := d }
/
    r:REM
    { result := r }
/
    sl:SHIFTLEFT
    { result := sl }
/
    sr:SHIFTRIGHT
    { result := sr }
/
    a:BITWISEAND
    { result := a }
/
    x:BITWISEXOR
    { result := x }
multiplicativeExpression:ASTExpression = expr:unaryExpression 
        (op:multiplicativeOperator expr:unaryExpression)*
    { result := Utils.combineExpressions(expr, op) }
additiveOperator:BinaryOperationType = a:ADD 
    { result := a }
/ 
    s:SUB
    { result := s }
/ 
    o:BITWISEOR
    { result := o }
additiveExpression:ASTExpression = expr:multiplicativeExpression 
        (op:additiveOperator expr:multiplicativeExpression)* 
    { result := Utils.combineExpressions(expr, op) }
rangeExpression:ASTExpression = left:additiveExpression ((e:ELLIPSIS / d:DOTDOT)
        right:additiveExpression? (BY step:additiveExpression)?)?
    {
        if e != null | d != null {
            result := new ASTRangeExpression(left.position, left, right,
                    step, e != null)
        }
        else
            result := left
    }
comparisonOperator:BinaryOperationType = i:IDENTITY 
    { result := i }
/ 
    e:EQ 
    { result := e }
/ 
    ni:NIDENTITY 
    { result := ni }
/
    ne:NEQ 
    { result := ne }
/ 
    le:LTEQ
    { result := le }
/ 
    ge:GTEQ 
    { result := ge }
/ 
    l:LT 
    { result := l }
/ 
    g:GT
    { result := g }
comparisonExpression:ASTExpression = expr:rangeExpression (op:comparisonOperator 
        expr:rangeExpression)*
    { result := Utils.combineExpressions(expr, op) }
andOperator:BinaryOperationType = a:AND
    { result := a }
/
    x:XOR
    { result := x }
andExpression:ASTExpression = expr:comparisonExpression (op:andOperator 
        expr:comparisonExpression)*
    { result := Utils.combineExpressions(expr, op) }
orExpression:ASTExpression = expr:andExpression (OR expr:andExpression)*
    { 
        result := Utils.combineExpressions(expr, BinaryOperationType.OR)
    }
expression:ASTExpression = o:orExpression
    { result := o }

term:ASTExpression = l:lambdaOrTuple
    { result := l }
/
    r:REAL
    { result := new ASTRealLiteral(new Position(file, pos), r) }
/
    i:INTEGER
    { result := new ASTIntegerLiteral(new Position(file, pos), i) } 
/
    LPAREN expr1:expression RPAREN
    { result := expr1 }
/ 
    TRUE
    { result := new ASTBitLiteral(new Position(file, pos), true) }
/ 
    FALSE 
    { result := new ASTBitLiteral(new Position(file, pos), false) }
/ 
    NULL 
    { result := new ASTNullLiteral(new Position(file, pos)) }
/ 
    s:STRING 
    { result := new ASTStringLiteral(new Position(file, pos), s) }
/ 
    p:PLUGIN 
    { result := new ASTPlugin(new Position(file, pos), p) }
/ 
    SELF 
    { result := new ASTSelf(new Position(file, pos)) }
/
    SUPER 
    { result := new ASTSuper(new Position(file, pos)) }
/
    CLASS LPAREN t:type RPAREN
    { result := new ASTClassLiteral(t) }
/ 
    CLASS
    { result := new ASTDotExpression(new ASTSelf(new Position(file, pos)), "$class") }
/  
    c:construct 
    { result := c }
/
    a:arrayLiteral
    { result := a }
/ 
    m:methodValue 
    { result := m }
/
    ATRETURN 
    { result := new ASTAtReturn(new Position(file, pos)) }
/ 
    PRE LPAREN expr2:expression RPAREN 
    { result := new ASTPre(new Position(file, pos), expr2) }
/ 
    CONSTRUCTOR
    { 
        result := new ASTDotExpression(new ASTSelf(new Position(file, pos)), 
                "constructor") 
    }
/
    id:IDENTIFIER
    { result := new ASTIdentifier(new Position(file, pos), id) }


arrayLiteral:ASTExpression = LBRACKET (expr:expression 
        (COMMA expr:expression)*)? RBRACKET
    {
        result := new ASTArrayLiteral(new Position(file, pos), expr)
    }

lambdaOrTuple:ASTExpression = LPAREN (name1:IDENTIFIER type1:typeDeclaration 
        (COMMA name1:IDENTIFIER type1:typeDeclaration)*)? RPAREN YIELDS ^ 
        expr1:expression 
    {
        def params := new Array<ASTTypedIdentifier>()
        assert name1.length = type1.length
        for i, n in name1
            params.add(new ASTTypedIdentifier(new Position(file, pos), n, type1[i]))
        result := new ASTLambdaExpression(new Position(file, pos), params, expr1)
    }
/
    LPAREN name2:IDENTIFIER (COMMA name2:IDENTIFIER)* RPAREN YIELDS ^ 
            expr2:expression 
    {
        def params := new Array<ASTTypedIdentifier>()
        for n in name2
            params.add(new ASTTypedIdentifier(new Position(file, pos), n, null))
        result := new ASTLambdaExpression(new Position(file, pos), params, expr2)
    }
/
    LPAREN ^ expr3:expression (COMMA expr3:expression)+ RPAREN 
    { result := new ASTTupleExpression(new Position(file, pos), expr3) }
/
    name4:IDENTIFIER type4:optionalTypeDeclaration YIELDS ^ expr4:expression
    { 
        result := new ASTLambdaExpression(new Position(file, pos), 
                [new ASTTypedIdentifier(new Position(file, pos), name4, type4)], expr4)
    }

construct:ASTExpression = NEW ^ t:type p:parameters
    { result := new ASTNew(new Position(file, pos), t, p) }

parameters:ListView<ASTExpression> = LPAREN (expr:expression 
        (COMMA expr:expression)*)? RPAREN
    { result := expr }

methodValue:ASTExpression = FUNCTION ^ p1:formalParameterList t1:typeDeclaration 
        b1:block
    {
        result := new ASTMethodValue(new Position(file, pos), MethodNodeType.FUNCTION, 
            p1, t1, b1)
    }
/
    METHOD ^ p2:formalParameterList t2:typeDeclaration? b2:block
    {
        result := new ASTMethodValue(new Position(file, pos), MethodNodeType.METHOD, 
            p2, t2, b2)
    }

statement:ASTStatement = 
    v:varDeclaration
    { result := v }
/ 
    i:ifStatement 
    { result := i }
/ 
    f:forLoop 
    { result := f }
/ 
    w:whileLoop 
    { result := w }
/ 
    d:doLoop 
    { result := d }
/ 
    l:loop 
    { result := l }
/ 
    e:expressionOrAssignment
    { result := e }
/ 
    a:assertStatement 
    { result := a }
/ 
    s:switchStatement
    { result := s }
/ 
    t:tryStatement 
    { result := t }
/
    b:block
    { result := b }
block:ASTBlock = LBRACE ^ s:statement* t:terminalStatement? RBRACE
    { 
        def statements := new Array<ASTStatement>()
        statements.addAll(s)
        if t != null
            statements.add(t)
        result := new ASTBlock(new Position(file, pos), statements)
    }
statementOrBlock:ASTStatement = s:statement 
    { result := s }
/ 
    t:terminalStatement
    { result := t }

assertStatement:ASTAssert = ASSERT ^ test:expression (COLON msg:expression)?
    { result := new ASTAssert(new Position(file, pos), test, msg) }
terminalStatement:ASTStatement = r:returnStatement 
    { result := r }
/ 
    b:breakStatement 
    { result := b }
/ 
    c:continueStatement 
    { result := c }
/ 
    t:throwStatement 
    { result := t }
/ 
    u:unreachableStatement
    { result := u }
returnStatement:ASTReturn = 'return' ^ (WS_SAMELINE expr:expression)? WS
    { result := new ASTReturn(new Position(file, pos), expr) }
breakStatement:ASTBreak = 'break' ^ (WS_SAMELINE label:IDENTIFIER)? WS
    { result := new ASTBreak(new Position(file, pos), label) }
continueStatement:ASTContinue = 'continue' ^ (WS_SAMELINE label:IDENTIFIER)? WS
    { result := new ASTContinue(new Position(file, pos), label) }
throwStatement:ASTThrow = THROW ^ expr:expression
    { result := new ASTThrow(new Position(file, pos), expr) }
unreachableStatement:ASTUnreachable = UNREACHABLE ^ (COLON expression)?
    { result := new ASTUnreachable(new Position(file, pos)) }

forLoop:ASTFor = label:label? FOR ^ (index:IDENTIFIER indexType:typeDeclaration? 
        COMMA)? (loopVar:IDENTIFIER ^ loopVarType:typeDeclaration? / 
        tuple:forTuple) IN list:expression statement:statementOrBlock
    {
        def indexVar:ASTTypedIdentifier?
        if index != null
            indexVar := new ASTTypedIdentifier(new Position(file, pos), index, indexType)
        else
            indexVar := null
        def valueVars := new Array<ASTTypedIdentifier>()
        if loopVar != null {
            valueVars.add(new ASTTypedIdentifier(new Position(file, pos), loopVar, 
                    loopVarType))
        }
        else {
            assert tuple != null
            assert tuple.ids.length = tuple.types.length
            for i, id in tuple.ids {
                valueVars.add(new ASTTypedIdentifier(new Position(file, pos), id, 
                        tuple.types[i]))
            }
        }
        result := new ASTFor(new Position(file, pos), label, indexVar, valueVars, list, 
                statement)
    }
forTuple:ForTuple = label:label? LPAREN ^ id:varName
        type:optionalTypeDeclaration (COMMA id:varName
        type:optionalTypeDeclaration)+ RPAREN
    { result := new ForTuple(id, type) }
doLoop:ASTDo = label:label? DO ^ statement:statementOrBlock WHILE 
        test:expression
    { result := new ASTDo(new Position(file, pos), label, test, statement) }
whileLoop:ASTWhile = label:label? WHILE ^ test:expression 
        statement:statementOrBlock
    { result := new ASTWhile(new Position(file, pos), label, test, statement) }
loop:ASTLoop = label:label? LOOP ^ statement:statementOrBlock
    { result := new ASTLoop(new Position(file, pos), label, statement) }
label:String = id:IDENTIFIER COLON
    { result := id }

ifStatement:ASTIf = IF test:expression thenStatement:statementOrBlock (ELSE
        elseStatement:statementOrBlock)?
    {  
        result := new ASTIf(new Position(file, pos), test, thenStatement, 
                elseStatement) 
    }

switchStatement:ASTSwitch = SWITCH value:expression LBRACE cases:switchCase* 
        (DEFAULT COLON defaultCase:statementOrBlock)? RBRACE
    {
        result := new ASTSwitch(new Position(file, pos), value, cases, defaultCase)
    }
switchCase:ASTSwitchCase = CASE expr:expression (COMMA expr:expression)* COLON 
        statement:statementOrBlock
    {
        result := new ASTSwitchCase(new Position(file, pos), expr, statement)
    }

tryStatement:ASTStatement = TRY statement:statementOrBlock catches:catchBlock+
    {
        result := new ASTTry(new Position(file, pos), statement, catches, null)
    }
catchBlock:ASTCatch = CATCH name:IDENTIFIER type:typeDeclaration
        statement:statementOrBlock
    {
        result := new ASTCatch(new Position(file, pos), name, type, statement)
    }

assignmentOperator:BinaryOperationType? = ASSIGNMENT 
    {
        result := null
    }
/ 
    ADDEQ
    {
        result := BinaryOperationType.ADD
    }
/ 
    SUBEQ
    {
        result := BinaryOperationType.SUBTRACT
    }
/ 
    MULEQ 
    {
        result := BinaryOperationType.MULTIPLY
    }
/ 
    DIVEQ 
    {
        result := BinaryOperationType.DIVIDE
    }
/ 
    INTDIVEQ 
    {
        result := BinaryOperationType.INT_DIVIDE
    }
/ 
    POWEQ 
    {
        result := BinaryOperationType.POWER
    }
/ 
    REMEQ 
    {
        result := BinaryOperationType.REMAINDER
    }
/ 
    ANDEQ 
    {
        result := BinaryOperationType.AND
    }
/ 
    BITWISEANDEQ 
    {
        result := BinaryOperationType.BITWISE_AND
    }
/ 
    OREQ 
    {
        result := BinaryOperationType.OR
    }
/ 
    BITWISEOREQ 
    {
        result := BinaryOperationType.BITWISE_OR
    }
/ 
    XOREQ 
    {
        result := BinaryOperationType.XOR
    }
/ 
    BITWISEXOREQ 
    {
        result := BinaryOperationType.BITWISE_OR
    }
/ 
    SHIFTLEFTEQ 
    {
        result := BinaryOperationType.SHIFT_LEFT
    }
/ 
    SHIFTRIGHTEQ
    {
        result := BinaryOperationType.SHIFT_RIGHT
    }

expressionOrAssignment:ASTStatement = left:expression (COMMA left:expression)* 
        op:assignmentOperator right:expression
    {
        result := new ASTAssignment(left, op, right)
    }
/
    expr:expression
    {
        result := new ASTExpressionStatement(expr)
    }

WS = ([ \r\n\t] / COMMENT)*
WS_SAMELINE = ([ \t] / COMMENT)*
COMMENT = LINE_COMMENT / BLOCK_COMMENT
LINE_COMMENT = '--' (!'\n' .)* '\n'
BLOCK_COMMENT = '-*' (BLOCK_COMMENT / !'*-' .)* '*-'
DOCCOMMENT:String = '===' '='* (!'===' s:.)* '='* WS
    { result := s.join("") }
IDCHAR:String = [a-zA-Z_0-9$]
KEYWORD = &[a-z] (PACKAGE / CLASS / INTERFACE / ENUM / USES / AS / METHOD / 
        FUNCTION / CONSTRUCTOR / VAR / DEF / CONSTANT / PROPERTY / CLASS / 
        TRUE / FALSE / NULL / SELF / SUPER / NEW / BY / FOR / IN / WHILE / DO / 
        LOOP / IF / ELSE / SWITCH / CASE / DEFAULT / ASSERT / UNREACHABLE / 
        TRY / CATCH / THROW / BREAK / CONTINUE / RETURN)
IDENTIFIER:String = !KEYWORD @c:[a-zA-Z$] @c:IDCHAR* WS
    { result := c.join("") }
/ 
    !KEYWORD @u:'_' @u:IDCHAR* WS
    { result := u.join("") }
INTEGER:UInt64 = i:[0-9]+ !IDCHAR WS
    { result := i.join("")->>(UInt64) }
/
    '0x' h:[0-9a-fA-F+]+ !IDCHAR WS
    { result := Utils.parseInt(h.join(""), 16) }
/
    '0b' b:[01]+ !IDCHAR WS
    { result := Utils.parseInt(b.join(""), 2) }
REAL:Real64 = r:[0-9]* r:'.' r:[0-9]+ (r:[eE] r:'-'? r:[0-9]+)? !IDCHAR WS
    { result := r.join("")->>(Real64) }
STRING_EXPRESSION = '{' expression (',' (!'}' .)+)? '}'
STRING_CHAR:String = !'\\' . / '\\' ([tnr\\'"] / STRING_EXPRESSION )
STRING:String = '"' (!'"' @s:STRING_CHAR)* '"' WS
    { result := s.join("") }
/
    '\'' (!'\'' @s:STRING_CHAR)* '\'' WS
    { result := s.join("") }
PLUGIN:String = '#' (!'#' p:.)* '#' WS
    { result := p.join("") }
UNDERSCORE:String = u:'_' !IDCHAR WS
    { result := u }
PACKAGE = 'package' !IDCHAR WS
CLASS = 'class' !IDCHAR WS
INTERFACE = 'interface' !IDCHAR WS
ENUM = 'enum' !IDCHAR WS
USES = 'uses' !IDCHAR WS
AS = 'as' !IDCHAR WS
METHOD = 'method' !IDCHAR WS
FUNCTION = 'function' !IDCHAR WS
CONSTRUCTOR = 'constructor' !IDCHAR WS
VAR:VariableType = 'var' !IDCHAR WS
    { result := VariableType.VAR }
DEF:VariableType = 'def' !IDCHAR WS
    { result := VariableType.DEF }
CONSTANT:VariableType = 'constant' !IDCHAR WS
    { result := VariableType.CONSTANT }
PROPERTY:VariableType = 'property' !IDCHAR WS 
    { result := VariableType.PROPERTY }
PROTECTED = '@protected' !IDCHAR WS
PRIVATE = '@private' !IDCHAR WS
ATCLASS = '@class' !IDCHAR WS
THREAD = '@thread' !IDCHAR WS
ABSTRACT = '@abstract' !IDCHAR WS
EXTERNAL = '@external' !IDCHAR WS
OVERRIDE = '@override' !IDCHAR WS
READONLY = '@readonly' !IDCHAR WS
LIMITED = '@limited' !IDCHAR WS
ATSELF = '@self' !IDCHAR WS
SAFERETURN = '@safeReturn' !IDCHAR WS
UNSAFEFUNCTION = '@unsafeFunction' !IDCHAR WS
FINAL = '@final' !IDCHAR WS
WRAPPER_METHOD = '@$wrapperMethod' !IDCHAR WS
MATH = '@math' !IDCHAR WS
OVERFLOW = 'overflow' !IDCHAR WS
INVARIANT = '@invariant' !IDCHAR WS
INSTANCE = '@$instance' !IDCHAR WS
PRE = '@pre' !IDCHAR WS
POST = '@post' !IDCHAR WS
PRE_OR = '@preOr' !IDCHAR WS
POST_AND = '@postAnd' !IDCHAR WS
ATRETURN = '@return' !IDCHAR WS
TRUE = 'true' !IDCHAR WS
FALSE = 'false' !IDCHAR WS
NULL = 'null' !IDCHAR WS
SELF = 'self' !IDCHAR WS
SUPER = 'super' !IDCHAR WS
NEW = 'new' !IDCHAR WS
BY = 'by' !IDCHAR WS
FOR = 'for' !IDCHAR WS
IN = 'in' !IDCHAR WS
WHILE = 'while' !IDCHAR WS
DO = 'do' !IDCHAR WS
LOOP = 'loop' !IDCHAR WS
IF = 'if' !IDCHAR WS
ELSE = 'else' !IDCHAR WS
SWITCH = 'switch' !IDCHAR WS
CASE = 'case' !IDCHAR WS
DEFAULT = 'default' !IDCHAR WS
ASSERT = 'assert' !IDCHAR WS
RETURN = 'return' !IDCHAR WS
BREAK = 'break' !IDCHAR WS
CONTINUE = 'continue' !IDCHAR WS
UNREACHABLE = 'unreachable' !IDCHAR WS
TRY = 'try' !IDCHAR WS
CATCH = 'catch' !IDCHAR WS
THROW = 'throw' !IDCHAR WS
COLON:Bit = ':' WS
    { result := true }
LBRACKET = '[' WS
RBRACKET = ']' WS
LBRACE = '{' WS
RBRACE = '}' WS
LPAREN = '(' WS
RPAREN = ')' WS
ADD:BinaryOperationType = '+' WS
    { result := BinaryOperationType.ADD }
SUB:BinaryOperationType = '-' WS
    { result := BinaryOperationType.SUBTRACT }
MUL:BinaryOperationType = '*' WS
    { result := BinaryOperationType.MULTIPLY }
DIV:BinaryOperationType = '/' WS
    { result := BinaryOperationType.DIVIDE }
REM:BinaryOperationType = '%' WS
    { result := BinaryOperationType.REMAINDER }
INTDIV:BinaryOperationType = '//' WS
    { result := BinaryOperationType.INT_DIVIDE }
AND:BinaryOperationType = '&' WS
    { result := BinaryOperationType.AND }
OR:BinaryOperationType = '|' WS
    { result := BinaryOperationType.OR }
XOR:BinaryOperationType = '~' WS
    { result := BinaryOperationType.XOR }
SHIFTLEFT:BinaryOperationType = '<<' WS
    { result := BinaryOperationType.SHIFT_LEFT }
SHIFTRIGHT:BinaryOperationType = '>>' WS
    { result := BinaryOperationType.SHIFT_RIGHT }
BITWISEAND:BinaryOperationType = '&&' WS
    { result := BinaryOperationType.BITWISE_AND }
BITWISEOR:BinaryOperationType = '||' WS
    { result := BinaryOperationType.BITWISE_OR }
BITWISEXOR:BinaryOperationType = '~~' WS
    { result := BinaryOperationType.BITWISE_XOR }
POW:BinaryOperationType = '^' WS
    { result := BinaryOperationType.POWER }
EQ:BinaryOperationType = '=' WS
    { result := BinaryOperationType.EQUAL }
NEQ:BinaryOperationType = '!=' WS
    { result := BinaryOperationType.NOT_EQUAL }
LT:BinaryOperationType = '<' WS
    { result := BinaryOperationType.LESS_THAN }
GT:BinaryOperationType = '>' WS
    { result := BinaryOperationType.GREATER_THAN }
LTEQ:BinaryOperationType = '<=' WS
    { result := BinaryOperationType.LESS_THAN_OR_EQUAL }
GTEQ:BinaryOperationType = '>=' WS
    { result := BinaryOperationType.GREATER_THAN_OR_EQUAL }
IDENTITY:BinaryOperationType = '==' WS
    { result := BinaryOperationType.IDENTITY }
NIDENTITY:BinaryOperationType = '!==' WS
    { result := BinaryOperationType.NOT_IDENTITY }
NOT:UnaryOperationType = '!' WS
    { result := UnaryOperationType.NOT }
BITWISENOT:UnaryOperationType = '!!' WS
    { result := UnaryOperationType.BITWISE_NOT }
UNARY_MINUS:UnaryOperationType = '-' WS
    { result := UnaryOperationType.MINUS }
ASSIGNMENT:BinaryOperationType? = ':=' WS
    { result := null }
ADDEQ:BinaryOperationType? = '+=' WS 
    { result := BinaryOperationType.ADD }
SUBEQ:BinaryOperationType? = '-=' WS
    { result := BinaryOperationType.SUBTRACT }
MULEQ:BinaryOperationType? = '*=' WS 
    { result := BinaryOperationType.MULTIPLY }
DIVEQ:BinaryOperationType? = '/=' WS 
    { result := BinaryOperationType.DIVIDE }
INTDIVEQ:BinaryOperationType? = '//=' WS 
    { result := BinaryOperationType.INT_DIVIDE }
POWEQ:BinaryOperationType? = '^=' WS 
    { result := BinaryOperationType.POWER }
REMEQ:BinaryOperationType? = '%=' WS 
    { result := BinaryOperationType.REMAINDER }
ANDEQ:BinaryOperationType? = '&=' WS 
    { result := BinaryOperationType.AND }
BITWISEANDEQ:BinaryOperationType? = '&&=' WS 
    { result := BinaryOperationType.BITWISE_AND }
OREQ:BinaryOperationType? = '|=' WS 
    { result := BinaryOperationType.OR }
BITWISEOREQ:BinaryOperationType? = '||=' WS 
    { result := BinaryOperationType.BITWISE_OR }
XOREQ:BinaryOperationType? = '~=' WS 
    { result := BinaryOperationType.XOR }
BITWISEXOREQ:BinaryOperationType? = '~~=' WS 
    { result := BinaryOperationType.BITWISE_XOR }
SHIFTLEFTEQ:BinaryOperationType? = '<<=' WS 
    { result := BinaryOperationType.SHIFT_LEFT }
SHIFTRIGHTEQ:BinaryOperationType? = '>>=' WS 
    { result := BinaryOperationType.SHIFT_RIGHT }
CAST = '->' WS
INSTANCEOF = '-?>' WS
NINSTANCEOF = '-!>' WS
CONVERT:Bit = '->>' WS
    { result := true }
COMMA  = ',' WS
STAR:String = '*' WS
    { result := "*" }
DOT:String = '.' WS
    { result := "." }
DOTDOT:Bit = '..' WS
    { result := true }
ELLIPSIS:Bit = '...' WS
    { result := true }
QUESTION:Bit = '?' WS
    { result := true }
YIELDS:Bit = '=>' WS
    { result := true }
YIELDS_METHOD:Bit = '=&>' WS
    { result := true }
YIELDS_IMMUTABLE:Bit = '=>*' WS
    { result := true }
YIELDS_METHOD_IMMUTABLE:Bit = '=&>*' WS
    { result := true }
EOF = !.