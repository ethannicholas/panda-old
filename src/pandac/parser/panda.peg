{
    uses org.pandalanguage.pandac.ast.ArrowOperationType
    uses org.pandalanguage.pandac.ast.ASTAnnotation
    uses org.pandalanguage.pandac.ast.ASTArrayLiteral
    uses org.pandalanguage.pandac.ast.ASTArrowExpression
    uses org.pandalanguage.pandac.ast.ASTAssert
    uses org.pandalanguage.pandac.ast.ASTAssignment
    uses org.pandalanguage.pandac.ast.ASTAtReturn
    uses org.pandalanguage.pandac.ast.ASTBinaryExpression
    uses org.pandalanguage.pandac.ast.ASTBitLiteral
    uses org.pandalanguage.pandac.ast.ASTBlock
    uses org.pandalanguage.pandac.ast.ASTBreak
    uses org.pandalanguage.pandac.ast.ASTCallExpression
    uses org.pandalanguage.pandac.ast.ASTCatch
    uses org.pandalanguage.pandac.ast.ASTClass
    uses org.pandalanguage.pandac.ast.ASTClassType
    uses org.pandalanguage.pandac.ast.ASTContinue
    uses org.pandalanguage.pandac.ast.ASTDo
    uses org.pandalanguage.pandac.ast.ASTDotExpression
    uses org.pandalanguage.pandac.ast.ASTEnum
    uses org.pandalanguage.pandac.ast.ASTEnumValue
    uses org.pandalanguage.pandac.ast.ASTExpression
    uses org.pandalanguage.pandac.ast.ASTExpressionStatement
    uses org.pandalanguage.pandac.ast.ASTField
    uses org.pandalanguage.pandac.ast.ASTFor
    uses org.pandalanguage.pandac.ast.ASTIdentifier
    uses org.pandalanguage.pandac.ast.ASTIf
    uses org.pandalanguage.pandac.ast.ASTIndex
    uses org.pandalanguage.pandac.ast.ASTInstanceDeclaration
    uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
    uses org.pandalanguage.pandac.ast.ASTInvariant
    uses org.pandalanguage.pandac.ast.ASTLambdaExpression
    uses org.pandalanguage.pandac.ast.ASTLoop
    uses org.pandalanguage.pandac.ast.ASTNew
    uses org.pandalanguage.pandac.ast.ASTNode
    uses org.pandalanguage.pandac.ast.ASTNullLiteral
    uses org.pandalanguage.pandac.ast.ASTMethod
    uses org.pandalanguage.pandac.ast.ASTMethodType
    uses org.pandalanguage.pandac.ast.ASTMethodValue
    uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
    uses org.pandalanguage.pandac.ast.ASTParameter
    uses org.pandalanguage.pandac.ast.ASTPostcondition
    uses org.pandalanguage.pandac.ast.ASTPre
    uses org.pandalanguage.pandac.ast.ASTPrecondition
    uses org.pandalanguage.pandac.ast.ASTRangeExpression
    uses org.pandalanguage.pandac.ast.ASTReturn
    uses org.pandalanguage.pandac.ast.ASTSelf
    uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
    uses org.pandalanguage.pandac.ast.ASTStatement
    uses org.pandalanguage.pandac.ast.ASTStringLiteral
    uses org.pandalanguage.pandac.ast.ASTSuper
    uses org.pandalanguage.pandac.ast.ASTSwitch
    uses org.pandalanguage.pandac.ast.ASTSwitchCase
    uses org.pandalanguage.pandac.ast.ASTThrow
    uses org.pandalanguage.pandac.ast.ASTTry
    uses org.pandalanguage.pandac.ast.ASTTupleExpression
    uses org.pandalanguage.pandac.ast.ASTTupleType
    uses org.pandalanguage.pandac.ast.ASTType
    uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
    uses org.pandalanguage.pandac.ast.ASTUnaryExpression
    uses org.pandalanguage.pandac.ast.ASTUnreachable
    uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
    uses org.pandalanguage.pandac.ast.ASTVarDeclaration
    uses org.pandalanguage.pandac.ast.ASTWhile
    uses org.pandalanguage.pandac.tree.BinaryOperationType
    uses org.pandalanguage.pandac.tree.MethodNodeType
    uses org.pandalanguage.pandac.tree.Position
    uses org.pandalanguage.pandac.tree.UnaryOperationType
    uses org.pandalanguage.pandac.tree.VariableType

    class ForTuple {
        def ids:ListView<String>

        def types:ListView<ASTType?>

        constructor(ids:ListView<String>, types:ListView<ASTType?>) {
            self.ids := ids
            self.types := types
        }
    }

    enum SuffixType {
        CALL,
        INDEX,
        DOT,
        INSTANCEOF,
        NINSTANCEOF,
        CAST,
        CONVERT
    }

    class Suffix {
        def suffixType:SuffixType
        
        def type:ASTType?

        def parameters:ListView<ASTExpression>

        def member:String

        constructor(suffixType:SuffixType, parameters:ListView<ASTExpression>) {
            self.suffixType := suffixType
            self.parameters := parameters
        }

        constructor(suffixType:SuffixType, type:ASTType) {
            self.suffixType := suffixType
            self.type := type
        }

        constructor(suffixType:SuffixType, member:String) {
            self.suffixType := suffixType
            self.member := member
        }
    }

    class Utils {
        @class
        function position():Position {
            return Position.INTERNAL
        }

        @class
        function isExternal(f:String):Bit {
            return f.endsWith(".plink")
        }

        @class
        function combineExpressions(expr:ListView<ASTExpression>,
                op:BinaryOperationType):ASTExpression {
            if expr.length = 1
                return expr[0]
            var result := expr[expr.length - 1]
            for i in expr.length - 2 ... 0 by -1
                result := new ASTBinaryExpression(op, expr[i], result)
            return result
        }

        @class
        function callExpression(term:ASTExpression, 
                suffixes:ListView<Suffix>):ASTExpression {
            var result := term
            for s in suffixes {
                switch s.suffixType {
                    case SuffixType.CALL: {
                        assert s.parameters != null
                        result := new ASTCallExpression(result, s.parameters)
                    }
                    case SuffixType.INDEX: {
                        assert s.parameters != null & s.parameters.length = 1
                        result := new ASTIndex(term, s.parameters[0])
                    }
                    case SuffixType.DOT: {
                        assert s.member != null
                        result := new ASTDotExpression(term, s.member)
                    }
                    case SuffixType.INSTANCEOF: {
                        assert s.type != null
                        result := new ASTArrowExpression(
                                ArrowOperationType.INSTANCE_OF, term, s.type)
                    }
                    case SuffixType.NINSTANCEOF: {
                        assert s.type != null
                        result := new ASTArrowExpression(
                                ArrowOperationType.NOT_INSTANCE_OF, term, 
                                s.type)
                    }
                    case SuffixType.CAST: {
                        assert s.type != null
                        result := new ASTArrowExpression(
                                ArrowOperationType.CAST, term, s.type)
                    }
                    case SuffixType.CONVERT: {
                        assert s.type != null
                        result := new ASTArrowExpression(
                                ArrowOperationType.CONVERT, term, s.type)
                    }
                    default:
                        unreachable
                }
            }
            return result
        }
    }
}

file:ListView<ASTNode> = WS? e:bodyEntry* EOF
    { result := e }
bodyEntry:ASTNode = u:usesStatement 
    { result := u }
/ 
    c:classDeclaration 
    { result := c }
/ 
    i:interfaceDeclaration 
    { result := i }
/ 
    e:enum 
    { result := e }
/ 
    m:methodDeclaration
    { result := m }
/ 
    f:functionDeclaration
    { result := f }
/ 
    p:packageDeclaration 
    { result := p }
/ 
    instance:instanceDeclaration 
    { result := instance }
/ 
    s:statement
    { result := s }

packageDeclaration:ASTPackageDeclaration = PACKAGE ^ @t:IDENTIFIER (@t:DOT 
        @t:IDENTIFIER)*
    { result := new ASTPackageDeclaration(Utils.position, t) }
usesStatement:ASTUsesDeclaration = USES ^ @i:IDENTIFIER (@i:DOT @i:IDENTIFIER)* 
        (@i:DOT @i:STAR)?
        (AS alias:IDENTIFIER)?
    { result := new ASTUsesDeclaration(Utils.position, i, alias) }
instanceDeclaration:ASTInstanceDeclaration = INSTANCE ^ t:type
    { result := new ASTInstanceDeclaration(Utils.position, t) }

annotations:ListView<ASTAnnotation> = (&'@' a:simpleAnnotation / 
        p:precondition)+
    { 
        def annotations := new Array<ASTAnnotation>()
        annotations.addAll(a)
        annotations.addAll(p)
        result := annotations
    }
simpleAnnotation:ASTAnnotation = PROTECTED 
    { result := new ASTSimpleAnnotation(Utils.position, "protected") }
/ 
    PRIVATE 
    { result := new ASTSimpleAnnotation(Utils.position, "private") }
/ 
    ATCLASS 
    { result := new ASTSimpleAnnotation(Utils.position, "class") }
/ 
    THREAD 
    { result := new ASTSimpleAnnotation(Utils.position, "thread") }
/ 
    ABSTRACT 
    { result := new ASTSimpleAnnotation(Utils.position, "abstract") }
/ 
    EXTERNAL 
    { result := new ASTSimpleAnnotation(Utils.position, "external") }
/ 
    OVERRIDE 
    { result := new ASTSimpleAnnotation(Utils.position, "override") }
/ 
    READONLY 
    { result := new ASTSimpleAnnotation(Utils.position, "readonly") }
/ 
    LIMITED 
    { result := new ASTSimpleAnnotation(Utils.position, "limited") }
/ 
    ATSELF 
    { result := new ASTSimpleAnnotation(Utils.position, "self") }
/ 
    SAFERETURN 
    { result := new ASTSimpleAnnotation(Utils.position, "safeReturn") }
/ 
    UNSAFEFUNCTION 
    { result := new ASTSimpleAnnotation(Utils.position, "unsafeFunction") }
/ 
    FINAL 
    { result := new ASTSimpleAnnotation(Utils.position, "final") }
/ 
    WRAPPER_METHOD 
    { result := new ASTSimpleAnnotation(Utils.position, "$wrapperMethod") }
/ 
    MATH ^ LPAREN OVERFLOW RPAREN
    { result := new ASTSimpleAnnotation(Utils.position, "math(overflow)") }
precondition:ASTAnnotation = PRE ^ LPAREN expr:expression RPAREN
    { result := new ASTPrecondition(Utils.position, expr, false) }
/
    PRE_OR ^ LPAREN expr:expression RPAREN
    { result := new ASTPrecondition(Utils.position, expr, true) }

classDeclaration:ASTClass = dc:DOCCOMMENT? a:annotations? CLASS ^ 
        name:IDENTIFIER gp:genericParametersDeclaration? (COLON s:classType)? 
        i:interfaces? LBRACE body:classMembers RBRACE
    {
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        for m in body {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := new ASTClass(Utils.position, name, false, dc, a, s, 
                i, gp, methods, fields, invariants, Utils.isExternal(fileName))
    }
interfaces:ListView<ASTType> = LPAREN t:type (COMMA t:type)* RPAREN
    { result := t }
genericParametersDeclaration:ListView<ASTTypedIdentifier> = LT t:typedIdentifier
         (COMMA t:typedIdentifier)* GT
    { result := t }
classMembers:ListView<ASTNode> = m:classMember*
    { result := m }
classMember:ASTNode = i:invariant 
    { result := i }
/ 
    m:methodDeclaration 
    { result := m }
/ 
    f:functionDeclaration 
    { result := f }
/ 
    c:constructorDeclaration 
    { result := c }
/ 
    field:fieldDeclaration
    { result := field }
invariant:ASTInvariant = INVARIANT LPAREN expr:expression RPAREN
    { result := new ASTInvariant(Utils.position, expr) }

interfaceDeclaration:ASTClass = dc:DOCCOMMENT? a:annotations? INTERFACE ^ 
        name:IDENTIFIER gp:genericParametersDeclaration? 
        (COLON s:classType (COMMA s:classType)*)? LBRACE body:classMembers 
        RBRACE
    {
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        for m in body {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := new ASTClass(Utils.position, name, true, dc, a, null, s, gp, 
                methods, fields, invariants, Utils.isExternal(fileName))
    }

enum:ASTEnum = dc:DOCCOMMENT? a:annotations? ENUM ^ name:IDENTIFIER LBRACE 
        (v:enumValue (COMMA v:enumValue)*)? RBRACE
    {
        result := new ASTEnum(Utils.position, name, dc, a, v, 
                Utils.isExternal(fileName))
    }
enumValue:ASTEnumValue = dc:DOCCOMMENT? name:IDENTIFIER
    { result := new ASTEnumValue(Utils.position, name, dc) }

typeDeclaration:ASTType = COLON ^ type:type
    { result := type }
type:ASTType = m:methodOrTupleType 
    { result := m }
/ 
    cl:classType
    { result := cl }
methodOrTupleType:ASTType = LPAREN (type:type (COMMA type:type)*)? RPAREN 
        ((y:YIELDS / ym:YIELDS_METHOD / yi:YIELDS_IMMUTABLE / 
        ymi:YIELDS_METHOD_IMMUTABLE) LPAREN ret:type? RPAREN)? 
        nullable:QUESTION?
    {
        if y != null {
            result := new ASTMethodType(Utils.position, type, ret,
                    nullable != null, true, false)
        }
        else if yi != null {
            result := new ASTMethodType(Utils.position, type, ret,
                    nullable != null, true, true)
        }
        else if ym != null {
            result := new ASTMethodType(Utils.position, type, ret,
                    nullable != null, false, false)
        }
        else if ymi != null {
            result := new ASTMethodType(Utils.position, type, ret,
                    nullable != null, false, true)
        }
        else {
            result := new ASTTupleType(Utils.position, type, 
                    nullable != null)
        }
    }
classType:ASTType = @name:IDENTIFIER (@name:DOT @name:IDENTIFIER)* 
        params:genericParameters? nullable:QUESTION?
    {
        result := new ASTClassType(Utils.position, name, params, 
                nullable != null)
    }
genericParameters:ListView<ASTType> = LT type:type (COMMA type:type)* GT
    { result := type }

methodDeclaration:ASTMethod = dc:DOCCOMMENT? a:annotations? METHOD ^ 
        name:methodName gp:genericParametersDeclaration? 
        params:formalParameterList t:typeDeclaration? b:block? 
        post:postcondition*
    {
        result := new ASTMethod(Utils.position, name, MethodNodeType.METHOD, 
                dc, a, params, t, b, post)
    }
functionDeclaration:ASTMethod = dc:DOCCOMMENT? a:annotations? FUNCTION ^ 
        name:methodName gp:genericParametersDeclaration? 
        params:formalParameterList t:typeDeclaration b:block? 
        post:postcondition*
    {
        result := new ASTMethod(Utils.position, name, MethodNodeType.FUNCTION, 
                dc, a, params, t, b, post)
    }
constructorDeclaration:ASTMethod = dc:DOCCOMMENT? a:annotations? CONSTRUCTOR ^ 
        gp:genericParametersDeclaration? params:formalParameterList 
        t:typeDeclaration? b:block? post:postcondition*
    {
        result := new ASTMethod(Utils.position, "constructor", 
                MethodNodeType.CONSTRUCTOR, dc, a, params, t, b, post)
    }
methodName = IDENTIFIER / ADD / SUB / MUL / DIV / INTDIV / POW / EQ / GT / 
        LT / GTEQ / LTEQ / REM / AND / BITWISEAND / OR / BITWISEOR / XOR /
        BITWISEXOR / NOT / BITWISENOT / SHIFTLEFT / SHIFTRIGHT / 
        CONVERT / (LBRACKET (DOTDOT / ELLIPSIS)? RBRACKET ASSIGNMENT?)
formalParameter:ASTParameter = v:VAR? n:IDENTIFIER (COLON / cnv:CONVERT) t:type 
        e:ELLIPSIS?
    {
        result := new ASTParameter(Utils.position, n, t, v != null,
            cnv != null, e != null)
    }
formalParameterList:ListView<ASTParameter> = LPAREN (p:formalParameter 
        (COMMA p:formalParameter)*)? RPAREN
    { result := p }
postcondition:ASTPostcondition = POST ^ LPAREN expr:expression RPAREN
    { result := new ASTPostcondition(Utils.position, expr, false) }
/
    POST_AND ^ LPAREN expr:expression RPAREN
    { result := new ASTPostcondition(Utils.position, expr, true) }

varType:VariableType = v:VAR 
    { result := v }
/ 
    d:DEF
    { result := d }
/ 
    c:CONSTANT 
    { result := c }
/ 
    p:PROPERTY
    { result := p }

varName = IDENTIFIER / UNDERSCORE

varDeclaration:ASTVarDeclaration = varType:varType ^ t:typedIdentifier 
        (COMMA t:typedIdentifier)* (ASSIGNMENT expr:expression)?
    { result := new ASTVarDeclaration(Utils.position, varType, t, expr) }
typedIdentifier:ASTTypedIdentifier = i:IDENTIFIER t:optionalTypeDeclaration
    { result := new ASTTypedIdentifier(Utils.position, i, t) }
optionalTypeDeclaration:ASTType? = (COLON type:type)?
    { result := type }
fieldDeclaration:ASTField = dc:DOCCOMMENT? a:annotations? v:varDeclaration
    { result := new ASTField(dc, a, v) }


suffix:Suffix = p:parameters 
    { result := new Suffix(SuffixType.CALL, p) }
/
    LBRACKET expr:expression RBRACKET 
    { result := new Suffix(SuffixType.INDEX, [expr]) }
/
    DOT id:IDENTIFIER 
    { result := new Suffix(SuffixType.DOT, id) }
/
    DOT CLASS
    { result := new Suffix(SuffixType.DOT, "$class") }
/
    DOT CONSTRUCTOR
    { result := new Suffix(SuffixType.DOT, "constructor") }
/
    INSTANCEOF t1:type
    {  result := new Suffix(SuffixType.INSTANCEOF, t1) }
/
    NINSTANCEOF t2:type
    {  result := new Suffix(SuffixType.NINSTANCEOF, t2) }
/
    CAST t3:type
    {  result := new Suffix(SuffixType.CAST, t3) }
/
    CONVERT t4:type
    {  result := new Suffix(SuffixType.NINSTANCEOF, t4) }
callExpression:ASTExpression = t:term s:suffix*
    { result := Utils.callExpression(t, s) }
exponentExpression:ASTExpression = expr:callExpression 
        (POW expr:callExpression)*
    {
        result := Utils.combineExpressions(expr, BinaryOperationType.POWER)
    }
unaryExpression:ASTExpression = SUB expr1:exponentExpression
    {
        result := new ASTUnaryExpression(Utils.position, 
                UnaryOperationType.MINUS, expr1)
    }
/ 
    n:NOT expr2:exponentExpression
    {
        result := new ASTUnaryExpression(Utils.position, 
                UnaryOperationType.NOT, expr2)
    }
/ 
    BITWISENOT expr3:exponentExpression
    {
        result := new ASTUnaryExpression(Utils.position, 
                UnaryOperationType.BITWISE_NOT, expr3)
    }
/ 
    expr4:exponentExpression
    { result := expr4 }
multiplicativeExpression:ASTExpression = expr:unaryExpression 
        ((m:MUL / d:DIV / i:INTDIV) expr:unaryExpression)*
    {
        if m != null {
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.MULTIPLY)
        }
        else if d != null {
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.DIVIDE)
        }        
        else {
            assert i != null
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.INT_DIVIDE)
        }        
    }
additiveExpression:ASTExpression = expr:multiplicativeExpression 
        ((a:ADD / s:SUB) expr:multiplicativeExpression)* 
    {
        if a != null
            result := Utils.combineExpressions(expr, BinaryOperationType.ADD)
        else {
            assert s != null
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.SUBTRACT)
        }
    }
rangeExpression:ASTExpression = left:additiveExpression ((e:ELLIPSIS / d:DOTDOT)
        right:additiveExpression? (BY step:additiveExpression)?)?
    {
        if right != null {
            result := new ASTRangeExpression(left.position, left, right,
                    step, e != null)
        }
        result := left
    }
comparisonExpression:ASTExpression = expr:rangeExpression ((e:EQ / i:IDENTITY / 
        ne:NEQ / ni:NIDENTITY / le:LTEQ / ge:GTEQ / l:LT / g:GT) 
        expr:rangeExpression)*
    {
        if e != null
            result := Utils.combineExpressions(expr, BinaryOperationType.EQUAL)
        else if i != null {
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.IDENTITY)
        }
        else if ne != null {
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.NOT_EQUAL)
        }
        else if ni != null {
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.NOT_IDENTITY)
        }
        else if le != null {
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.LESS_THAN_OR_EQUAL)
        }
        else if ge != null {
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.GREATER_THAN_OR_EQUAL)
        }
        else if l != null {
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.LESS_THAN)
        }
        else {
            assert g != null
            result := Utils.combineExpressions(expr, 
                    BinaryOperationType.GREATER_THAN)
        }
    }
andExpression:ASTExpression = expr:comparisonExpression ((a:AND / x:XOR) 
        expr:comparisonExpression)*
    { 
        if a != null
            result := Utils.combineExpressions(expr, BinaryOperationType.AND)
        else {
            assert x != null
            result := Utils.combineExpressions(expr, BinaryOperationType.XOR)
        }
    }
orExpression:ASTExpression = expr:andExpression (OR expr:andExpression)*
    { 
        result := Utils.combineExpressions(expr, BinaryOperationType.OR)
    }
expression:ASTExpression = o:orExpression
    { result := o }

term:ASTExpression = id:IDENTIFIER
    { result := new ASTIdentifier(Utils.position, id) }
/
    i:INTEGER
    { result := new ASTIntegerLiteral(Utils.position, i->>(UInt64)) }
/ 
    TRUE
    { result := new ASTBitLiteral(Utils.position, true) }
/ 
    FALSE 
    { result := new ASTBitLiteral(Utils.position, false) }
/ 
    NULL 
    { result := new ASTNullLiteral(Utils.position) }
/ 
    s:STRING 
    { result := new ASTStringLiteral(Utils.position, s) }
/ 
    PLUGIN 
    { if true unreachable }
/ 
    SELF 
    { result := new ASTSelf(Utils.position) }
/
    SUPER 
    { result := new ASTSuper(Utils.position) }
/ 
    CLASS
    { result := new ASTDotExpression(new ASTSelf(Utils.position), "$class") }
/ 
    l:lambdaOrTuple
    { result := l }
/ 
    c:construct 
    { result := c }
/
    a:arrayLiteral
    { result := a }
/ 
    m:methodValue 
    { result := m }
/
    ATRETURN 
    { result := new ASTAtReturn(Utils.position) }
/ 
    PRE LPAREN expr:expression RPAREN 
    { result := new ASTPre(Utils.position, expr) }
/ 
    CONSTRUCTOR
    { 
        result := new ASTDotExpression(new ASTSelf(Utils.position), 
                "constructor") 
    }

arrayLiteral:ASTExpression = LBRACKET (expr:expression 
        (COMMA expr:expression)*)? RBRACKET
    {
        result := new ASTArrayLiteral(Utils.position, expr)
    }

lambdaOrTuple:ASTExpression = LPAREN (name1:IDENTIFIER type1:typeDeclaration 
        (COMMA name1:IDENTIFIER type1:typeDeclaration)*)? RPAREN YIELDS ^ 
        expr1:expression 
    {
        def params := new Array<ASTTypedIdentifier>()
        assert name1.length = type1.length
        for i, n in name1
            params.add(new ASTTypedIdentifier(Utils.position, n, type1[i]))
        result := new ASTLambdaExpression(Utils.position, params, expr1)
    }
/
    LPAREN name2:IDENTIFIER (COMMA name2:IDENTIFIER)* RPAREN YIELDS ^ 
            expr2:expression 
    {
        def params := new Array<ASTTypedIdentifier>()
        for n in name2
            params.add(new ASTTypedIdentifier(Utils.position, n, null))
        result := new ASTLambdaExpression(Utils.position, params, expr2)
    }
/
    LPAREN ^ expr3:expression (COMMA expr3:expression)* RPAREN 
    { result := new ASTTupleExpression(Utils.position, expr3) }
/
    name4:IDENTIFIER YIELDS ^ expr4:expression
    { 
        result := new ASTLambdaExpression(Utils.position, 
                [new ASTTypedIdentifier(Utils.position, name4, null)], expr4)
    }

construct:ASTExpression = NEW ^ t:type p:parameters
    { result := new ASTNew(Utils.position, t, p) }

parameters:ListView<ASTExpression> = LPAREN (expr:expression 
        (COMMA expr:expression)*)? RPAREN
    { result := expr }

methodValue:ASTExpression = FUNCTION ^ p1:formalParameterList t1:typeDeclaration 
        b1:block
    {
        result := new ASTMethodValue(Utils.position, MethodNodeType.FUNCTION, 
            p1, t1, b1)
    }
/
    METHOD ^ p2:formalParameterList t2:typeDeclaration? b2:block
    {
        result := new ASTMethodValue(Utils.position, MethodNodeType.METHOD, 
            p2, t2, b2)
    }

statement:ASTStatement = 
    e:expressionOrAssignment
    { result := e }
/ 
    v:varDeclaration
    { result := v }
/ 
    i:ifStatement 
    { result := i }
/ 
    f:forLoop 
    { result := f }
/ 
    w:whileLoop 
    { result := w }
/ 
    d:doLoop 
    { result := d }
/ 
    l:loop 
    { result := l }
/ 
    a:assertStatement 
    { result := a }
/ 
    s:switchStatement
    { result := s }
/ 
    t:tryStatement 
    { result := t }
/
    b:block
    { result := b }
block:ASTBlock = LBRACE ^ s:statement* t:terminalStatement? RBRACE
    { 
        def statements := new Array<ASTStatement>()
        statements.addAll(s)
        if t != null
            statements.add(t)
        result := new ASTBlock(Utils.position, statements)
    }
statementOrBlock:ASTStatement = s:statement 
    { result := s }
/ 
    t:terminalStatement
    { result := t }

assertStatement:ASTAssert = ASSERT ^ test:expression (COLON msg:expression)?
    { result := new ASTAssert(Utils.position, test, msg) }
terminalStatement:ASTStatement = r:returnStatement 
    { result := r }
/ 
    b:breakStatement 
    { result := b }
/ 
    c:continueStatement 
    { result := c }
/ 
    t:throwStatement 
    { result := t }
/ 
    u:unreachableStatement
    { result := u }
returnStatement:ASTReturn = RETURN ^ expr:expression?
    { result := new ASTReturn(Utils.position, expr) }
breakStatement:ASTBreak = BREAK ^ label:IDENTIFIER?
    { result := new ASTBreak(Utils.position, label) }
continueStatement:ASTContinue = CONTINUE ^ label:IDENTIFIER?
    { result := new ASTContinue(Utils.position, label) }
throwStatement:ASTThrow = THROW ^ expr:expression
    { result := new ASTThrow(Utils.position, expr) }
unreachableStatement:ASTUnreachable = UNREACHABLE ^ (COLON expression)?
    { result := new ASTUnreachable(Utils.position) }

forLoop:ASTFor = label:label? FOR ^ (index:IDENTIFIER indexType:typeDeclaration? 
        COMMA)? (loopVar:IDENTIFIER ^ loopVarType:typeDeclaration? / 
        tuple:forTuple) IN list:expression statement:statementOrBlock
    {
        def indexVar:ASTTypedIdentifier?
        if index != null
            indexVar := new ASTTypedIdentifier(Utils.position, index, indexType)
        else
            indexVar := null
        def valueVars := new Array<ASTTypedIdentifier>()
        if loopVar != null {
            valueVars.add(new ASTTypedIdentifier(Utils.position, loopVar, 
                    loopVarType))
        }
        else {
            assert tuple != null
            assert tuple.ids.length = tuple.types.length
            for i, id in tuple.ids {
                valueVars.add(new ASTTypedIdentifier(Utils.position, id, 
                        tuple.types[i]))
            }
        }
        result := new ASTFor(Utils.position, null, indexVar, valueVars, list, 
                statement)
    }
forTuple:ForTuple = label:label? LPAREN ^ (id:IDENTIFIER / id:UNDERSCORE) 
        type:optionalTypeDeclaration (COMMA (id:IDENTIFIER / id:UNDERSCORE) 
        type:optionalTypeDeclaration)+ RPAREN
    { result := new ForTuple(id, type) }
doLoop:ASTDo = label:label? DO ^ statement:statementOrBlock WHILE 
        test:expression
    { result := new ASTDo(Utils.position(), label, test, statement) }
whileLoop:ASTWhile = label:label? WHILE ^ test:expression 
        statement:statementOrBlock
    { result := new ASTWhile(Utils.position(), label, test, statement) }
loop:ASTLoop = label:label? LOOP ^ statement:statementOrBlock
    { result := new ASTLoop(Utils.position, label, statement) }
label:String = id:IDENTIFIER COLON
    { result := id }

ifStatement:ASTIf = IF test:expression thenStatement:statementOrBlock (ELSE
        elseStatement:statementOrBlock)?
    {  
        result := new ASTIf(Utils.position, test, thenStatement, 
                elseStatement) 
    }

switchStatement:ASTSwitch = SWITCH value:expression LBRACE cases:switchCase* 
        (DEFAULT COLON defaultCase:statementOrBlock)? RBRACE
    {
        result := new ASTSwitch(Utils.position, value, cases, defaultCase)
    }
switchCase:ASTSwitchCase = CASE expr:expression (COMMA expr:expression)* COLON 
        statement:statementOrBlock
    {
        result := new ASTSwitchCase(Utils.position, expr, statement)
    }

tryStatement:ASTStatement = TRY statement:statementOrBlock catches:catchBlock+
    {
        result := new ASTTry(Utils.position, statement, catches, null)
    }
catchBlock:ASTCatch = CATCH name:IDENTIFIER type:typeDeclaration
        statement:statementOrBlock
    {
        result := new ASTCatch(Utils.position, name, type, statement)
    }

assignmentOperator:BinaryOperationType? = ASSIGNMENT 
    {
        result := null
    }
/ 
    ADDEQ
    {
        result := BinaryOperationType.ADD
    }
/ 
    SUBEQ
    {
        result := BinaryOperationType.SUBTRACT
    }
/ 
    MULEQ 
    {
        result := BinaryOperationType.MULTIPLY
    }
/ 
    DIVEQ 
    {
        result := BinaryOperationType.DIVIDE
    }
/ 
    INTDIVEQ 
    {
        result := BinaryOperationType.INT_DIVIDE
    }
/ 
    POWEQ 
    {
        result := BinaryOperationType.POWER
    }
/ 
    REMEQ 
    {
        result := BinaryOperationType.REMAINDER
    }
/ 
    ANDEQ 
    {
        result := BinaryOperationType.AND
    }
/ 
    BITWISEANDEQ 
    {
        result := BinaryOperationType.BITWISE_AND
    }
/ 
    OREQ 
    {
        result := BinaryOperationType.OR
    }
/ 
    BITWISEOREQ 
    {
        result := BinaryOperationType.BITWISE_OR
    }
/ 
    XOREQ 
    {
        result := BinaryOperationType.XOR
    }
/ 
    BITWISEXOREQ 
    {
        result := BinaryOperationType.BITWISE_OR
    }
/ 
    SHIFTLEFTEQ 
    {
        result := BinaryOperationType.SHIFT_LEFT
    }
/ 
    SHIFTRIGHTEQ
    {
        result := BinaryOperationType.SHIFT_RIGHT
    }

expressionOrAssignment:ASTStatement = left:expression (COMMA left:expression)* 
        op:assignmentOperator right:expression
    {
        result := new ASTAssignment(left, op, right)
    }
/
    expr:expression
    {
        result := new ASTExpressionStatement(expr)
    }

WS = ([ \n\t] / COMMENT)*
COMMENT = LINE_COMMENT / BLOCK_COMMENT
LINE_COMMENT = '--' (!'\n' .)* '\n'
BLOCK_COMMENT = '-*' (BLOCK_COMMENT / !'*-' .)* '*-'
DOCCOMMENT = '===' '='* (!'===' .)* '='* WS
IDCHAR = [a-zA-Z_0-9$]
KEYWORD = &[a-z] (PACKAGE / CLASS / INTERFACE / ENUM / USES / AS / METHOD / 
        FUNCTION / CONSTRUCTOR / VAR / DEF / CONSTANT / PROPERTY / CLASS / 
        TRUE / FALSE / NULL / SELF / SUPER / NEW / BY / FOR / IN / WHILE / DO / 
        LOOP / IF / ELSE / SWITCH / CASE / DEFAULT / ASSERT / UNREACHABLE / 
        TRY / CATCH / THROW / BREAK / CONTINUE / RETURN)
IDENTIFIER = !KEYWORD @c:[a-zA-Z$] @c:IDCHAR* WS
    { result := c }
/ 
    !KEYWORD @u:'_' @u:IDCHAR* WS
    { result := u }
INTEGER = @i:[0-9]+ !IDCHAR WS
    { result := i }
STRING_CHAR = !'\\' . / '\\' ([tnr\\'"] / '{' expression '}')
STRING = '"' (!'"' @s:STRING_CHAR)* '"' WS
    { result := s }
/
    '\'' (!'\'' @s:STRING_CHAR)* '\'' WS
    { result := s }
PLUGIN = '#' (!'#' .)* '#' WS
UNDERSCORE = u:'_' !IDCHAR WS
    { result := u }
PACKAGE = 'package' !IDCHAR WS
CLASS = 'class' !IDCHAR WS
INTERFACE = 'interface' !IDCHAR WS
ENUM = 'enum' !IDCHAR WS
USES = 'uses' !IDCHAR WS
AS = 'as' !IDCHAR WS
METHOD = 'method' !IDCHAR WS
FUNCTION = 'function' !IDCHAR WS
CONSTRUCTOR = 'constructor' !IDCHAR WS
VAR:VariableType = 'var' !IDCHAR WS
    { result := VariableType.VAR }
DEF:VariableType = 'def' !IDCHAR WS
    { result := VariableType.DEF }
CONSTANT:VariableType = 'constant' !IDCHAR WS
    { result := VariableType.CONSTANT }
PROPERTY:VariableType = 'property' !IDCHAR WS 
    { result := VariableType.PROPERTY }
PROTECTED = '@protected' !IDCHAR WS
PRIVATE = '@private' !IDCHAR WS
ATCLASS = '@class' !IDCHAR WS
THREAD = '@thread' !IDCHAR WS
ABSTRACT = '@abstract' !IDCHAR WS
EXTERNAL = '@external' !IDCHAR WS
OVERRIDE = '@override' !IDCHAR WS
READONLY = '@readonly' !IDCHAR WS
LIMITED = '@limited' !IDCHAR WS
ATSELF = '@self' !IDCHAR WS
SAFERETURN = '@return' !IDCHAR WS
UNSAFEFUNCTION = '@unsafeFunction' !IDCHAR WS
FINAL = '@final' !IDCHAR WS
WRAPPER_METHOD = '@$wrapperMethod' !IDCHAR WS
MATH = '@math' !IDCHAR WS
OVERFLOW = 'overflow' !IDCHAR WS
INVARIANT = '@invariant' !IDCHAR WS
INSTANCE = '@$instance' !IDCHAR WS
PRE = '@pre' !IDCHAR WS
POST = '@post' !IDCHAR WS
PRE_OR = '@preOr' !IDCHAR WS
POST_AND = '@postAnd' !IDCHAR WS
ATRETURN = '@return' !IDCHAR WS
TRUE = 'true' !IDCHAR WS
FALSE = 'false' !IDCHAR WS
NULL = 'null' !IDCHAR WS
SELF = 'self' !IDCHAR WS
SUPER = 'super' !IDCHAR WS
NEW = 'new' !IDCHAR WS
BY = 'by' !IDCHAR WS
FOR = 'for' !IDCHAR WS
IN = 'in' !IDCHAR WS
WHILE = 'while' !IDCHAR WS
DO = 'do' !IDCHAR WS
LOOP = 'loop' !IDCHAR WS
IF = 'if' !IDCHAR WS
ELSE = 'else' !IDCHAR WS
SWITCH = 'switch' !IDCHAR WS
CASE = 'case' !IDCHAR WS
DEFAULT = 'default' !IDCHAR WS
ASSERT = 'assert' !IDCHAR WS
RETURN = 'return' !IDCHAR WS
BREAK = 'break' !IDCHAR WS
CONTINUE = 'continue' !IDCHAR WS
UNREACHABLE = 'unreachable' !IDCHAR WS
TRY = 'try' !IDCHAR WS
CATCH = 'catch' !IDCHAR WS
THROW = 'throw' !IDCHAR WS
COLON = ':' WS
LBRACKET = '[' WS
RBRACKET = ']' WS
LBRACE = '{' WS
RBRACE = '}' WS
LPAREN = '(' WS
RPAREN = ')' WS
ADD:BinaryOperationType = '+' WS
    { result := BinaryOperationType.ADD }
SUB:BinaryOperationType = '-' WS
    { result := BinaryOperationType.SUBTRACT }
MUL:BinaryOperationType = '*' WS
    { result := BinaryOperationType.MULTIPLY }
DIV:BinaryOperationType = '/' WS
    { result := BinaryOperationType.DIVIDE }
REM:BinaryOperationType = '%' WS
    { result := BinaryOperationType.REMAINDER }
INTDIV:BinaryOperationType = '//' WS
    { result := BinaryOperationType.INT_DIVIDE }
AND:BinaryOperationType = '&' WS
    { result := BinaryOperationType.AND }
OR:BinaryOperationType = '|' WS
    { result := BinaryOperationType.OR }
XOR:BinaryOperationType = '^' WS
    { result := BinaryOperationType.XOR }
SHIFTLEFT:BinaryOperationType = '<<' WS
    { result := BinaryOperationType.SHIFT_LEFT }
SHIFTRIGHT:BinaryOperationType = '>>' WS
    { result := BinaryOperationType.SHIFT_RIGHT }
BITWISEAND:BinaryOperationType = '&&' WS
    { result := BinaryOperationType.BITWISE_AND }
BITWISEOR:BinaryOperationType = '||' WS
    { result := BinaryOperationType.BITWISE_OR }
BITWISEXOR:BinaryOperationType = '^^' WS
    { result := BinaryOperationType.BITWISE_XOR }
POW:BinaryOperationType = '^' WS
    { result := BinaryOperationType.POWER }
EQ:BinaryOperationType = '=' WS
    { result := BinaryOperationType.EQUAL }
NEQ:BinaryOperationType = '!=' WS
    { result := BinaryOperationType.NOT_EQUAL }
LT:BinaryOperationType = '<' WS
    { result := BinaryOperationType.LESS_THAN }
GT:BinaryOperationType = '>' WS
    { result := BinaryOperationType.GREATER_THAN }
LTEQ:BinaryOperationType = '<=' WS
    { result := BinaryOperationType.LESS_THAN_OR_EQUAL }
GTEQ:BinaryOperationType = '>=' WS
    { result := BinaryOperationType.GREATER_THAN_OR_EQUAL }
IDENTITY:BinaryOperationType = '==' WS
    { result := BinaryOperationType.IDENTITY }
NIDENTITY:BinaryOperationType = '!==' WS
    { result := BinaryOperationType.NOT_IDENTITY }
NOT:UnaryOperationType = '!' WS
    { result := UnaryOperationType.NOT }
BITWISENOT:UnaryOperationType = '!!' WS
    { result := UnaryOperationType.BITWISE_NOT }
UNARY_MINUS:UnaryOperationType = '-' WS
    { result := UnaryOperationType.MINUS }
ASSIGNMENT:BinaryOperationType? = ':=' WS
    { result := null }
ADDEQ:BinaryOperationType? = '+=' WS 
    { result := BinaryOperationType.ADD }
SUBEQ:BinaryOperationType? = '-=' WS
    { result := BinaryOperationType.SUBTRACT }
MULEQ:BinaryOperationType? = '*=' WS 
    { result := BinaryOperationType.MULTIPLY }
DIVEQ:BinaryOperationType? = '/=' WS 
    { result := BinaryOperationType.DIVIDE }
INTDIVEQ:BinaryOperationType? = '//=' WS 
    { result := BinaryOperationType.INT_DIVIDE }
POWEQ:BinaryOperationType? = '^=' WS 
    { result := BinaryOperationType.POWER }
REMEQ:BinaryOperationType? = '%=' WS 
    { result := BinaryOperationType.REMAINDER }
ANDEQ:BinaryOperationType? = '&=' WS 
    { result := BinaryOperationType.AND }
BITWISEANDEQ:BinaryOperationType? = '&&=' WS 
    { result := BinaryOperationType.BITWISE_AND }
OREQ:BinaryOperationType? = '|=' WS 
    { result := BinaryOperationType.OR }
BITWISEOREQ:BinaryOperationType? = '||=' WS 
    { result := BinaryOperationType.BITWISE_OR }
XOREQ:BinaryOperationType? = '^=' WS 
    { result := BinaryOperationType.XOR }
BITWISEXOREQ:BinaryOperationType? = '^^=' WS 
    { result := BinaryOperationType.BITWISE_XOR }
SHIFTLEFTEQ:BinaryOperationType? = '<<=' WS 
    { result := BinaryOperationType.SHIFT_LEFT }
SHIFTRIGHTEQ:BinaryOperationType? = '>>=' WS 
    { result := BinaryOperationType.SHIFT_RIGHT }
CAST = '->' WS
INSTANCEOF = '-?>' WS
NINSTANCEOF = '-!>' WS
CONVERT = '->>' WS
COMMA  = ',' WS
STAR    = '*' WS
    { result := "*" }
DOT    = '.' WS
    { result := "." }
DOTDOT = '..' WS
ELLIPSIS = '...' WS
QUESTION = '?' WS
YIELDS = '=>' WS
YIELDS_METHOD = '=&>' WS
YIELDS_IMMUTABLE = '=>*' WS
YIELDS_METHOD_IMMUTABLE = '=&>*' WS
EOF = !.