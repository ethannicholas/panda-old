{
	class Grammar {
		def definitions:ListView<Definition>

		def code:String?

		constructor(definitions:ListView<Definition>, code:String?) {
			self.definitions := definitions
			if code != null
				self.code := code.trim()
			else
				self.code := null
		}

		@override
		function format(fmt:String):String {
			def code:String
			if self.code != null
				code := self.code
			else
				code := "<null>"
			return "Grammar<definitions=\{definitions}>"
		}
	}

	class Identifier {
		def text:String

		constructor(text:String) {
			self.text := text
		}

		constructor(text:Array<String>) {
			self.text := text.join("")
		}

		@override
		function format(fmt:String):String {
			return "Identifier<\{text}>"
		}
	}

	class Definition {
		def name:String

		def type:String?

		def definition:Options

		constructor(name:String, type:String?, definition:Options) {
			self.name := name
			self.type := type
			self.definition := definition
		}

		@override
		function format(fmt:String):String {
			def type:String
			if self.type != null
				type := self.type
			else
				type := "<null>"
			return "Definition<name=\{name}, type=\{type}, definition=\{definition}>"
		}
	}

	class Options {
		def options:ListView<Sequence>

		constructor(options:ListView<Sequence>) {
			self.options := options
		}

		@override
		function format(fmt:String):String {
			return "Options<\{options}>"
		}
	}

	class Sequence {
		def terms:ListView<Term>

		def code:String?

		constructor(terms:ListView<Term>, code:String?) {
			self.terms := terms
			if code != null
				self.code := code.trim()
			else
				self.code := null
		}

		@override
		function format(fmt:String):String {
			def code:String
			if self.code != null
				code := self.code
			else
				code := "<null>"
			return "Sequence<terms=\{terms}>"
		}
	}

	class Range {
		def start:Char

		def end:Char

		constructor(start:Char, end:Char) {
			self.start := start
			self.end := end
		}

		@override
		function format(fmt:String):String {
			if start = end
				return start->>(String)
			else
				return "\{start}-\{end}"
		}
	}

	class CharClass {
		def ranges:ListView<Range>

		constructor(ranges:ListView<Range>) {
			self.ranges := ranges
		}

		@override
		function format(fmt:String):String {
			return "[" + ranges.join("") + "]"
		}		
	}

	enum Prefix {
		AND, NOT
	}

	enum Suffix {
		QUESTION, STAR, PLUS
	}

	class Term {
		def name:String?

		def prefix:Prefix?

		def value:Object

		def suffix:Suffix?

		constructor(name:String?, prefix:Prefix?, value:Object, 
				suffix:Suffix?) {
			self.name := name
			self.prefix := prefix
			self.value := value
			self.suffix := suffix
		}

		@override
		function format(fmt:String):String {
			def result := new MutableString("Term<name=")
			if name != null
				result.append(name)
			else
				result.append("<null>")
			result.append(", prefix=")
			if prefix != null
				result.append(prefix)
			else
				result.append("<null>")
			result.append(", value=\{value}, suffix=")
			if suffix != null
				result.append(suffix)
			else
				result.append("<null>")
			return result + ">"
		}
	}

	class Dot {
		@override
		function format(fmt:String):String {
			return "<DOT>"
		}
	}

	class Util {
		@class
		function unescape(text:String):String {
			return text.replace("\\n", "\n").replace("\\r", "\r").replace("\\t", 
					"\t").replace("\\[", "[").replace("\\]", "]").replace("\\\\", "\\")
		}
	}
}

Grammar:Grammar = Spacing code:Code? definitions:Definition+ EndOfFile 
	{ result := new Grammar(definitions, code) }
Code = '{' (Code / !'}' .)* '}' Spacing
Definition:Definition = id:Identifier (COLON type:Type)? EQUAL expr:Expression 
	{ result := new Definition(id.text, type, expr) }
Type:String = id:Identifier { result := id.text.trim }
Expression:Options = seq:Sequence (SLASH seq:Sequence)* 
	{ result := new Options(seq) }
Sequence:Sequence = terms:Prefix* code:Code? 
	{ result := new Sequence(terms, code) }
Prefix:Term = (id:Identifier COLON)? (a:AND / n:NOT)? s:Suffix 
	{ 
		def pre:Prefix := null
		if a != null
			pre := Prefix.AND
		else if n != null
			pre := Prefix.NOT
		def name:String?
		if id != null
			name := id.text
		else
			name := null
		result := new Term(name, pre, s.value, s.suffix)
	}
Suffix:Term = value:Primary (q:QUESTION / st:STAR / p:PLUS)? 
	{
		def suf:Suffix? := null
		if q != null
			suf := Suffix.QUESTION
		else if st != null
			suf := Suffix.STAR
		else if p != null
			suf := Suffix.PLUS
		result := new Term(null, null, value, suf)
	}
Primary:Object = i:Identifier !EQUAL { result := i }
	/ OPEN e:Expression CLOSE { result := e }
	/ l:Literal { result := l }
	/ cl:Class { result := cl }
	/ d:DOT  { result := d }

Identifier:Identifier = text:IdentStart text:IdentCont* Spacing  
	{
		result := new Identifier(text)
	}

Range:Range = start:Char '-' end:Char
	{
		result := new Range(start[0], end[0])
	}
	/ single:Char 
	{
		result := new Range(single[0], single[0])
	}

Class:CharClass = '[' (!']' ranges:Range)* ']' Spacing 
	{
		result := new CharClass(ranges)
	}

IdentStart = [a-zA-Z_]
IdentCont = IdentStart / [0-9]
Literal:String = ['] (!['] text:Char)* ['] Spacing 
	{
		result := Util.unescape(text.join(""))
	}
/ ["] (!["] text:Char)* ["] Spacing 
	{
		result := Util.unescape(text.join(""))
	}
DOT:Dot = '.' Spacing
	{
		result := new Dot()
	}
Char = '\\' char:[nrt'"\[\]\\] 
	{
		result := Util.unescape("\\" + char)
	}
/ !'\\' char:.
	{
		result := char
	}
EQUAL = '=' Spacing 
SLASH = '/' Spacing 
AND = '&' Spacing 
NOT = '!' Spacing 
QUESTION = '?' Spacing 
STAR = '*' Spacing 
PLUS = '+' Spacing 
OPEN = '(' Spacing 
CLOSE = ')' Spacing 
COLON = ':' Spacing
Spacing = (Space / Comment)*
Comment = '#' (!EndOfLine .)* EndOfLine 
Space = ' ' / '\t' / EndOfLine 
EndOfLine = '\r\n' / '\n' / '\r' 
EndOfFile = !.