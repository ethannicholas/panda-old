{
	class Grammar {
		def definitions:ListView<Definition>

		def code:String?

		constructor(definitions:ListView<Definition>, code:String?) {
			self.definitions := definitions
			if code != null
				self.code := code.trim()
			else
				self.code := null
		}

		@override
		function format(fmt:String):String {
			def code:String
			if self.code != null
				code := "{ \{self.code} }\n"
			else
				code := ""
			return code + definitions.join("\n")
		}
	}

	class Identifier {
		def text:String

		constructor(text:String) {
			self.text := text
		}

		constructor(text:Array<String>) {
			self.text := text.join("")
		}

		@override
		function format(fmt:String):String {
			return text
		}
	}

	class Definition {
		def name:String

		def type:String?

		def definition:Options

		constructor(name:String, type:String?, definition:Options) {
			self.name := name
			self.type := type
			self.definition := definition
		}

		@override
		function format(fmt:String):String {
			def type:String
			if self.type != null
				type := ":" + self.type
			else
				type := ""
			return "\{name}\{type} = \{definition}"
		}
	}

	class Options {
		def options:ListView<Sequence>

		constructor(options:ListView<Sequence>) {
			self.options := options
		}

		@override
		function format(fmt:String):String {
			return "(" + options.join(" / ") + ")"
		}
	}

	class Sequence {
		def terms:ListView<Term>

		def code:String?

		constructor(terms:ListView<Term>, code:String?) {
			self.terms := terms
			if code != null
				self.code := code.trim()
			else
				self.code := null
		}

		@override
		function format(fmt:String):String {
			def code:String
			if self.code != null
				code := " { \{self.code} }"
			else
				code := ""
			return terms.join(" ") + code
		}
	}

	class Range {
		def start:Char

		def end:Char

		constructor(start:Char, end:Char) {
			self.start := start
			self.end := end
		}

		@override
		function format(fmt:String):String {
			if start = end
				return start->>(String)
			else
				return "\{start}-\{end}"
		}
	}

	class CharClass {
		def ranges:ListView<Range>

		constructor(ranges:ListView<Range>) {
			self.ranges := ranges
		}

		@override
		function format(fmt:String):String {
			return "[" + ranges.join("") + "]"
		}		
	}

	enum Prefix {
		AND, NOT
	}

	enum Suffix {
		QUESTION, STAR, PLUS
	}

	class Term {
		def name:String?

		def prefix:Prefix?

		def value:Object

		def suffix:Suffix?

		constructor(name:String?, prefix:Prefix?, value:Object, 
				suffix:Suffix?) {
			self.name := name
			self.prefix := prefix
			self.value := value
			self.suffix := suffix
		}

		@override
		function format(fmt:String):String {
			def result := new MutableString()
			if name != null
				result.append(name + ":")
			switch prefix {
				case Prefix.AND: result.append("&")
				case Prefix.NOT: result.append("!")
			}
			result.append(value)
			switch suffix {
				case Suffix.QUESTION: result.append("?")
				case Suffix.STAR: result.append("*")
				case Suffix.PLUS: result.append("+")
			}
			return result->>(String)
		}
	}

	class Cut : Term {
		constructor() {
			super.constructor("^", null, "^", null)
		}

		@override
		function format(fmt:String):String {
			return "^"
		}		
	}

	class Dot {
		@override
		function format(fmt:String):String {
			return "."
		}
	}

	class Util {
		@class
		function unescape(text:String):String {
			return text.replace("\\n", "\n").replace("\\r", "\r").replace("\\t", 
					"\t").replace("\\[", "[").replace("\\]", "]").replace("\\\\", "\\")
		}
	}
}

Grammar:Grammar = Spacing code:Code? definitions:Definition+ EndOfFile 
	{ result := new Grammar(definitions, code) }
Code:String = c:'{' (c:Code / !'}' c:.)* c:'}' Spacing
	{ result := c.join("") }
Definition:Definition = id:Identifier (COLON type:Type)? EQUAL expr:Expression 
	{ result := new Definition(id.text, type, expr) }
Type:String = id:Identifier (LT t:Type (COMMA t:Type)* GT)? nullable:QUESTION? 
	{
 		var text := id.text.trim 
 		if t.length > 0
 			text += "<\{t.join(',')}>"
 		if nullable != null
 			text += "?"
 		result := text
 	}
Expression:Options = seq:Sequence (SLASH seq:Sequence)* 
	{ result := new Options(seq) }
Sequence:Sequence = terms:Prefix* code:Code? 
	{ result := new Sequence(terms, code) }
Prefix:Term = (id:Identifier COLON)? (a:AND / n:NOT)? s:Suffix 
	{ 
		def pre:Prefix := null
		if a != null
			pre := Prefix.AND
		else if n != null
			pre := Prefix.NOT
		def name:String?
		if id != null
			name := id.text
		else
			name := null
		result := new Term(name, pre, s.value, s.suffix)
	}
/
	CUT
	{ result := new Cut() }
Suffix:Term = value:Primary (q:QUESTION / st:STAR / p:PLUS)?
	{
		def suf:Suffix? := null
		if q != null
			suf := Suffix.QUESTION
		else if st != null
			suf := Suffix.STAR
		else if p != null
			suf := Suffix.PLUS
		result := new Term(null, null, value, suf)
	}
Primary:Object = i:Identifier !EQUAL 
	{ result := i }
/ 
	OPEN e:Expression CLOSE 
	{ result := e }
/ 
	l:Literal 
	{ result := l }
/ 
	cl:Class 
	{ result := cl }
/ 
	d:DOT  
	{ result := d }

Identifier:Identifier = text:IdentStart text:IdentCont* Spacing  
	{ result := new Identifier(text.join("")) }

Range:Range = start:Char '-' end:Char
	{ result := new Range(start, end) }
/ 
	single:Char 
	{ result := new Range(single, single) }

Class:CharClass = '[' (!']' ranges:Range)* ']' Spacing 
	{ result := new CharClass(ranges) }

IdentStart:Char = c:[a-zA-Z_]
	{ result := c }
IdentCont:Char = c1:IdentStart
	{ result := c1 }
/ 
	c2:[0-9]
	{ result := c2 }
Literal:String = ['] (!['] text:Char)* ['] Spacing 
	{ result := Util.unescape(text.join("")) }
/ ["] (!["] text:Char)* ["] Spacing 
	{ result := Util.unescape(text.join("")) }
DOT:Dot = '.' Spacing
	{ result := new Dot() }
Char:Char = '\\' char1:[nrt'"\[\]\\] 
	{ result := Util.unescape("\\" + char1)[0] }
/ !'\\' char2:.
	{ result := char2 }
EQUAL = '=' Spacing 
SLASH = '/' Spacing 
AND:Bit = '&' Spacing 
	{ result := true }
NOT:Bit = '!' Spacing 
	{ result := true }
CUT = '^' Spacing
LT = '<' Spacing 
GT = '>' Spacing 
COMMA = ',' Spacing 
STAR:Bit = '*' Spacing 
	{ result := true }
PLUS:Bit = '+' Spacing 
	{ result := true }
OPEN = '(' Spacing 
CLOSE = ')' Spacing 
COLON = ':' Spacing
QUESTION:Bit = '?' Spacing
	{ result := true }
Spacing = (Space / Comment)*
Comment = '#' (!EndOfLine .)* EndOfLine 
Space = ' ' / '\t' / EndOfLine 
EndOfLine = '\r\n' / '\n' / '\r' 
EndOfFile = !.