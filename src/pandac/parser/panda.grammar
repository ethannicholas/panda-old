{
    package org.pandalanguage.pandac.parser
    
    uses org.pandalanguage.pandac.ast.Alignment
    uses org.pandalanguage.pandac.ast.ASTArrayLiteral
    uses org.pandalanguage.pandac.ast.ASTArrowExpression
    uses org.pandalanguage.pandac.ast.ArrowOperationType
    uses org.pandalanguage.pandac.ast.ASTAnnotation
    uses org.pandalanguage.pandac.ast.ASTAssert
    uses org.pandalanguage.pandac.ast.ASTAssignment
    uses org.pandalanguage.pandac.ast.ASTAtReturn
    uses org.pandalanguage.pandac.ast.ASTBinaryExpression
    uses org.pandalanguage.pandac.ast.ASTBitLiteral
    uses org.pandalanguage.pandac.ast.ASTBlock
    uses org.pandalanguage.pandac.ast.ASTBreak
    uses org.pandalanguage.pandac.ast.ASTCallExpression
    uses org.pandalanguage.pandac.ast.ASTCatch
    uses org.pandalanguage.pandac.ast.ASTClass
    uses org.pandalanguage.pandac.ast.ASTClassLiteral
    uses org.pandalanguage.pandac.ast.ASTClassType
    uses org.pandalanguage.pandac.ast.ASTContinue
    uses org.pandalanguage.pandac.ast.ASTDo
    uses org.pandalanguage.pandac.ast.ASTDotExpression
    uses org.pandalanguage.pandac.ast.ASTEnum
    uses org.pandalanguage.pandac.ast.ASTEnumValue
    uses org.pandalanguage.pandac.ast.ASTExpression
    uses org.pandalanguage.pandac.ast.ASTExpressionStatement
    uses org.pandalanguage.pandac.ast.ASTField
    uses org.pandalanguage.pandac.ast.ASTFile
    uses org.pandalanguage.pandac.ast.ASTFor
    uses org.pandalanguage.pandac.ast.ASTFormatExpression
    uses org.pandalanguage.pandac.ast.ASTIdentifier
    uses org.pandalanguage.pandac.ast.ASTIf
    uses org.pandalanguage.pandac.ast.ASTIndex
    uses org.pandalanguage.pandac.ast.ASTInstanceDeclaration
    uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
    uses org.pandalanguage.pandac.ast.ASTInvariant
    uses org.pandalanguage.pandac.ast.ASTLambdaExpression
    uses org.pandalanguage.pandac.ast.ASTLoop
    uses org.pandalanguage.pandac.ast.ASTMethod
    uses org.pandalanguage.pandac.ast.ASTMethodType
    uses org.pandalanguage.pandac.ast.ASTMethodValue
    uses org.pandalanguage.pandac.ast.ASTNew
    uses org.pandalanguage.pandac.ast.ASTNode
    uses org.pandalanguage.pandac.ast.ASTNullLiteral
    uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
    uses org.pandalanguage.pandac.ast.ASTParameter
    uses org.pandalanguage.pandac.ast.ASTPlugin
    uses org.pandalanguage.pandac.ast.ASTPostcondition
    uses org.pandalanguage.pandac.ast.ASTPre
    uses org.pandalanguage.pandac.ast.ASTPrecondition
    uses org.pandalanguage.pandac.ast.ASTRangeExpression
    uses org.pandalanguage.pandac.ast.ASTRealLiteral
    uses org.pandalanguage.pandac.ast.ASTReturn
    uses org.pandalanguage.pandac.ast.ASTSelf
    uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
    uses org.pandalanguage.pandac.ast.ASTStatement
    uses org.pandalanguage.pandac.ast.ASTStringLiteral
    uses org.pandalanguage.pandac.ast.ASTSuper
    uses org.pandalanguage.pandac.ast.ASTSwitch
    uses org.pandalanguage.pandac.ast.ASTSwitchCase
    uses org.pandalanguage.pandac.ast.ASTThrow
    uses org.pandalanguage.pandac.ast.ASTTry
    uses org.pandalanguage.pandac.ast.ASTTupleExpression
    uses org.pandalanguage.pandac.ast.ASTTupleType
    uses org.pandalanguage.pandac.ast.ASTType
    uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
    uses org.pandalanguage.pandac.ast.ASTUnaryExpression
    uses org.pandalanguage.pandac.ast.ASTUnreachable
    uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
    uses org.pandalanguage.pandac.ast.ASTVarDeclaration
    uses org.pandalanguage.pandac.ast.ASTWhile
    uses org.pandalanguage.pandac.tree.BinaryOperationType
    uses org.pandalanguage.pandac.tree.MethodNode
    uses org.pandalanguage.pandac.tree.MethodNodeType
    uses org.pandalanguage.pandac.tree.Position
    uses org.pandalanguage.pandac.tree.UnaryOperationType
    uses org.pandalanguage.pandac.tree.VariableType

    class ForTarget {
        def index:ASTTypedIdentifier?
        def loopVars:ListView<ASTTypedIdentifier>

        constructor(index:ASTTypedIdentifier?, 
                loopVars:ListView<ASTTypedIdentifier>) {
            self.index := index
            self.loopVars := loopVars
        }
    }

    class FormatField {
        def fillChar:Char
        def alignment:Alignment
        def width:Int

        constructor(fillChar:Char, alignment:Alignment, width:Int) {
            self.fillChar := fillChar
            self.alignment := alignment
            self.width := width
        }
    }

    class ParserUtil {
        constant KEYWORDS := new HashSet<String>(["package", "uses", "as", 
                    "class", "method", "function", "constructor", "var", "def", 
                    "property", "constant", "do", "while", "for", "by", "loop", 
                    "if", "else", "switch", "case", "default", "self", "true",
                     "false", "enum", "return", "break", "continue", "null", 
                     "new", "assert", "unreachable", "try", "catch", "finally", 
                     "throw", "super"])

        @class
        @pre(base >= 2 & base <= 36)
        function parseInt(s:String, base:UInt):UInt64? {
            var result:UInt64 := 0
            constant DIGITS := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            constant DIGITS_LOWER := "0123456789abcdefghijklmnopqrstuvwxyz"
            for i in 0 .. s.length {
                var digit := DIGITS.indexOf(s[i])
                if digit = null {
                    digit := DIGITS_LOWER.indexOf(s[i])
                }
                if digit = null | digit >= base {
                    return null
                }
                result := result * base + digit->(UInt64)
            }
            return result
        }

        @class
        function unescape(text:String):String {
            return text.replace("\\n", "\n").replace("\\r", "\r").replace("\\t", 
                    "\t").replace("\\[", "[").replace("\\]", "]").
                    replace("\\:", ":").replace("\\\\", "\\").
                    replace("\\'", "'")
        }

        @class
        function isExternal(file:File):Bit {
            return file.name.endsWith(".plink")
        }
    }
}

@file:Array<ASTNode> = WS bodyEntries optionalTrailingLineComment
    { result := bodyEntries }
@file:Array<ASTNode> = WS optionalTrailingLineComment
    { result := [] }
bodyEntries:Array<ASTNode> = bodyEntries bodyEntry
    { 
        result := [] 
        result.addAll(bodyEntries)
        result.add(bodyEntry)
    }
bodyEntries:Array<ASTNode> = bodyEntry
    { result := [bodyEntry] }
optionalTrailingLineComment = TRAILING_LINE_COMMENT
optionalTrailingLineComment =

bodyEntry:ASTNode = usesStatement 
    { result := usesStatement }
bodyEntry:ASTNode = classDeclaration 
    { result := classDeclaration }
bodyEntry:ASTNode = interfaceDeclaration 
    { result := interfaceDeclaration }
bodyEntry:ASTNode = enumDeclaration
    { result := enumDeclaration }
bodyEntry:ASTNode = methodDeclaration
    { result := methodDeclaration }
bodyEntry:ASTNode = functionDeclaration
    { result := functionDeclaration }
bodyEntry:ASTNode = packageDeclaration 
    { result := packageDeclaration }
bodyEntry:ASTNode = instanceDeclaration 
    { result := instanceDeclaration }
bodyEntry:ASTNode = statement
    { result := statement }

packageDeclaration:ASTPackageDeclaration = PACKAGE ^ dottedName
    { result := new ASTPackageDeclaration(new Position(file, parserState.position), dottedName) }
dottedName:String = dottedName DOT IDENTIFIER
    { result := dottedName + "." + IDENTIFIER }
dottedName:String = IDENTIFIER
    { result := IDENTIFIER }
usesStatement:ASTUsesDeclaration = USES usesName
    { result := new ASTUsesDeclaration(new Position(file, parserState.position), usesName, null) }
usesStatement:ASTUsesDeclaration = USES id:dottedName AS ^ alias:dottedName
    { result := new ASTUsesDeclaration(new Position(file, parserState.position), id, alias) }
usesName:String = dottedName DOT STAR
    { result := dottedName + ".*" }
usesName:String = dottedName
    { result := dottedName }
instanceDeclaration:ASTInstanceDeclaration = INSTANCE ^ type
    { result := new ASTInstanceDeclaration(new Position(file, parserState.position), type) }

classDeclaration:ASTClass = optionalDoccomment optionalAnnotations CLASS 
        IDENTIFIER optionalGenericsDeclaration optionalTypeDeclaration
        optionalInterfaces LBRACE ^ classMembers RBRACE
    { 
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        for m in classMembers {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := new ASTClass(new Position(file, parserState.position), IDENTIFIER, false, 
                optionalDoccomment, optionalAnnotations, 
                optionalTypeDeclaration, optionalInterfaces, 
                optionalGenericsDeclaration, methods, fields, invariants, 
                ParserUtil.isExternal(file))
    }
interfaceDeclaration:ASTClass = optionalDoccomment optionalAnnotations 
        INTERFACE ^ IDENTIFIER optionalGenericsDeclaration 
        optionalTypeDeclarations LBRACE classMembers RBRACE
    { 
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        for m in classMembers {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := new ASTClass(new Position(file, parserState.position), IDENTIFIER, true, 
                optionalDoccomment, optionalAnnotations, 
                null, optionalTypeDeclarations, optionalGenericsDeclaration, 
                methods, fields, invariants, ParserUtil.isExternal(file))
    }
enumDeclaration:ASTEnum = optionalDoccomment optionalAnnotations ENUM ^ 
        IDENTIFIER LBRACE enumValues RBRACE
    {
        result := new ASTEnum(new Position(file, parserState.position), IDENTIFIER, optionalDoccomment, 
                optionalAnnotations, enumValues, ParserUtil.isExternal(file))
    }
enumValues:Array<ASTEnumValue> = enumValues COMMA enumValue
    {
        result := []
        result.addAll(enumValues)
        result.add(enumValue)
    }
enumValues:Array<ASTEnumValue> = enumValue
    { result := [enumValue] }
enumValue:ASTEnumValue = optionalDoccomment IDENTIFIER
    { 
        result := new ASTEnumValue(new Position(file, parserState.position), IDENTIFIER, 
                optionalDoccomment) 
    }
optionalDoccomment:String? = DOCCOMMENT
    { result := DOCCOMMENT }
optionalDoccomment:String? =
    { result := null }
optionalAnnotations:Array<ASTAnnotation>? = annotations
    { result := annotations }
optionalAnnotations:Array<ASTAnnotation>? =
    { result := null }
optionalTypeDeclarations:Array<ASTType>? = COLON typeList
    { result := typeList }
optionalTypeDeclarations:Array<ASTType>? =
    { result := null }
optionalTypeDeclaration:ASTType? = typeDeclaration 
    { result := typeDeclaration }
optionalTypeDeclaration:ASTType? =
    { result := null }
typeDeclaration:ASTType = COLON type
    { result := type }
optionalGenericsDeclaration:Array<ASTTypedIdentifier>? = LT genericsDeclarations 
        GT
    { result := genericsDeclarations }
optionalGenericsDeclaration:Array<ASTTypedIdentifier>? =
    { result := null }
genericsDeclarations:Array<ASTTypedIdentifier> = genericsDeclarations COMMA
        optionallyTypedIdentifier
    { 
        result := []
        result.addAll(genericsDeclarations)
        result.add(optionallyTypedIdentifier)
    }
genericsDeclarations:Array<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := [optionallyTypedIdentifier] }
optionalInterfaces:Array<ASTType>? = LPAREN typeList RPAREN
    { result := typeList }
optionalInterfaces:Array<ASTType>? =
    { result := null }
classMembers:Array<ASTNode> = classMemberList
    { result := classMemberList }
classMembers:Array<ASTNode> =
    { result := [] }
classMemberList:Array<ASTNode> = classMemberList classMember
    { 
        result := []
        result.addAll(classMemberList)
        result.add(classMember)
    }
classMemberList:Array<ASTNode> =
    { result := [] }
classMember:ASTNode = invariant 
    { result := invariant }
classMember:ASTNode = methodDeclaration 
    { result := methodDeclaration }
classMember:ASTNode = functionDeclaration 
    { result := functionDeclaration }
classMember:ASTNode = constructorDeclaration 
    { result := constructorDeclaration }
classMember:ASTNode = fieldDeclaration 
    { result := fieldDeclaration }
annotations:Array<ASTAnnotation> = annotations annotation
    {
        result := []
        result.addAll(annotations)
        result.add(annotation)
    }
annotations:Array<ASTAnnotation> = annotation
    { result := [annotation] }
annotation:ASTAnnotation = PROTECTED 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "protected") }
annotation:ASTAnnotation = PRIVATE 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "private") }
annotation:ASTAnnotation = ATCLASS 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "class") }
annotation:ASTAnnotation = THREAD 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "thread") }
annotation:ASTAnnotation = ABSTRACT 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "abstract") }
annotation:ASTAnnotation = EXTERNAL 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "external") }
annotation:ASTAnnotation = OVERRIDE 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "override") }
annotation:ASTAnnotation = READONLY 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "readonly") }
annotation:ASTAnnotation = LIMITED 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "limited") }
annotation:ASTAnnotation = ATSELF 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "self") }
annotation:ASTAnnotation = SAFERETURN 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "safeReturn") }
annotation:ASTAnnotation = UNSAFEFUNCTION 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "unsafeFunction") }
annotation:ASTAnnotation = FINAL 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "final") }
annotation:ASTAnnotation = WRAPPER_METHOD 
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "$wrapperMethod") }
annotation:ASTAnnotation = MATH LPAREN OVERFLOW RPAREN
    { result := new ASTSimpleAnnotation(new Position(file, parserState.position), "math(overflow)") }
annotation:ASTAnnotation = PRE LPAREN expression RPAREN
    { result := new ASTPrecondition(new Position(file, parserState.position), expression, false) }
annotation:ASTAnnotation = PRE_OR LPAREN expression RPAREN
    { result := new ASTPrecondition(new Position(file, parserState.position), expression, true) }
postcondition:ASTPostcondition = POST LPAREN expression RPAREN
    { result := new ASTPostcondition(new Position(file, parserState.position), expression, false) }
postcondition:ASTPostcondition = POST_AND LPAREN expression RPAREN
    { result := new ASTPostcondition(new Position(file, parserState.position), expression, true) }
postconditions:Array<ASTPostcondition> = postconditions postcondition
    {
        result := []
        result.addAll(postconditions)
        result.add(postcondition)
    }
postconditions:Array<ASTPostcondition> = postcondition
    { result := [postcondition] }
optionalPostconditions:Array<ASTPostcondition>? = postconditions
    { result := postconditions }
optionalPostconditions:Array<ASTPostcondition>? = 
    { result := null }

invariant:ASTInvariant = INVARIANT LPAREN expression RPAREN
    { result := new ASTInvariant(new Position(file, parserState.position), expression) }

methodDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        METHOD ^ methodName formalParameters optionalTypeDeclaration 
        optionalBlock optionalPostconditions
    {
        result := new ASTMethod(new Position(file, parserState.position), methodName, 
                MethodNodeType.METHOD, optionalDoccomment, 
                optionalAnnotations, formalParameters, optionalTypeDeclaration, 
                optionalBlock, optionalPostconditions)
    }
methodName:String = IDENTIFIER 
    { result := IDENTIFIER }
methodName:String = IDENTIFIER ASSIGNMENT
    { result := IDENTIFIER + ":=" }
methodName:String = CONVERT
    { result := "->>" }
methodName:String = SHIFTLEFT
    { result := "<<" }
methodName:String = SHIFTRIGHT
    { result := ">>" }
methodName:String = ADD
    { result := "+" }
methodName:String = SUB
    { result := "-" }
methodName:String = MUL
    { result := "*" }
methodName:String = DIV
    { result := "/" }
methodName:String = INTDIV
    { result := "//" }
methodName:String = REM
    { result := "%" }
methodName:String = AND
    { result := "&" }
methodName:String = OR
    { result := "|" }
methodName:String = XOR
    { result := "~" }
methodName:String = BITWISEAND
    { result := "&&" }
methodName:String = BITWISEOR
    { result := "||" }
methodName:String = BITWISEXOR
    { result := "~~" }
methodName:String = POW
    { result := "^" }
methodName:String = NOT
    { result := "!" }
methodName:String = BITWISENOT
    { result := "!!" }
methodName:String = '[]' WS
    { result := "[]" }
methodName:String = '[..]' WS
    { result := "[..]" }
methodName:String = '[...]' WS
    { result := "[...]" }
methodName:String = '[]:=' WS
    { result := "[]:=" }
methodName:String = '[..]:=' WS
    { result := "[..]:=" }
methodName:String = '[...]:=' WS
    { result := "[...]:=" }
methodName:String = EQ
    { result := "=" }
methodName:String = GT
    { result := ">" }
methodName:String = LT
    { result := "<" }
methodName:String = GTEQ
    { result := ">=" }
methodName:String = LTEQ
    { result := "<=" }
formalParameters:Array<ASTParameter> = LPAREN parameterList RPAREN
    { result := parameterList }
formalParameters:Array<ASTParameter> = LPAREN RPAREN
    { result := [] }
parameterList:Array<ASTParameter> = parameterList COMMA parameter
    {
        result := []
        result.addAll(parameterList)
        result.add(parameter)
    }
parameterList:Array<ASTParameter> = parameter
    { result := [parameter] }
parameter:ASTParameter = optionalVar IDENTIFIER optionalConvert type 
        optionalEllipsis
    { 
        result := new ASTParameter(new Position(file, parserState.position), IDENTIFIER, type, optionalVar, 
                optionalConvert, optionalEllipsis)
    }
optionalVar:Bit = VAR
    { result := true }
optionalVar:Bit =
    { result := false }
optionalConvert:Bit = CONVERT
    { result := true }
optionalConvert:Bit = COLON
    { result := false }
optionalEllipsis:Bit = ELLIPSIS
    { result := true }
optionalEllipsis:Bit =
    { result := false }
optionalBlock:ASTBlock? = block
    { result := block }
optionalBlock:ASTBlock? = 
    { result := null }

@anyMethod:ASTMethod = functionDeclaration
    { result := functionDeclaration }
@anyMethod:ASTMethod = methodDeclaration
    { result := methodDeclaration }
@anyMethod:ASTMethod = constructorDeclaration
    { result := constructorDeclaration }

functionDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        FUNCTION ^ methodName formalParameters typeDeclaration optionalBlock
        optionalPostconditions
    {
        result := new ASTMethod(new Position(file, parserState.position), 
                methodName, MethodNodeType.FUNCTION, optionalDoccomment, 
                optionalAnnotations, formalParameters, typeDeclaration, 
                optionalBlock, optionalPostconditions)
    }

constructorDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        CONSTRUCTOR ^ formalParameters optionalBlock optionalPostconditions
    {
        result := new ASTMethod(new Position(file, parserState.position), 
                MethodNode.CONSTRUCTOR_NAME, 
                MethodNodeType.CONSTRUCTOR, optionalDoccomment, 
                optionalAnnotations, formalParameters, null, 
                optionalBlock, optionalPostconditions)
    }

fieldDeclaration:ASTField = optionalDoccomment optionalAnnotations 
        varDeclaration
    { 
        result := new ASTField(optionalDoccomment, optionalAnnotations, 
                varDeclaration) 
    }

@statement:ASTStatement = varDeclaration
    { result := varDeclaration }
@statement:ASTStatement = ifStatement
    { result := ifStatement }
@statement:ASTStatement = forLoop 
    { result := forLoop }
@statement:ASTStatement = whileLoop 
    { result := whileLoop }
@statement:ASTStatement = doLoop 
    { result := doLoop }
@statement:ASTStatement = loopLoop
    { result := loopLoop }
@statement:ASTStatement = methodCall
    { result := new ASTExpressionStatement(methodCall) }
@statement:ASTStatement = assignment
    { result := assignment }
@statement:ASTStatement = assertStatement 
    { result := assertStatement }
@statement:ASTStatement = switchStatement
    { result := switchStatement }
@statement:ASTStatement = tryStatement 
    { result := tryStatement }
@statement:ASTStatement = block
    { result := block }

statementOrBlock:ASTStatement = statement 
    { result := statement }
statementOrBlock:ASTStatement = terminalStatement 
    { result := terminalStatement }

varDeclaration:ASTVarDeclaration = VAR varDeclarations
    { 
        result := new ASTVarDeclaration(new Position(file, parserState.position), VariableType.VAR, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = DEF varDeclarations
    { 
        result := new ASTVarDeclaration(new Position(file, parserState.position), VariableType.DEF, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = PROPERTY varDeclarations
    { 
        result := new ASTVarDeclaration(new Position(file, parserState.position), VariableType.PROPERTY, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = CONSTANT varDeclarations
    { 
        result := new ASTVarDeclaration(new Position(file, parserState.position), VariableType.CONSTANT, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = VAR varDeclarations ASSIGNMENT expression
    { 
        result := new ASTVarDeclaration(new Position(file, parserState.position), VariableType.VAR, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = DEF varDeclarations ASSIGNMENT expression
    { 
        result := new ASTVarDeclaration(new Position(file, parserState.position), VariableType.DEF, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = PROPERTY varDeclarations ASSIGNMENT expression
    { 
        result := new ASTVarDeclaration(new Position(file, parserState.position), VariableType.PROPERTY, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = CONSTANT varDeclarations ASSIGNMENT expression
    { 
        result := new ASTVarDeclaration(new Position(file, parserState.position), VariableType.CONSTANT, 
                varDeclarations, expression) 
    }
varDeclarations:Array<ASTTypedIdentifier> = varDeclarations COMMA 
        optionallyTypedIdentifier
    { 
        result := [] 
        result.addAll(varDeclarations)
        result.add(optionallyTypedIdentifier)
    }
varDeclarations:Array<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := [optionallyTypedIdentifier] }
optionallyTypedIdentifier:ASTTypedIdentifier = IDENTIFIER
    { result := new ASTTypedIdentifier(new Position(file, parserState.position), IDENTIFIER, null) }
optionallyTypedIdentifier:ASTTypedIdentifier = IDENTIFIER COLON type
    { result := new ASTTypedIdentifier(new Position(file, parserState.position), IDENTIFIER, type) }

ifStatement:ASTIf = IF ^ expression statementOrBlock optionalElse
    { 
        result := new ASTIf(new Position(file, parserState.position), expression, statementOrBlock, 
                optionalElse) 
    }
optionalElse:ASTStatement? = ELSE statementOrBlock
    { result := statementOrBlock }
optionalElse:ASTStatement? =
    { result := null }

forLoop:ASTFor = optionalLabel FOR ^ forTarget IN ^ expression 
        statementOrBlock
    { 
        result := new ASTFor(new Position(file, parserState.position), optionalLabel, forTarget.index, 
                forTarget.loopVars, expression, statementOrBlock) 
    }
optionalLabel:String? = IDENTIFIER COLON
    { result := IDENTIFIER }
optionalLabel:String? =
    { result := null }
forTarget:ForTarget = optionallyTypedIdentifier
    { result := new ForTarget(null, [optionallyTypedIdentifier]) }
forTarget:ForTarget = index:optionallyTypedIdentifier COMMA 
        loopVar:optionallyTypedIdentifier
    { result := new ForTarget(index, [loopVar]) }
forTarget:ForTarget = forTuple
    { result := new ForTarget(null, forTuple) }
forTarget:ForTarget = optionallyTypedIdentifier COMMA forTuple
    { result := new ForTarget(optionallyTypedIdentifier, forTuple) }
forTuple:Array<ASTTypedIdentifier> = LPAREN varDeclarations RPAREN
    { result := varDeclarations }

whileLoop:ASTWhile = optionalLabel WHILE ^ expression statementOrBlock
    { 
        result := new ASTWhile(new Position(file, parserState.position), optionalLabel, expression, 
                statementOrBlock)
    }

doLoop:ASTDo = optionalLabel DO ^ statementOrBlock WHILE expression
    { 
        result := new ASTDo(new Position(file, parserState.position), optionalLabel, expression, 
                statementOrBlock)
    }

loopLoop:ASTLoop = optionalLabel LOOP ^ statementOrBlock
    { result := new ASTLoop(new Position(file, parserState.position), optionalLabel, statementOrBlock) }

methodCall:ASTExpression = callExpression parameters
    { result := new ASTCallExpression(callExpression, parameters) }
methodCall:ASTExpression = CONSTRUCTOR parameters
    { 
        result := new ASTCallExpression(
                new ASTIdentifier(new Position(file, parserState.position), 
                    "constructor"), 
                parameters) 
    }
assignment:ASTStatement = expressionList assignmentOperator expression
    { 
        result := new ASTAssignment(expressionList, assignmentOperator, 
                expression) 
    }
assignmentOperator:BinaryOperationType? = ASSIGNMENT
    { result := null }
assignmentOperator:BinaryOperationType? = ADDEQ
    { result := BinaryOperationType.ADD }
assignmentOperator:BinaryOperationType? = SUBEQ
    { result := BinaryOperationType.SUBTRACT }
assignmentOperator:BinaryOperationType? = MULEQ 
    { result := BinaryOperationType.MULTIPLY }
assignmentOperator:BinaryOperationType? = DIVEQ 
    { result := BinaryOperationType.DIVIDE }
assignmentOperator:BinaryOperationType? = INTDIVEQ 
    { result := BinaryOperationType.INT_DIVIDE }
assignmentOperator:BinaryOperationType? = POWEQ 
    { result := BinaryOperationType.POWER }
assignmentOperator:BinaryOperationType? = REMEQ 
    { result := BinaryOperationType.REMAINDER }
assignmentOperator:BinaryOperationType? = ANDEQ 
    { result := BinaryOperationType.AND }
assignmentOperator:BinaryOperationType? = BITWISEANDEQ 
    { result := BinaryOperationType.BITWISE_AND }
assignmentOperator:BinaryOperationType? = OREQ 
    { result := BinaryOperationType.OR }
assignmentOperator:BinaryOperationType? = BITWISEOREQ 
    { result := BinaryOperationType.BITWISE_OR }
assignmentOperator:BinaryOperationType? = XOREQ 
    { result := BinaryOperationType.XOR }
assignmentOperator:BinaryOperationType? = BITWISEXOREQ 
    { result := BinaryOperationType.BITWISE_OR }
assignmentOperator:BinaryOperationType? = SHIFTLEFTEQ 
    { result := BinaryOperationType.SHIFT_LEFT }
assignmentOperator:BinaryOperationType? = SHIFTRIGHTEQ
    { result := BinaryOperationType.SHIFT_RIGHT }

assertStatement:ASTAssert = ASSERT expression
    { result := new ASTAssert(new Position(file, parserState.position), expression, null) }
assertStatement:ASTAssert = ASSERT test:expression COLON ^ msg:expression
    { result := new ASTAssert(new Position(file, parserState.position), test, msg) }

switchStatement:ASTSwitch = SWITCH expression LBRACE switchCases RBRACE ^
    { result := new ASTSwitch(new Position(file, parserState.position), expression, switchCases, null) }
switchStatement:ASTSwitch = SWITCH expression LBRACE switchCases defaultCase 
        RBRACE ^
    { 
        result := new ASTSwitch(new Position(file, parserState.position), expression, switchCases, 
                defaultCase) 
    }
switchCases:Array<ASTSwitchCase> = switchCases switchCase
    { 
        result := []
        result.addAll(switchCases)
        result.add(switchCase)
    }
switchCases:Array<ASTSwitchCase> = switchCase
    { result := [switchCase] }
switchCase:ASTSwitchCase = CASE ^ expressionList COLON statementOrBlock
    {
        result := new ASTSwitchCase(new Position(file, parserState.position), expressionList, 
                statementOrBlock)
    }
defaultCase:ASTStatement = DEFAULT ^ COLON statementOrBlock
    { result := statementOrBlock }

tryStatement:ASTStatement = TRY ^ statementOrBlock catchBlocks
    { result := new ASTTry(new Position(file, parserState.position), statementOrBlock, catchBlocks, null) }
catchBlocks:Array<ASTCatch> = catchBlocks catchBlock
    { 
        result := []
        result.addAll(catchBlocks)
        result.add(catchBlock)
    }
catchBlocks:Array<ASTCatch> = catchBlock
    { result := [catchBlock] }
catchBlock:ASTCatch = CATCH ^ IDENTIFIER typeDeclaration statementOrBlock
    { 
        result := new ASTCatch(new Position(file, parserState.position), IDENTIFIER, typeDeclaration, 
                statementOrBlock) 
    }

@block:ASTBlock = LBRACE statements RBRACE
    { result := new ASTBlock(new Position(file, parserState.position), statements) }
@block:ASTBlock = LBRACE RBRACE
    { result := new ASTBlock(new Position(file, parserState.position), []) }
statements:Array<ASTStatement> = statementList
    { result := statementList }
statements:Array<ASTStatement> = terminalStatement
    { result := [terminalStatement] }
statements:Array<ASTStatement> = statementList terminalStatement
    {
        result := []
        result.addAll(statementList)
        result.add(terminalStatement)
    }
statementList:Array<ASTStatement> = statementList statement
    {
        result := []
        result.addAll(statementList)
        result.add(statement)
    }
statementList:Array<ASTStatement> = statement
    { result := [statement] }

terminalStatement:ASTStatement = returnStatement 
    { result := returnStatement }
terminalStatement:ASTStatement = breakStatement 
    { result := breakStatement }
terminalStatement:ASTStatement = continueStatement 
    { result := continueStatement }
terminalStatement:ASTStatement = throwStatement 
    { result := throwStatement }
terminalStatement:ASTStatement = unreachableStatement 
    { result := unreachableStatement }

returnStatement:ASTReturn = RETURN_TEXT WS
    { result := new ASTReturn(new Position(file, parserState.position), null) }
returnStatement:ASTReturn = RETURN_TEXT WS_SAMELINE expression ^
    { result := new ASTReturn(new Position(file, parserState.position), expression) }

breakStatement:ASTBreak = BREAK_TEXT WS
    { result := new ASTBreak(new Position(file, parserState.position), null) }
breakStatement:ASTBreak = BREAK_TEXT WS_SAMELINE IDENTIFIER ^
    { result := new ASTBreak(new Position(file, parserState.position), IDENTIFIER) }

continueStatement:ASTContinue = CONTINUE_TEXT WS
    { result := new ASTContinue(new Position(file, parserState.position), null) }
continueStatement:ASTContinue = CONTINUE_TEXT WS_SAMELINE IDENTIFIER ^
    { result := new ASTContinue(new Position(file, parserState.position), IDENTIFIER) }

throwStatement:ASTThrow = THROW ^ expression
    { result := new ASTThrow(new Position(file, parserState.position), expression) }

unreachableStatement:ASTUnreachable = UNREACHABLE
    { result := new ASTUnreachable(new Position(file, parserState.position)) }

@type:ASTType = dottedName optionalQuestion
    { 
        result := new ASTClassType(new Position(file, parserState.position), dottedName, null,
                optionalQuestion) 
    }
@type:ASTType = dottedName genericParameters optionalQuestion
    { 
        result := new ASTClassType(new Position(file, parserState.position), dottedName,
                genericParameters, optionalQuestion) 
    }
@type:ASTType = LPAREN typeList RPAREN optionalQuestion
    { result := new ASTTupleType(new Position(file, parserState.position), typeList, optionalQuestion) }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS methodReturnType 
        optionalQuestion
    { 
        result := new ASTMethodType(new Position(file, parserState.position), optionalTypeList, 
                methodReturnType, true, true, false) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_METHOD methodReturnType 
        optionalQuestion
    { 
        result := new ASTMethodType(new Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, false, false) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_IMMUTABLE methodReturnType
        optionalQuestion
    { 
        result := new ASTMethodType(new Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, true, true) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_METHOD_IMMUTABLE 
        methodReturnType optionalQuestion
    { 
        result := new ASTMethodType(new Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, false, true) 
    }
genericParameters:Array<ASTType> = LT typeList GT
    { result := typeList }
typeList:Array<ASTType> = typeList COMMA type
    { 
        result := []
        result.addAll(typeList)
        result.add(type)
    }
typeList:Array<ASTType> = type
    { result := [type] }
optionalTypeList:Array<ASTType> = typeList
    { result := typeList }
optionalTypeList:Array<ASTType> =
    { result := [] }
optionalQuestion:Bit = QUESTION
    { result := true }
optionalQuestion:Bit = 
    { result := false }
methodReturnType:ASTType? = LPAREN RPAREN
    { result := null }
methodReturnType:ASTType? = LPAREN type RPAREN
    { result := type }

@expression:ASTExpression = orExpression
    { result := orExpression }
orExpression:ASTExpression = andExpression 
    { result := andExpression }
orExpression:ASTExpression = orExpression OR andExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.OR, orExpression,
                andExpression)
    }
andExpression:ASTExpression = comparisonExpression 
    { result := comparisonExpression }
andExpression:ASTExpression = andExpression AND comparisonExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.AND, 
                andExpression, comparisonExpression)
    }

comparisonExpression:ASTExpression = rangeExpression
    { result := rangeExpression }
comparisonExpression:ASTExpression = comparisonExpression EQ rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression NEQ rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.NOT_EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression IDENTITY 
        rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.IDENTITY, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression NIDENTITY 
        rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.NOT_IDENTITY, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression GT rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.GREATER_THAN, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression LT rangeExpression 
    { 
        result := new ASTBinaryExpression(BinaryOperationType.LESS_THAN, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression GTEQ rangeExpression 
    { 
        result := new ASTBinaryExpression(
                BinaryOperationType.GREATER_THAN_OR_EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression LTEQ rangeExpression 
    { 
        result := new ASTBinaryExpression(
                BinaryOperationType.LESS_THAN_OR_EQUAL, 
                comparisonExpression, rangeExpression)
    }

rangeExpression:ASTExpression = additiveExpression
    { result := additiveExpression }
rangeExpression:ASTExpression = DOTDOT
    { result := new ASTRangeExpression(new Position(file, parserState.position), null, null, null, false) }
rangeExpression:ASTExpression = ELLIPSIS
    { result := new ASTRangeExpression(new Position(file, parserState.position), null, null, null, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT
    { result := new ASTRangeExpression(new Position(file, parserState.position), l, null, null, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS
    { result := new ASTRangeExpression(new Position(file, parserState.position), l, null, null, true) }
rangeExpression:ASTExpression = DOTDOT r:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), null, r, null, false) }
rangeExpression:ASTExpression = ELLIPSIS r:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), null, r, null, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT r:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), l, r, null, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS 
        r:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), l, r, null, true) }
rangeExpression:ASTExpression = DOTDOT BY s:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), null, null, s, false) }
rangeExpression:ASTExpression = ELLIPSIS BY s:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), null, null, s, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT BY 
        s:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), l, null, s, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS BY 
        s:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), l, null, s, true) }
rangeExpression:ASTExpression = DOTDOT r:additiveExpression BY 
        s:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), null, r, s, false) }
rangeExpression:ASTExpression = ELLIPSIS r:additiveExpression BY 
        s:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), null, r, s, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT r:additiveExpression
        BY s:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), l, r, s, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS 
        r:additiveExpression BY s:additiveExpression
    { result := new ASTRangeExpression(new Position(file, parserState.position), l, r, s, true) }

additiveExpression:ASTExpression = multiplicativeExpression
    { result := multiplicativeExpression }
additiveExpression:ASTExpression = additiveExpression ADD 
        multiplicativeExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.ADD, 
                additiveExpression, multiplicativeExpression) 
    }
additiveExpression:ASTExpression = additiveExpression SUB 
        multiplicativeExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.SUBTRACT, 
                additiveExpression, multiplicativeExpression) 
    }
additiveExpression:ASTExpression = additiveExpression BITWISEOR
        multiplicativeExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.BITWISE_OR, 
                additiveExpression, multiplicativeExpression) 
    }

multiplicativeExpression:ASTExpression = unaryExpression
    { result := unaryExpression }
multiplicativeExpression:ASTExpression = multiplicativeExpression MUL
        unaryExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.MULTIPLY, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression DIV
        unaryExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.DIVIDE, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression INTDIV
        unaryExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.INT_DIVIDE, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression REM
        unaryExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.REMAINDER, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression SHIFTLEFT
        unaryExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.SHIFT_LEFT, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression SHIFTRIGHT
        unaryExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.SHIFT_RIGHT, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression BITWISEAND
        unaryExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.BITWISE_AND, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression BITWISEXOR
        unaryExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.BITWISE_XOR, 
                multiplicativeExpression, unaryExpression) 
    }

unaryExpression:ASTExpression = exponentExpression
    { result := exponentExpression }
unaryExpression:ASTExpression = SUB exponentExpression
    { 
        result := new ASTUnaryExpression(new Position(file, parserState.position), 
                UnaryOperationType.MINUS, exponentExpression) 
    }
unaryExpression:ASTExpression = NOT exponentExpression
    { 
        result := new ASTUnaryExpression(new Position(file, parserState.position), UnaryOperationType.NOT,
                exponentExpression) 
    }
unaryExpression:ASTExpression = BITWISENOT exponentExpression
    { 
        result := new ASTUnaryExpression(new Position(file, parserState.position), 
                UnaryOperationType.BITWISE_NOT, exponentExpression) 
    }

exponentExpression:ASTExpression = callExpression
    { result := callExpression }
exponentExpression:ASTExpression = callExpression POW exponentExpression
    { 
        result := new ASTBinaryExpression(BinaryOperationType.POWER, 
                callExpression, exponentExpression)
    }

callExpression:ASTExpression = term
    { result := term }
callExpression:ASTExpression = methodCall
    { result := methodCall }
callExpression:ASTExpression = callExpression LBRACKET expression RBRACKET
    { result := new ASTIndex(callExpression, expression) }
callExpression:ASTExpression = callExpression DOT IDENTIFIER
    { result := new ASTDotExpression(callExpression, IDENTIFIER) }
callExpression:ASTExpression = callExpression DOT IDENTIFIER
    { result := new ASTDotExpression(callExpression, IDENTIFIER) }
callExpression:ASTExpression = callExpression DOT CLASS
    { result := new ASTDotExpression(callExpression, "$class") }
callExpression:ASTExpression = callExpression DOT CONSTRUCTOR
    { result := new ASTDotExpression(callExpression, "constructor") }
callExpression:ASTExpression = callExpression INSTANCEOF typeExpression
    { 
        result := new ASTArrowExpression(ArrowOperationType.INSTANCE_OF,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression NINSTANCEOF typeExpression
    { 
        result := new ASTArrowExpression(ArrowOperationType.NOT_INSTANCE_OF,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression CAST typeExpression
    { 
        result := new ASTArrowExpression(ArrowOperationType.CAST,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression CONVERT typeExpression
    { 
        result := new ASTArrowExpression(ArrowOperationType.CONVERT,
                callExpression, typeExpression) 
    }
typeExpression:ASTType = type
    { result := type }
typeExpression:ASTType = LPAREN type RPAREN
    { result := type }

parameters:Array<ASTExpression> = LPAREN expressionList RPAREN
    { result := expressionList }
parameters:Array<ASTExpression> = LPAREN RPAREN
    { result := [] }
expressionList:Array<ASTExpression> = expressionList COMMA expression
    { 
        result := [] 
        result.addAll(expressionList)
        result.add(expression)
    }
expressionList:Array<ASTExpression> = expression
    { result := [expression] }

term:ASTExpression = IDENTIFIER
    { result := new ASTIdentifier(new Position(file, parserState.position), IDENTIFIER) }
term:ASTExpression = INTEGER
    { result := INTEGER }
term:ASTExpression = STRING
    { result := STRING }
term:ASTExpression = REAL
    { result := REAL }
term:ASTExpression = TRUE
    { result := new ASTBitLiteral(new Position(file, parserState.position), true) }
term:ASTExpression = FALSE
    { result := new ASTBitLiteral(new Position(file, parserState.position), false) }
term:ASTExpression = NULL
    { result := new ASTNullLiteral(new Position(file, parserState.position)) }
term:ASTExpression = SELF
    { result := new ASTSelf(new Position(file, parserState.position)) }
term:ASTExpression = SUPER
    { result := new ASTSuper(new Position(file, parserState.position)) }
term:ASTExpression = CLASS
    { result := new ASTDotExpression(new ASTSelf(new Position(file, parserState.position)), "$class") }
term:ASTExpression = LPAREN expressionList RPAREN
    {  
        if expressionList.length = 1
            result := expressionList[0]
        else
            result := new ASTTupleExpression(new Position(file, parserState.position), expressionList)
    }
term:ASTExpression = NEW type parameters
    { result := new ASTNew(new Position(file, parserState.position), type, parameters) }
term:ASTExpression = LBRACKET expressionList RBRACKET
    { result := new ASTArrayLiteral(new Position(file, parserState.position), expressionList) }
term:ASTExpression = LBRACKET RBRACKET
    { result := new ASTArrayLiteral(new Position(file, parserState.position), []) }
term:ASTExpression = lambda
    { result := lambda }
term:ASTExpression = CLASS LPAREN type RPAREN
    { result := new ASTClassLiteral(type) }
term:ASTExpression = methodValue
    { result := methodValue }
term:ASTExpression = plugin
    { result := plugin }
term:ASTExpression = '/' regex '/' WS
    { result := new ASTPlugin(new Position(file, parserState.position), "/" + regex + "/" ) }
term:ASTExpression = PRE LPAREN expression RPAREN
    { result := new ASTPre(new Position(file, parserState.position), expression) }
term:ASTExpression = ATRETURN
    { result := new ASTAtReturn(new Position(file, parserState.position)) }

plugin:ASTPlugin = '#' pluginChars '#' WS
    { result := new ASTPlugin(new Position(file, parserState.position), pluginChars) }
pluginChars:String = pluginChars char:[^#]
    { result := pluginChars + char }
pluginChars:String = char:[^#]
    { result := char }

regex:String = regexTerm
    { result := regexTerm }
regex:String = regexTerm '|' regex
    { result := regexTerm + "|" + regex }
regexTerm:String = regexFactor
    { result := regexFactor }
regexTerm:String = regexTerm regexFactor
    { result := regexTerm + regexFactor }
regexFactor:String = regexAtom
    { result := regexAtom }
regexFactor:String = regexAtom regexQuantifier
    { result := regexAtom + regexQuantifier }
regexAtom:String = regexCharacter
    { result := regexCharacter }
regexAtom:String = char:[.^$]
    { result := char }
regexAtom:String = '(' regex ')'
    { result := "(" + regex + ")" }
regexAtom:String = '(?' type:[:=!>] regex ')'
    { result := "(?" + type + regex + ")" }
regexAtom:String = '(?<' type:[!=] regex ')'
    { result := "(?<" + type + regex + ")" }
regexAtom:String = '[' regexCharClass ']'
    { result := "[" + regexCharClass + "]" }
regexAtom:String = '[^' regexCharClass ']'
    { result := "[^" + regexCharClass + "]" }
regexCharClass:String = regexRange
    { result := regexRange }
regexCharClass:String = regexCharClass regexRange
    { result := regexCharClass + regexRange }
regexRange:String = regexRangeCharacter
    { result := regexRangeCharacter }
regexRangeCharacter:String = char:[/|()[{^$*+?.]
    { result := char }
regexRangeCharacter:String = regexCharacter
    { result := regexCharacter }
regexRangeCharacter:String = begin:regexRangeCharacter '-' end:regexRangeCharacter
    { result := begin + "-" + end }
regexCharacter:String = char:[-!"#%&',:;<=>@_`~0-9A-Za-z]
    { result := char->>(String) }
regexCharacter:String = '\\' char:[-!"#%&',/:;<=>@_`~0-9A-Za-z\\|()[\]{}^$*+?.]
    { result := "\\" + char }
regexQuantifier:String = regexQuantifierBase
    { result := regexQuantifierBase }
regexQuantifier:String = regexQuantifierBase modifier:[+?]
    { result := regexQuantifierBase + modifier }
regexQuantifierBase:String = char:[*+?]
    { result := char->>(String) }
regexQuantifierBase:String = '{' regexInt '}'
    { result := "{" + regexInt + "}" }
regexQuantifierBase:String = '{' regexInt ',}'
    { result := "{" + regexInt + ",}" }
regexQuantifierBase:String = '{' min:regexInt ',' max:regexInt '}'
    { result := "{" + min + "," + max + "}" }
regexInt:String = DECIMAL_CHAR
    { result := DECIMAL_CHAR->>(String) }
regexInt:String = regexInt DECIMAL_CHAR
    { result := regexInt + DECIMAL_CHAR }

lambda:ASTExpression = lambdaParameters YIELDS expression
    { 
        result := new ASTLambdaExpression(new Position(file, parserState.position), lambdaParameters, 
                expression) 
    }
lambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER
    { 
        result := [new ASTTypedIdentifier(new Position(file, parserState.position), IDENTIFIER,
                null)]
    }
lambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER COLON type
    { 
        result := [new ASTTypedIdentifier(new Position(file, parserState.position), IDENTIFIER,
                type)]
    }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN RPAREN
    { result := [] }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN untypedLambdaParameters 
        RPAREN
    { result := untypedLambdaParameters }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN typedLambdaParameters RPAREN
    { result := typedLambdaParameters }
untypedLambdaParameters:Array<ASTTypedIdentifier> = untypedLambdaParameters 
        COMMA IDENTIFIER
    { 
        result := []
        result.addAll(untypedLambdaParameters)
        result.add(new ASTTypedIdentifier(new Position(file, parserState.position), IDENTIFIER,
                null))
    }
untypedLambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER
    {  
        result := [new ASTTypedIdentifier(new Position(file, parserState.position), IDENTIFIER,
                null)]
    }
typedLambdaParameters:Array<ASTTypedIdentifier> = typedLambdaParameters 
        COMMA IDENTIFIER COLON type
    { 
        result := []
        result.addAll(typedLambdaParameters)
        result.add(new ASTTypedIdentifier(new Position(file, parserState.position), IDENTIFIER,
                type))
    }
typedLambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER COLON type
    {  
        result := [new ASTTypedIdentifier(new Position(file, parserState.position), IDENTIFIER,
                type)]
    }

@methodValue:ASTMethodValue = METHOD formalParameters ^ optionalTypeDeclaration 
        block
    {
        result := new ASTMethodValue(new Position(file, parserState.position), MethodNodeType.METHOD, 
                formalParameters, optionalTypeDeclaration, block)
    }
@methodValue:ASTMethodValue = FUNCTION formalParameters ^ 
        optionalTypeDeclaration block
    {
        result := new ASTMethodValue(new Position(file, parserState.position), MethodNodeType.FUNCTION, 
                formalParameters, optionalTypeDeclaration, block)
    }


IDENTIFIER:String = identifierText WS
    {
        if ParserUtil.KEYWORDS.contains(identifierText)
            return Parser.DIE
        else
            result := identifierText 
    }
identifierText:String = identifierStart identifierChars ![A-Za-z_$0-9]
    { result := identifierStart + identifierChars }
identifierText:String = identifierStart ![A-Za-z_$0-9]
    { result := identifierStart }
identifierStart:String = char:[a-zA-Z_$]
    { result := char }
identifierChars:String = identifierChars identifierChar
    { result := identifierChars + identifierChar }
identifierChars:String = identifierChar
    { result := identifierChar }
identifierChar:String = char:[a-zA-Z_$0-9]
    { result := char }

INTEGER:ASTIntegerLiteral = DECIMAL_TEXT WS
    { result := new ASTIntegerLiteral(new Position(file, parserState.position), DECIMAL_TEXT->>(UInt64)) }
INTEGER:ASTIntegerLiteral = '0x' HEX_TEXT WS
    { result := new ASTIntegerLiteral(new Position(file, parserState.position), ParserUtil.parseInt(HEX_TEXT, 16)) }
INTEGER:ASTIntegerLiteral = '0b' BINARY_TEXT WS
    { 
        result := new ASTIntegerLiteral(new Position(file, parserState.position), ParserUtil.parseInt(BINARY_TEXT, 
                2)) 
    }
DECIMAL_TEXT:String = DECIMAL_CHARS ![A-Za-z_$0-9]
    { result := DECIMAL_CHARS }
DECIMAL_CHARS:String = DECIMAL_CHARS DECIMAL_CHAR
    { result := DECIMAL_CHARS + DECIMAL_CHAR }
DECIMAL_CHARS:String = DECIMAL_CHAR
    { result := DECIMAL_CHAR }
DECIMAL_CHAR:String = digit:[0-9]
    { result := digit }
HEX_TEXT:String = HEX_CHARS ![A-Za-z_$0-9]
    { result := HEX_CHARS }
HEX_CHARS:String = HEX_CHARS HEX_CHAR
    { result := HEX_CHARS + HEX_CHAR }
HEX_CHARS:String = HEX_CHAR
    { result := HEX_CHAR }
HEX_CHAR:String = digit:[0-9A-Fa-f]
    { result := digit }
BINARY_TEXT:String = BINARY_CHARS ![A-Za-z_$0-9]
    { result := BINARY_CHARS }
BINARY_CHARS:String = BINARY_CHARS BINARY_CHAR
    { result := BINARY_CHARS + BINARY_CHAR }
BINARY_CHARS:String = BINARY_CHAR
    { result := BINARY_CHAR }
BINARY_CHAR:String = digit:[01]
    { result := digit }

REAL:ASTRealLiteral = '.' DECIMAL_TEXT WS
    { 
        result := new ASTRealLiteral(new Position(file, parserState.position), ("." + 
            DECIMAL_TEXT)->>(Real64))
    }
REAL:ASTRealLiteral = '.' DECIMAL_CHARS EXPONENT WS
    { 
        result := new ASTRealLiteral(new Position(file, parserState.position), ("." + 
            DECIMAL_CHARS + EXPONENT)->>(Real64))
    }
REAL:ASTRealLiteral = d1:DECIMAL_CHARS '.' d2:DECIMAL_TEXT WS
    { result := new ASTRealLiteral(new Position(file, parserState.position), (d1 + "." + d2)->>(Real64)) }
REAL:ASTRealLiteral = DECIMAL_CHARS EXPONENT WS
    { 
        result := new ASTRealLiteral(new Position(file, parserState.position), (DECIMAL_CHARS + 
                EXPONENT)->>(Real64)) 
    }
REAL:ASTRealLiteral = d1:DECIMAL_CHARS '.' d2:DECIMAL_CHARS EXPONENT WS
    { 
        result := new ASTRealLiteral(new Position(file, parserState.position), (d1 + "." + d2 + 
                EXPONENT)->>(Real64))
    }
EXPONENT:String = [eE] DECIMAL_TEXT
    { result := "e" + DECIMAL_TEXT }
EXPONENT:String = [eE] sign:[+-] DECIMAL_TEXT
    { result := "e" + sign + DECIMAL_TEXT }

STRING:ASTStringLiteral = STRING_SINGLE ^ WS
    { result := STRING_SINGLE }
STRING:ASTStringLiteral = STRING_DOUBLE ^ WS
    { result := STRING_DOUBLE }
STRING_SINGLE:ASTStringLiteral = ['] STRING_CHARS_SINGLE [']
    { result := new ASTStringLiteral(new Position(file, parserState.position), STRING_CHARS_SINGLE) }
STRING_CHARS_SINGLE:String = STRING_CHARS_SINGLE STRING_CHAR_SINGLE
    { result := STRING_CHARS_SINGLE + STRING_CHAR_SINGLE }
STRING_CHARS_SINGLE:String = 
    { result := "" }
STRING_CHAR_SINGLE:String = char:[^'\\\n\r]
    { result := char }
STRING_CHAR_SINGLE:String = ESCAPE
    { result := ESCAPE }
STRING_DOUBLE:ASTStringLiteral = ["] STRING_CHARS_DOUBLE ["]
    { result := new ASTStringLiteral(new Position(file, parserState.position), STRING_CHARS_DOUBLE) }
STRING_CHARS_DOUBLE:String = STRING_CHARS_DOUBLE STRING_CHAR_DOUBLE
    { result := STRING_CHARS_DOUBLE + STRING_CHAR_DOUBLE }
STRING_CHARS_DOUBLE:String = 
    { result := "" }
STRING_CHAR_DOUBLE:String = char:[^"\\\n\r]
    { result := char }
STRING_CHAR_DOUBLE:String = ESCAPE
    { result := ESCAPE }
ESCAPE:String = '\\' char:[nrt'":\\]
    { result := '\\' + char }
ESCAPE:String = '\\{' formatExpression '}'
    { result := "\\{" + formatExpression + "}" }
@formatExpression:ASTFormatExpression = expression optionalField 
        optionalFormatString
    { 
        if optionalField != null {
            result := new ASTFormatExpression(expression, optionalFormatString,
                    optionalField.fillChar, optionalField.alignment, 
                    optionalField.width)
        }
        else {
            result := new ASTFormatExpression(expression, optionalFormatString,
                    null, null, null)
        }
    }
optionalField:FormatField? = COMMA optionalFillChar alignment DECIMAL_CHARS
    { 
        result := new FormatField(optionalFillChar, alignment, 
                DECIMAL_CHARS->>(Int)) 
    }
optionalField:FormatField? =
    { result := null }
optionalFillChar:Char = char:[^:\n\r\\]
    { result := char[0] }
optionalFillChar:Char = ESCAPE
    { result := ParserUtil.unescape(ESCAPE)[0] }
optionalFillChar:Char =
    { result := " " }
alignment:Alignment = '<'
    { result := Alignment.LEFT }
alignment:Alignment = '^'
    { result := Alignment.CENTER }
alignment:Alignment = '>'
    { result := Alignment.RIGHT }
formatString:String = formatString char:[^\\}]
    { result := formatString + char }
formatString:String = char:[^\\}]
    { result := char }
optionalFormatString:String? = COLON formatString
    { result := formatString }
optionalFormatString:String? =
    { result := null }

PACKAGE_TEXT = 'package' ![A-Za-z_$0-9]
PACKAGE = PACKAGE_TEXT WS
CLASS_TEXT = 'class' ![A-Za-z_$0-9]
CLASS = CLASS_TEXT WS
INTERFACE_TEXT = 'interface' ![A-Za-z_$0-9]
INTERFACE = INTERFACE_TEXT WS
ENUM_TEXT = 'enum' ![A-Za-z_$0-9]
ENUM = ENUM_TEXT WS
USES_TEXT = 'uses' ![A-Za-z_$0-9]
USES = USES_TEXT WS
AS_TEXT = 'as' ![A-Za-z_$0-9]
AS = AS_TEXT WS
METHOD_TEXT = 'method' ![A-Za-z_$0-9]
METHOD = METHOD_TEXT WS
FUNCTION_TEXT = 'function' ![A-Za-z_$0-9]
FUNCTION = FUNCTION_TEXT WS
CONSTRUCTOR_TEXT = 'constructor' ![A-Za-z_$0-9]
CONSTRUCTOR = CONSTRUCTOR_TEXT WS
VAR_TEXT = 'var' ![A-Za-z_$0-9]
VAR:VariableType = VAR_TEXT WS
    { result := VariableType.VAR }
DEF_TEXT = 'def' ![A-Za-z_$0-9]
DEF:VariableType = DEF_TEXT WS
    { result := VariableType.DEF }
CONSTANT_TET = 'constant' ![A-Za-z_$0-9]
CONSTANT:VariableType = 'constant' WS
    { result := VariableType.CONSTANT }
PROPERTY_TEXT = 'property' ![A-Za-z_$0-9]
PROPERTY:VariableType = PROPERTY_TEXT WS 
    { result := VariableType.PROPERTY }
PROTECTED_TEXT = '@protected' ![A-Za-z_$0-9]
PROTECTED = PROTECTED_TEXT WS
PRIVATE_TEXT = '@private' ![A-Za-z_$0-9]
PRIVATE = PRIVATE_TEXT WS
ATCLASS_TEXT = '@class' ![A-Za-z_$0-9]
ATCLASS = ATCLASS_TEXT WS
THREAD_TEXT = '@thread' ![A-Za-z_$0-9]
THREAD = THREAD_TEXT WS
ABSTRACT_TEXT = '@abstract' ![A-Za-z_$0-9]
ABSTRACT = ABSTRACT_TEXT WS
EXTERNAL_TEXT = '@external' ![A-Za-z_$0-9]
EXTERNAL = EXTERNAL_TEXT WS
OVERRIDE_TEXT = '@override' ![A-Za-z_$0-9]
OVERRIDE = OVERRIDE_TEXT WS
READONLY_TEXT = '@readonly' ![A-Za-z_$0-9]
READONLY = READONLY_TEXT WS
LIMITED_TEXT = '@limited' ![A-Za-z_$0-9]
LIMITED = LIMITED_TEXT WS
ATSELF_TEXT = '@self' ![A-Za-z_$0-9]
ATSELF = ATSELF_TEXT WS
SAFERETURN_TEXT = '@safeReturn' ![A-Za-z_$0-9]
SAFERETURN = SAFERETURN_TEXT WS
UNSAFEFUNCTION_TEXT = '@unsafeFunction' ![A-Za-z_$0-9]
UNSAFEFUNCTION = UNSAFEFUNCTION_TEXT WS
FINAL_TEXT = '@final' ![A-Za-z_$0-9]
FINAL = FINAL_TEXT WS
WRAPPER_METHOD = '@$wrapperMethod' WS
MATH_TEXT = '@math' ![A-Za-z_$0-9]
MATH = MATH_TEXT WS
OVERFLOW_TEXT = 'overflow' ![A-Za-z_$0-9]
OVERFLOW = OVERFLOW_TEXT WS
INVARIANT_TEXT = '@invariant' ![A-Za-z_$0-9]
INVARIANT = INVARIANT_TEXT WS
INSTANCE = '@$instance' WS
PRE_TEXT = '@pre' ![A-Za-z_$0-9]
PRE = PRE_TEXT WS
POST_TEXT = '@post' ![A-Za-z_$0-9]
POST = POST_TEXT WS
PRE_OR = '@preOr' WS
POST_AND = '@postAnd' WS
ATRETURN_TEXT = '@return' ![A-Za-z_$0-9]
ATRETURN = ATRETURN_TEXT WS
TRUE_TEXT = 'true' ![A-Za-z_$0-9]
TRUE = TRUE_TEXT WS
FALSE_TEXT = 'false' ![A-Za-z_$0-9]
FALSE = FALSE_TEXT WS
NULL_TEXT = 'null' ![A-Za-z_$0-9]
NULL = NULL_TEXT WS
SELF_TEXT = 'self' ![A-Za-z_$0-9]
SELF = SELF_TEXT WS
SUPER_TEXT = 'super' ![A-Za-z_$0-9]
SUPER = SUPER_TEXT WS
NEW_TEXT = 'new' ![A-Za-z_$0-9]
NEW = NEW_TEXT WS
BY_TEXT = 'by' ![A-Za-z_$0-9]
BY = BY_TEXT WS
FOR_TEXT = 'for' ![A-Za-z_$0-9]
FOR = FOR_TEXT WS
IN_TEXT = 'in' ![A-Za-z_$0-9]
IN = IN_TEXT WS
WHILE_TEXT = 'while' ![A-Za-z_$0-9]
WHILE = WHILE_TEXT WS
DO_TEXT = 'do' ![A-Za-z_$0-9]
DO = DO_TEXT WS
LOOP_TEXT = 'loop' ![A-Za-z_$0-9]
LOOP = LOOP_TEXT WS
IF_TEXT = 'if' ![A-Za-z_$0-9]
IF = IF_TEXT WS
ELSE_TEXT = 'else' ![A-Za-z_$0-9]
ELSE = ELSE_TEXT WS
SWITCH_TEXT = 'switch' ![A-Za-z_$0-9]
SWITCH = SWITCH_TEXT WS
CASE_TEXT = 'case' ![A-Za-z_$0-9]
CASE = CASE_TEXT WS
DEFAULT_TEXT = 'default' ![A-Za-z_$0-9]
DEFAULT = DEFAULT_TEXT WS
RETURN_TEXT = 'return' ![A-Za-z_$0-9]
CONTINUE_TEXT = 'continue' ![A-Za-z_$0-9]
BREAK_TEXT = 'break' ![A-Za-z_$0-9]
ASSERT_TEXT = 'assert' ![A-Za-z_$0-9]
ASSERT = ASSERT_TEXT WS
UNREACHABLE_TEXT = 'unreachable' ![A-Za-z_$0-9]
UNREACHABLE = UNREACHABLE_TEXT WS
TRY_TEXT = 'try' ![A-Za-z_$0-9]
TRY = TRY_TEXT WS
CATCH_TEXT = 'catch' ![A-Za-z_$0-9]
CATCH = CATCH_TEXT WS
THROW_TEXT = 'throw' ![A-Za-z_$0-9]
THROW = THROW_TEXT WS
COLON = ':' WS
LBRACKET = '[' WS
RBRACKET = ']' WS
LBRACE = '{' WS
RBRACE = '}' WS
LPAREN = '(' WS
RPAREN = ')' WS
ADD = '+' WS
SUB = '-' WS
MUL = '*' WS
DIV = '/' WS
REM = '%' WS
INTDIV = '//' WS
AND = '&' WS
OR = '|' WS
XOR = '~' WS
SHIFTLEFT = '<<' WS
SHIFTRIGHT = '>>' WS
BITWISEAND = '&&' WS
BITWISEOR = '||' WS
BITWISEXOR = '~~' WS
POW = '^' WS
EQ = '=' WS
NEQ = '!=' WS
LT = '<' WS
GT = '>' WS
LTEQ = '<=' WS
GTEQ = '>=' WS
IDENTITY = '==' WS
NIDENTITY = '!==' WS
NOT = '!' WS
BITWISENOT = '!!' WS
ASSIGNMENT = ':=' WS
ADDEQ = '+=' WS 
SUBEQ = '-=' WS
MULEQ = '*=' WS 
DIVEQ = '/=' WS 
INTDIVEQ = '//=' WS 
POWEQ = '^=' WS 
REMEQ = '%=' WS 
ANDEQ = '&=' WS 
BITWISEANDEQ = '&&=' WS 
OREQ = '|=' WS 
BITWISEOREQ = '||=' WS 
XOREQ = '~=' WS 
BITWISEXOREQ = '~~=' WS 
SHIFTLEFTEQ = '<<=' WS 
SHIFTRIGHTEQ = '>>=' WS 
CAST = '->' WS
INSTANCEOF = '-?>' WS
NINSTANCEOF = '-!>' WS
CONVERT = '->>' WS
COMMA  = ',' WS
STAR = '*' WS
DOT = '.' WS
DOTDOT = '..' WS
ELLIPSIS = '...' WS
QUESTION = '?' WS
YIELDS = '=>' WS
YIELDS_METHOD = '=&>' WS
YIELDS_IMMUTABLE = '=>*' WS
YIELDS_METHOD_IMMUTABLE = '=&>*' WS

WS = WS WS_CHAR
WS =
WS_CHAR = [ \r\n\t]
WS_CHAR = COMMENT
WS_SAMELINE = WS_SAMELINE WS_SAMELINE_CHAR
WS_SAMELINE =
WS_SAMELINE_CHAR = [ \t]
WS_SAMELINE_CHAR = SINGLE_LINE_BLOCK_COMMENT
COMMENT = LINE_COMMENT
COMMENT = BLOCK_COMMENT
LINE_COMMENT = '--' LINE_COMMENT_CHARS [\n]
LINE_COMMENT_CHARS = LINE_COMMENT_CHARS [^\n]
LINE_COMMENT_CHARS =
TRAILING_LINE_COMMENT = '--' LINE_COMMENT_CHARS
BLOCK_COMMENT = '-*' BLOCK_COMMENT_CHARS '*-'
BLOCK_COMMENT_CHARS = BLOCK_COMMENT_CHARS BLOCK_COMMENT_CHAR
BLOCK_COMMENT_CHARS =
BLOCK_COMMENT_CHAR = [^*]
BLOCK_COMMENT_CHAR = '*' [^-]
BLOCK_COMMENT_CHAR = BLOCK_COMMENT
SINGLE_LINE_BLOCK_COMMENT = '-*' SINGLE_LINE_BLOCK_COMMENT_CHARS '*-'
SINGLE_LINE_BLOCK_COMMENT_CHARS = SINGLE_LINE_BLOCK_COMMENT_CHARS 
        SINGLE_LINE_BLOCK_COMMENT_CHAR
SINGLE_LINE_BLOCK_COMMENT_CHARS =
SINGLE_LINE_BLOCK_COMMENT_CHAR = [^*\n\r]
SINGLE_LINE_BLOCK_COMMENT_CHAR = '*' [^-]
SINGLE_LINE_BLOCK_COMMENT_CHAR = SINGLE_LINE_BLOCK_COMMENT
DOCCOMMENT:String = '===' TRAILING_EQUALS DOCCOMMENT_CHARS '===' TRAILING_EQUALS
        WS
    { result := DOCCOMMENT_CHARS }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHARS DOCCOMMENT_CHAR
    { result := DOCCOMMENT_CHARS + DOCCOMMENT_CHAR }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHAR
    { result := DOCCOMMENT_CHAR }
DOCCOMMENT_CHAR:String = char:[^=]
    { result := char }
DOCCOMMENT_CHAR:String = '=' char:[^=]
    { result := "=" + char }
DOCCOMMENT_CHAR:String = '==' char:[^=]
    { result := "==" + char }
TRAILING_EQUALS = TRAILING_EQUALS_CHARS
TRAILING_EQUALS =
TRAILING_EQUALS_CHARS = TRAILING_EQUALS_CHARS '='
TRAILING_EQUALS_CHARS = '='
