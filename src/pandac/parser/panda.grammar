{
    package org.pandalanguage.pandac.parser
    
    uses org.pandalanguage.pandac.ast.Alignment
    uses org.pandalanguage.pandac.ast.ASTArrayLiteral
    uses org.pandalanguage.pandac.ast.ASTArrowExpression
    uses org.pandalanguage.pandac.ast.ArrowOperationType
    uses org.pandalanguage.pandac.ast.ASTAnnotation
    uses org.pandalanguage.pandac.ast.ASTAssert
    uses org.pandalanguage.pandac.ast.ASTAssignment
    uses org.pandalanguage.pandac.ast.ASTAtReturn
    uses org.pandalanguage.pandac.ast.ASTBinaryExpression
    uses org.pandalanguage.pandac.ast.ASTBitLiteral
    uses org.pandalanguage.pandac.ast.ASTBlock
    uses org.pandalanguage.pandac.ast.ASTBreak
    uses org.pandalanguage.pandac.ast.ASTCallExpression
    uses org.pandalanguage.pandac.ast.ASTCatch
    uses org.pandalanguage.pandac.ast.ASTClass
    uses org.pandalanguage.pandac.ast.ASTClassLiteral
    uses org.pandalanguage.pandac.ast.ASTClassType
    uses org.pandalanguage.pandac.ast.ASTContinue
    uses org.pandalanguage.pandac.ast.ASTDo
    uses org.pandalanguage.pandac.ast.ASTDotExpression
    uses org.pandalanguage.pandac.ast.ASTEnum
    uses org.pandalanguage.pandac.ast.ASTEnumValue
    uses org.pandalanguage.pandac.ast.ASTExpression
    uses org.pandalanguage.pandac.ast.ASTExpressionStatement
    uses org.pandalanguage.pandac.ast.ASTField
    uses org.pandalanguage.pandac.ast.ASTFile
    uses org.pandalanguage.pandac.ast.ASTFor
    uses org.pandalanguage.pandac.ast.ASTFormatExpression
    uses org.pandalanguage.pandac.ast.ASTIdentifier
    uses org.pandalanguage.pandac.ast.ASTIf
    uses org.pandalanguage.pandac.ast.ASTIndex
    uses org.pandalanguage.pandac.ast.ASTInstanceDeclaration
    uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
    uses org.pandalanguage.pandac.ast.ASTInvariant
    uses org.pandalanguage.pandac.ast.ASTLambdaExpression
    uses org.pandalanguage.pandac.ast.ASTLoop
    uses org.pandalanguage.pandac.ast.ASTMethod
    uses org.pandalanguage.pandac.ast.ASTMethodType
    uses org.pandalanguage.pandac.ast.ASTMethodValue
    uses org.pandalanguage.pandac.ast.ASTNode
    uses org.pandalanguage.pandac.ast.ASTNullLiteral
    uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
    uses org.pandalanguage.pandac.ast.ASTParameter
    uses org.pandalanguage.pandac.ast.ASTPostcondition
    uses org.pandalanguage.pandac.ast.ASTPre
    uses org.pandalanguage.pandac.ast.ASTPrecondition
    uses org.pandalanguage.pandac.ast.ASTRangeExpression
    uses org.pandalanguage.pandac.ast.ASTRealLiteral
    uses org.pandalanguage.pandac.ast.ASTRegex
    uses org.pandalanguage.pandac.ast.ASTReturn
    uses org.pandalanguage.pandac.ast.ASTSelf
    uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
    uses org.pandalanguage.pandac.ast.ASTStatement
    uses org.pandalanguage.pandac.ast.ASTStringLiteral
    uses org.pandalanguage.pandac.ast.ASTSuper
    uses org.pandalanguage.pandac.ast.ASTSwitch
    uses org.pandalanguage.pandac.ast.ASTSwitchCase
    uses org.pandalanguage.pandac.ast.ASTThrow
    uses org.pandalanguage.pandac.ast.ASTTry
    uses org.pandalanguage.pandac.ast.ASTTupleExpression
    uses org.pandalanguage.pandac.ast.ASTTupleType
    uses org.pandalanguage.pandac.ast.ASTType
    uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
    uses org.pandalanguage.pandac.ast.ASTUnaryExpression
    uses org.pandalanguage.pandac.ast.ASTUnreachable
    uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
    uses org.pandalanguage.pandac.ast.ASTVarDeclaration
    uses org.pandalanguage.pandac.ast.ASTWhile
    uses org.pandalanguage.pandac.tree.BinaryOperationType
    uses org.pandalanguage.pandac.tree.MethodNode
    uses org.pandalanguage.pandac.tree.MethodNodeType
    uses org.pandalanguage.pandac.tree.Position
    uses org.pandalanguage.pandac.tree.UnaryOperationType
    uses org.pandalanguage.pandac.tree.VariableType

    class FormatField {
        def fillChar:Char
        def alignment:Alignment
        def width:Int

        init(fillChar:Char, alignment:Alignment, width:Int) {
            self.fillChar := fillChar
            self.alignment := alignment
            self.width := width
        }
    }

    class ParserUtil {
        constant KEYWORDS := HashSet<String>(["package", "uses", "as", 
                    "class", "method", "function", "constructor", "var", "def", 
                    "property", "constant", "do", "while", "for", "by", "loop", 
                    "if", "else", "switch", "case", "default", "self", "true",
                     "false", "enum", "return", "break", "continue", "null", 
                     "assert", "unreachable", "try", "catch", "finally", 
                     "throw", "super"])

        @class
        @pre(base >= 2 & base <= 36)
        function parseInt(s:String, base:UInt):UInt64? {
            var result:UInt64 := 0
            constant DIGITS := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            constant DIGITS_LOWER := "0123456789abcdefghijklmnopqrstuvwxyz"
            for i in 0 .. s.length {
                var digit := DIGITS.indexOf(s[i])
                if digit = null {
                    digit := DIGITS_LOWER.indexOf(s[i])
                }
                if digit = null | digit >= base {
                    return null
                }
                result := result * base + digit->(UInt64)
            }
            return result
        }

        @class
        function unescape(text:String):String {
            def result := MutableString()
            var i := 0
            while i < result.length {
                var c := text[i]
                i += 1
                if c = "\\" {
                    c := text[i]
                    switch c {
                        case "n": result.append("\n")
                        case "r": result.append("\r")
                        case "t": result.append("\t")
                        default: result.append(c)
                    }
                    i += 1
                }
                else
                    result.append(c)
            }
            return result->>String
        }

        @class
        function isExternal(file:File):Bit {
            return file.name.endsWith(".plink")
        }
    }
}

@file:Array<ASTNode> = WS bodyEntries optionalTrailingLineComment
    { result := bodyEntries }
@file:Array<ASTNode> = WS optionalTrailingLineComment
    { result := [] }
bodyEntries:Array<ASTNode> = bodyEntries bodyEntry
    { 
        result := [] 
        result.addAll(bodyEntries)
        result.add(bodyEntry)
    }
bodyEntries:Array<ASTNode> = bodyEntry
    { result := [bodyEntry] }
optionalTrailingLineComment = TRAILING_LINE_COMMENT
optionalTrailingLineComment =

bodyEntry:ASTNode = usesStatement 
    { result := usesStatement }
bodyEntry:ASTNode = classDeclaration 
    { result := classDeclaration }
bodyEntry:ASTNode = interfaceDeclaration 
    { result := interfaceDeclaration }
bodyEntry:ASTNode = enumDeclaration
    { result := enumDeclaration }
bodyEntry:ASTNode = methodDeclaration
    { result := methodDeclaration }
bodyEntry:ASTNode = functionDeclaration
    { result := functionDeclaration }
bodyEntry:ASTNode = packageDeclaration 
    { result := packageDeclaration }
bodyEntry:ASTNode = instanceDeclaration 
    { result := instanceDeclaration }
bodyEntry:ASTNode = statement
    { result := statement }

packageDeclaration:ASTPackageDeclaration = PACKAGE ^ dottedName
    { result := ASTPackageDeclaration(Position(file, parserState.position), dottedName) }
dottedName:String = dottedName DOT IDENTIFIER
    { result := dottedName + "." + IDENTIFIER }
dottedName:String = IDENTIFIER
    { result := IDENTIFIER }
usesStatement:ASTUsesDeclaration = USES usesName
    { result := ASTUsesDeclaration(Position(file, parserState.position), usesName, null) }
usesStatement:ASTUsesDeclaration = USES id:dottedName AS ^ alias:dottedName
    { result := ASTUsesDeclaration(Position(file, parserState.position), id, alias) }
usesName:String = dottedName DOT STAR
    { result := dottedName + ".*" }
usesName:String = dottedName
    { result := dottedName }
instanceDeclaration:ASTInstanceDeclaration = INSTANCE ^ type
    { result := ASTInstanceDeclaration(Position(file, parserState.position), type) }

classDeclaration:ASTClass = optionalDoccomment optionalAnnotations CLASS 
        IDENTIFIER optionalGenericsDeclaration optionalTypeDeclaration
        optionalInterfaces LBRACE ^ classMembers RBRACE
    { 
        def methods := Array<ASTMethod>()
        def fields := Array<ASTField>()
        def invariants := Array<ASTInvariant>()
        for m in classMembers {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := ASTClass(Position(file, parserState.position), IDENTIFIER, false, 
                optionalDoccomment, optionalAnnotations, 
                optionalTypeDeclaration, optionalInterfaces, 
                optionalGenericsDeclaration, methods, fields, invariants, 
                ParserUtil.isExternal(file))
    }
interfaceDeclaration:ASTClass = optionalDoccomment optionalAnnotations 
        INTERFACE ^ IDENTIFIER optionalGenericsDeclaration 
        optionalTypeDeclarations LBRACE classMembers RBRACE
    { 
        def methods := Array<ASTMethod>()
        def fields := Array<ASTField>()
        def invariants := Array<ASTInvariant>()
        for m in classMembers {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := ASTClass(Position(file, parserState.position), IDENTIFIER, true, 
                optionalDoccomment, optionalAnnotations, 
                null, optionalTypeDeclarations, optionalGenericsDeclaration, 
                methods, fields, invariants, ParserUtil.isExternal(file))
    }
enumDeclaration:ASTEnum = optionalDoccomment optionalAnnotations ENUM ^ 
        IDENTIFIER LBRACE enumValues RBRACE
    {
        result := ASTEnum(Position(file, parserState.position), IDENTIFIER, optionalDoccomment, 
                optionalAnnotations, enumValues, ParserUtil.isExternal(file))
    }
enumValues:Array<ASTEnumValue> = enumValues COMMA enumValue
    {
        result := []
        result.addAll(enumValues)
        result.add(enumValue)
    }
enumValues:Array<ASTEnumValue> = enumValue
    { result := [enumValue] }
enumValue:ASTEnumValue = optionalDoccomment IDENTIFIER
    { 
        result := ASTEnumValue(Position(file, parserState.position), IDENTIFIER, 
                optionalDoccomment) 
    }
optionalDoccomment:String? = DOCCOMMENT
    { result := DOCCOMMENT }
optionalDoccomment:String? =
    { result := null }
optionalAnnotations:Array<ASTAnnotation>? = annotations
    { result := annotations }
optionalAnnotations:Array<ASTAnnotation>? =
    { result := null }
optionalTypeDeclarations:Array<ASTType>? = COLON typeList
    { result := typeList }
optionalTypeDeclarations:Array<ASTType>? =
    { result := null }
optionalTypeDeclaration:ASTType? = typeDeclaration 
    { result := typeDeclaration }
optionalTypeDeclaration:ASTType? =
    { result := null }
typeDeclaration:ASTType = COLON type
    { result := type }
optionalGenericsDeclaration:Array<ASTTypedIdentifier>? = LT genericsDeclarations 
        GT
    { result := genericsDeclarations }
optionalGenericsDeclaration:Array<ASTTypedIdentifier>? =
    { result := null }
genericsDeclarations:Array<ASTTypedIdentifier> = genericsDeclarations COMMA
        optionallyTypedIdentifier
    { 
        result := []
        result.addAll(genericsDeclarations)
        result.add(optionallyTypedIdentifier)
    }
genericsDeclarations:Array<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := [optionallyTypedIdentifier] }
optionalInterfaces:Array<ASTType>? = LPAREN typeList RPAREN
    { result := typeList }
optionalInterfaces:Array<ASTType>? =
    { result := null }
classMembers:Array<ASTNode> = classMemberList
    { result := classMemberList }
classMembers:Array<ASTNode> =
    { result := [] }
classMemberList:Array<ASTNode> = classMemberList classMember
    { 
        result := []
        result.addAll(classMemberList)
        result.add(classMember)
    }
classMemberList:Array<ASTNode> =
    { result := [] }
classMember:ASTNode = invariant 
    { result := invariant }
classMember:ASTNode = methodDeclaration 
    { result := methodDeclaration }
classMember:ASTNode = functionDeclaration 
    { result := functionDeclaration }
classMember:ASTNode = constructorDeclaration 
    { result := constructorDeclaration }
classMember:ASTNode = fieldDeclaration 
    { result := fieldDeclaration }
annotations:Array<ASTAnnotation> = annotations annotation
    {
        result := []
        result.addAll(annotations)
        result.add(annotation)
    }
annotations:Array<ASTAnnotation> = annotation
    { result := [annotation] }
annotation:ASTAnnotation = PROTECTED 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "protected") }
annotation:ASTAnnotation = PRIVATE 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "private") }
annotation:ASTAnnotation = ATCLASS 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "class") }
annotation:ASTAnnotation = THREAD 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "thread") }
annotation:ASTAnnotation = ABSTRACT 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "abstract") }
annotation:ASTAnnotation = EXTERNAL 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "external") }
annotation:ASTAnnotation = OVERRIDE 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "override") }
annotation:ASTAnnotation = READONLY 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "readonly") }
annotation:ASTAnnotation = LIMITED 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "limited") }
annotation:ASTAnnotation = ATSELF 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "self") }
annotation:ASTAnnotation = SAFERETURN 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "safeReturn") }
annotation:ASTAnnotation = UNSAFEFUNCTION 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "unsafeFunction") }
annotation:ASTAnnotation = FINAL 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "final") }
annotation:ASTAnnotation = WRAPPER_METHOD 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "$wrapperMethod") }
annotation:ASTAnnotation = MATH LPAREN OVERFLOW RPAREN
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "math(overflow)") }
annotation:ASTAnnotation = PRE LPAREN expression RPAREN
    { result := ASTPrecondition(Position(file, parserState.position), expression, false) }
annotation:ASTAnnotation = PRE_OR LPAREN expression RPAREN
    { result := ASTPrecondition(Position(file, parserState.position), expression, true) }
postcondition:ASTPostcondition = POST LPAREN expression RPAREN
    { result := ASTPostcondition(Position(file, parserState.position), expression, false) }
postcondition:ASTPostcondition = POST_AND LPAREN expression RPAREN
    { result := ASTPostcondition(Position(file, parserState.position), expression, true) }
postconditions:Array<ASTPostcondition> = postconditions postcondition
    {
        result := []
        result.addAll(postconditions)
        result.add(postcondition)
    }
postconditions:Array<ASTPostcondition> = postcondition
    { result := [postcondition] }
optionalPostconditions:Array<ASTPostcondition>? = postconditions
    { result := postconditions }
optionalPostconditions:Array<ASTPostcondition>? = 
    { result := null }

invariant:ASTInvariant = INVARIANT LPAREN expression RPAREN
    { result := ASTInvariant(Position(file, parserState.position), expression) }

methodDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        METHOD ^ methodName formalParameters optionalTypeDeclaration 
        optionalBlock optionalPostconditions
    {
        result := ASTMethod(Position(file, parserState.position), methodName, 
                MethodNodeType.METHOD, optionalDoccomment, 
                optionalAnnotations, formalParameters, optionalTypeDeclaration, 
                optionalBlock, optionalPostconditions)
    }
methodName:String = IDENTIFIER 
    { result := IDENTIFIER }
methodName:String = specialMethodName
    { result := specialMethodName }
specialMethodName:String = IDENTIFIER ASSIGNMENT
    { result := IDENTIFIER + ":=" }
specialMethodName:String = CONVERT
    { result := "->>" }
specialMethodName:String = SHIFTLEFT
    { result := "<<" }
specialMethodName:String = SHIFTRIGHT
    { result := ">>" }
specialMethodName:String = ADD
    { result := "+" }
specialMethodName:String = SUB
    { result := "-" }
specialMethodName:String = MUL
    { result := "*" }
specialMethodName:String = DIV
    { result := "/" }
specialMethodName:String = INTDIV
    { result := "//" }
specialMethodName:String = REM
    { result := "%" }
specialMethodName:String = AND
    { result := "&" }
specialMethodName:String = OR
    { result := "|" }
specialMethodName:String = XOR
    { result := "~" }
specialMethodName:String = BITWISEAND
    { result := "&&" }
specialMethodName:String = BITWISEOR
    { result := "||" }
specialMethodName:String = BITWISEXOR
    { result := "~~" }
specialMethodName:String = POW
    { result := "^" }
specialMethodName:String = NOT
    { result := "!" }
specialMethodName:String = BITWISENOT
    { result := "!!" }
specialMethodName:String = '[]' WS
    { result := "[]" }
specialMethodName:String = '[..]' WS
    { result := "[..]" }
specialMethodName:String = '[...]' WS
    { result := "[...]" }
specialMethodName:String = '[]:=' WS
    { result := "[]:=" }
specialMethodName:String = '[..]:=' WS
    { result := "[..]:=" }
specialMethodName:String = '[...]:=' WS
    { result := "[...]:=" }
specialMethodName:String = EQ
    { result := "=" }
specialMethodName:String = GT
    { result := ">" }
specialMethodName:String = LT
    { result := "<" }
specialMethodName:String = GTEQ
    { result := ">=" }
specialMethodName:String = LTEQ
    { result := "<=" }
formalParameters:Array<ASTParameter> = LPAREN parameterList RPAREN
    { result := parameterList }
formalParameters:Array<ASTParameter> = LPAREN RPAREN
    { result := [] }
parameterList:Array<ASTParameter> = parameterList COMMA parameter
    {
        result := []
        result.addAll(parameterList)
        result.add(parameter)
    }
parameterList:Array<ASTParameter> = parameter
    { result := [parameter] }
parameter:ASTParameter = optionalVar IDENTIFIER COLON type 
        optionalEllipsis
    { 
        result := ASTParameter(Position(file, parserState.position), 
                IDENTIFIER, type, optionalVar, optionalEllipsis)
    }
optionalVar:Bit = VAR
    { result := true }
optionalVar:Bit =
    { result := false }
optionalEllipsis:Bit = ELLIPSIS
    { result := true }
optionalEllipsis:Bit =
    { result := false }
optionalBlock:ASTBlock? = block
    { result := block }
optionalBlock:ASTBlock? = 
    { result := null }

@anyMethod:ASTMethod = functionDeclaration
    { result := functionDeclaration }
@anyMethod:ASTMethod = methodDeclaration
    { result := methodDeclaration }
@anyMethod:ASTMethod = constructorDeclaration
    { result := constructorDeclaration }

functionDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        FUNCTION ^ methodName formalParameters typeDeclaration optionalBlock
        optionalPostconditions
    {
        result := ASTMethod(Position(file, parserState.position), 
                methodName, MethodNodeType.FUNCTION, optionalDoccomment, 
                optionalAnnotations, formalParameters, typeDeclaration, 
                optionalBlock, optionalPostconditions)
    }

constructorDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        CONSTRUCTOR ^ formalParameters optionalBlock optionalPostconditions
    {
        result := ASTMethod(Position(file, parserState.position), 
                MethodNode.CONSTRUCTOR_NAME, 
                MethodNodeType.CONSTRUCTOR, optionalDoccomment, 
                optionalAnnotations, formalParameters, null, 
                optionalBlock, optionalPostconditions)
    }
constructorDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        INIT ^ formalParameters optionalBlock optionalPostconditions
    {
        result := ASTMethod(Position(file, parserState.position), 
                MethodNode.CONSTRUCTOR_NAME, 
                MethodNodeType.CONSTRUCTOR, optionalDoccomment, 
                optionalAnnotations, formalParameters, null, 
                optionalBlock, optionalPostconditions)
    }

fieldDeclaration:ASTField = optionalDoccomment optionalAnnotations 
        varDeclaration
    { 
        result := ASTField(optionalDoccomment, optionalAnnotations, 
                varDeclaration) 
    }

@statement:ASTStatement = varDeclaration
    { result := varDeclaration }
@statement:ASTStatement = ifStatement
    { result := ifStatement }
@statement:ASTStatement = forLoop 
    { result := forLoop }
@statement:ASTStatement = whileLoop 
    { result := whileLoop }
@statement:ASTStatement = doLoop 
    { result := doLoop }
@statement:ASTStatement = loopLoop
    { result := loopLoop }
@statement:ASTStatement = methodCall
    { result := ASTExpressionStatement(methodCall) }
@statement:ASTStatement = assignment
    { result := assignment }
@statement:ASTStatement = assertStatement 
    { result := assertStatement }
@statement:ASTStatement = switchStatement
    { result := switchStatement }
@statement:ASTStatement = tryStatement 
    { result := tryStatement }
@statement:ASTStatement = block
    { result := block }

statementOrBlock:ASTStatement = statement 
    { result := statement }
statementOrBlock:ASTStatement = terminalStatement 
    { result := terminalStatement }

varDeclaration:ASTVarDeclaration = VAR varDeclarations
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.VAR, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = DEF varDeclarations
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.DEF, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = PROPERTY varDeclarations
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.PROPERTY, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = CONSTANT varDeclarations
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.CONSTANT, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = VAR varDeclarations ASSIGNMENT expression
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.VAR, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = DEF varDeclarations ASSIGNMENT expression
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.DEF, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = PROPERTY varDeclarations ASSIGNMENT expression
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.PROPERTY, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = CONSTANT varDeclarations ASSIGNMENT expression
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.CONSTANT, 
                varDeclarations, expression) 
    }
varDeclarations:Array<ASTTypedIdentifier> = varDeclarations COMMA 
        optionallyTypedIdentifier
    { 
        result := [] 
        result.addAll(varDeclarations)
        result.add(optionallyTypedIdentifier)
    }
varDeclarations:Array<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := [optionallyTypedIdentifier] }
optionallyTypedIdentifier:ASTTypedIdentifier = IDENTIFIER
    { 
        result := ASTTypedIdentifier(
                Position(file, parserState.position), IDENTIFIER, null) 
    }
optionallyTypedIdentifier:ASTTypedIdentifier = IDENTIFIER COLON type
    { 
        result := ASTTypedIdentifier(
                Position(file, parserState.position), IDENTIFIER, type) 
    }

ifStatement:ASTIf = IF ^ expression statementOrBlock optionalElse
    { 
        result := ASTIf(Position(file, parserState.position), 
                expression, statementOrBlock, optionalElse) 
    }
optionalElse:ASTStatement? = ELSE statementOrBlock
    { result := statementOrBlock }
optionalElse:ASTStatement? =
    { result := null }

forLoop:ASTFor = optionalLabel FOR ^ forTarget IN ^ expression 
        statementOrBlock
    { 
        result := ASTFor(Position(file, parserState.position), 
                optionalLabel, forTarget, expression, statementOrBlock) 
    }
optionalLabel:String? = IDENTIFIER COLON
    { result := IDENTIFIER }
optionalLabel:String? =
    { result := null }
forTarget:ListView<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := [optionallyTypedIdentifier] }
forTarget:ListView<ASTTypedIdentifier> = LPAREN varDeclarations RPAREN
    { result := varDeclarations }

whileLoop:ASTWhile = optionalLabel WHILE ^ expression statementOrBlock
    { 
        result := ASTWhile(Position(file, parserState.position), optionalLabel, expression, 
                statementOrBlock)
    }

doLoop:ASTDo = optionalLabel DO ^ statementOrBlock WHILE expression
    { 
        result := ASTDo(Position(file, parserState.position), optionalLabel, expression, 
                statementOrBlock)
    }

loopLoop:ASTLoop = optionalLabel LOOP ^ statementOrBlock
    { result := ASTLoop(Position(file, parserState.position), optionalLabel, statementOrBlock) }

methodCall:ASTExpression = callExpression parameters
    { result := ASTCallExpression(callExpression, parameters) }
methodCall:ASTExpression = CONSTRUCTOR parameters
    { 
        result := ASTCallExpression(
                ASTIdentifier(Position(file, parserState.position), 
                    "constructor"), 
                parameters) 
    }
assignment:ASTStatement = expressionList assignmentOperator expression
    { 
        result := ASTAssignment(expressionList, assignmentOperator, 
                expression) 
    }
assignmentOperator:BinaryOperationType? = ASSIGNMENT
    { result := null }
assignmentOperator:BinaryOperationType? = ADDEQ
    { result := BinaryOperationType.ADD }
assignmentOperator:BinaryOperationType? = SUBEQ
    { result := BinaryOperationType.SUBTRACT }
assignmentOperator:BinaryOperationType? = MULEQ 
    { result := BinaryOperationType.MULTIPLY }
assignmentOperator:BinaryOperationType? = DIVEQ 
    { result := BinaryOperationType.DIVIDE }
assignmentOperator:BinaryOperationType? = INTDIVEQ 
    { result := BinaryOperationType.INT_DIVIDE }
assignmentOperator:BinaryOperationType? = POWEQ 
    { result := BinaryOperationType.POWER }
assignmentOperator:BinaryOperationType? = REMEQ 
    { result := BinaryOperationType.REMAINDER }
assignmentOperator:BinaryOperationType? = ANDEQ 
    { result := BinaryOperationType.AND }
assignmentOperator:BinaryOperationType? = BITWISEANDEQ 
    { result := BinaryOperationType.BITWISE_AND }
assignmentOperator:BinaryOperationType? = OREQ 
    { result := BinaryOperationType.OR }
assignmentOperator:BinaryOperationType? = BITWISEOREQ 
    { result := BinaryOperationType.BITWISE_OR }
assignmentOperator:BinaryOperationType? = XOREQ 
    { result := BinaryOperationType.XOR }
assignmentOperator:BinaryOperationType? = BITWISEXOREQ 
    { result := BinaryOperationType.BITWISE_OR }
assignmentOperator:BinaryOperationType? = SHIFTLEFTEQ 
    { result := BinaryOperationType.SHIFT_LEFT }
assignmentOperator:BinaryOperationType? = SHIFTRIGHTEQ
    { result := BinaryOperationType.SHIFT_RIGHT }

assertStatement:ASTAssert = ASSERT expression
    { result := ASTAssert(Position(file, parserState.position), expression, null) }
assertStatement:ASTAssert = ASSERT test:expression COLON ^ msg:expression
    { result := ASTAssert(Position(file, parserState.position), test, msg) }

switchStatement:ASTSwitch = SWITCH expression LBRACE switchCases RBRACE ^
    { result := ASTSwitch(Position(file, parserState.position), expression, switchCases, null) }
switchStatement:ASTSwitch = SWITCH expression LBRACE switchCases defaultCase 
        RBRACE ^
    { 
        result := ASTSwitch(Position(file, parserState.position), expression, switchCases, 
                defaultCase) 
    }
switchCases:Array<ASTSwitchCase> = switchCases switchCase
    { 
        result := []
        result.addAll(switchCases)
        result.add(switchCase)
    }
switchCases:Array<ASTSwitchCase> = switchCase
    { result := [switchCase] }
switchCase:ASTSwitchCase = CASE ^ expressionList COLON statementOrBlock
    {
        result := ASTSwitchCase(Position(file, parserState.position), expressionList, 
                statementOrBlock)
    }
defaultCase:ASTStatement = DEFAULT ^ COLON statementOrBlock
    { result := statementOrBlock }

tryStatement:ASTStatement = TRY ^ statementOrBlock catchBlocks
    { result := ASTTry(Position(file, parserState.position), statementOrBlock, catchBlocks, null) }
catchBlocks:Array<ASTCatch> = catchBlocks catchBlock
    { 
        result := []
        result.addAll(catchBlocks)
        result.add(catchBlock)
    }
catchBlocks:Array<ASTCatch> = catchBlock
    { result := [catchBlock] }
catchBlock:ASTCatch = CATCH ^ IDENTIFIER typeDeclaration statementOrBlock
    { 
        result := ASTCatch(Position(file, parserState.position), IDENTIFIER, typeDeclaration, 
                statementOrBlock) 
    }

@block:ASTBlock = LBRACE statements RBRACE
    { result := ASTBlock(Position(file, parserState.position), statements) }
@block:ASTBlock = LBRACE RBRACE
    { result := ASTBlock(Position(file, parserState.position), []) }
statements:Array<ASTStatement> = statementList
    { result := statementList }
statements:Array<ASTStatement> = terminalStatement
    { result := [terminalStatement] }
statements:Array<ASTStatement> = statementList terminalStatement
    {
        result := []
        result.addAll(statementList)
        result.add(terminalStatement)
    }
statementList:Array<ASTStatement> = statementList statement
    {
        result := []
        result.addAll(statementList)
        result.add(statement)
    }
statementList:Array<ASTStatement> = statement
    { result := [statement] }

terminalStatement:ASTStatement = returnStatement 
    { result := returnStatement }
terminalStatement:ASTStatement = breakStatement 
    { result := breakStatement }
terminalStatement:ASTStatement = continueStatement 
    { result := continueStatement }
terminalStatement:ASTStatement = throwStatement 
    { result := throwStatement }
terminalStatement:ASTStatement = unreachableStatement 
    { result := unreachableStatement }

returnStatement:ASTReturn = RETURN_TEXT WS
    { result := ASTReturn(Position(file, parserState.position), null) }
returnStatement:ASTReturn = RETURN_TEXT WS_SAMELINE expression ^
    { result := ASTReturn(Position(file, parserState.position), expression) }

breakStatement:ASTBreak = BREAK_TEXT WS
    { result := ASTBreak(Position(file, parserState.position), null) }
breakStatement:ASTBreak = BREAK_TEXT WS_SAMELINE IDENTIFIER ^
    { result := ASTBreak(Position(file, parserState.position), IDENTIFIER) }

continueStatement:ASTContinue = CONTINUE_TEXT WS
    { result := ASTContinue(Position(file, parserState.position), null) }
continueStatement:ASTContinue = CONTINUE_TEXT WS_SAMELINE IDENTIFIER ^
    { result := ASTContinue(Position(file, parserState.position), IDENTIFIER) }

throwStatement:ASTThrow = THROW ^ expression
    { result := ASTThrow(Position(file, parserState.position), expression) }

unreachableStatement:ASTUnreachable = UNREACHABLE
    { result := ASTUnreachable(Position(file, parserState.position)) }

@type:ASTType = dottedName optionalQuestion
    { 
        result := ASTClassType(Position(file, parserState.position), dottedName, null,
                optionalQuestion) 
    }
@type:ASTType = dottedName genericParameters optionalQuestion
    { 
        result := ASTClassType(Position(file, parserState.position), dottedName,
                genericParameters, optionalQuestion) 
    }
@type:ASTType = LPAREN typeList RPAREN optionalQuestion
    { result := ASTTupleType(Position(file, parserState.position), typeList, optionalQuestion) }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS methodReturnType 
        optionalQuestion
    { 
        result := ASTMethodType(Position(file, parserState.position), optionalTypeList, 
                methodReturnType, true, true, false) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_METHOD methodReturnType 
        optionalQuestion
    { 
        result := ASTMethodType(Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, false, false) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_IMMUTABLE methodReturnType
        optionalQuestion
    { 
        result := ASTMethodType(Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, true, true) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_METHOD_IMMUTABLE 
        methodReturnType optionalQuestion
    { 
        result := ASTMethodType(Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, false, true) 
    }
genericParameters:Array<ASTType> = LT typeList GT
    { result := typeList }
typeList:Array<ASTType> = typeList COMMA type
    { 
        result := []
        result.addAll(typeList)
        result.add(type)
    }
typeList:Array<ASTType> = type
    { result := [type] }
optionalTypeList:Array<ASTType> = typeList
    { result := typeList }
optionalTypeList:Array<ASTType> =
    { result := [] }
optionalQuestion:Bit = QUESTION
    { result := true }
optionalQuestion:Bit = 
    { result := false }
methodReturnType:ASTType? = LPAREN RPAREN
    { result := null }
methodReturnType:ASTType? = LPAREN type RPAREN
    { result := type }

@expression:ASTExpression = orExpression
    { result := orExpression }
orExpression:ASTExpression = andExpression 
    { result := andExpression }
orExpression:ASTExpression = orExpression OR andExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.OR, orExpression,
                andExpression)
    }
andExpression:ASTExpression = comparisonExpression 
    { result := comparisonExpression }
andExpression:ASTExpression = andExpression AND comparisonExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.AND, 
                andExpression, comparisonExpression)
    }

comparisonExpression:ASTExpression = rangeExpression
    { result := rangeExpression }
comparisonExpression:ASTExpression = comparisonExpression EQ rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression NEQ rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.NOT_EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression IDENTITY 
        rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.IDENTITY, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression NIDENTITY 
        rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.NOT_IDENTITY, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression GT rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.GREATER_THAN, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression LT rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.LESS_THAN, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression GTEQ rangeExpression 
    { 
        result := ASTBinaryExpression(
                BinaryOperationType.GREATER_THAN_OR_EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression LTEQ rangeExpression 
    { 
        result := ASTBinaryExpression(
                BinaryOperationType.LESS_THAN_OR_EQUAL, 
                comparisonExpression, rangeExpression)
    }

rangeExpression:ASTExpression = additiveExpression
    { result := additiveExpression }
rangeExpression:ASTExpression = DOTDOT
    { result := ASTRangeExpression(Position(file, parserState.position), null, null, null, false) }
rangeExpression:ASTExpression = ELLIPSIS
    { result := ASTRangeExpression(Position(file, parserState.position), null, null, null, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT
    { result := ASTRangeExpression(Position(file, parserState.position), l, null, null, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS
    { result := ASTRangeExpression(Position(file, parserState.position), l, null, null, true) }
rangeExpression:ASTExpression = DOTDOT r:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, r, null, false) }
rangeExpression:ASTExpression = ELLIPSIS r:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, r, null, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT r:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, r, null, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS 
        r:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, r, null, true) }
rangeExpression:ASTExpression = DOTDOT BY s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, null, s, false) }
rangeExpression:ASTExpression = ELLIPSIS BY s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, null, s, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT BY 
        s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, null, s, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS BY 
        s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, null, s, true) }
rangeExpression:ASTExpression = DOTDOT r:additiveExpression BY 
        s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, r, s, false) }
rangeExpression:ASTExpression = ELLIPSIS r:additiveExpression BY 
        s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, r, s, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT r:additiveExpression
        BY s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, r, s, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS 
        r:additiveExpression BY s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, r, s, true) }

additiveExpression:ASTExpression = multiplicativeExpression
    { result := multiplicativeExpression }
additiveExpression:ASTExpression = additiveExpression ADD 
        multiplicativeExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.ADD, 
                additiveExpression, multiplicativeExpression) 
    }
additiveExpression:ASTExpression = additiveExpression SUB 
        multiplicativeExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.SUBTRACT, 
                additiveExpression, multiplicativeExpression) 
    }
additiveExpression:ASTExpression = additiveExpression BITWISEOR
        multiplicativeExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.BITWISE_OR, 
                additiveExpression, multiplicativeExpression) 
    }

multiplicativeExpression:ASTExpression = unaryExpression
    { result := unaryExpression }
multiplicativeExpression:ASTExpression = multiplicativeExpression MUL
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.MULTIPLY, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression DIV
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.DIVIDE, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression INTDIV
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.INT_DIVIDE, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression REM
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.REMAINDER, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression SHIFTLEFT
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.SHIFT_LEFT, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression SHIFTRIGHT
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.SHIFT_RIGHT, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression BITWISEAND
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.BITWISE_AND, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression BITWISEXOR
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.BITWISE_XOR, 
                multiplicativeExpression, unaryExpression) 
    }

unaryExpression:ASTExpression = exponentExpression
    { result := exponentExpression }
unaryExpression:ASTExpression = SUB exponentExpression
    { 
        result := ASTUnaryExpression(Position(file, parserState.position), 
                UnaryOperationType.MINUS, exponentExpression) 
    }
unaryExpression:ASTExpression = NOT exponentExpression
    { 
        result := ASTUnaryExpression(Position(file, parserState.position), UnaryOperationType.NOT,
                exponentExpression) 
    }
unaryExpression:ASTExpression = BITWISENOT exponentExpression
    { 
        result := ASTUnaryExpression(Position(file, parserState.position), 
                UnaryOperationType.BITWISE_NOT, exponentExpression) 
    }

exponentExpression:ASTExpression = callExpression
    { result := callExpression }
exponentExpression:ASTExpression = callExpression POW exponentExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.POWER, 
                callExpression, exponentExpression)
    }

callExpression:ASTExpression = term
    { result := term }
callExpression:ASTExpression = methodCall
    { result := methodCall }
callExpression:ASTExpression = callExpression LBRACKET expression RBRACKET
    { result := ASTIndex(callExpression, expression) }
callExpression:ASTExpression = callExpression LT typeList GT
    { 
        if callExpression-?>ASTDotExpression | callExpression-?>ASTIdentifier {
            result := ASTClassLiteral(ASTClassType(
                    callExpression.position, callExpression->>String, typeList,
                    false))
        }
        else
            return Parser.DIE
    }
callExpression:ASTExpression = callExpression DOT IDENTIFIER
    { result := ASTDotExpression(callExpression, IDENTIFIER) }
callExpression:ASTExpression = callExpression DOT specialMethodName
    { result := ASTDotExpression(callExpression, specialMethodName) }
callExpression:ASTExpression = callExpression DOT CLASS
    { result := ASTDotExpression(callExpression, "$class") }
callExpression:ASTExpression = callExpression DOT CONSTRUCTOR
    { result := ASTDotExpression(callExpression, "constructor") }
callExpression:ASTExpression = callExpression INSTANCEOF typeExpression
    { 
        result := ASTArrowExpression(ArrowOperationType.INSTANCE_OF,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression NINSTANCEOF typeExpression
    { 
        result := ASTArrowExpression(ArrowOperationType.NOT_INSTANCE_OF,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression CAST typeExpression
    { 
        result := ASTArrowExpression(ArrowOperationType.CAST,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression CONVERT typeExpression
    { 
        result := ASTArrowExpression(ArrowOperationType.CONVERT,
                callExpression, typeExpression) 
    }
typeExpression:ASTType = type
    { result := type }
typeExpression:ASTType = LPAREN type RPAREN
    { result := type }

parameters:Array<ASTExpression> = LPAREN expressionList RPAREN
    { result := expressionList }
parameters:Array<ASTExpression> = LPAREN RPAREN
    { result := [] }
expressionList:Array<ASTExpression> = expressionList COMMA expression
    { 
        result := [] 
        result.addAll(expressionList)
        result.add(expression)
    }
expressionList:Array<ASTExpression> = expression
    { result := [expression] }

term:ASTExpression = IDENTIFIER
    { result := ASTIdentifier(Position(file, parserState.position), IDENTIFIER) }
term:ASTExpression = INTEGER
    { result := INTEGER }
term:ASTExpression = STRING
    { result := STRING }
term:ASTExpression = REAL
    { result := REAL }
term:ASTExpression = TRUE
    { result := ASTBitLiteral(Position(file, parserState.position), true) }
term:ASTExpression = FALSE
    { result := ASTBitLiteral(Position(file, parserState.position), false) }
term:ASTExpression = NULL
    { result := ASTNullLiteral(Position(file, parserState.position)) }
term:ASTExpression = SELF
    { result := ASTSelf(Position(file, parserState.position)) }
term:ASTExpression = SUPER
    { result := ASTSuper(Position(file, parserState.position)) }
term:ASTExpression = CLASS
    { result := ASTDotExpression(ASTSelf(Position(file, parserState.position)), "$class") }
term:ASTExpression = LPAREN expressionList RPAREN
    {  
        if expressionList.length = 1
            result := expressionList[0]
        else
            result := ASTTupleExpression(Position(file, parserState.position), expressionList)
    }
term:ASTExpression = LBRACKET expressionList RBRACKET
    { result := ASTArrayLiteral(Position(file, parserState.position), expressionList) }
term:ASTExpression = LBRACKET RBRACKET
    { result := ASTArrayLiteral(Position(file, parserState.position), []) }
term:ASTExpression = lambda
    { result := lambda }
term:ASTExpression = methodValue
    { result := methodValue }
term:ASTExpression = '/' regex '/' WS
    { result := ASTRegex(Position(file, parserState.position), regex) }
term:ASTExpression = PRE LPAREN expression RPAREN
    { result := ASTPre(Position(file, parserState.position), expression) }
term:ASTExpression = ATRETURN
    { result := ASTAtReturn(Position(file, parserState.position)) }

regex:String = regexTerm
    { result := regexTerm }
regex:String = regexTerm '|' regex
    { result := regexTerm + "|" + regex }
regexTerm:String = regexFactor
    { result := regexFactor }
regexTerm:String = regexTerm regexFactor
    { result := regexTerm + regexFactor }
regexFactor:String = regexAtom
    { result := regexAtom }
regexFactor:String = regexAtom regexQuantifier
    { result := regexAtom + regexQuantifier }
regexAtom:String = regexCharacter
    { result := regexCharacter }
regexAtom:String = char:[.^$]
    { result := char }
regexAtom:String = '(' regex ')'
    { result := "(" + regex + ")" }
regexAtom:String = '(?' type:[:=!>] regex ')'
    { result := "(?" + type + regex + ")" }
regexAtom:String = '(?<' type:[!=] regex ')'
    { result := "(?<" + type + regex + ")" }
regexAtom:String = '[' regexCharClass ']'
    { result := "[" + regexCharClass + "]" }
regexAtom:String = '[^' regexCharClass ']'
    { result := "[^" + regexCharClass + "]" }
regexCharClass:String = regexRange
    { result := regexRange }
regexCharClass:String = regexCharClass regexRange
    { result := regexCharClass + regexRange }
regexRange:String = regexRangeCharacter
    { result := regexRangeCharacter }
regexRangeCharacter:String = char:[/|()[{^$*+?.]
    { result := char }
regexRangeCharacter:String = regexCharacter
    { result := regexCharacter }
regexRangeCharacter:String = begin:regexRangeCharacter '-' end:regexRangeCharacter
    { result := begin + "-" + end }
regexCharacter:String = char:[-!"#%&',:;<=>@_`~0-9A-Za-z ]
    { result := char->>(String) }
regexCharacter:String = '\\' char:[-!"#%&',/:;<=>@_`~0-9A-Za-z \\|()[\]{}^$*+?.]
    { result := "\\" + char }
regexQuantifier:String = regexQuantifierBase
    { result := regexQuantifierBase }
regexQuantifier:String = regexQuantifierBase modifier:[+?]
    { result := regexQuantifierBase + modifier }
regexQuantifierBase:String = char:[*+?]
    { result := char->>(String) }
regexQuantifierBase:String = '{' regexInt '}'
    { result := "{" + regexInt + "}" }
regexQuantifierBase:String = '{' regexInt ',}'
    { result := "{" + regexInt + ",}" }
regexQuantifierBase:String = '{' min:regexInt ',' max:regexInt '}'
    { result := "{" + min + "," + max + "}" }
regexInt:String = DECIMAL_CHAR
    { result := DECIMAL_CHAR->>(String) }
regexInt:String = regexInt DECIMAL_CHAR
    { result := regexInt + DECIMAL_CHAR }

lambda:ASTExpression = lambdaParameters YIELDS expression
    { 
        result := ASTLambdaExpression(Position(file, parserState.position), lambdaParameters, 
                expression) 
    }
lambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER
    { 
        result := [ASTTypedIdentifier(Position(file, parserState.position), IDENTIFIER,
                null)]
    }
lambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER COLON type
    { 
        result := [ASTTypedIdentifier(Position(file, parserState.position), IDENTIFIER,
                type)]
    }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN RPAREN
    { result := [] }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN untypedLambdaParameters 
        RPAREN
    { result := untypedLambdaParameters }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN typedLambdaParameters RPAREN
    { result := typedLambdaParameters }
untypedLambdaParameters:Array<ASTTypedIdentifier> = untypedLambdaParameters 
        COMMA IDENTIFIER
    { 
        result := []
        result.addAll(untypedLambdaParameters)
        result.add(ASTTypedIdentifier(Position(file, parserState.position), IDENTIFIER,
                null))
    }
untypedLambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER
    {  
        result := [ASTTypedIdentifier(Position(file, parserState.position), IDENTIFIER,
                null)]
    }
typedLambdaParameters:Array<ASTTypedIdentifier> = typedLambdaParameters 
        COMMA IDENTIFIER COLON type
    { 
        result := []
        result.addAll(typedLambdaParameters)
        result.add(ASTTypedIdentifier(Position(file, parserState.position), IDENTIFIER,
                type))
    }
typedLambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER COLON type
    {  
        result := [ASTTypedIdentifier(Position(file, parserState.position), IDENTIFIER,
                type)]
    }

@methodValue:ASTMethodValue = METHOD formalParameters ^ optionalTypeDeclaration 
        block
    {
        result := ASTMethodValue(Position(file, parserState.position), MethodNodeType.METHOD, 
                formalParameters, optionalTypeDeclaration, block)
    }
@methodValue:ASTMethodValue = FUNCTION formalParameters ^ 
        optionalTypeDeclaration block
    {
        result := ASTMethodValue(Position(file, parserState.position), MethodNodeType.FUNCTION, 
                formalParameters, optionalTypeDeclaration, block)
    }


IDENTIFIER:String = identifierText WS
    {
        if ParserUtil.KEYWORDS.contains(identifierText)
            return Parser.DIE
        else
            result := identifierText 
    }
identifierText:String = identifierStart identifierChars ![A-Za-z_$0-9]
    { result := identifierStart + identifierChars }
identifierText:String = identifierStart ![A-Za-z_$0-9]
    { result := identifierStart }
identifierStart:String = char:[a-zA-Z_$]
    { result := char }
identifierChars:String = identifierChars identifierChar
    { result := identifierChars + identifierChar }
identifierChars:String = identifierChar
    { result := identifierChar }
identifierChar:String = char:[a-zA-Z_$0-9]
    { result := char }

INTEGER:ASTIntegerLiteral = DECIMAL_TEXT WS
    { result := ASTIntegerLiteral(Position(file, parserState.position), DECIMAL_TEXT->>(UInt64)) }
INTEGER:ASTIntegerLiteral = '0x' HEX_TEXT WS
    { result := ASTIntegerLiteral(Position(file, parserState.position), ParserUtil.parseInt(HEX_TEXT, 16)) }
INTEGER:ASTIntegerLiteral = '0b' BINARY_TEXT WS
    { 
        result := ASTIntegerLiteral(Position(file, parserState.position), ParserUtil.parseInt(BINARY_TEXT, 
                2)) 
    }
DECIMAL_TEXT:String = DECIMAL_CHARS ![A-Za-z_$0-9]
    { result := DECIMAL_CHARS }
DECIMAL_CHARS:String = DECIMAL_CHARS DECIMAL_CHAR
    { result := DECIMAL_CHARS + DECIMAL_CHAR }
DECIMAL_CHARS:String = DECIMAL_CHAR
    { result := DECIMAL_CHAR }
DECIMAL_CHAR:String = digit:[0-9]
    { result := digit }
HEX_TEXT:String = HEX_CHARS ![A-Za-z_$0-9]
    { result := HEX_CHARS }
HEX_CHARS:String = HEX_CHARS HEX_CHAR
    { result := HEX_CHARS + HEX_CHAR }
HEX_CHARS:String = HEX_CHAR
    { result := HEX_CHAR }
HEX_CHAR:String = digit:[0-9A-Fa-f]
    { result := digit }
BINARY_TEXT:String = BINARY_CHARS ![A-Za-z_$0-9]
    { result := BINARY_CHARS }
BINARY_CHARS:String = BINARY_CHARS BINARY_CHAR
    { result := BINARY_CHARS + BINARY_CHAR }
BINARY_CHARS:String = BINARY_CHAR
    { result := BINARY_CHAR }
BINARY_CHAR:String = digit:[01]
    { result := digit }

REAL:ASTRealLiteral = '.' DECIMAL_TEXT WS
    { 
        result := ASTRealLiteral(Position(file, parserState.position), ("." + 
            DECIMAL_TEXT)->>(Real64))
    }
REAL:ASTRealLiteral = '.' DECIMAL_CHARS EXPONENT WS
    { 
        result := ASTRealLiteral(Position(file, parserState.position), ("." + 
            DECIMAL_CHARS + EXPONENT)->>(Real64))
    }
REAL:ASTRealLiteral = d1:DECIMAL_CHARS '.' d2:DECIMAL_TEXT WS
    { result := ASTRealLiteral(Position(file, parserState.position), (d1 + "." + d2)->>(Real64)) }
REAL:ASTRealLiteral = DECIMAL_CHARS EXPONENT WS
    { 
        result := ASTRealLiteral(Position(file, parserState.position), (DECIMAL_CHARS + 
                EXPONENT)->>(Real64)) 
    }
REAL:ASTRealLiteral = d1:DECIMAL_CHARS '.' d2:DECIMAL_CHARS EXPONENT WS
    { 
        result := ASTRealLiteral(Position(file, parserState.position), (d1 + "." + d2 + 
                EXPONENT)->>(Real64))
    }
EXPONENT:String = [eE] DECIMAL_TEXT
    { result := "e" + DECIMAL_TEXT }
EXPONENT:String = [eE] sign:[+-] DECIMAL_TEXT
    { result := "e" + sign + DECIMAL_TEXT }

STRING:ASTStringLiteral = STRING_SINGLE ^ WS
    { result := STRING_SINGLE }
STRING:ASTStringLiteral = STRING_DOUBLE ^ WS
    { result := STRING_DOUBLE }
STRING_SINGLE:ASTStringLiteral = ['] STRING_CHARS_SINGLE [']
    { result := ASTStringLiteral(Position(file, parserState.position), STRING_CHARS_SINGLE) }
STRING_CHARS_SINGLE:String = STRING_CHARS_SINGLE STRING_CHAR_SINGLE
    { result := STRING_CHARS_SINGLE + STRING_CHAR_SINGLE }
STRING_CHARS_SINGLE:String = 
    { result := "" }
STRING_CHAR_SINGLE:String = char:[^'\\\n\r]
    { result := char }
STRING_CHAR_SINGLE:String = ESCAPE
    { result := ESCAPE }
STRING_DOUBLE:ASTStringLiteral = ["] STRING_CHARS_DOUBLE ["]
    { result := ASTStringLiteral(Position(file, parserState.position), STRING_CHARS_DOUBLE) }
STRING_CHARS_DOUBLE:String = STRING_CHARS_DOUBLE STRING_CHAR_DOUBLE
    { result := STRING_CHARS_DOUBLE + STRING_CHAR_DOUBLE }
STRING_CHARS_DOUBLE:String = 
    { result := "" }
STRING_CHAR_DOUBLE:String = char:[^"\\\n\r]
    { result := char }
STRING_CHAR_DOUBLE:String = ESCAPE
    { result := ESCAPE }
ESCAPE:String = '\\' char:[nrt'":\\]
    { result := '\\' + char }
ESCAPE:String = '\\{' formatExpression '}'
    { result := "\\{" + formatExpression + "}" }
@formatExpression:ASTFormatExpression = expression optionalField 
        optionalFormatString
    { 
        if optionalField != null {
            result := ASTFormatExpression(expression, optionalFormatString,
                    optionalField.fillChar, optionalField.alignment, 
                    optionalField.width)
        }
        else {
            result := ASTFormatExpression(expression, optionalFormatString,
                    null, null, null)
        }
    }
optionalField:FormatField? = COMMA optionalFillChar alignment DECIMAL_CHARS
    { 
        result := FormatField(optionalFillChar, alignment, 
                DECIMAL_CHARS->>(Int)) 
    }
optionalField:FormatField? =
    { result := null }
optionalFillChar:Char = char:[^:\n\r\\]
    { result := char[0] }
optionalFillChar:Char = ESCAPE
    { result := ParserUtil.unescape(ESCAPE)[0] }
optionalFillChar:Char =
    { result := " " }
alignment:Alignment = '<'
    { result := Alignment.LEFT }
alignment:Alignment = '^'
    { result := Alignment.CENTER }
alignment:Alignment = '>'
    { result := Alignment.RIGHT }
formatString:String = formatString char:[^\\}]
    { result := formatString + char }
formatString:String = char:[^\\}]
    { result := char }
optionalFormatString:String? = COLON formatString
    { result := formatString }
optionalFormatString:String? =
    { result := null }

PACKAGE_TEXT = 'package' ![A-Za-z_$0-9]
PACKAGE = PACKAGE_TEXT WS
CLASS_TEXT = 'class' ![A-Za-z_$0-9]
CLASS = CLASS_TEXT WS
INTERFACE_TEXT = 'interface' ![A-Za-z_$0-9]
INTERFACE = INTERFACE_TEXT WS
ENUM_TEXT = 'enum' ![A-Za-z_$0-9]
ENUM = ENUM_TEXT WS
USES_TEXT = 'uses' ![A-Za-z_$0-9]
USES = USES_TEXT WS
AS_TEXT = 'as' ![A-Za-z_$0-9]
AS = AS_TEXT WS
METHOD_TEXT = 'method' ![A-Za-z_$0-9]
METHOD = METHOD_TEXT WS
FUNCTION_TEXT = 'function' ![A-Za-z_$0-9]
FUNCTION = FUNCTION_TEXT WS
CONSTRUCTOR_TEXT = 'constructor' ![A-Za-z_$0-9]
CONSTRUCTOR = CONSTRUCTOR_TEXT WS
INIT_TEXT = 'init' ![A-Za-z_$0-9]
INIT = INIT_TEXT WS
VAR_TEXT = 'var' ![A-Za-z_$0-9]
VAR:VariableType = VAR_TEXT WS
    { result := VariableType.VAR }
DEF_TEXT = 'def' ![A-Za-z_$0-9]
DEF:VariableType = DEF_TEXT WS
    { result := VariableType.DEF }
CONSTANT_TET = 'constant' ![A-Za-z_$0-9]
CONSTANT:VariableType = 'constant' WS
    { result := VariableType.CONSTANT }
PROPERTY_TEXT = 'property' ![A-Za-z_$0-9]
PROPERTY:VariableType = PROPERTY_TEXT WS 
    { result := VariableType.PROPERTY }
PROTECTED_TEXT = '@protected' ![A-Za-z_$0-9]
PROTECTED = PROTECTED_TEXT WS
PRIVATE_TEXT = '@private' ![A-Za-z_$0-9]
PRIVATE = PRIVATE_TEXT WS
ATCLASS_TEXT = '@class' ![A-Za-z_$0-9]
ATCLASS = ATCLASS_TEXT WS
THREAD_TEXT = '@thread' ![A-Za-z_$0-9]
THREAD = THREAD_TEXT WS
ABSTRACT_TEXT = '@abstract' ![A-Za-z_$0-9]
ABSTRACT = ABSTRACT_TEXT WS
EXTERNAL_TEXT = '@external' ![A-Za-z_$0-9]
EXTERNAL = EXTERNAL_TEXT WS
OVERRIDE_TEXT = '@override' ![A-Za-z_$0-9]
OVERRIDE = OVERRIDE_TEXT WS
READONLY_TEXT = '@readonly' ![A-Za-z_$0-9]
READONLY = READONLY_TEXT WS
LIMITED_TEXT = '@limited' ![A-Za-z_$0-9]
LIMITED = LIMITED_TEXT WS
ATSELF_TEXT = '@self' ![A-Za-z_$0-9]
ATSELF = ATSELF_TEXT WS
SAFERETURN_TEXT = '@safeReturn' ![A-Za-z_$0-9]
SAFERETURN = SAFERETURN_TEXT WS
UNSAFEFUNCTION_TEXT = '@unsafeFunction' ![A-Za-z_$0-9]
UNSAFEFUNCTION = UNSAFEFUNCTION_TEXT WS
FINAL_TEXT = '@final' ![A-Za-z_$0-9]
FINAL = FINAL_TEXT WS
WRAPPER_METHOD = '@$wrapperMethod' WS
MATH_TEXT = '@math' ![A-Za-z_$0-9]
MATH = MATH_TEXT WS
OVERFLOW_TEXT = 'overflow' ![A-Za-z_$0-9]
OVERFLOW = OVERFLOW_TEXT WS
INVARIANT_TEXT = '@invariant' ![A-Za-z_$0-9]
INVARIANT = INVARIANT_TEXT WS
INSTANCE = '@$instance' WS
PRE_TEXT = '@pre' ![A-Za-z_$0-9]
PRE = PRE_TEXT WS
POST_TEXT = '@post' ![A-Za-z_$0-9]
POST = POST_TEXT WS
PRE_OR = '@preOr' WS
POST_AND = '@postAnd' WS
ATRETURN_TEXT = '@return' ![A-Za-z_$0-9]
ATRETURN = ATRETURN_TEXT WS
TRUE_TEXT = 'true' ![A-Za-z_$0-9]
TRUE = TRUE_TEXT WS
FALSE_TEXT = 'false' ![A-Za-z_$0-9]
FALSE = FALSE_TEXT WS
NULL_TEXT = 'null' ![A-Za-z_$0-9]
NULL = NULL_TEXT WS
SELF_TEXT = 'self' ![A-Za-z_$0-9]
SELF = SELF_TEXT WS
SUPER_TEXT = 'super' ![A-Za-z_$0-9]
SUPER = SUPER_TEXT WS
BY_TEXT = 'by' ![A-Za-z_$0-9]
BY = BY_TEXT WS
FOR_TEXT = 'for' ![A-Za-z_$0-9]
FOR = FOR_TEXT WS
IN_TEXT = 'in' ![A-Za-z_$0-9]
IN = IN_TEXT WS
WHILE_TEXT = 'while' ![A-Za-z_$0-9]
WHILE = WHILE_TEXT WS
DO_TEXT = 'do' ![A-Za-z_$0-9]
DO = DO_TEXT WS
LOOP_TEXT = 'loop' ![A-Za-z_$0-9]
LOOP = LOOP_TEXT WS
IF_TEXT = 'if' ![A-Za-z_$0-9]
IF = IF_TEXT WS
ELSE_TEXT = 'else' ![A-Za-z_$0-9]
ELSE = ELSE_TEXT WS
SWITCH_TEXT = 'switch' ![A-Za-z_$0-9]
SWITCH = SWITCH_TEXT WS
CASE_TEXT = 'case' ![A-Za-z_$0-9]
CASE = CASE_TEXT WS
DEFAULT_TEXT = 'default' ![A-Za-z_$0-9]
DEFAULT = DEFAULT_TEXT WS
RETURN_TEXT = 'return' ![A-Za-z_$0-9]
CONTINUE_TEXT = 'continue' ![A-Za-z_$0-9]
BREAK_TEXT = 'break' ![A-Za-z_$0-9]
ASSERT_TEXT = 'assert' ![A-Za-z_$0-9]
ASSERT = ASSERT_TEXT WS
UNREACHABLE_TEXT = 'unreachable' ![A-Za-z_$0-9]
UNREACHABLE = UNREACHABLE_TEXT WS
TRY_TEXT = 'try' ![A-Za-z_$0-9]
TRY = TRY_TEXT WS
CATCH_TEXT = 'catch' ![A-Za-z_$0-9]
CATCH = CATCH_TEXT WS
THROW_TEXT = 'throw' ![A-Za-z_$0-9]
THROW = THROW_TEXT WS
COLON = ':' WS
LBRACKET = '[' WS
RBRACKET = ']' WS
LBRACE = '{' WS
RBRACE = '}' WS
LPAREN = '(' WS
RPAREN = ')' WS
ADD = '+' WS
SUB = '-' WS
MUL = '*' WS
DIV = '/' WS
REM = '%' WS
INTDIV = '//' WS
AND = '&' WS
OR = '|' WS
XOR = '~' WS
SHIFTLEFT = '<<' WS
SHIFTRIGHT = '>>' WS
BITWISEAND = '&&' WS
BITWISEOR = '||' WS
BITWISEXOR = '~~' WS
POW = '^' WS
EQ = '=' WS
NEQ = '!=' WS
LT = '<' WS
GT = '>' WS
LTEQ = '<=' WS
GTEQ = '>=' WS
IDENTITY = '==' WS
NIDENTITY = '!==' WS
NOT = '!' WS
BITWISENOT = '!!' WS
ASSIGNMENT = ':=' WS
ADDEQ = '+=' WS 
SUBEQ = '-=' WS
MULEQ = '*=' WS 
DIVEQ = '/=' WS 
INTDIVEQ = '//=' WS 
POWEQ = '^=' WS 
REMEQ = '%=' WS 
ANDEQ = '&=' WS 
BITWISEANDEQ = '&&=' WS 
OREQ = '|=' WS 
BITWISEOREQ = '||=' WS 
XOREQ = '~=' WS 
BITWISEXOREQ = '~~=' WS 
SHIFTLEFTEQ = '<<=' WS 
SHIFTRIGHTEQ = '>>=' WS 
CAST = '->' WS
INSTANCEOF = '-?>' WS
NINSTANCEOF = '-!>' WS
CONVERT = '->>' WS
COMMA  = ',' WS
STAR = '*' WS
DOT = '.' WS
DOTDOT = '..' WS
ELLIPSIS = '...' WS
QUESTION = '?' WS
YIELDS = '=>' WS
YIELDS_METHOD = '=&>' WS
YIELDS_IMMUTABLE = '=>*' WS
YIELDS_METHOD_IMMUTABLE = '=&>*' WS

WS = WS WS_CHAR
WS =
WS_CHAR = [ \r\n\t]
WS_CHAR = COMMENT
WS_SAMELINE = WS_SAMELINE WS_SAMELINE_CHAR
WS_SAMELINE =
WS_SAMELINE_CHAR = [ \t]
WS_SAMELINE_CHAR = SINGLE_LINE_BLOCK_COMMENT
COMMENT = LINE_COMMENT
COMMENT = BLOCK_COMMENT
LINE_COMMENT = '--' LINE_COMMENT_CHARS [\n]
LINE_COMMENT_CHARS = LINE_COMMENT_CHARS [^\n]
LINE_COMMENT_CHARS =
TRAILING_LINE_COMMENT = '--' LINE_COMMENT_CHARS
BLOCK_COMMENT = '-*' BLOCK_COMMENT_CHARS '*-'
BLOCK_COMMENT_CHARS = BLOCK_COMMENT_CHARS BLOCK_COMMENT_CHAR
BLOCK_COMMENT_CHARS =
BLOCK_COMMENT_CHAR = [^*]
BLOCK_COMMENT_CHAR = '*' [^-]
BLOCK_COMMENT_CHAR = BLOCK_COMMENT
SINGLE_LINE_BLOCK_COMMENT = '-*' SINGLE_LINE_BLOCK_COMMENT_CHARS '*-'
SINGLE_LINE_BLOCK_COMMENT_CHARS = SINGLE_LINE_BLOCK_COMMENT_CHARS 
        SINGLE_LINE_BLOCK_COMMENT_CHAR
SINGLE_LINE_BLOCK_COMMENT_CHARS =
SINGLE_LINE_BLOCK_COMMENT_CHAR = [^*\n\r]
SINGLE_LINE_BLOCK_COMMENT_CHAR = '*' [^-]
SINGLE_LINE_BLOCK_COMMENT_CHAR = SINGLE_LINE_BLOCK_COMMENT
DOCCOMMENT:String = '===' TRAILING_EQUALS DOCCOMMENT_CHARS '===' TRAILING_EQUALS
        WS
    { result := DOCCOMMENT_CHARS }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHARS DOCCOMMENT_CHAR
    { result := DOCCOMMENT_CHARS + DOCCOMMENT_CHAR }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHAR
    { result := DOCCOMMENT_CHAR }
DOCCOMMENT_CHAR:String = char:[^=]
    { result := char }
DOCCOMMENT_CHAR:String = '=' char:[^=]
    { result := "=" + char }
DOCCOMMENT_CHAR:String = '==' char:[^=]
    { result := "==" + char }
TRAILING_EQUALS = TRAILING_EQUALS_CHARS
TRAILING_EQUALS =
TRAILING_EQUALS_CHARS = TRAILING_EQUALS_CHARS '='
TRAILING_EQUALS_CHARS = '='
