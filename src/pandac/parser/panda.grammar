{
    package org.pandalanguage.pandac.parser
    
    uses org.pandalanguage.pandac.ast.Alignment
    uses org.pandalanguage.pandac.ast.ASTArrayLiteral
    uses org.pandalanguage.pandac.ast.ASTArrowExpression
    uses org.pandalanguage.pandac.ast.ArrowOperationType
    uses org.pandalanguage.pandac.ast.ASTAnnotation
    uses org.pandalanguage.pandac.ast.ASTAssert
    uses org.pandalanguage.pandac.ast.ASTAssignment
    uses org.pandalanguage.pandac.ast.ASTAtReturn
    uses org.pandalanguage.pandac.ast.ASTBinaryExpression
    uses org.pandalanguage.pandac.ast.ASTBitLiteral
    uses org.pandalanguage.pandac.ast.ASTBlock
    uses org.pandalanguage.pandac.ast.ASTBreak
    uses org.pandalanguage.pandac.ast.ASTCallExpression
    uses org.pandalanguage.pandac.ast.ASTCatch
    uses org.pandalanguage.pandac.ast.ASTClass
    uses org.pandalanguage.pandac.ast.ASTClassLiteral
    uses org.pandalanguage.pandac.ast.ASTClassType
    uses org.pandalanguage.pandac.ast.ASTContinue
    uses org.pandalanguage.pandac.ast.ASTDo
    uses org.pandalanguage.pandac.ast.ASTDotExpression
    uses org.pandalanguage.pandac.ast.ASTEnum
    uses org.pandalanguage.pandac.ast.ASTEnumValue
    uses org.pandalanguage.pandac.ast.ASTExpression
    uses org.pandalanguage.pandac.ast.ASTExpressionStatement
    uses org.pandalanguage.pandac.ast.ASTField
    uses org.pandalanguage.pandac.ast.ASTFile
    uses org.pandalanguage.pandac.ast.ASTFor
    uses org.pandalanguage.pandac.ast.ASTFormatExpression
    uses org.pandalanguage.pandac.ast.ASTIdentifier
    uses org.pandalanguage.pandac.ast.ASTIf
    uses org.pandalanguage.pandac.ast.ASTIndex
    uses org.pandalanguage.pandac.ast.ASTInstanceDeclaration
    uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
    uses org.pandalanguage.pandac.ast.ASTInvariant
    uses org.pandalanguage.pandac.ast.ASTLambdaExpression
    uses org.pandalanguage.pandac.ast.ASTLoop
    uses org.pandalanguage.pandac.ast.ASTMethod
    uses org.pandalanguage.pandac.ast.ASTMethodType
    uses org.pandalanguage.pandac.ast.ASTMethodValue
    uses org.pandalanguage.pandac.ast.ASTNode
    uses org.pandalanguage.pandac.ast.ASTNullLiteral
    uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
    uses org.pandalanguage.pandac.ast.ASTParameter
    uses org.pandalanguage.pandac.ast.ASTPostcondition
    uses org.pandalanguage.pandac.ast.ASTPre
    uses org.pandalanguage.pandac.ast.ASTPrecondition
    uses org.pandalanguage.pandac.ast.ASTRangeExpression
    uses org.pandalanguage.pandac.ast.ASTRealLiteral
    uses org.pandalanguage.pandac.ast.ASTRegex
    uses org.pandalanguage.pandac.ast.ASTReturn
    uses org.pandalanguage.pandac.ast.ASTSelf
    uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
    uses org.pandalanguage.pandac.ast.ASTStatement
    uses org.pandalanguage.pandac.ast.ASTStringLiteral
    uses org.pandalanguage.pandac.ast.ASTSuper
    uses org.pandalanguage.pandac.ast.ASTSwitch
    uses org.pandalanguage.pandac.ast.ASTSwitchCase
    uses org.pandalanguage.pandac.ast.ASTThrow
    uses org.pandalanguage.pandac.ast.ASTTry
    uses org.pandalanguage.pandac.ast.ASTTupleExpression
    uses org.pandalanguage.pandac.ast.ASTTupleType
    uses org.pandalanguage.pandac.ast.ASTType
    uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
    uses org.pandalanguage.pandac.ast.ASTUnaryExpression
    uses org.pandalanguage.pandac.ast.ASTUnreachable
    uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
    uses org.pandalanguage.pandac.ast.ASTVarDeclaration
    uses org.pandalanguage.pandac.ast.ASTWhile
    uses org.pandalanguage.pandac.tree.BinaryOperationType
    uses org.pandalanguage.pandac.tree.MethodNode
    uses org.pandalanguage.pandac.tree.MethodNodeType
    uses org.pandalanguage.pandac.tree.Position
    uses org.pandalanguage.pandac.tree.UnaryOperationType
    uses org.pandalanguage.pandac.tree.VariableType

    class FormatField {
        def fillChar:Char
        def alignment:Alignment
        def width:Int

        init(fillChar:Char, alignment:Alignment, width:Int) {
            self.fillChar := fillChar
            self.alignment := alignment
            self.width := width
        }
    }

    class Identifier {
        def text:String
        def position:Position

        init(text:String, position:Position) {
            self.text := text
            self.position := position
        }
    }

    class ParserUtil {
        constant KEYWORDS := HashSet<String>(["package", "uses", "as", 
                    "class", "method", "function", "init", "var", "def", 
                    "property", "constant", "do", "while", "for", "by", "loop", 
                    "if", "else", "switch", "case", "default", "self", "true",
                     "false", "enum", "return", "break", "continue", "null", 
                     "assert", "unreachable", "try", "catch", "finally", 
                     "throw", "super"])

        @class
        @pre(base >= 2 & base <= 36)
        function parseInt(s:String, base:UInt):UInt64? {
            var result:UInt64 := 0
            constant DIGITS := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            constant DIGITS_LOWER := "0123456789abcdefghijklmnopqrstuvwxyz"
            for i in 0 .. s.length {
                var digit := DIGITS.indexOf(s[i])
                if digit = null {
                    digit := DIGITS_LOWER.indexOf(s[i])
                }
                if digit = null | digit >= base {
                    return null
                }
                result := result * base + digit->(UInt64)
            }
            return result
        }

        @class
        function unescape(text:String):String {
            def result := MutableString()
            var i := 0
            while i < result.length {
                var c := text[i]
                i += 1
                if c = "\\" {
                    c := text[i]
                    switch c {
                        case "n": result.append("\n")
                        case "r": result.append("\r")
                        case "t": result.append("\t")
                        default: result.append(c)
                    }
                    i += 1
                }
                else
                    result.append(c)
            }
            return result.convert()
        }

        @class
        function isExternal(file:File):Bit {
            return file.name.endsWith(".plink")
        }
    }
}

@file:Array<ASTNode> = WS bodyEntries optionalTrailingLineComment
    { result := bodyEntries }
@file:Array<ASTNode> = WS optionalTrailingLineComment
    { result := [] }
bodyEntries:Array<ASTNode> = bodyEntries bodyEntry
    { 
        result := [] 
        result.addAll(bodyEntries)
        result.add(bodyEntry)
    }
bodyEntries:Array<ASTNode> = bodyEntry
    { result := [bodyEntry] }
optionalTrailingLineComment = TRAILING_LINE_COMMENT
optionalTrailingLineComment =

bodyEntry:ASTNode = usesStatement 
    { result := usesStatement }
bodyEntry:ASTNode = classDeclaration 
    { result := classDeclaration }
bodyEntry:ASTNode = interfaceDeclaration 
    { result := interfaceDeclaration }
bodyEntry:ASTNode = enumDeclaration
    { result := enumDeclaration }
bodyEntry:ASTNode = methodDeclaration
    { result := methodDeclaration }
bodyEntry:ASTNode = functionDeclaration
    { result := functionDeclaration }
bodyEntry:ASTNode = packageDeclaration 
    { result := packageDeclaration }
bodyEntry:ASTNode = instanceDeclaration 
    { result := instanceDeclaration }
bodyEntry:ASTNode = statement
    { result := statement }

packageDeclaration:ASTPackageDeclaration = PACKAGE ^ dottedName
    { result := ASTPackageDeclaration(PACKAGE, dottedName) }
dottedName:String = dottedName DOT IDENTIFIER
    { result := dottedName + "." + IDENTIFIER.text }
dottedName:String = IDENTIFIER
    { result := IDENTIFIER.text }
usesStatement:ASTUsesDeclaration = USES usesName
    { result := ASTUsesDeclaration(USES, usesName, null) }
usesStatement:ASTUsesDeclaration = USES id:dottedName AS ^ alias:dottedName
    { result := ASTUsesDeclaration(USES, id, alias) }
usesName:String = dottedName DOT STAR
    { result := dottedName + ".*" }
usesName:String = dottedName
    { result := dottedName }
instanceDeclaration:ASTInstanceDeclaration = INSTANCE ^ type
    { result := ASTInstanceDeclaration(Position(file, parserState.position), type) }

classDeclaration:ASTClass = optionalDoccomment optionalAnnotations CLASS 
        IDENTIFIER optionalGenericsDeclaration optionalTypeDeclaration
        optionalInterfaces LBRACE ^ classMembers RBRACE
    { 
        def methods := Array<ASTMethod>()
        def fields := Array<ASTField>()
        def invariants := Array<ASTInvariant>()
        for m in classMembers {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := ASTClass(CLASS, IDENTIFIER.text, false, optionalDoccomment, 
                optionalAnnotations, optionalTypeDeclaration, 
                optionalInterfaces, optionalGenericsDeclaration, methods, 
                fields, invariants, ParserUtil.isExternal(file))
    }
interfaceDeclaration:ASTClass = optionalDoccomment optionalAnnotations 
        INTERFACE ^ IDENTIFIER optionalGenericsDeclaration 
        optionalTypeDeclarations LBRACE classMembers RBRACE
    { 
        def methods := Array<ASTMethod>()
        def fields := Array<ASTField>()
        def invariants := Array<ASTInvariant>()
        for m in classMembers {
            if m-?>(ASTMethod)
                methods.add(m->(ASTMethod))
            else if m-?>(ASTField)
                fields.add(m->(ASTField))
            else if m-?>(ASTInvariant)
                invariants.add(m->(ASTInvariant))
            else
                unreachable
        }
        result := ASTClass(INTERFACE, IDENTIFIER.text, true, optionalDoccomment, 
                optionalAnnotations, null, optionalTypeDeclarations, 
                optionalGenericsDeclaration, methods, fields, invariants, 
                ParserUtil.isExternal(file))
    }
enumDeclaration:ASTEnum = optionalDoccomment optionalAnnotations ENUM ^ 
        IDENTIFIER LBRACE enumValues RBRACE
    {
        result := ASTEnum(ENUM, IDENTIFIER.text, optionalDoccomment, 
                optionalAnnotations, enumValues, ParserUtil.isExternal(file))
    }
enumValues:Array<ASTEnumValue> = enumValues COMMA enumValue
    {
        result := []
        result.addAll(enumValues)
        result.add(enumValue)
    }
enumValues:Array<ASTEnumValue> = enumValue
    { result := [enumValue] }
enumValue:ASTEnumValue = optionalDoccomment IDENTIFIER
    { 
        result := ASTEnumValue(IDENTIFIER.position, IDENTIFIER.text, 
                optionalDoccomment) 
    }
optionalDoccomment:String? = DOCCOMMENT
    { result := DOCCOMMENT }
optionalDoccomment:String? =
    { result := null }
optionalAnnotations:Array<ASTAnnotation>? = annotations
    { result := annotations }
optionalAnnotations:Array<ASTAnnotation>? =
    { result := null }
optionalTypeDeclarations:Array<ASTType>? = COLON typeList
    { result := typeList }
optionalTypeDeclarations:Array<ASTType>? =
    { result := null }
optionalTypeDeclaration:ASTType? = typeDeclaration 
    { result := typeDeclaration }
optionalTypeDeclaration:ASTType? =
    { result := null }
typeDeclaration:ASTType = COLON type
    { result := type }
optionalGenericsDeclaration:Array<ASTTypedIdentifier>? = LT genericsDeclarations 
        GT
    { result := genericsDeclarations }
optionalGenericsDeclaration:Array<ASTTypedIdentifier>? =
    { result := null }
genericsDeclarations:Array<ASTTypedIdentifier> = genericsDeclarations COMMA
        optionallyTypedIdentifier
    { 
        result := []
        result.addAll(genericsDeclarations)
        result.add(optionallyTypedIdentifier)
    }
genericsDeclarations:Array<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := [optionallyTypedIdentifier] }
optionalInterfaces:Array<ASTType>? = LPAREN typeList RPAREN
    { result := typeList }
optionalInterfaces:Array<ASTType>? =
    { result := null }
classMembers:Array<ASTNode> = classMemberList
    { result := classMemberList }
classMembers:Array<ASTNode> =
    { result := [] }
classMemberList:Array<ASTNode> = classMemberList classMember
    { 
        result := []
        result.addAll(classMemberList)
        result.add(classMember)
    }
classMemberList:Array<ASTNode> =
    { result := [] }
classMember:ASTNode = invariant 
    { result := invariant }
classMember:ASTNode = methodDeclaration 
    { result := methodDeclaration }
classMember:ASTNode = functionDeclaration 
    { result := functionDeclaration }
classMember:ASTNode = initDeclaration 
    { result := initDeclaration }
classMember:ASTNode = fieldDeclaration 
    { result := fieldDeclaration }
annotations:Array<ASTAnnotation> = annotations annotation
    {
        result := []
        result.addAll(annotations)
        result.add(annotation)
    }
annotations:Array<ASTAnnotation> = annotation
    { result := [annotation] }
annotation:ASTAnnotation = PROTECTED 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "protected") }
annotation:ASTAnnotation = PRIVATE 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "private") }
annotation:ASTAnnotation = ATCLASS 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "class") }
annotation:ASTAnnotation = THREAD 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "thread") }
annotation:ASTAnnotation = ABSTRACT 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "abstract") }
annotation:ASTAnnotation = EXTERNAL 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "external") }
annotation:ASTAnnotation = OVERRIDE 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "override") }
annotation:ASTAnnotation = READONLY 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "readonly") }
annotation:ASTAnnotation = LIMITED 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "limited") }
annotation:ASTAnnotation = ATSELF 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "self") }
annotation:ASTAnnotation = SAFERETURN 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "safeReturn") }
annotation:ASTAnnotation = UNSAFEFUNCTION 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "unsafeFunction") }
annotation:ASTAnnotation = FINAL 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "final") }
annotation:ASTAnnotation = WRAPPER_METHOD 
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "$wrapperMethod") }
annotation:ASTAnnotation = MATH LPAREN OVERFLOW RPAREN
    { result := ASTSimpleAnnotation(Position(file, parserState.position), "math(overflow)") }
annotation:ASTAnnotation = PRE LPAREN expression RPAREN
    { result := ASTPrecondition(Position(file, parserState.position), expression, false) }
annotation:ASTAnnotation = PRE_OR LPAREN expression RPAREN
    { result := ASTPrecondition(Position(file, parserState.position), expression, true) }
postcondition:ASTPostcondition = POST LPAREN expression RPAREN
    { result := ASTPostcondition(Position(file, parserState.position), expression, false) }
postcondition:ASTPostcondition = POST_AND LPAREN expression RPAREN
    { result := ASTPostcondition(Position(file, parserState.position), expression, true) }
postconditions:Array<ASTPostcondition> = postconditions postcondition
    {
        result := []
        result.addAll(postconditions)
        result.add(postcondition)
    }
postconditions:Array<ASTPostcondition> = postcondition
    { result := [postcondition] }
optionalPostconditions:Array<ASTPostcondition>? = postconditions
    { result := postconditions }
optionalPostconditions:Array<ASTPostcondition>? = 
    { result := null }

invariant:ASTInvariant = INVARIANT LPAREN expression RPAREN
    { result := ASTInvariant(Position(file, parserState.position), expression) }

methodDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        METHOD ^ methodName formalParameters optionalTypeDeclaration 
        optionalBlock optionalPostconditions
    {
        result := ASTMethod(Position(file, parserState.position), methodName, 
                MethodNodeType.METHOD, optionalDoccomment, 
                optionalAnnotations, formalParameters, optionalTypeDeclaration, 
                optionalBlock, optionalPostconditions)
    }
methodName:String = IDENTIFIER 
    { result := IDENTIFIER.text }
methodName:String = specialMethodName
    { result := specialMethodName }
specialMethodName:String = IDENTIFIER ASSIGNMENT
    { result := IDENTIFIER.text + ":=" }
specialMethodName:String = SHIFTLEFT
    { result := "<<" }
specialMethodName:String = SHIFTRIGHT
    { result := ">>" }
specialMethodName:String = ADD
    { result := "+" }
specialMethodName:String = SUB
    { result := "-" }
specialMethodName:String = MUL
    { result := "*" }
specialMethodName:String = DIV
    { result := "/" }
specialMethodName:String = INTDIV
    { result := "//" }
specialMethodName:String = REM
    { result := "%" }
specialMethodName:String = AND
    { result := "&" }
specialMethodName:String = OR
    { result := "|" }
specialMethodName:String = XOR
    { result := "~" }
specialMethodName:String = BITWISEAND
    { result := "&&" }
specialMethodName:String = BITWISEOR
    { result := "||" }
specialMethodName:String = BITWISEXOR
    { result := "~~" }
specialMethodName:String = POW
    { result := "^" }
specialMethodName:String = NOT
    { result := "!" }
specialMethodName:String = BITWISENOT
    { result := "!!" }
specialMethodName:String = '[]' WS
    { result := "[]" }
specialMethodName:String = '[..]' WS
    { result := "[..]" }
specialMethodName:String = '[...]' WS
    { result := "[...]" }
specialMethodName:String = '[]:=' WS
    { result := "[]:=" }
specialMethodName:String = '[..]:=' WS
    { result := "[..]:=" }
specialMethodName:String = '[...]:=' WS
    { result := "[...]:=" }
specialMethodName:String = EQ
    { result := "=" }
specialMethodName:String = GT
    { result := ">" }
specialMethodName:String = LT
    { result := "<" }
specialMethodName:String = GTEQ
    { result := ">=" }
specialMethodName:String = LTEQ
    { result := "<=" }
formalParameters:Array<ASTParameter> = LPAREN parameterList RPAREN
    { result := parameterList }
formalParameters:Array<ASTParameter> = LPAREN RPAREN
    { result := [] }
parameterList:Array<ASTParameter> = parameterList COMMA parameter
    {
        result := []
        result.addAll(parameterList)
        result.add(parameter)
    }
parameterList:Array<ASTParameter> = parameter
    { result := [parameter] }
parameter:ASTParameter = optionalVar IDENTIFIER COLON type 
        optionalEllipsis
    { 
        result := ASTParameter(IDENTIFIER.position, IDENTIFIER.text, type, 
                optionalVar, optionalEllipsis)
    }
optionalVar:Bit = VAR
    { result := true }
optionalVar:Bit =
    { result := false }
optionalEllipsis:Bit = ELLIPSIS
    { result := true }
optionalEllipsis:Bit =
    { result := false }
optionalBlock:ASTBlock? = block
    { result := block }
optionalBlock:ASTBlock? = 
    { result := null }

@anyMethod:ASTMethod = functionDeclaration
    { result := functionDeclaration }
@anyMethod:ASTMethod = methodDeclaration
    { result := methodDeclaration }
@anyMethod:ASTMethod = initDeclaration
    { result := initDeclaration }

functionDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        FUNCTION ^ methodName formalParameters typeDeclaration optionalBlock
        optionalPostconditions
    {
        result := ASTMethod(Position(file, parserState.position), 
                methodName, MethodNodeType.FUNCTION, optionalDoccomment, 
                optionalAnnotations, formalParameters, typeDeclaration, 
                optionalBlock, optionalPostconditions)
    }

initDeclaration:ASTMethod = optionalDoccomment optionalAnnotations 
        INIT ^ formalParameters optionalBlock optionalPostconditions
    {
        result := ASTMethod(Position(file, parserState.position), 
                MethodNode.INIT_NAME, 
                MethodNodeType.INIT, optionalDoccomment, 
                optionalAnnotations, formalParameters, null, 
                optionalBlock, optionalPostconditions)
    }

fieldDeclaration:ASTField = optionalDoccomment optionalAnnotations 
        varDeclaration
    { 
        result := ASTField(optionalDoccomment, optionalAnnotations, 
                varDeclaration) 
    }

@statement:ASTStatement = varDeclaration
    { result := varDeclaration }
@statement:ASTStatement = ifStatement
    { result := ifStatement }
@statement:ASTStatement = forLoop 
    { result := forLoop }
@statement:ASTStatement = whileLoop 
    { result := whileLoop }
@statement:ASTStatement = doLoop 
    { result := doLoop }
@statement:ASTStatement = loopLoop
    { result := loopLoop }
@statement:ASTStatement = methodCall
    { result := ASTExpressionStatement(methodCall) }
@statement:ASTStatement = assignment
    { result := assignment }
@statement:ASTStatement = assertStatement 
    { result := assertStatement }
@statement:ASTStatement = switchStatement
    { result := switchStatement }
@statement:ASTStatement = tryStatement 
    { result := tryStatement }
@statement:ASTStatement = block
    { result := block }

statementOrBlock:ASTStatement = statement 
    { result := statement }
statementOrBlock:ASTStatement = terminalStatement 
    { result := terminalStatement }

varDeclaration:ASTVarDeclaration = VAR varDeclarations
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.VAR, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = DEF varDeclarations
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.DEF, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = PROPERTY varDeclarations
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.PROPERTY, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = CONSTANT varDeclarations
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.CONSTANT, 
                varDeclarations, null) 
    }
varDeclaration:ASTVarDeclaration = VAR varDeclarations ASSIGNMENT expression
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.VAR, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = DEF varDeclarations ASSIGNMENT expression
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.DEF, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = PROPERTY varDeclarations ASSIGNMENT expression
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.PROPERTY, 
                varDeclarations, expression) 
    }
varDeclaration:ASTVarDeclaration = CONSTANT varDeclarations ASSIGNMENT expression
    { 
        result := ASTVarDeclaration(Position(file, parserState.position), VariableType.CONSTANT, 
                varDeclarations, expression) 
    }
varDeclarations:Array<ASTTypedIdentifier> = varDeclarations COMMA 
        optionallyTypedIdentifier
    { 
        result := [] 
        result.addAll(varDeclarations)
        result.add(optionallyTypedIdentifier)
    }
varDeclarations:Array<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := [optionallyTypedIdentifier] }
optionallyTypedIdentifier:ASTTypedIdentifier = IDENTIFIER
    { result := ASTTypedIdentifier(IDENTIFIER.position, IDENTIFIER.text, null) }
optionallyTypedIdentifier:ASTTypedIdentifier = IDENTIFIER COLON type
    { result := ASTTypedIdentifier(IDENTIFIER.position, IDENTIFIER.text, type) }

ifStatement:ASTIf = IF ^ expression statementOrBlock optionalElse
    { 
        result := ASTIf(Position(file, parserState.position), 
                expression, statementOrBlock, optionalElse) 
    }
optionalElse:ASTStatement? = ELSE statementOrBlock
    { result := statementOrBlock }
optionalElse:ASTStatement? =
    { result := null }

forLoop:ASTFor = optionalLabel FOR ^ forTarget IN ^ expression 
        statementOrBlock
    { 
        result := ASTFor(Position(file, parserState.position), 
                optionalLabel, forTarget, expression, statementOrBlock) 
    }
optionalLabel:String? = IDENTIFIER COLON
    { result := IDENTIFIER.text }
optionalLabel:String? =
    { result := null }
forTarget:ListView<ASTTypedIdentifier> = optionallyTypedIdentifier
    { result := [optionallyTypedIdentifier] }
forTarget:ListView<ASTTypedIdentifier> = LPAREN varDeclarations RPAREN
    { result := varDeclarations }

whileLoop:ASTWhile = optionalLabel WHILE ^ expression statementOrBlock
    { 
        result := ASTWhile(Position(file, parserState.position), optionalLabel, expression, 
                statementOrBlock)
    }

doLoop:ASTDo = optionalLabel DO ^ statementOrBlock WHILE expression
    { 
        result := ASTDo(Position(file, parserState.position), optionalLabel, expression, 
                statementOrBlock)
    }

loopLoop:ASTLoop = optionalLabel LOOP ^ statementOrBlock
    { result := ASTLoop(Position(file, parserState.position), optionalLabel, statementOrBlock) }

methodCall:ASTExpression = callExpression parameters
    { result := ASTCallExpression(callExpression, parameters) }
methodCall:ASTExpression = INIT parameters
    { result := ASTCallExpression(ASTIdentifier(INIT, "init"), parameters) }
assignment:ASTStatement = expressionList assignmentOperator expression
    { 
        result := ASTAssignment(expressionList, assignmentOperator, 
                expression) 
    }
assignmentOperator:BinaryOperationType? = ASSIGNMENT
    { result := null }
assignmentOperator:BinaryOperationType? = ADDEQ
    { result := BinaryOperationType.ADD }
assignmentOperator:BinaryOperationType? = SUBEQ
    { result := BinaryOperationType.SUBTRACT }
assignmentOperator:BinaryOperationType? = MULEQ 
    { result := BinaryOperationType.MULTIPLY }
assignmentOperator:BinaryOperationType? = DIVEQ 
    { result := BinaryOperationType.DIVIDE }
assignmentOperator:BinaryOperationType? = INTDIVEQ 
    { result := BinaryOperationType.INT_DIVIDE }
assignmentOperator:BinaryOperationType? = POWEQ 
    { result := BinaryOperationType.POWER }
assignmentOperator:BinaryOperationType? = REMEQ 
    { result := BinaryOperationType.REMAINDER }
assignmentOperator:BinaryOperationType? = ANDEQ 
    { result := BinaryOperationType.AND }
assignmentOperator:BinaryOperationType? = BITWISEANDEQ 
    { result := BinaryOperationType.BITWISE_AND }
assignmentOperator:BinaryOperationType? = OREQ 
    { result := BinaryOperationType.OR }
assignmentOperator:BinaryOperationType? = BITWISEOREQ 
    { result := BinaryOperationType.BITWISE_OR }
assignmentOperator:BinaryOperationType? = XOREQ 
    { result := BinaryOperationType.XOR }
assignmentOperator:BinaryOperationType? = BITWISEXOREQ 
    { result := BinaryOperationType.BITWISE_XOR }
assignmentOperator:BinaryOperationType? = SHIFTLEFTEQ 
    { result := BinaryOperationType.SHIFT_LEFT }
assignmentOperator:BinaryOperationType? = SHIFTRIGHTEQ
    { result := BinaryOperationType.SHIFT_RIGHT }

assertStatement:ASTAssert = ASSERT expression
    { result := ASTAssert(Position(file, parserState.position), expression, null) }
assertStatement:ASTAssert = ASSERT test:expression COLON ^ msg:expression
    { result := ASTAssert(Position(file, parserState.position), test, msg) }

switchStatement:ASTSwitch = SWITCH expression LBRACE switchCases RBRACE ^
    { result := ASTSwitch(Position(file, parserState.position), expression, switchCases, null) }
switchStatement:ASTSwitch = SWITCH expression LBRACE switchCases defaultCase 
        RBRACE ^
    { 
        result := ASTSwitch(Position(file, parserState.position), expression, switchCases, 
                defaultCase) 
    }
switchCases:Array<ASTSwitchCase> = switchCases switchCase
    { 
        result := []
        result.addAll(switchCases)
        result.add(switchCase)
    }
switchCases:Array<ASTSwitchCase> = switchCase
    { result := [switchCase] }
switchCase:ASTSwitchCase = CASE ^ expressionList COLON statementOrBlock
    {
        result := ASTSwitchCase(Position(file, parserState.position), expressionList, 
                statementOrBlock)
    }
defaultCase:ASTStatement = DEFAULT ^ COLON statementOrBlock
    { result := statementOrBlock }

tryStatement:ASTStatement = TRY ^ statementOrBlock catchBlocks
    { result := ASTTry(Position(file, parserState.position), statementOrBlock, catchBlocks, null) }
catchBlocks:Array<ASTCatch> = catchBlocks catchBlock
    { 
        result := []
        result.addAll(catchBlocks)
        result.add(catchBlock)
    }
catchBlocks:Array<ASTCatch> = catchBlock
    { result := [catchBlock] }
catchBlock:ASTCatch = CATCH ^ IDENTIFIER typeDeclaration statementOrBlock
    { 
        result := ASTCatch(CATCH, IDENTIFIER.text, typeDeclaration, 
                statementOrBlock) 
    }

@block:ASTBlock = LBRACE statements RBRACE
    { result := ASTBlock(Position(file, parserState.position), statements) }
@block:ASTBlock = LBRACE RBRACE
    { result := ASTBlock(Position(file, parserState.position), []) }
statements:Array<ASTStatement> = statementList
    { result := statementList }
statements:Array<ASTStatement> = terminalStatement
    { result := [terminalStatement] }
statements:Array<ASTStatement> = statementList terminalStatement
    {
        result := []
        result.addAll(statementList)
        result.add(terminalStatement)
    }
statementList:Array<ASTStatement> = statementList statement
    {
        result := []
        result.addAll(statementList)
        result.add(statement)
    }
statementList:Array<ASTStatement> = statement
    { result := [statement] }

terminalStatement:ASTStatement = returnStatement 
    { result := returnStatement }
terminalStatement:ASTStatement = breakStatement 
    { result := breakStatement }
terminalStatement:ASTStatement = continueStatement 
    { result := continueStatement }
terminalStatement:ASTStatement = throwStatement 
    { result := throwStatement }
terminalStatement:ASTStatement = unreachableStatement 
    { result := unreachableStatement }

returnStatement:ASTReturn = RETURN_TEXT WS
    { result := ASTReturn(Position(file, parserState.position), null) }
returnStatement:ASTReturn = RETURN_TEXT WS_SAMELINE expression ^
    { result := ASTReturn(Position(file, parserState.position), expression) }

breakStatement:ASTBreak = BREAK_TEXT WS
    { result := ASTBreak(Position(file, parserState.position), null) }
breakStatement:ASTBreak = BREAK_TEXT WS_SAMELINE IDENTIFIER ^
    { result := ASTBreak(Position(file, parserState.position), IDENTIFIER.text) }

continueStatement:ASTContinue = CONTINUE_TEXT WS
    { result := ASTContinue(Position(file, parserState.position), null) }
continueStatement:ASTContinue = CONTINUE_TEXT WS_SAMELINE IDENTIFIER ^
    { result := ASTContinue(Position(file, parserState.position), IDENTIFIER.text) }

throwStatement:ASTThrow = THROW ^ expression
    { result := ASTThrow(Position(file, parserState.position), expression) }

unreachableStatement:ASTUnreachable = UNREACHABLE
    { result := ASTUnreachable(Position(file, parserState.position)) }

@type:ASTType = dottedName optionalQuestion
    { 
        result := ASTClassType(Position(file, parserState.position), dottedName, null,
                optionalQuestion) 
    }
@type:ASTType = dottedName genericParameters optionalQuestion
    { 
        result := ASTClassType(Position(file, parserState.position), dottedName,
                genericParameters, optionalQuestion) 
    }
@type:ASTType = LPAREN typeList RPAREN optionalQuestion
    { result := ASTTupleType(Position(file, parserState.position), typeList, optionalQuestion) }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS methodReturnType 
        optionalQuestion
    { 
        result := ASTMethodType(Position(file, parserState.position), optionalTypeList, 
                methodReturnType, true, true, false) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_METHOD methodReturnType 
        optionalQuestion
    { 
        result := ASTMethodType(Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, false, false) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_IMMUTABLE methodReturnType
        optionalQuestion
    { 
        result := ASTMethodType(Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, true, true) 
    }
@type:ASTType = LPAREN optionalTypeList RPAREN YIELDS_METHOD_IMMUTABLE 
        methodReturnType optionalQuestion
    { 
        result := ASTMethodType(Position(file, parserState.position), optionalTypeList, 
                methodReturnType, optionalQuestion, false, true) 
    }
genericParameters:Array<ASTType> = LT typeList GT
    { result := typeList }
typeList:Array<ASTType> = typeList COMMA type
    { 
        result := []
        result.addAll(typeList)
        result.add(type)
    }
typeList:Array<ASTType> = type
    { result := [type] }
optionalTypeList:Array<ASTType> = typeList
    { result := typeList }
optionalTypeList:Array<ASTType> =
    { result := [] }
optionalQuestion:Bit = QUESTION
    { result := true }
optionalQuestion:Bit = 
    { result := false }
methodReturnType:ASTType? = LPAREN RPAREN
    { result := null }
methodReturnType:ASTType? = LPAREN type RPAREN
    { result := type }

@expression:ASTExpression = orExpression
    { result := orExpression }
orExpression:ASTExpression = andExpression 
    { result := andExpression }
orExpression:ASTExpression = orExpression OR andExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.OR, orExpression,
                andExpression)
    }
andExpression:ASTExpression = comparisonExpression 
    { result := comparisonExpression }
andExpression:ASTExpression = andExpression AND comparisonExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.AND, 
                andExpression, comparisonExpression)
    }
andExpression:ASTExpression = andExpression XOR comparisonExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.XOR, 
                andExpression, comparisonExpression)
    }

comparisonExpression:ASTExpression = rangeExpression
    { result := rangeExpression }
comparisonExpression:ASTExpression = comparisonExpression EQ rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression NEQ rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.NOT_EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression IDENTITY 
        rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.IDENTITY, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression NIDENTITY 
        rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.NOT_IDENTITY, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression GT rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.GREATER_THAN, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression LT rangeExpression 
    { 
        result := ASTBinaryExpression(BinaryOperationType.LESS_THAN, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression GTEQ rangeExpression 
    { 
        result := ASTBinaryExpression(
                BinaryOperationType.GREATER_THAN_OR_EQUAL, 
                comparisonExpression, rangeExpression)
    }
comparisonExpression:ASTExpression = comparisonExpression LTEQ rangeExpression 
    { 
        result := ASTBinaryExpression(
                BinaryOperationType.LESS_THAN_OR_EQUAL, 
                comparisonExpression, rangeExpression)
    }

rangeExpression:ASTExpression = additiveExpression
    { result := additiveExpression }
rangeExpression:ASTExpression = DOTDOT
    { result := ASTRangeExpression(Position(file, parserState.position), null, null, null, false) }
rangeExpression:ASTExpression = ELLIPSIS
    { result := ASTRangeExpression(Position(file, parserState.position), null, null, null, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT
    { result := ASTRangeExpression(Position(file, parserState.position), l, null, null, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS
    { result := ASTRangeExpression(Position(file, parserState.position), l, null, null, true) }
rangeExpression:ASTExpression = DOTDOT r:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, r, null, false) }
rangeExpression:ASTExpression = ELLIPSIS r:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, r, null, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT r:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, r, null, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS 
        r:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, r, null, true) }
rangeExpression:ASTExpression = DOTDOT BY s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, null, s, false) }
rangeExpression:ASTExpression = ELLIPSIS BY s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, null, s, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT BY 
        s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, null, s, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS BY 
        s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, null, s, true) }
rangeExpression:ASTExpression = DOTDOT r:additiveExpression BY 
        s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, r, s, false) }
rangeExpression:ASTExpression = ELLIPSIS r:additiveExpression BY 
        s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), null, r, s, true) }
rangeExpression:ASTExpression = l:additiveExpression DOTDOT r:additiveExpression
        BY s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, r, s, false) }
rangeExpression:ASTExpression = l:additiveExpression ELLIPSIS 
        r:additiveExpression BY s:additiveExpression
    { result := ASTRangeExpression(Position(file, parserState.position), l, r, s, true) }

additiveExpression:ASTExpression = multiplicativeExpression
    { result := multiplicativeExpression }
additiveExpression:ASTExpression = additiveExpression ADD 
        multiplicativeExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.ADD, 
                additiveExpression, multiplicativeExpression) 
    }
additiveExpression:ASTExpression = additiveExpression SUB 
        multiplicativeExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.SUBTRACT, 
                additiveExpression, multiplicativeExpression) 
    }
additiveExpression:ASTExpression = additiveExpression BITWISEOR
        multiplicativeExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.BITWISE_OR, 
                additiveExpression, multiplicativeExpression) 
    }

multiplicativeExpression:ASTExpression = unaryExpression
    { result := unaryExpression }
multiplicativeExpression:ASTExpression = multiplicativeExpression MUL
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.MULTIPLY, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression DIV
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.DIVIDE, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression INTDIV
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.INT_DIVIDE, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression REM
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.REMAINDER, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression SHIFTLEFT
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.SHIFT_LEFT, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression SHIFTRIGHT
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.SHIFT_RIGHT, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression BITWISEAND
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.BITWISE_AND, 
                multiplicativeExpression, unaryExpression) 
    }
multiplicativeExpression:ASTExpression = multiplicativeExpression BITWISEXOR
        unaryExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.BITWISE_XOR, 
                multiplicativeExpression, unaryExpression) 
    }

unaryExpression:ASTExpression = exponentExpression
    { result := exponentExpression }
unaryExpression:ASTExpression = SUB exponentExpression
    { 
        result := ASTUnaryExpression(Position(file, parserState.position), 
                UnaryOperationType.MINUS, exponentExpression) 
    }
unaryExpression:ASTExpression = NOT exponentExpression
    { 
        result := ASTUnaryExpression(Position(file, parserState.position), UnaryOperationType.NOT,
                exponentExpression) 
    }
unaryExpression:ASTExpression = BITWISENOT exponentExpression
    { 
        result := ASTUnaryExpression(Position(file, parserState.position), 
                UnaryOperationType.BITWISE_NOT, exponentExpression) 
    }

exponentExpression:ASTExpression = callExpression
    { result := callExpression }
exponentExpression:ASTExpression = callExpression POW exponentExpression
    { 
        result := ASTBinaryExpression(BinaryOperationType.POWER, 
                callExpression, exponentExpression)
    }

callExpression:ASTExpression = term
    { result := term }
callExpression:ASTExpression = methodCall
    { result := methodCall }
callExpression:ASTExpression = callExpression LBRACKET expression RBRACKET
    { result := ASTIndex(callExpression, expression) }
callExpression:ASTExpression = callExpression LT typeList GT
    { 
        if callExpression-?>ASTDotExpression | callExpression-?>ASTIdentifier {
            result := ASTClassLiteral(ASTClassType(
                    callExpression.position, callExpression.convert(), typeList,
                    false))
        }
        else
            return Parser.DIE
    }
callExpression:ASTExpression = callExpression DOT IDENTIFIER
    { result := ASTDotExpression(callExpression, IDENTIFIER.text) }
callExpression:ASTExpression = callExpression DOT specialMethodName
    { result := ASTDotExpression(callExpression, specialMethodName) }
callExpression:ASTExpression = callExpression DOT CLASS
    { result := ASTDotExpression(callExpression, "$class") }
callExpression:ASTExpression = callExpression DOT INIT
    { result := ASTDotExpression(callExpression, "init") }
callExpression:ASTExpression = callExpression INSTANCEOF typeExpression
    { 
        result := ASTArrowExpression(ArrowOperationType.INSTANCE_OF,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression NINSTANCEOF typeExpression
    { 
        result := ASTArrowExpression(ArrowOperationType.NOT_INSTANCE_OF,
                callExpression, typeExpression) 
    }
callExpression:ASTExpression = callExpression CAST typeExpression
    { 
        result := ASTArrowExpression(ArrowOperationType.CAST,
                callExpression, typeExpression) 
    }
typeExpression:ASTType = type
    { result := type }
typeExpression:ASTType = LPAREN type RPAREN
    { result := type }

parameters:Array<ASTExpression> = LPAREN expressionList RPAREN
    { result := expressionList }
parameters:Array<ASTExpression> = LPAREN RPAREN
    { result := [] }
expressionList:Array<ASTExpression> = expressionList COMMA expression
    { 
        result := [] 
        result.addAll(expressionList)
        result.add(expression)
    }
expressionList:Array<ASTExpression> = expression
    { result := [expression] }

term:ASTExpression = IDENTIFIER
    { result := ASTIdentifier(IDENTIFIER.position, IDENTIFIER.text) }
term:ASTExpression = INTEGER
    { result := INTEGER }
term:ASTExpression = STRING
    { result := STRING }
term:ASTExpression = REAL
    { result := REAL }
term:ASTExpression = TRUE
    { result := ASTBitLiteral(TRUE, true) }
term:ASTExpression = FALSE
    { result := ASTBitLiteral(FALSE, false) }
term:ASTExpression = NULL
    { result := ASTNullLiteral(NULL) }
term:ASTExpression = SELF
    { result := ASTSelf(SELF) }
term:ASTExpression = SUPER
    { result := ASTSuper(SUPER) }
term:ASTExpression = CLASS
    { result := ASTDotExpression(ASTSelf(CLASS), "$class") }
term:ASTExpression = LPAREN expressionList RPAREN
    {  
        if expressionList.length = 1
            result := expressionList[0]
        else
            result := ASTTupleExpression(Position(file, parserState.position), expressionList)
    }
term:ASTExpression = LBRACKET expressionList RBRACKET
    { result := ASTArrayLiteral(Position(file, parserState.position), expressionList) }
term:ASTExpression = LBRACKET RBRACKET
    { result := ASTArrayLiteral(Position(file, parserState.position), []) }
term:ASTExpression = lambda
    { result := lambda }
term:ASTExpression = methodValue
    { result := methodValue }
term:ASTExpression = '/' regex '/' WS
    { result := ASTRegex(Position(file, parserState.position), regex) }
term:ASTExpression = PRE LPAREN expression RPAREN
    { result := ASTPre(Position(file, parserState.position), expression) }
term:ASTExpression = ATRETURN
    { result := ASTAtReturn(Position(file, parserState.position)) }

regex:String = regexTerm
    { result := regexTerm }
regex:String = regexTerm '|' regex
    { result := regexTerm + "|" + regex }
regexTerm:String = regexFactor
    { result := regexFactor }
regexTerm:String = regexTerm regexFactor
    { result := regexTerm + regexFactor }
regexFactor:String = regexAtom
    { result := regexAtom }
regexFactor:String = regexAtom regexQuantifier
    { result := regexAtom + regexQuantifier }
regexAtom:String = regexCharacter
    { result := regexCharacter }
regexAtom:String = char:[.^$]
    { result := char }
regexAtom:String = '(' regex ')'
    { result := "(" + regex + ")" }
regexAtom:String = '(?' type:[:=!>] regex ')'
    { result := "(?" + type + regex + ")" }
regexAtom:String = '(?<' type:[!=] regex ')'
    { result := "(?<" + type + regex + ")" }
regexAtom:String = '[' regexCharClass ']'
    { result := "[" + regexCharClass + "]" }
regexAtom:String = '[^' regexCharClass ']'
    { result := "[^" + regexCharClass + "]" }
regexCharClass:String = regexRange
    { result := regexRange }
regexCharClass:String = regexCharClass regexRange
    { result := regexCharClass + regexRange }
regexRange:String = regexRangeCharacter
    { result := regexRangeCharacter }
regexRangeCharacter:String = char:[/|()[{^$*+?.]
    { result := char }
regexRangeCharacter:String = regexCharacter
    { result := regexCharacter }
regexRangeCharacter:String = begin:regexRangeCharacter '-' end:regexRangeCharacter
    { result := begin + "-" + end }
regexCharacter:String = char:[-!"#%&',:;<=>@_`~0-9A-Za-z ]
    { result := char.convert() }
regexCharacter:String = '\\' char:[-!"#%&',/:;<=>@_`~0-9A-Za-z \\|()[\]{}^$*+?.]
    { result := "\\" + char }
regexQuantifier:String = regexQuantifierBase
    { result := regexQuantifierBase }
regexQuantifier:String = regexQuantifierBase modifier:[+?]
    { result := regexQuantifierBase + modifier }
regexQuantifierBase:String = char:[*+?]
    { result := char.convert() }
regexQuantifierBase:String = '{' regexInt '}'
    { result := "{" + regexInt + "}" }
regexQuantifierBase:String = '{' regexInt ',}'
    { result := "{" + regexInt + ",}" }
regexQuantifierBase:String = '{' min:regexInt ',' max:regexInt '}'
    { result := "{" + min + "," + max + "}" }
regexInt:String = DECIMAL_CHAR
    { result := DECIMAL_CHAR.convert() }
regexInt:String = regexInt DECIMAL_CHAR
    { result := regexInt + DECIMAL_CHAR }

lambda:ASTExpression = lambdaParameters YIELDS expression
    { 
        result := ASTLambdaExpression(Position(file, parserState.position), lambdaParameters, 
                expression) 
    }
lambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER
    { 
        result := [ASTTypedIdentifier(IDENTIFIER.position, IDENTIFIER.text,
                null)]
    }
lambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER COLON type
    { 
        result := [ASTTypedIdentifier(IDENTIFIER.position, IDENTIFIER.text,
                type)]
    }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN RPAREN
    { result := [] }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN untypedLambdaParameters 
        RPAREN
    { result := untypedLambdaParameters }
lambdaParameters:Array<ASTTypedIdentifier> = LPAREN typedLambdaParameters RPAREN
    { result := typedLambdaParameters }
untypedLambdaParameters:Array<ASTTypedIdentifier> = untypedLambdaParameters 
        COMMA IDENTIFIER
    { 
        result := []
        result.addAll(untypedLambdaParameters)
        result.add(ASTTypedIdentifier(IDENTIFIER.position, IDENTIFIER.text,
                null))
    }
untypedLambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER
    {  
        result := [ASTTypedIdentifier(IDENTIFIER.position, IDENTIFIER.text,
                null)]
    }
typedLambdaParameters:Array<ASTTypedIdentifier> = typedLambdaParameters 
        COMMA IDENTIFIER COLON type
    { 
        result := []
        result.addAll(typedLambdaParameters)
        result.add(ASTTypedIdentifier(IDENTIFIER.position, IDENTIFIER.text,
                type))
    }
typedLambdaParameters:Array<ASTTypedIdentifier> = IDENTIFIER COLON type
    {  
        result := [ASTTypedIdentifier(IDENTIFIER.position, IDENTIFIER.text,
                type)]
    }

@methodValue:ASTMethodValue = METHOD formalParameters ^ optionalTypeDeclaration 
        block
    {
        result := ASTMethodValue(METHOD, MethodNodeType.METHOD, 
                formalParameters, optionalTypeDeclaration, block)
    }
@methodValue:ASTMethodValue = FUNCTION formalParameters ^ 
        optionalTypeDeclaration block
    {
        result := ASTMethodValue(FUNCTION, MethodNodeType.FUNCTION, 
                formalParameters, optionalTypeDeclaration, block)
    }


IDENTIFIER:Identifier = identifierContents WS
    {
        if ParserUtil.KEYWORDS.contains(identifierContents.text)
            return Parser.DIE
        else
            result := identifierContents
    }
identifierContents:Identifier = identifierText
    { 
        result := Identifier(identifierText, Position(file, 
                parserState.position - identifierText.length))
    }
identifierText:String = identifierStart identifierChars ![A-Za-z_$0-9]
    { result := identifierStart + identifierChars }
identifierText:String = identifierStart ![A-Za-z_$0-9]
    { result := identifierStart }
identifierStart:String = char:[a-zA-Z_$]
    { result := char }
identifierChars:String = identifierChars identifierChar
    { result := identifierChars + identifierChar }
identifierChars:String = identifierChar
    { result := identifierChar }
identifierChar:String = char:[a-zA-Z_$0-9]
    { result := char }

INTEGER:ASTIntegerLiteral = DECIMAL_TEXT WS
    { result := ASTIntegerLiteral(Position(file, parserState.position), DECIMAL_TEXT.convert()) }
INTEGER:ASTIntegerLiteral = '0x' HEX_TEXT WS
    { result := ASTIntegerLiteral(Position(file, parserState.position), ParserUtil.parseInt(HEX_TEXT, 16)) }
INTEGER:ASTIntegerLiteral = '0b' BINARY_TEXT WS
    { 
        result := ASTIntegerLiteral(Position(file, parserState.position), ParserUtil.parseInt(BINARY_TEXT, 
                2)) 
    }
DECIMAL_TEXT:String = DECIMAL_CHARS ![A-Za-z_$0-9]
    { result := DECIMAL_CHARS }
DECIMAL_CHARS:String = DECIMAL_CHARS DECIMAL_CHAR
    { result := DECIMAL_CHARS + DECIMAL_CHAR }
DECIMAL_CHARS:String = DECIMAL_CHAR
    { result := DECIMAL_CHAR }
DECIMAL_CHAR:String = digit:[0-9]
    { result := digit }
HEX_TEXT:String = HEX_CHARS ![A-Za-z_$0-9]
    { result := HEX_CHARS }
HEX_CHARS:String = HEX_CHARS HEX_CHAR
    { result := HEX_CHARS + HEX_CHAR }
HEX_CHARS:String = HEX_CHAR
    { result := HEX_CHAR }
HEX_CHAR:String = digit:[0-9A-Fa-f]
    { result := digit }
BINARY_TEXT:String = BINARY_CHARS ![A-Za-z_$0-9]
    { result := BINARY_CHARS }
BINARY_CHARS:String = BINARY_CHARS BINARY_CHAR
    { result := BINARY_CHARS + BINARY_CHAR }
BINARY_CHARS:String = BINARY_CHAR
    { result := BINARY_CHAR }
BINARY_CHAR:String = digit:[01]
    { result := digit }

REAL:ASTRealLiteral = '.' DECIMAL_TEXT WS
    { 
        result := ASTRealLiteral(Position(file, parserState.position), ("." + 
            DECIMAL_TEXT).convert())
    }
REAL:ASTRealLiteral = '.' DECIMAL_CHARS EXPONENT WS
    { 
        result := ASTRealLiteral(Position(file, parserState.position), ("." + 
            DECIMAL_CHARS + EXPONENT).convert())
    }
REAL:ASTRealLiteral = d1:DECIMAL_CHARS '.' d2:DECIMAL_TEXT WS
    { result := ASTRealLiteral(Position(file, parserState.position), (d1 + "." + d2).convert()) }
REAL:ASTRealLiteral = DECIMAL_CHARS EXPONENT WS
    { 
        result := ASTRealLiteral(Position(file, parserState.position), (DECIMAL_CHARS + 
                EXPONENT).convert()) 
    }
REAL:ASTRealLiteral = d1:DECIMAL_CHARS '.' d2:DECIMAL_CHARS EXPONENT WS
    { 
        result := ASTRealLiteral(Position(file, parserState.position), (d1 + "." + d2 + 
                EXPONENT).convert())
    }
EXPONENT:String = [eE] DECIMAL_TEXT
    { result := "e" + DECIMAL_TEXT }
EXPONENT:String = [eE] sign:[+-] DECIMAL_TEXT
    { result := "e" + sign + DECIMAL_TEXT }

STRING:ASTStringLiteral = STRING_SINGLE ^ WS
    { result := STRING_SINGLE }
STRING:ASTStringLiteral = STRING_DOUBLE ^ WS
    { result := STRING_DOUBLE }
STRING_SINGLE:ASTStringLiteral = ['] STRING_CHARS_SINGLE [']
    { result := ASTStringLiteral(Position(file, parserState.position), STRING_CHARS_SINGLE) }
STRING_CHARS_SINGLE:String = STRING_CHARS_SINGLE STRING_CHAR_SINGLE
    { result := STRING_CHARS_SINGLE + STRING_CHAR_SINGLE }
STRING_CHARS_SINGLE:String = 
    { result := "" }
STRING_CHAR_SINGLE:String = char:[^'\\\n\r]
    { result := char }
STRING_CHAR_SINGLE:String = ESCAPE
    { result := ESCAPE }
STRING_DOUBLE:ASTStringLiteral = ["] STRING_CHARS_DOUBLE ["]
    { result := ASTStringLiteral(Position(file, parserState.position), STRING_CHARS_DOUBLE) }
STRING_CHARS_DOUBLE:String = STRING_CHARS_DOUBLE STRING_CHAR_DOUBLE
    { result := STRING_CHARS_DOUBLE + STRING_CHAR_DOUBLE }
STRING_CHARS_DOUBLE:String = 
    { result := "" }
STRING_CHAR_DOUBLE:String = char:[^"\\\n\r]
    { result := char }
STRING_CHAR_DOUBLE:String = ESCAPE
    { result := ESCAPE }
ESCAPE:String = '\\' char:[nrt'":\\]
    { result := '\\' + char }
ESCAPE:String = '\\{' formatExpression '}'
    { result := "\\{" + formatExpression + "}" }
@formatExpression:ASTFormatExpression = expression optionalField 
        optionalFormatString
    { 
        if optionalField != null {
            result := ASTFormatExpression(expression, optionalFormatString,
                    optionalField.fillChar, optionalField.alignment, 
                    optionalField.width)
        }
        else {
            result := ASTFormatExpression(expression, optionalFormatString,
                    null, null, null)
        }
    }
optionalField:FormatField? = COMMA optionalFillChar alignment DECIMAL_CHARS
    { 
        result := FormatField(optionalFillChar, alignment, 
                DECIMAL_CHARS.convert()) 
    }
optionalField:FormatField? =
    { result := null }
optionalFillChar:Char = char:[^:\n\r\\]
    { result := char[0] }
optionalFillChar:Char = ESCAPE
    { result := ParserUtil.unescape(ESCAPE)[0] }
optionalFillChar:Char =
    { result := " " }
alignment:Alignment = '<'
    { result := Alignment.LEFT }
alignment:Alignment = '^'
    { result := Alignment.CENTER }
alignment:Alignment = '>'
    { result := Alignment.RIGHT }
formatString:String = formatString char:[^\\}]
    { result := formatString + char }
formatString:String = char:[^\\}]
    { result := char }
optionalFormatString:String? = COLON formatString
    { result := formatString }
optionalFormatString:String? =
    { result := null }

PACKAGE_TEXT:Position = 'package' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 7) }
PACKAGE:Position = PACKAGE_TEXT WS
    { result := PACKAGE_TEXT }
CLASS_TEXT:Position = 'class' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
CLASS:Position = CLASS_TEXT WS
    { result := CLASS_TEXT }
INTERFACE_TEXT:Position = 'interface' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 9) }
INTERFACE:Position = INTERFACE_TEXT WS
    { result := INTERFACE_TEXT }
ENUM_TEXT:Position = 'enum' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
ENUM:Position = ENUM_TEXT WS
    { result := ENUM_TEXT }
USES_TEXT:Position = 'uses' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
USES:Position = USES_TEXT WS
    { result := USES_TEXT }
AS_TEXT:Position = 'as' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 2) }
AS:Position = AS_TEXT WS
    { result := AS_TEXT }
METHOD_TEXT:Position = 'method' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 6) }
METHOD:Position = METHOD_TEXT WS
    { result := METHOD_TEXT }
FUNCTION_TEXT:Position = 'function' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 7) }
FUNCTION:Position = FUNCTION_TEXT WS
    { result := FUNCTION_TEXT }
INIT_TEXT :Position= 'init' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
INIT:Position = INIT_TEXT WS
    { result := INIT_TEXT }
VAR_TEXT:Position = 'var' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 3) }
VAR:Position = VAR_TEXT WS
    { result := VAR_TEXT }
DEF_TEXT:Position = 'def' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 3) }
DEF:Position = DEF_TEXT WS
    { result := DEF_TEXT }
CONSTANT_TEXT:Position = 'constant' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 8) }
CONSTANT:Position = CONSTANT_TEXT WS
    { result := CONSTANT_TEXT }
PROPERTY_TEXT:Position = 'property' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 8) }
PROPERTY:Position = PROPERTY_TEXT WS 
    { result := PROPERTY_TEXT }
PROTECTED_TEXT:Position = '@protected' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 10) }
PROTECTED:Position = PROTECTED_TEXT WS
    { result := PROTECTED_TEXT }
PRIVATE_TEXT:Position = '@private' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 8) }
PRIVATE:Position = PRIVATE_TEXT WS
    { result := PRIVATE_TEXT }
ATCLASS_TEXT:Position = '@class' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 6) }
ATCLASS:Position = ATCLASS_TEXT WS
    { result := ATCLASS_TEXT }
THREAD_TEXT:Position = '@thread' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 7) }
THREAD:Position = THREAD_TEXT WS
    { result := THREAD_TEXT }
ABSTRACT_TEXT:Position = '@abstract' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 9) }
ABSTRACT:Position = ABSTRACT_TEXT WS
    { result := ABSTRACT_TEXT }
EXTERNAL_TEXT:Position = '@external' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 9) }
EXTERNAL:Position = EXTERNAL_TEXT WS
    { result := EXTERNAL_TEXT }
OVERRIDE_TEXT:Position = '@override' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 9) }
OVERRIDE:Position = OVERRIDE_TEXT WS
    { result := OVERRIDE_TEXT }
READONLY_TEXT:Position = '@readonly' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 9) }
READONLY:Position = READONLY_TEXT WS
    { result := READONLY_TEXT }
LIMITED_TEXT:Position = '@limited' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 8) }
LIMITED:Position = LIMITED_TEXT WS
    { result := LIMITED_TEXT }
ATSELF_TEXT:Position = '@self' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
ATSELF:Position = ATSELF_TEXT WS
    { result := ATSELF_TEXT }
SAFERETURN_TEXT:Position = '@safeReturn' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 11) }
SAFERETURN:Position = SAFERETURN_TEXT WS
    { result := SAFERETURN_TEXT }
UNSAFEFUNCTION_TEXT:Position = '@unsafeFunction' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 15) }
UNSAFEFUNCTION:Position = UNSAFEFUNCTION_TEXT WS
    { result := UNSAFEFUNCTION_TEXT }
FINAL_TEXT:Position = '@final' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 6) }
FINAL:Position = FINAL_TEXT WS
    { result := FINAL_TEXT }
WRAPPER_METHOD = '@$wrapperMethod' WS
MATH_TEXT:Position = '@math' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
MATH:Position = MATH_TEXT WS
    { result := MATH_TEXT }
OVERFLOW_TEXT = 'overflow' ![A-Za-z_$0-9]
OVERFLOW = OVERFLOW_TEXT WS
INVARIANT_TEXT:Position = '@invariant' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 10) }
INVARIANT:Position = INVARIANT_TEXT WS
    { result := INVARIANT_TEXT }
INSTANCE = '@$instance' WS
PRE_TEXT:Position = '@pre' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
PRE:Position = PRE_TEXT WS
    { result := PRE_TEXT }
POST_TEXT:Position= '@post' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
POST:Position = POST_TEXT WS
    { result := POST_TEXT }
PRE_OR_TEXT:Position= '@preOr' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 6) }
PRE_OR:Position = PRE_OR_TEXT WS
    { result := PRE_OR_TEXT }
POST_AND_TEXT:Position= '@postAnd' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 8) }
POST_AND:Position = POST_AND_TEXT WS
    { result := POST_AND_TEXT }
ATRETURN_TEXT:Position = '@return' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 7) }
ATRETURN:Position = ATRETURN_TEXT WS
    { result := ATRETURN_TEXT }
TRUE_TEXT:Position = 'true' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
TRUE:Position = TRUE_TEXT WS
    { result := TRUE_TEXT }
FALSE_TEXT:Position = 'false' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
FALSE:Position = FALSE_TEXT WS
    { result := FALSE_TEXT }
NULL_TEXT:Position = 'null' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
NULL:Position = NULL_TEXT WS
    { result := NULL_TEXT }
SELF_TEXT:Position = 'self' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
SELF:Position = SELF_TEXT WS
    { result := SELF_TEXT }
SUPER_TEXT:Position = 'super' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
SUPER:Position = SUPER_TEXT WS
    { result := SUPER_TEXT }
BY_TEXT:Position = 'by' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 2) }
BY:Position = BY_TEXT WS
    { result := BY_TEXT }
FOR_TEXT:Position = 'for' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 3) }
FOR:Position = FOR_TEXT WS
    { result := FOR_TEXT }
IN_TEXT:Position = 'in' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 2) }
IN:Position = IN_TEXT WS
    { result := IN_TEXT }
WHILE_TEXT:Position = 'while' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
WHILE:Position = WHILE_TEXT WS
    { result := WHILE_TEXT }
DO_TEXT:Position = 'do' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 2) }
DO:Position = DO_TEXT WS
    { result := DO_TEXT }
LOOP_TEXT:Position = 'loop' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
LOOP:Position = LOOP_TEXT WS
    { result := LOOP_TEXT }
IF_TEXT:Position = 'if' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 2) }
IF:Position = IF_TEXT WS
    { result := IF_TEXT }
ELSE_TEXT:Position = 'else' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
ELSE:Position = ELSE_TEXT WS
    { result := ELSE_TEXT }
SWITCH_TEXT:Position = 'switch' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 6) }
SWITCH:Position = SWITCH_TEXT WS
    { result := SWITCH_TEXT }
CASE_TEXT:Position = 'case' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 4) }
CASE:Position = CASE_TEXT WS
    { result := CASE_TEXT }
DEFAULT_TEXT:Position = 'default' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 7) }
DEFAULT:Position = DEFAULT_TEXT WS
    { result := DEFAULT_TEXT }
RETURN_TEXT:Position = 'return' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 6) }
CONTINUE_TEXT:Position = 'continue' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 8) }
BREAK_TEXT:Position = 'break' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
ASSERT_TEXT:Position = 'assert' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 6) }
ASSERT:Position = ASSERT_TEXT WS
    { result := ASSERT_TEXT }
UNREACHABLE_TEXT:Position = 'unreachable' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 11) }
UNREACHABLE:Position = UNREACHABLE_TEXT WS
    { result := UNREACHABLE_TEXT }
TRY_TEXT:Position = 'try' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 3) }
TRY:Position = TRY_TEXT WS
    { result := TRY_TEXT }
CATCH_TEXT:Position = 'catch' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
CATCH:Position = CATCH_TEXT WS
    { result := CATCH_TEXT }
THROW_TEXT:Position = 'throw' ![A-Za-z_$0-9]
    { result := Position(file, parserState.position - 5) }
THROW:Position = THROW_TEXT WS
    { result := THROW_TEXT }
COLON = ':' WS
LBRACKET = '[' WS
RBRACKET = ']' WS
LBRACE = '{' WS
RBRACE = '}' WS
LPAREN = '(' WS
RPAREN = ')' WS
ADD = '+' WS
SUB = '-' WS
MUL = '*' WS
DIV = '/' WS
REM = '%' WS
INTDIV = '//' WS
AND = '&' WS
OR = '|' WS
XOR = '~' WS
SHIFTLEFT = '<<' WS
SHIFTRIGHT = '>>' WS
BITWISEAND = '&&' WS
BITWISEOR = '||' WS
BITWISEXOR = '~~' WS
POW = '^' WS
EQ = '=' WS
NEQ = '!=' WS
LT = '<' WS
GT = '>' WS
LTEQ = '<=' WS
GTEQ = '>=' WS
IDENTITY = '==' WS
NIDENTITY = '!==' WS
NOT = '!' WS
BITWISENOT = '!!' WS
ASSIGNMENT = ':=' WS
ADDEQ = '+=' WS 
SUBEQ = '-=' WS
MULEQ = '*=' WS 
DIVEQ = '/=' WS 
INTDIVEQ = '//=' WS 
POWEQ = '^=' WS 
REMEQ = '%=' WS 
ANDEQ = '&=' WS 
BITWISEANDEQ = '&&=' WS 
OREQ = '|=' WS 
BITWISEOREQ = '||=' WS 
XOREQ = '~=' WS 
BITWISEXOREQ = '~~=' WS 
SHIFTLEFTEQ = '<<=' WS 
SHIFTRIGHTEQ = '>>=' WS 
CAST = '->' WS
INSTANCEOF = '-?>' WS
NINSTANCEOF = '-!>' WS
COMMA  = ',' WS
STAR = '*' WS
DOT = '.' WS
DOTDOT = '..' WS
ELLIPSIS = '...' WS
QUESTION = '?' WS
YIELDS = '=>' WS
YIELDS_METHOD = '=&>' WS
YIELDS_IMMUTABLE = '=>*' WS
YIELDS_METHOD_IMMUTABLE = '=&>*' WS

WS = WS WS_CHAR
WS =
WS_CHAR = [ \r\n\t]
WS_CHAR = COMMENT
WS_SAMELINE = WS_SAMELINE WS_SAMELINE_CHAR
WS_SAMELINE =
WS_SAMELINE_CHAR = [ \t]
WS_SAMELINE_CHAR = SINGLE_LINE_BLOCK_COMMENT
COMMENT = LINE_COMMENT
COMMENT = BLOCK_COMMENT
LINE_COMMENT = '--' LINE_COMMENT_CHARS [\n]
LINE_COMMENT_CHARS = LINE_COMMENT_CHARS [^\n]
LINE_COMMENT_CHARS =
TRAILING_LINE_COMMENT = '--' LINE_COMMENT_CHARS
BLOCK_COMMENT = '-*' BLOCK_COMMENT_CHARS '*-'
BLOCK_COMMENT_CHARS = BLOCK_COMMENT_CHARS BLOCK_COMMENT_CHAR
BLOCK_COMMENT_CHARS =
BLOCK_COMMENT_CHAR = [^*]
BLOCK_COMMENT_CHAR = '*' [^-]
BLOCK_COMMENT_CHAR = BLOCK_COMMENT
SINGLE_LINE_BLOCK_COMMENT = '-*' SINGLE_LINE_BLOCK_COMMENT_CHARS '*-'
SINGLE_LINE_BLOCK_COMMENT_CHARS = SINGLE_LINE_BLOCK_COMMENT_CHARS 
        SINGLE_LINE_BLOCK_COMMENT_CHAR
SINGLE_LINE_BLOCK_COMMENT_CHARS =
SINGLE_LINE_BLOCK_COMMENT_CHAR = [^*\n\r]
SINGLE_LINE_BLOCK_COMMENT_CHAR = '*' [^-]
SINGLE_LINE_BLOCK_COMMENT_CHAR = SINGLE_LINE_BLOCK_COMMENT
DOCCOMMENT:String = '===' TRAILING_EQUALS DOCCOMMENT_CHARS '===' TRAILING_EQUALS
        WS
    { result := DOCCOMMENT_CHARS }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHARS DOCCOMMENT_CHAR
    { result := DOCCOMMENT_CHARS + DOCCOMMENT_CHAR }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHAR
    { result := DOCCOMMENT_CHAR }
DOCCOMMENT_CHAR:String = char:[^=]
    { result := char }
DOCCOMMENT_CHAR:String = '=' char:[^=]
    { result := "=" + char }
DOCCOMMENT_CHAR:String = '==' char:[^=]
    { result := "==" + char }
TRAILING_EQUALS = TRAILING_EQUALS_CHARS
TRAILING_EQUALS =
TRAILING_EQUALS_CHARS = TRAILING_EQUALS_CHARS '='
TRAILING_EQUALS_CHARS = '='
