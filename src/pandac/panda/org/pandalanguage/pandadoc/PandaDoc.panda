package org.pandalanguage.pandac.pandadoc

uses org.pandalanguage.pandac.compiler.CodeGenerator
uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.compiler.XMLWriter
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNodeType
uses org.pandalanguage.pandac.parser.TokenNode
uses org.pandalanguage.pandac.parser.TokenType
uses org.pandalanguage.pandac.transformers.SafetyChecker
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType

class DocComment {
    def owner:Node
    def summary:String
    def longDescription:String
    def params:Map<String, String> := new GenericHashMap<String, String>()
    def see := new PrimitiveArray<String>()
    var returnDoc:String?
    
    constructor(owner:Node, rawText:String, engine:PandaDoc) {
        self.owner := owner
        def text := rawText->>(MutableString)
        -- extract tags
        var start:Int? := 0
        loop {
            start := nextTag(text->>(String), start)
            if start = null
                break
            var end := nextTag(text->>(String), start + 1)
            if end = null
                end := text.length
            processTag(text[start .. end], engine)
            text.remove(start, end)
        }
        def dot := text.indexOf(".")
        if dot != null {
            summary := text[0 .. dot + 1].trim()
            longDescription := text->>(String).trim()
        }
        else {
            summary := text->>(String).trim()
            longDescription := summary
        }
    }
    
    function nextTag(text:String, var start:Int):Int? {
        var next:Int? := start
        while next < text.length {
            next := text.indexOf("@", start)
            if next = null
                break
            if substringMatches(text, next, "@param ") |
                    substringMatches(text, next, "@returns ") |
                    substringMatches(text, next, "@see ") |
                    substringMatches(text, next, "@copy ") {
                return next
            }
            start := next + 1
        }
        return null
    }

    method processTag(var tag:String, engine:PandaDoc) {
        if tag.startsWith("@param ") {
            tag := tag["@param ".length..]
            def space := tag.indexOf(" ")
            assert space != null
            def name := tag[0 .. space]
            def desc := tag[space + 1..]
            params[name] := desc
        }
        else if tag.startsWith("@returns ")
            returnDoc := tag["@returns ".length..]
        else if tag.startsWith("@see ") {
            var link := tag["@see ".length..].trim
            see.append(link)
        }
    }
    
    function substringMatches(text:String, start:Int, 
                search:String):Bit {
        return(text.length > start + search.length & 
                text[start .. start + search.length] = search)
    }
}

================================================================================
Documentation generator which scans source files for doccomments and generates
XML documentation from them.

Please note that while PandaDoc will eventually be general-purpose, right this 
second it only has one "customer" (the Panda API documentation) and thus has
gotten a bit locked into this one use case. It definitely needs some more
flexibility about site layouts, stylesheets, etc.
================================================================================
class PandaDoc (CodeGenerator) {
    var showSource := true

    var xml := new MarkdownXMLWriter(new MemoryOutputStream()) -- dummy value

    var currentPosition:Position := Position.INTERNAL

    var currentClass:ClassNode?

    @override
    function defaultExtension():String? {
        return null
    }

    @private
    @unsafeFunction -- SymbolTable.getType() is a method, but it's ok here
    function resolveType(name:String):Type {
        def symbolTable := currentClass->(ClassNode).symbolTable
        def result := symbolTable.getType(currentPosition, name)
        if result-?>(UnresolvedType) {
            throw new CompilerException("could not resolve link '\{name}'",
                    currentPosition)
        }
        return result
    }

    @private
    @unsafeFunction
    function parseTypes(types:String):PrimitiveArray<Type> {
        def result := new PrimitiveArray<Type>()
        def nodes := new PandaParser().parseTypes(types, currentPosition)
        assert nodes[0]->(TokenNode).token.type = TokenType.LPAREN
        def cl := currentClass
        assert cl != null
        for i in 1 .. nodes.length - 1 by 2 {
            assert nodes[i].type = ParseNodeType.TYPE
            def type := cl.symbolTable.getType(currentPosition,
                    nodes[i]->>(String))
            if type-?>(UnresolvedType) {
                throw new CompilerException(
                        "could not resolve type '\{type.name}'", 
                        currentPosition)
            }
            result.append(type)
        }
        assert nodes[nodes.length - 1]->(TokenNode).token.type = 
                TokenType.RPAREN
        return result
    }

    @private
    function resolveField(context:ClassNode, name:String):FieldNode? {
        for f in context.fields {
            if f.name = name
                return f
        }
        if context.superclass != null
            return resolveField(context.superclass->(ClassNode), name)
        return null
    }

    @private
    function resolveMethod(context:ClassNode, name:String):MethodNode? {
        var match:MethodNode? := null
        def paren := name.indexOf("(")
        if paren != null {
            def methodName := name[0 .. paren]
            def colon := name.indexOf(":", paren)
            def typesString:String
            def returnType:Type?
            if colon != null {
                typesString := name[paren .. colon]
                returnType := resolveType(name[colon + 1..])
            }
            else {
                typesString := name[paren..]
                returnType := null
            }
            def types := parseTypes(typesString)
            outer: for m in context.methods {
                if m.name != methodName
                    continue
                def start:Int
                if m.annotations.isClass
                    start := 0
                else
                    start := 1
                if types.length != m.parameters.length - start
                    continue
                for i, p in m.parameters {
                    if i < start
                        continue
                    if p.type != types[i - start]
                        continue outer
                }
                if returnType != null & m.returnType != returnType
                    continue
                match := m
                break
            }
        }
        else {
            for m in context.methods {
                if m.name = name {
                    if match != null {
                        throw new CompilerException("reference to " +
                                "\{context.name}.\{name} is ambiguous, " +
                                "specify parameters to disambiguate", 
                                currentPosition)
                    }
                    match := m
                }
            }
        }
        if match != null
            return match
        if context.superclass != null
            return resolveMethod(context.superclass->(ClassNode), name)
        return null
    }

    @private
    function linkTo(cl:ClassNode):String {
        return linkTo(cl, false)
    }

    @private
    @unsafeFunction
    function linkTo(cl:ClassNode, source:Bit):String {
        def name := cl.type().displayName
        if source {
            return (name.split(".").length - 1) * "../" + "source/" +
                    name.replace(".", "/") + ".html"
        }
        else {
            return (name.split(".").length - 1) * "../" + 
                    name.replace(".", "/") + ".html"
        }
    }

    @private
    function linkTo(type:Type):String {
        return linkTo(type, false)
    }

    @private
    @unsafeFunction
    function linkTo(type:Type, source:Bit):String {
        if type.isMethod
            return linkTo(ClassType.METHOD(), source)
        else {
            if type.isPrimitive
                return linkTo(type->(PrimitiveType).wrapperVersion(), source)
            return linkTo(type.classNode, source)
        }
    }

    @private
    function linkTo(m:MethodNode):String {
        return linkTo(m, false)
    }

    @private
    function methodName(m:MethodNode, name:(Type)=>(String)):String {
        def result := new MutableString()
        result.append(m.name)
        result.append("(")
        def start:Int
        if m.annotations.isClass
            start := 0
        else
            start := 1
        for i, p in m.parameters {
            if i < start
                continue
            if i > start
                result.append(",")
            result.append(name(p.type))
        }
        result.append(")")
        if m.returnType != VoidType.VOID {
            result.append(":")
            result.append(name(m.returnType))
        }
        return result->>(String)
    }

    @private
    function methodName(m:MethodNode):String {
        return methodName(m, type => type.displayName)
    }

    @private
    function simpleName(m:MethodNode):String {
        return methodName(m, type => type.simpleName)
    }


    @private
    function linkTo(m:MethodNode, source:Bit):String {
        def result := new MutableString()
        result.append(linkTo(m.owner, source))
        result.append("#")
        result.append(methodName(m))
        return result->>(String)
    }

    @private
    function linkTo(f:FieldNode):String {
        return linkTo(f, false)
    }

    @private
    function linkTo(f:FieldNode, source:Bit):String {
        return "\{linkTo(f.owner, source)}#\{f.name}"
    }

    @private
    function resolveLink(text:String):String {
        return resolveLink(text, false)
    }

    @private
    function resolveLink(text:String, source:Bit):String {
        if text.startsWith("..") | text.startsWith("/") | 
                text.startsWith("http:") | text.startsWith("https:") |
                text.endsWith(".html") | text.contains("#")
            return text
        def member := text.indexOf("::")
        def classNode:ClassNode
        def memberName:String
        if member != null {
            classNode := resolveType(text[0 .. member].trim()).classNode
            memberName := text[member + 2..].trim()
        }
        else {
            if !text.contains("(") {
                try {
                    return linkTo(resolveType(text), source)
                }
                catch e:Exception {
                }
            }
            classNode := currentClass->(ClassNode)
            memberName := text
        }
        if !memberName.contains("(") {
            def fieldNode := resolveField(classNode, memberName)
            if fieldNode != null
                return linkTo(fieldNode.owner, source) + "#" + fieldNode.name
        }
        def methodNode := resolveMethod(classNode, memberName)
        if methodNode = null {
            Panda.log("failed on \{memberName} in \{classNode} - \{classNode.children}")
            throw new CompilerException("no match found for '\{memberName}' " +
                    "in '\{classNode.name}'", currentPosition)
        }
        return linkTo(methodNode, source)
    }

    @private
    method getComment(m:MethodNode):(String, MethodNode)? {
        if m.doccomment != null {
            currentPosition := m.position
            return (m.doccomment->(String), m)
        }
        if m.annotations.isOverride {
            def overridden := m.findOverriddenMethod()
            assert overridden != null: "could not find overridden method for " +
                    "\{m.owner}.\{m}:\{m.position}"
            return getComment(overridden)
        }
        return null
    }

    @private
    method remapParameters(d:DocComment, m:MethodNode) {
        if d.owner = m
            return
        assert d.owner->(MethodNode).parameters.length = m.parameters.length
        def remapped := new GenericHashMap<String, String>()
        def unused := new HashSet<String>()
        for (key, _) in d.params
            unused.add(key)
        for i, p in d.owner->(MethodNode).parameters {
            remapped[m.parameters[i].name] := d.params[p.name]->(String)
            unused.remove(p.name)
        }
        for name in unused {
            PandaCompiler.reportError("@param annotation for " +
                    "'\{name}', but no parameter by that name", 
                    d.owner.position)
        }
        d.params.clear()
        d.params.addAll(remapped)
    }
    
    method writeMethod(m:MethodNode) {
        currentPosition := m.position
        def mdc := getComment(m)
        if mdc != null & mdc[0].contains("@hidden")
            return
        var methodType:String
        switch m.methodType {
            case MethodNodeType.METHOD: methodType := "method"
            case MethodNodeType.FUNCTION: methodType := "function"
            case MethodNodeType.CONSTRUCTOR: methodType := "constructor"
            default: throw new CompilerException("unsupported method type: " +
                    m.methodType, m.position)
        }
        xml.open(methodType)
        xml.open("annotations")
        def pre := SafetyChecker.getPreconditionsForMethodAndAncestors(m)
        if pre != null {
            xml.open("pre")
            xml.text(pre)
            xml.close("pre")
        }
        def post := SafetyChecker.getPostconditionsForMethodAndAncestors(m)
        if post.length > 0 {
            xml.open("post")
            if post.length = 1
                xml.text(post[0])
            else {
                def text := new MutableString()
                for i, p in post {
                    if i > 0
                        text.append(" & ")
                    text.append("(\{p})")
                }
                xml.text(text)
            }
            xml.close("post")
        }
        for ann in m.annotations.all {
            if ann != AnnotationType.PRE & ann != AnnotationType.POST &
                    ann != AnnotationType.INVARIANT {
                def name := Annotations.annotationNames[ann]
                if name != null
                    xml.textTag("annotation", name)
            }
        }
        xml.close("annotations")
        if m.name = "$class"
            xml.textTag("name", "class")
        else
            xml.textTag("name", m.name)
        var doccomment:DocComment?
        if mdc != null {
            doccomment := new DocComment(mdc[1], mdc[0], self)
            remapParameters(doccomment, m)
            xml.open("doc")
            xml.markdownTag("summary", doccomment.summary)
            xml.markdownTag("description", doccomment.longDescription)
            xml.close("doc")
        }
        else {
            doccomment := null
            PandaCompiler.reportWarning("no documentation for " + m, 
                    currentPosition)
        }
        if m.parameters.length > 0 {
            xml.open("params")
            for param in m.parameters {
                if param.name = Parameter.SELF_NAME
                    continue
                xml.open("param")
                xml.textTag("name", param.name)
                xml.open("type")
                xml.textTag("name", param.type.displayName)
                xml.textTag("simpleName", param.type.simpleName)
                xml.close("type")
                if doccomment != null {
                    def desc := doccomment.params[param.name]
                    if desc != null
                        xml.markdownTag("description", desc->(String))
                    else {
                        PandaCompiler.reportWarning("method is missing " +
                                "@param annotation for '\{param.name}'", 
                                currentPosition)
                    }
                }
                xml.close("param")
            }
            xml.close("params")
            if doccomment != null {
                outer: for (name, value) in doccomment.params {
                    for p in m.parameters {
                        if p.name = name 
                            continue outer
                    }
                    PandaCompiler.reportError("@param annotation for " +
                            "'\{name}', but no parameter by that name", 
                            currentPosition)
                }
            }
        }
        if m.returnType != VoidType.VOID {
            xml.open("return")
            xml.open("type")
            xml.textTag("name", m.returnType.displayName)
            xml.textTag("simpleName", m.returnType.simpleName)
            xml.close("type")
            if doccomment != null {
                def returnDoc := doccomment.returnDoc
                if returnDoc != null
                    xml.markdownTag("description", returnDoc)
                else {
                    PandaCompiler.reportWarning("method is missing @returns " +
                        "annotation", currentPosition)
                }
            }
            xml.close("return")
        }
        else if doccomment != null & doccomment.returnDoc != null {
            PandaCompiler.reportError("method returns nothing but is " +
                    "annotated with @returns", currentPosition)
        }
        def sourceLink:String?
        if showSource & !m.position.compilationUnit.endsWith(".plink")
            sourceLink := linkTo(m.owner, true) + "#" + m.position.line
        else
            sourceLink := null
        if doccomment != null & doccomment.see.length > 0 | sourceLink != null {
            xml.open("seeAlsos")
            if doccomment != null {
                for link in doccomment.see {
                    def finalLink:String
                    if !link.startsWith("[") | !link.endsWith("]")
                        finalLink := "[\{link}]"
                    else
                        finalLink := link
                    xml.markdownTag("seeAlso", finalLink)
                }
            }
            if sourceLink != null {
                xml.markdownTag("seeAlso", 
                        "[\{m.position:line}](\{sourceLink})")
            }
            xml.close("seeAlsos")
        }
        xml.close(methodType)
    }
    
    method writeField(f:FieldNode) {
        currentPosition := f.position
        def fdc := f.doccomment
        if fdc != null & fdc.contains("@hidden")
            return
        xml.open("field")
        xml.open("annotations")
        for ann in f.annotations.all {
            def name := Annotations.annotationNames[ann]
            if name != null
                xml.textTag("annotation", name)
        }
        xml.close("annotations")
        xml.textTag("name", f.name)
        xml.open("type")
        xml.textTag("name", f.type.displayName)
        xml.textTag("simpleName", f.type.simpleName)
        xml.close("type")
        if fdc != null {
            def doccomment := new DocComment(f, fdc, self)
            xml.open("doc")
            xml.markdownTag("summary", doccomment.summary)
            xml.markdownTag("description", doccomment.longDescription)
            xml.close("doc")
        }
        else {
            PandaCompiler.reportWarning("no documentation for field " + f, 
                    currentPosition)
        }
        xml.close("field")
    }
    
    method processClass(_cl:ClassNode) {
        if _cl.annotations.isPrivate
            return
        currentPosition := _cl.position
        currentClass := _cl
        xml.open("class")
        if _cl.isInterface
            xml.attribute("type", "interface")
        xml.textTag("name", _cl.type().displayName)
        xml.textTag("simpleName", _cl.type().simpleName)
        var ancestor := _cl.superclass
        if ancestor != null & !_cl.isInterface {
            def ancestors := new PrimitiveArray<ClassNode>()
            while ancestor != null {
                ancestors.append(ancestor)
                ancestor := ancestor.superclass
            }
            xml.open("ancestors")
            for a in ancestors {
                xml.open("type")
                xml.textTag("name", a.type().displayName)
                xml.textTag("simpleName", a.type().simpleName)
                xml.close("type")
            }
            xml.close("ancestors")
        }
        def interfaces := _cl.allInterfaces().filter(intf => intf != _cl)
        if interfaces.length > 0 {
            xml.open("interfaces")
            for intf in interfaces {
                xml.open("type")
                xml.textTag("name", intf.type().displayName)
                xml.textTag("simpleName", intf.type().simpleName)
                xml.close("type")
            }
            xml.close("interfaces")
        }
        def cldc := _cl.doccomment
        if cldc != null {
            def doccomment := new DocComment(_cl, cldc, self)
            xml.open("doc")
            xml.markdownTag("summary", doccomment.summary)
            xml.markdownTag("description", doccomment.longDescription)
            xml.close("doc")
        } 
        else
            PandaCompiler.reportWarning("no documentation for " + _cl, 
                    _cl.position)
        for child in _cl.children {
            if child-?>(MethodNode) {
                def m := child->(MethodNode)
                if !m.annotations.isPrivate & (!m.annotations.isSynthetic |
                        m.methodType = MethodNodeType.CONSTRUCTOR)
                    writeMethod(m)
            }
            else if child-?>(FieldNode) {
                def f := child->(FieldNode)
                if !f.annotations.isPrivate & !f.annotations.isSynthetic
                    writeField(f)
            }
        }
        var inheritedMethods := _cl.virtualMethods.filter(m => m.owner != _cl & 
                !m.annotations.isPrivate)
        if _cl.isInterface {
            inheritedMethods := inheritedMethods.filter(
                    m => m.owner.name != class(Object).name)
        }
        if inheritedMethods.length > 0 {
            xml.open("inheritedMethods")
            for m in inheritedMethods {
                xml.open("method")
                xml.textTag("name", simpleName(m))
                xml.textTag("link", linkTo(m))
                xml.close("method")
            }
            xml.close("inheritedMethods")
        }
        def inheritedFields := _cl.unifiedFields.filter(f => f.owner != _cl & 
                !f.annotations.isPrivate)
        if inheritedFields.length > 0 {
            xml.open("inheritedFields")
            for f in inheritedFields {
                xml.open("field")
                xml.textTag("name", f.name)
                xml.textTag("link", linkTo(f))
                xml.close("field")
            }
            xml.close("inheritedFields")
        }
        xml.close("class")
    }

    method generateSource(outputDir:File) {
        def generator := new HTMLGenerator()
        for cl in SymbolTable.classes {
            if cl.parent-?>(CompilationUnit) {
                if cl.name.contains("<")
                    continue
                def compilationUnit := cl.parent->(CompilationUnit)
                if !compilationUnit.name.endsWith(".panda")
                    continue
                def dest := outputDir.resolve(cl.name.replace(".", "/") + 
                        ".html")
                dest.parent()->(File).createDirectories()
                generator.writeCompilationUnit(compilationUnit, 
                        cl.name.split(".").length, dest)
            }
        }
    }

    @override
    method generateCode(outputDir:File) {
        if !outputDir.isDirectory()
            throw new CompilerException(outputDir + " is not a directory")

        def packages := new GenericHashMap<String, PrimitiveArray<ClassNode>>()
        -- FIXME oh god I can't wait for generics to be in
        def classes := new PrimitiveArray<Object>(SymbolTable.classes, 0, 
                SymbolTable.classes.length)
        Panda.sort(classes, (x, y) => x->(ClassNode).name > y->(ClassNode).name)
        for clObject in classes {
            def cl := clObject->(ClassNode)
            def comment := cl.doccomment
            if comment != null & comment.contains("@hidden")
                continue
            if cl.state = ClassNodeState.DEFINED & !cl.isPrimitiveArray() & 
                    !cl.annotations.isPrivate() & !cl.annotations.isSynthetic {
                var packageName := cl.packageName
                if packageName = null
                    packageName := "unnamed"
                var packageList := packages[packageName]
                if packageList = null {
                    packageList := new PrimitiveArray<ClassNode>()
                    packages[packageName] := packageList
                }
                packageList.append(cl)
                def name := cl.type().displayName
                def target := outputDir.resolve(name.replace(".", "/") + 
                        ".xml")
                target.parent()->(File).createDirectories()
                xml := new MarkdownXMLWriter(target.openOutputStream(),
                        s => resolveLink(s))
                processClass(cl)
                xml.close()
            }
        }
        def index := new XMLWriter(
                outputDir.resolve("index.xml").openOutputStream())
        index.open("packages")
        def packageNames := new PrimitiveArray<Object>()
        for (key, _) in packages
            packageNames.append(key)
        Panda.sort(packageNames, (x, y) => x->(String) > y->(String))
        for packageName in packageNames {
            def packageList := packages[packageName->(String)]
            index.open("package")
            index.textTag("name", packageName->(String))
            index.open("classes")
            for cl in packageList->(PrimitiveArray<ClassNode>) {
                index.open("class")
                def type := cl.type()
                index.textTag("name", type.simpleName)
                index.textTag("path", type.displayName.replace(".", "/") + 
                        ".html")
                index.close("class")
            }
            index.close("classes")
            index.close("package")
        }
        index.close("packages")
        index.close()
        generateSource(outputDir.resolve("source"))
    }
}