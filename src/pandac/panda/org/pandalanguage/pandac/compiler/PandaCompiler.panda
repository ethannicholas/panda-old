package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

class CompilerErrorReporter : ErrorReporter {
    constant ERROR_MESSAGE := "error"
    constant WARNING_MESSAGE := "warning"
    def queue:MessageQueue

    constructor(queue:MessageQueue) {
        self.queue := queue
    }

    @override
    method error(message:String, position:Position) {
        Console.writeLine("error: \{position}: \{message}")
        queue.post(ERROR_MESSAGE)
    }

    @override
    method warning(message:String, position:Position) {
        Console.writeLine("warning: \{position}: \{message}")
        queue.post(WARNING_MESSAGE)
    }
}

================================================================================
Main entry point for the Panda compiler.
================================================================================
class PandaCompiler {
    constant PANDA_HOME := determinePandaHome()

    var lastCheckpointLabel:String?
    var lastCheckpointTime:Int64
    def errorQueue := new MessageQueue()
    def errors := new CompilerErrorReporter(errorQueue)
    var errorCount := 0
    var warningCount := 0

    @class
    function determinePandaHome():File {
        var home := System.environment["PANDA_HOME"]
        if home != null
            return new File(home)
        else
            throw new CompilerException("PANDA_HOME is not set")
    }

    @class
    method getLLVMHome():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX: {
                def libexec := new File("/opt/local/libexec")
                if !libexec.exists() {
                    throw new CompilerException("path '" + libexec + 
                            "' does not exist. Use MacPorts to install " +
                            "Panda dependencies.")
                }
                def llvms := libexec.list("llvm-*.*")
                var maxMajor := 0
                var maxMinor := 0
                for llvm in llvms {
                    try {
                        def versions := llvm.name.parse(#/llvm-(\d+)\.(\d+)/#)
                        assert versions != null
                        def major := versions[0]->>(Int)
                        def minor := versions[1]->>(Int)
                        if major > maxMajor | (major = maxMajor &
                                minor > maxMinor) {
                            maxMajor := major
                            maxMinor := minor
                        }
                    }
                    catch e:ParseException {
                    }
                }
                if maxMajor = 0 {
                    throw new CompilerException("no LLVM installation found " +
                            "under \{libexec}. Use MacPorts to install Panda " +
                            "dependencies.")
                }
                return verifyExists(new File("/opt/local/libexec/llvm-" +
                        "\{maxMajor}.\{maxMinor}/bin"))
            }
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin"))
            default:
                throw new CompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method verifyExists(file:File):File {
        if !file.exists() {
            throw new CompilerException("required file '\{file}' was not " +
                    "found. Please ensure that Panda's dependencies are " +
                    "installed.")
        }
        return file
    }

    @class
    method getCCompiler():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX:
                return verifyExists(getLLVMHome().resolve("clang"))
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin/gcc"))
            default:
                throw new CompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method getCPPCompiler():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX:
                return verifyExists(getLLVMHome().resolve("clang++"))
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin/g++"))
            default:
                throw new InternalCompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    method checkpoint(label:String) {
-*        var now := Panda.currentTime()
        var lastCheckpointLabel := lastCheckpointLabel
        if lastCheckpointLabel != null {
            Console.writeLine(lastCheckpointLabel + " - " + 
                    (now - lastCheckpointTime) + "ms")
        }
        self.lastCheckpointLabel := label
        lastCheckpointTime := now*-
    }

    @protected
    method getASTFiles(settings:CompilerSettings):CollectionView<ASTFile> {
        def result := new Array<ASTFile>()
-*        def workQueue := new MessageQueue()
        def responseQueue := new MessageQueue()
        constant THREADS := 1
        for f in settings.sources
            workQueue.post(f)
        def errorReporter := self.errors
        for i in 0 .. THREADS {
            workQueue.post(null)
            Thread.start(method() {
                def result := new Array<ASTFile>()
                loop {
                    def f := workQueue.getMessage()->(File?)
                    if f = null
                        break
                    def input := new BufferedInputStream(f.openInputStream())
                    def parsed := new PandaParser(errorReporter).parseFile(
                            f.path, input)
                    if parsed != null
                        result.add(parsed)
                    input.close()
                }
                responseQueue.post(new ImmutableArray<ASTFile>(result))
            })
        }
        for i in 0 .. THREADS {
            def subresult := responseQueue.getMessage()->
                    (ImmutableArray<ASTFile>)
            result.addAll(subresult)
        }*-
        for f in settings.sources {
            def input := new BufferedInputStream(f.openInputStream())
            def parsed := new PandaParser(errors).parseFile(f.path, input)
            if parsed != null
                result.add(parsed)
            input.close()
        }
        return result
    }

    @private
    method processMessages() {
        while errorQueue.hasMessage() {
            def message := errorQueue.getMessage()
            switch message {
                case CompilerErrorReporter.ERROR_MESSAGE: errorCount += 1
                case CompilerErrorReporter.WARNING_MESSAGE: warningCount += 1
                default: unreachable
            }
        }
    }

    @protected
    method compile(settings:CompilerSettings) {
        checkpoint("parse")
        def files := getASTFiles(settings)
        processMessages()
        if errorCount = 0 {
            processMessages()
            if errorCount = 0 {
                checkpoint("extract types")
                def stubGenerator := new StubGenerator(files, errors)
                def root := stubGenerator.getRootPackage()
                processMessages()
                if errorCount = 0 {
                    checkpoint("semantic analysis")
                    def program := new IRGenerator(root,  
                            new HashMap<String, ClassStub>(), stubGenerator,
                            settings, errors).generateProgram()
                    processMessages()
                    if errorCount = 0 {
                        def cg:CodeGenerator
                        checkpoint("codegen")
                        switch settings.outputFormat {
                            case OutputFormat.EXECUTABLE:
                                cg := new ExecutableCodeGenerator(program, 
                                        settings)
                            case OutputFormat.JAVA:
                                cg := new JavaCodeGenerator(program, settings)
                            case OutputFormat.JAR:
                                cg := new JARCodeGenerator(program, settings)
                            case OutputFormat.HEADERS:
                                cg := new HeaderCodeGenerator(program, settings)
                            case OutputFormat.JAVA_HEADERS: {
                                cg := new JavaHeaderCodeGenerator(program, 
                                        settings)
                            }
                            case OutputFormat.LIB: {
                                cg := new LibraryCodeGenerator(program, 
                                    settings)
                            }
                            case OutputFormat.PLINK:
                                cg := new PLinkCodeGenerator(program, settings)
                            default: unreachable
                        } 
                        cg.generateCode(settings.target)
                    }
                }
            }
        }
        if warningCount > 1 {
            Console.writeLine(warningCount + " warnings")
        }
        else if warningCount = 1 {
            Console.writeLine("1 warning")
        }
        if errorCount > 1 {
            Console.writeLine(errorCount + " errors")
        }
        else if errorCount = 1 {
            Console.writeLine("1 error")
        }
    }

    method processArguments(args:PrimitiveArray<String>):CompilerSettings {
        def sources := new Array<File>()
        def librarySearchPaths := new Array<File>() 
        librarySearchPaths.add(new File("/opt/local/lib"))
        librarySearchPaths.add(PandaCompiler.PANDA_HOME.resolve(
                "native/core/lib"))
        var target:File? := null
        var loadCoreLibraries := true
        var outputFormat := OutputFormat.EXECUTABLE
        var preserveTempArtifacts := true
        var i := 0
        while i < args.length {
            def arg := args[i]
            switch arg {
                case "-o": {
                    i += 1
                    if i >= args.length {
                        Console.writeLine("expected file path after '-o'")
                        System.exit(1)
                    }
                    if target != null {
                        Console.writeLine("'-o' specified multiple times")
                        System.exit(1)
                    }
                    target := new File(args[i])
                }
                case "-f": {
                    i += 1
                    if i >= args.length {
                        Console.writeLine("expected output format after '-f'")
                        System.exit(1)
                    }
                    switch args[i] {
                        case "java": outputFormat := OutputFormat.JAVA
                        case "jar": outputFormat := OutputFormat.JAR
                        case "exec": outputFormat := OutputFormat.EXECUTABLE
                        case "h": outputFormat := OutputFormat.HEADERS
                        case "javah": outputFormat := OutputFormat.JAVA_HEADERS
                        case "lib": outputFormat := OutputFormat.LIB
                        case "plink": outputFormat := OutputFormat.PLINK
                        default: {
                            Console.writeLine("unsupported output format " +
                                    "'\{args[i]}'")
                            System.exit(1)                        
                        }
                    }
                }
                case "-L": {
                    i += 1
                    if i >= args.length {
                        Console.writeLine("expected file path after '-L'")
                        System.exit(1)
                    }
                    librarySearchPaths.add(new File(args[i]))
                }
                case "-XnoCoreLib":
                    loadCoreLibraries := false
                case "-XpreserveTempArtifacts":
                    preserveTempArtifacts := true
                default:
                    if arg.endsWith(".panda")
                        sources.add(new File(arg))
                    else {
                        Console.writeLine("test output \{3 * 7}")
                        Console.writeLine("args is: " + args)
                        Console.writeLine("unsupported argument '\{arg}'")
                        System.exit(1)
                    }
            }
            i += 1
        }
        if target = null {
            if sources.length = 1 & sources[0].path.endsWith(".panda") {
                def path := sources[0].path
                target := new File(path[0 .. path.length - ".panda".length])
            }
            else {
                Console.writeLine("multiple input files specified, use " +
                        "'-o <path>' to specify output path")
                System.exit(1)
            }
        }
        if loadCoreLibraries {
            sources.add(PANDA_HOME.resolve(
                    "shared/core/lib/PandaCoreClasses.plink"))
        }
        return new CompilerSettings(sources, librarySearchPaths, outputFormat,
                target->(File), preserveTempArtifacts)
    }

    method runWithArgs(args:PrimitiveArray<String>) {
        checkpoint("process arguments")
        def settings := processArguments(args)
        compile(settings)
        checkpoint("finished")
    }

    @class
    method main(args:PrimitiveArray<String>) {
        try {
            if args.length < 1 {
                Console.writeLine("usage: pandac <input.panda>")
                System.exit(1)
            }
            def pandac := new PandaCompiler()
            pandac.runWithArgs(args)
            if pandac.errorCount > 0
                System.exit(2)
        }
        catch e:InternalCompilerException {
            def position := e.position
            if position != null
                Console.writeLine(position + ": " + e)
            else
                Console.writeLine(e)
            System.exit(3)
        }
        catch e:CompilerException {
            def position := e.position
            if position != null
                Console.writeLine(position + ": " + e)
            else
                Console.writeLine(e)
            System.exit(3)
        }
        catch e:Error {
            Console.writeLine(e)
            System.exit(3)
        }
    }
}