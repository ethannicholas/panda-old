package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.analysis.DataFlowAnalyzer
uses org.pandalanguage.pandac.analysis.SafetyChecker
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.pandadoc.PandaDoc
uses org.pandalanguage.pandac.pandadoc.HTMLFragmentGenerator
uses org.pandalanguage.pandac.pandadoc.HTMLGenerator
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

class CompilerErrorReporter : ErrorReporter {
    constant ERROR_MESSAGE := "error"
    constant WARNING_MESSAGE := "warning"
    def queue:MessageQueue

    constructor(queue:MessageQueue) {
        self.queue := queue
    }

    @override
    method error(message:String, position:Position) {
        Console.writeLine("error: \{position}: \{message}")
        queue.post(ERROR_MESSAGE)
    }

    @override
    method warning(message:String, position:Position) {
        Console.writeLine("warning: \{position}: \{message}")
        queue.post(WARNING_MESSAGE)
    }
}

================================================================================
Main entry point for the Panda compiler.
================================================================================
class PandaCompiler {
    constant PANDA_HOME := determinePandaHome()

    var lastCheckpointLabel:String?
    var lastCheckpointTime:Int64
    def errorQueue := new MessageQueue()
    def errors := new CompilerErrorReporter(errorQueue)
    var errorCount := 0
    var warningCount := 0

    @class
    function determinePandaHome():File {
        var home := System.environment["PANDA_HOME"]
        if home != null
            return new File(home)
        else
            throw new CompilerException("PANDA_HOME is not set")
    }

    @class
    method getLLVMHome():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX: {
                def libexec := new File("/opt/local/libexec")
                if !libexec.exists() {
                    throw new CompilerException("path '" + libexec + 
                            "' does not exist. Use MacPorts to install " +
                            "Panda dependencies.")
                }
                def llvms := libexec.list("llvm-*.*")
                var maxMajor := 0
                var maxMinor := 0
                for llvm in llvms {
                    try {
                        def versions := llvm.name.parse(#/llvm-(\d+)\.(\d+)/#)
                        assert versions != null
                        def major := versions[0]->>(Int)
                        def minor := versions[1]->>(Int)
                        if major > maxMajor | (major = maxMajor &
                                minor > maxMinor) {
                            maxMajor := major
                            maxMinor := minor
                        }
                    }
                    catch e:ParseException {
                    }
                }
                if maxMajor = 0 {
                    throw new CompilerException("no LLVM installation found " +
                            "under \{libexec}. Use MacPorts to install Panda " +
                            "dependencies.")
                }
                return verifyExists(new File("/opt/local/libexec/llvm-" +
                        "\{maxMajor}.\{maxMinor}/bin"))
            }
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin"))
            default:
                throw new CompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method verifyExists(file:File):File {
        if !file.exists() {
            throw new CompilerException("required file '\{file}' was not " +
                    "found. Please ensure that Panda's dependencies are " +
                    "installed.")
        }
        return file
    }

    @class
    method getCCompiler():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX:
                return verifyExists(getLLVMHome().resolve("clang"))
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin/gcc"))
            default:
                throw new CompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method getCPPCompiler():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX:
                return verifyExists(getLLVMHome().resolve("clang++"))
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin/g++"))
            default:
                throw new InternalCompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method reportError(message:String, position:Position?) {
        throw new NotSupportedException()
    }
    
    @class
    method reportError(e:CompilerException) {
        throw new NotSupportedException()
    }

    @class
    method reportWarning(msg:String, position:Position?) {
        throw new NotSupportedException()
    }

    method getCount():Int {
        throw new NotSupportedException()
    }

    method checkpoint(label:String) {
        var now := Panda.currentTime()
        var lastCheckpointLabel := lastCheckpointLabel
        if lastCheckpointLabel != null {
            Console.writeLine(lastCheckpointLabel + " - " + 
                    (now - lastCheckpointTime) + "ms")
        }
        self.lastCheckpointLabel := label
        lastCheckpointTime := now
    }

    @protected
    method getASTFiles(settings:CompilerSettings):CollectionView<ASTFile> {
        def result := new Array<ASTFile>()
        def workQueue := new MessageQueue()
        def responseQueue := new MessageQueue()
        constant THREADS := 1
        for f in settings.sources
            workQueue.post(f)
        def errorReporter := self.errors
        for i in 0 .. THREADS {
            workQueue.post(null)
            Thread.start(method() {
                def result := new Array<ASTFile>()
                loop {
                    def f := workQueue.getMessage()->(File?)
                    if f = null
                        break
                    def input := new BufferedInputStream(f.openInputStream())
                    def parsed := new PandaParser(errorReporter).parseFile(
                            f.name, input)
                    if parsed != null
                        result.add(parsed)
                    input.close()
                }
                responseQueue.post(new ImmutableArray<ASTFile>(result))
            })
        }
        for i in 0 .. THREADS {
            def subresult := responseQueue.getMessage()->
                    (ImmutableArray<ASTFile>)
            result.addAll(subresult)
        }
        return result
    }

    @private
    method processMessages() {
        while errorQueue.hasMessage() {
            def message := errorQueue.getMessage()
            switch message {
                case CompilerErrorReporter.ERROR_MESSAGE: errorCount += 1
                case CompilerErrorReporter.WARNING_MESSAGE: warningCount += 1
                default: unreachable
            }
        }
    }

    @protected
    method compile(settings:CompilerSettings) {
        def files := getASTFiles(settings)
        processMessages()
        if errorCount = 0 {
            def typeResolver := new TypeResolver(files, errors)
            processMessages()
            if errorCount = 0 {
                def stubs := new StubGenerator(files, typeResolver, 
                        errors).generateStubs()
                processMessages()
                if errorCount = 0 {
                    def program := new IRGenerator(stubs, typeResolver, settings,
                            errors).generateProgram()
                    processMessages()
                    if errorCount = 0 {
                        def cg := new ExecutableCodeGenerator(program, settings)
                        cg.generateCode(new File("/tmp/foo"))
                    }
                }
            }
        }
        if warningCount > 1 {
            Console.writeLine(warningCount + " warnings")
        }
        else if warningCount = 1 {
            Console.writeLine("1 warning")
        }
        if errorCount > 1 {
            Console.writeLine(errorCount + " errors")
        }
        else if errorCount = 1 {
            Console.writeLine("1 error")
        }
    }

    function processArguments(args:PrimitiveArray<String>):CompilerSettings {
        def sources := new Array<File>()
        sources.add(PANDA_HOME.resolve(
                "shared/core/lib/PandaCoreClasses.plink"))
        for arg in args.filter(arg => arg.endsWith(".panda"))
            sources.add(new File(arg))
        return new CompilerSettings(sources)
    }

    method runWithArgs(args:PrimitiveArray<String>) {
        def settings := processArguments(args)
        compile(settings)
    }

    @class
    method main(args:PrimitiveArray<String>) {
        try {
            if args.length < 1 {
                Console.writeLine("usage: pandac <input.panda>")
                System.exit(1)
            }
            def pandac := new PandaCompiler()
            pandac.runWithArgs(args)
        }
        catch e:InternalCompilerException {
            def position := e.position
            if position != null
                Console.writeLine(position + ": " + e)
            else
                Console.writeLine(e)
            System.exit(3)
        }
        catch e:CompilerException {
            def position := e.position
            if position != null
                Console.writeLine(position + ": " + e)
            else
                Console.writeLine(e)
            System.exit(3)
        }
        catch e:Error {
            Console.writeLine(e)
            System.exit(3)
        }
    }
}