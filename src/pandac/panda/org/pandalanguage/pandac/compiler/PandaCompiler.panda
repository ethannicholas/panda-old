package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.analysis.DataFlowAnalyzer
uses org.pandalanguage.pandac.analysis.SafetyChecker
uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.pandadoc.PandaDoc
uses org.pandalanguage.pandac.pandadoc.HTMLFragmentGenerator
uses org.pandalanguage.pandac.pandadoc.HTMLGenerator
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.TypedCompilationUnitStub
uses org.pandalanguage.pandac.stubs.UntypedCompilationUnitStub
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

class PandaCompiler {
    constant PANDA_HOME := determinePandaHome()

    var lastCheckpointLabel:String?
    var lastCheckpointTime:Int64

    @class
    function determinePandaHome():File {
        var home := System.environment["PANDA_HOME"]
        if home != null
            return new File(home)
        else
            throw new CompilerException("PANDA_HOME is not set")
    }

    @class
    method getLLVMHome():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX: {
                def libexec := new File("/opt/local/libexec")
                if !libexec.exists() {
                    throw new CompilerException("path '" + libexec + 
                            "' does not exist. Use MacPorts to install " +
                            "Panda dependencies.")
                }
                def llvms := libexec.list("llvm-*.*")
                var maxMajor := 0
                var maxMinor := 0
                for llvm in llvms {
                    try {
                        def versions := llvm.name.parse(#/llvm-(\d+)\.(\d+)/#)
                        assert versions != null
                        def major := versions[0]->>(Int)
                        def minor := versions[1]->>(Int)
                        if major > maxMajor | (major = maxMajor &
                                minor > maxMinor) {
                            maxMajor := major
                            maxMinor := minor
                        }
                    }
                    catch e:ParseException {
                    }
                }
                if maxMajor = 0 {
                    throw new CompilerException("no LLVM installation found " +
                            "under \{libexec}. Use MacPorts to install Panda " +
                            "dependencies.")
                }
                return verifyExists(new File("/opt/local/libexec/llvm-" +
                        "\{maxMajor}.\{maxMinor}/bin"))
            }
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin"))
            default:
                throw new CompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method verifyExists(file:File):File {
        if !file.exists() {
            throw new CompilerException("required file '\{file}' was not " +
                    "found. Please ensure that Panda's dependencies are " +
                    "installed.")
        }
        return file
    }

    @class
    method getCCompiler():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX:
                return verifyExists(getLLVMHome().resolve("clang"))
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin/gcc"))
            default:
                throw new CompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method getCPPCompiler():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX:
                return verifyExists(getLLVMHome().resolve("clang++"))
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin/g++"))
            default:
                throw new InternalCompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method reportError(message:String, position:Position?) {
        throw new NotSupportedException()
    }
    
    @class
    method reportError(e:CompilerException) {
        throw new NotSupportedException()
    }

    @class
    method reportWarning(msg:String, position:Position?) {
        throw new NotSupportedException()
    }

    method getCount():Int {
        throw new NotSupportedException()
    }

    method checkpoint(label:String) {
        var now := Panda.currentTime()
        var lastCheckpointLabel := lastCheckpointLabel
        if lastCheckpointLabel != null {
            Console.writeLine(lastCheckpointLabel + " - " + 
                    (now - lastCheckpointTime) + "ms")
        }
        self.lastCheckpointLabel := label
        lastCheckpointTime := now
    }

    @protected
    method getUntypedCompilationUnits(settings:CompilerSettings):
            (CollectionView<UntypedCompilationUnitStub>, ListView<Message>?) {
        def result := new Array<UntypedCompilationUnitStub>()
        var messages:List<Message>? := null
        def scanner := new Scanner()
        def workQueue := new MessageQueue()
        def responseQueue := new MessageQueue()
        constant THREADS := settings.sources.length.min(
            Thread.preferredThreadCount)
        for f in settings.sources
            workQueue.post(f)
        for i in 0 .. THREADS {
            workQueue.post(null)
            Thread.start(method() {
                def result := new Array<UntypedCompilationUnitStub>()
                var messages:List<Message>? := null
                loop {
                    def f := workQueue.getMessage()->(File?)
                    if f = null
                        break
                    def input := f.openInputStream()
                    def parsed := new PandaParser().parseCompilationUnit(f.name,
                            input)
                    def stub, subMessages := scanner.convertCompilationUnit(f.name, 
                            parsed)
                    result.add(stub)
                    if subMessages != null {
                        if messages = null
                            messages := new Array<Message>()
                        messages.addAll(subMessages)
                    }
                    input.close()
                }
                def responseMessages:ImmutableArray<Message>?
                if messages != null
                    responseMessages := new ImmutableArray<Message>(messages)
                else
                    responseMessages := null
                responseQueue.post(
                        (new ImmutableArray<UntypedCompilationUnitStub>(result),
                         responseMessages))
            })
        }
        for i in 0 .. THREADS {
            def subresult, submessages := responseQueue.getMessage()->((ImmutableArray<UntypedCompilationUnitStub>, ImmutableArray<Message>?))
            result.addAll(subresult)
            if submessages != null {
                if messages = null
                    messages := new Array<Message>()
                messages.addAll(submessages)
            }
        }
        return (result, messages)
    }

    @private
    function fatal(messages:ListView<Message>?):Bit {
        if messages = null
            return false
        for m in messages {
            if !m.warning
                return true
        }
        return false
    }

    @private
    method getTypedCompilationUnits(
            untypedCompilationUnits:CollectionView<UntypedCompilationUnitStub>):
                (ListView<TypedCompilationUnitStub>, ListView<Message>?) {
        return new TypeResolver(untypedCompilationUnits).resolveTypes()
    }

    @protected
    method compile(settings:CompilerSettings):ListView<Message>? {
        var messages:List<Message>? := null
        checkpoint("loading symbols")
        def untypedCompilationUnits, phase1Messages := 
                getUntypedCompilationUnits(settings)
        if phase1Messages != null {
            if messages = null
                messages := new Array<Message>()
            messages.addAll(phase1Messages)
        }
        if fatal(messages)
            return messages

        checkpoint("resolving types")
        def typedCompilationUnits, phase2Messages :=
                getTypedCompilationUnits(untypedCompilationUnits)
        if phase2Messages != null {
            if messages = null
                messages := new Array<Message>()
            messages.addAll(phase2Messages)
        }
        if fatal(messages)
            return messages

        checkpoint("done")
        Console.writeLine("done")
        return messages
    }

    function processArguments(args:PrimitiveArray<String>):CompilerSettings {
        def sources := new Array<File>()
        sources.add(PANDA_HOME.resolve(
                "shared/core/lib/PandaCoreClasses.plink"))
        for arg in args.filter(arg => arg.endsWith(".panda"))
            sources.add(new File(arg))
        return new CompilerSettings(sources)
    }

    method runWithArgs(args:PrimitiveArray<String>):ListView<Message>? {
        def settings := processArguments(args)
        return compile(settings)
    }

    @class
    method main(args:PrimitiveArray<String>) {
        try {
            if args.length < 1 {
                Console.writeLine("usage: pandac <input.panda>")
                System.exit(1)
            }
            def pandac := new PandaCompiler()
            def result := pandac.runWithArgs(args)
            if result != null {
                var warnings := 0
                var errors := 0
                for m in result {
                    if m.warning
                        warnings += 1
                    else
                        errors += 1
                    Console.writeLine(m)
                }
                if errors != 0 {
                    Console.write(errors + " error")
                    if errors != 1
                        Console.write("s")
                }
                if warnings != 0 {
                    if errors != 0
                        Console.write(", ")
                    Console.write(errors + " warning")
                    if errors != 1
                        Console.write("s")
                }
                if errors + warnings != 0
                    Console.writeLine()
            }
            System.exit(0)
        }
        catch e:Error {
            Console.writeLine(e)
            System.exit(3)
        }
    }
}