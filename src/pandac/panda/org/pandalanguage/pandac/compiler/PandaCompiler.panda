package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.analysis.DataFlowAnalyzer
uses org.pandalanguage.pandac.analysis.SafetyChecker
uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.pandadoc.PandaDoc
uses org.pandalanguage.pandac.pandadoc.HTMLFragmentGenerator
uses org.pandalanguage.pandac.pandadoc.HTMLGenerator
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.stubs.TypedCompilationUnitStub
uses org.pandalanguage.pandac.stubs.UntypedCompilationUnitStub
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

================================================================================
Main entry point for the Panda compiler.

The overall design of the compiler is:

1. [PandaParser] is run on each compilation unit, resulting in a [ParseNode] of
   type `COMPILATION_UNIT`.
2. The [Scanner] class takes these `ParseNode`s and converts them into a tree of
   [UntypedCompilationUnitStub], [UntypedClassStub], etc. At this point we know
   all of the symbols but have not resolved them yet.
3. The [TypeResolver] class takes the various untyped stubs and resolves all of
   the [Type]s (with the assistance of [TypeMap]), producing 
   [TypedCompilationUnitStub], [TypedClassStub], etc. These stubs are fully
   resolved, but any code associated with them is still just raw `ParseNode`s.
4. For stubs loaded from plink files, their journey has already ended: they will
   never be anything more than stubs. Classes found in .panda files now go 
   through [ASTGenerator], which takes `TypedClassStub`, `TypedMethodStub`, etc.
   and turns then into [ClassNode], [MethodNode], and the rest of the nodes in
   the `org.pandalanguage.pandac.tree` package.

(at this point, the narrative diverges into fantasy land. FIXME: update this 
when the new compiler design is finished.)

5. The `ClassNode`s are analyzed by [CFGGenerator] and then [DataFlowAnalyzer].
6. The classes and analysis information go to [SafetyChecker], which inserts
   checks for preconditions, postconditions, and invariants (among other 
   things).
7. The classes are passed to [Optimizer] to be optimized.
8. Finally, a [CodeGenerator] produces the actual, finished output code from the
   processed `ClassNode`s. 
================================================================================
class PandaCompiler (MessageProcessor) {
    constant PANDA_HOME := determinePandaHome()

    var lastCheckpointLabel:String?
    var lastCheckpointTime:Int64

    @class
    function determinePandaHome():File {
        var home := System.environment["PANDA_HOME"]
        if home != null
            return new File(home)
        else
            throw new CompilerException("PANDA_HOME is not set")
    }

    @class
    method getLLVMHome():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX: {
                def libexec := new File("/opt/local/libexec")
                if !libexec.exists() {
                    throw new CompilerException("path '" + libexec + 
                            "' does not exist. Use MacPorts to install " +
                            "Panda dependencies.")
                }
                def llvms := libexec.list("llvm-*.*")
                var maxMajor := 0
                var maxMinor := 0
                for llvm in llvms {
                    try {
                        def versions := llvm.name.parse(#/llvm-(\d+)\.(\d+)/#)
                        assert versions != null
                        def major := versions[0]->>(Int)
                        def minor := versions[1]->>(Int)
                        if major > maxMajor | (major = maxMajor &
                                minor > maxMinor) {
                            maxMajor := major
                            maxMinor := minor
                        }
                    }
                    catch e:ParseException {
                    }
                }
                if maxMajor = 0 {
                    throw new CompilerException("no LLVM installation found " +
                            "under \{libexec}. Use MacPorts to install Panda " +
                            "dependencies.")
                }
                return verifyExists(new File("/opt/local/libexec/llvm-" +
                        "\{maxMajor}.\{maxMinor}/bin"))
            }
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin"))
            default:
                throw new CompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method verifyExists(file:File):File {
        if !file.exists() {
            throw new CompilerException("required file '\{file}' was not " +
                    "found. Please ensure that Panda's dependencies are " +
                    "installed.")
        }
        return file
    }

    @class
    method getCCompiler():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX:
                return verifyExists(getLLVMHome().resolve("clang"))
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin/gcc"))
            default:
                throw new CompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method getCPPCompiler():File {
        switch System.operatingSystem.type {
            case OperatingSystemType.MACOSX:
                return verifyExists(getLLVMHome().resolve("clang++"))
            case OperatingSystemType.LINUX, OperatingSystemType.OTHER_UNIX:
                return verifyExists(new File("/usr/bin/g++"))
            default:
                throw new InternalCompilerException("Unsupported operating " +
                        "system type: " + System.operatingSystem.type)
        }
    }

    @class
    method reportError(message:String, position:Position?) {
        throw new NotSupportedException()
    }
    
    @class
    method reportError(e:CompilerException) {
        throw new NotSupportedException()
    }

    @class
    method reportWarning(msg:String, position:Position?) {
        throw new NotSupportedException()
    }

    method getCount():Int {
        throw new NotSupportedException()
    }

    method checkpoint(label:String) {
        var now := Panda.currentTime()
        var lastCheckpointLabel := lastCheckpointLabel
        if lastCheckpointLabel != null {
            Console.writeLine(lastCheckpointLabel + " - " + 
                    (now - lastCheckpointTime) + "ms")
        }
        self.lastCheckpointLabel := label
        lastCheckpointTime := now
    }

    @protected
    method getUntypedCompilationUnits(settings:CompilerSettings):
            (CollectionView<UntypedCompilationUnitStub>, ListView<Message>?) {
        def result := new Array<UntypedCompilationUnitStub>()
        var messages:ListView<Message>? := null
        def scanner := new Scanner()
        def workQueue := new MessageQueue()
        def responseQueue := new MessageQueue()
        constant THREADS := settings.sources.length.min(
            Thread.preferredThreadCount)
        for f in settings.sources
            workQueue.post(f)
        for i in 0 .. THREADS {
            workQueue.post(null)
            Thread.start(method() {
                def result := new Array<UntypedCompilationUnitStub>()
                var messages:ListView<Message>? := null
                loop {
                    def f := workQueue.getMessage()->(File?)
                    if f = null
                        break
                    def input := new BufferedInputStream(f.openInputStream())
                    def parsed := new PandaParser().parseCompilationUnit(f.name,
                            input)
                    def stub, submessages := scanner.convertCompilationUnit(f.name, 
                            parsed)
                    result.add(stub)
                    messages := addMessages(messages, submessages)
                    input.close()
                }
                def responseMessages:ImmutableArray<Message>?
                if messages != null
                    responseMessages := new ImmutableArray<Message>(messages)
                else
                    responseMessages := null
                responseQueue.post(
                        (new ImmutableArray<UntypedCompilationUnitStub>(result),
                         responseMessages))
            })
        }
        for i in 0 .. THREADS {
            def subresult, submessages := responseQueue.getMessage()->((ImmutableArray<UntypedCompilationUnitStub>, ImmutableArray<Message>?))
            result.addAll(subresult)
            messages := addMessages(messages, submessages)
        }
        return (result, messages)
    }

    @private
    function fatal(messages:ListView<Message>?):Bit {
        if messages = null
            return false
        for m in messages {
            if !m.warning
                return true
        }
        return false
    }

    @private
    method getTypedCompilationUnits(
            untypedCompilationUnits:CollectionView<UntypedCompilationUnitStub>):
                (CollectionView<TypedCompilationUnitStub>, TypeMap, 
                ListView<Message>?) {
        return TypeResolver.resolveTypes(untypedCompilationUnits)
    }

    @private
    method getClassNodes(
            typedCompilationUnits:CollectionView<TypedCompilationUnitStub>,
            typeMap:TypeMap):
            (CollectionView<ClassNode>, MapView<String, TypedClassStub>, ListView<Message>?) {
        return new ASTGenerator().convertCompilationUnits(typedCompilationUnits,
                typeMap)
    }


    @protected
    method compile(settings:CompilerSettings):ListView<Message>? {
        var messages:ListView<Message>? := null
        checkpoint("loading symbols")
        def untypedCompilationUnits, phase1Messages := 
                getUntypedCompilationUnits(settings)
        messages := addMessages(messages, phase1Messages)
        if fatal(messages)
            return messages

        checkpoint("resolving types")
        def typedCompilationUnits, typeMap, phase2Messages :=
                getTypedCompilationUnits(untypedCompilationUnits)
        messages := addMessages(messages, phase2Messages)
        if fatal(messages)
            return messages

        checkpoint("generating abstract syntax tree")
        def classes, stubs, phase3Messages := getClassNodes(
                typedCompilationUnits, typeMap)
        messages := addMessages(messages, phase3Messages)
        if fatal(messages)
            return messages

        checkpoint("codegen")
        def program := new Program(settings, stubs, classes, 
                typeMap.allTypes().values)
        new ExecutableCodeGenerator(program).generateCode(new File("/tmp/foo"))
        checkpoint("done")
        Console.writeLine("done")
        return messages
    }

    function processArguments(args:PrimitiveArray<String>):CompilerSettings {
        def sources := new Array<File>()
        sources.add(PANDA_HOME.resolve(
                "shared/core/lib/PandaCoreClasses.plink"))
        for arg in args.filter(arg => arg.endsWith(".panda"))
            sources.add(new File(arg))
        return new CompilerSettings(sources)
    }

    method runWithArgs(args:PrimitiveArray<String>):ListView<Message>? {
        def settings := processArguments(args)
        return compile(settings)
    }

    @class
    method main(args:PrimitiveArray<String>) {
        try {
            if args.length < 1 {
                Console.writeLine("usage: pandac <input.panda>")
                System.exit(1)
            }
            def pandac := new PandaCompiler()
            def result := pandac.runWithArgs(args)
            if result != null {
                var warnings := 0
                var errors := 0
                for m in result {
                    if m.warning
                        warnings += 1
                    else
                        errors += 1
                    Console.writeLine(m)
                }
                if errors != 0 {
                    Console.write(errors + " error")
                    if errors != 1
                        Console.write("s")
                }
                if warnings != 0 {
                    if errors != 0
                        Console.write(", ")
                    Console.write(errors + " warning")
                    if errors != 1
                        Console.write("s")
                }
                if errors + warnings != 0
                    Console.writeLine()
            }
            System.exit(0)
        }
        catch e:Error {
            Console.writeLine(e)
            System.exit(3)
        }
    }
}