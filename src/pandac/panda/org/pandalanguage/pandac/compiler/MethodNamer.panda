package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.types.Type

================================================================================
Applies a pluggable naming strategy to all of the methods in a class, in order
to name methods in a fashion which is compatible with and unambiguous in the
target language.
================================================================================
class MethodNamer {
    constant NAMED := "named"
    constant NAME := "name"

    @class
    function escapeTypeName(name:String):String {
        return name.replace(".", "$").replace("<", "$LT").
                            replace(">", "$GT").replace("?", "$Z").
                            replace("*", "$p").replace("(", "$LP").
                            replace(")", "$RP").replace("=", "$EQ").
                            replace(",", "$C").replace("&", "$AM")
    }

    @class
    method nameMethods(st:MethodNamingStrategy) {
        for cl in SymbolTable.classes
            nameMethods(cl, st)
    }

    ============================================================================
    Goes through all of the methods in a class, giving each a NAME property
    in accordance with the specified `MethodNamingStrategy`.
    ============================================================================
    @private
    @class
    method nameMethods(cl:ClassNode, st:MethodNamingStrategy) {
        if cl.getProperty(NAMED) = true
            return
        cl.setProperty(NAMED, true)
        var sc := cl.superclass
        if sc != null
            nameMethods(sc, st)
        for intf in cl.interfaces
            nameMethods(intf.classNode, st)
        def disambiguationBuckets:Map<String, Array<MethodNode>> := 
                new HashMap<String, Array<MethodNode>>()
        for m in cl.methods {
            if !cl.annotations.isUnspecified | m.annotations.isClass
                addToBucket(disambiguationBuckets, st.disambiguation(m), m)
        }
        for (_, bucket) in disambiguationBuckets {
            def shortBuckets:Map<String, Array<MethodNode>> := 
                    new HashMap<String, Array<MethodNode>>()
            for m in bucket
                addToBucket(shortBuckets, st.shortName(m), m)
            for (key, shortBucket) in shortBuckets {
                if shortBucket.length = 1
                    shortBucket[0].setProperty(NAME, key)
                else {
                    def mediumBuckets:Map<String, Array<MethodNode>> := 
                            new HashMap<String, Array<MethodNode>>()
                    for m in shortBucket
                        addToBucket(mediumBuckets, st.mediumName(m), m)
                    for (mKey, mediumBucket) in mediumBuckets {
                        if mediumBucket.length = 1
                            mediumBucket[0].setProperty(NAME, mKey)
                        else {
                            for m in mediumBucket
                                m.setProperty(NAME, st.longName(m))
                        }
                    }
                }
            }
        }
    }

    @private
    @class
    method addToBucket(buckets:Map<String, Array<MethodNode>>, name:String, 
            m:MethodNode) {
        var bucket := buckets[name]
        if bucket = null {
            bucket := new Array<MethodNode>()
            buckets[name] := bucket
        }
        bucket.add(m)
    }
}