package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.Alignment
uses org.pandalanguage.pandac.ast.ArrowOperationType
uses org.pandalanguage.pandac.ast.ASTArrayLiteral
uses org.pandalanguage.pandac.ast.ASTArrowExpression
uses org.pandalanguage.pandac.ast.ASTAssert
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBinaryExpression
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTBreak
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTCatch
uses org.pandalanguage.pandac.ast.ASTClassLiteral
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTContinue
uses org.pandalanguage.pandac.ast.ASTDo
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTFor
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTIndex
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTLambdaExpression
uses org.pandalanguage.pandac.ast.ASTLoop
uses org.pandalanguage.pandac.ast.ASTMethodType
uses org.pandalanguage.pandac.ast.ASTMethodValue
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTNullLiteral
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTRangeExpression
uses org.pandalanguage.pandac.ast.ASTRealLiteral
uses org.pandalanguage.pandac.ast.ASTRegex
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTSwitch
uses org.pandalanguage.pandac.ast.ASTThrow
uses org.pandalanguage.pandac.ast.ASTTry
uses org.pandalanguage.pandac.ast.ASTTupleExpression
uses org.pandalanguage.pandac.ast.ASTTupleType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnaryExpression
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTVarDeclaration
uses org.pandalanguage.pandac.ast.ASTWhile
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.Package
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.stubs.TypeSymbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.InstanceContext
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodReference
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.PackageReference
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedDotExpression
uses org.pandalanguage.pandac.tree.UnresolvedIdentifier
uses org.pandalanguage.pandac.tree.UnresolvedIndex
uses org.pandalanguage.pandac.tree.UnresolvedLambda
uses org.pandalanguage.pandac.tree.UnresolvedMethod
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedSlice
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.SuperType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class IRGenerator {
    constant SHIM_PREFIX := "$shim_"

    constant STRING_GROUP := /(?<!\\)\\\{.*?(?<!\\)\}/

    constant UNESCAPED_BRACE := /(?<!\\)\{/

    var context:Context

    def currentlyInferring := HashSet<FieldNode>()

    var addMethods := true

    @thread
    var nameCount := 0

    constructor(root:Package, classes:MapView<String, ClassStub>,
            stubGenerator:StubGenerator, compilerSettings:CompilerSettings,
            errors:ErrorReporter) {
        context := Context(self, stubGenerator, root, classes, errors, 
                compilerSettings)
    }

    @class
    function makeExplicit(v:Value):Value {
        if v-?>Cast {
            return Cast(v.position, v->Cast.value, v.type, 
                    CastType.EXPLICIT)
        }
        return v
    }
    
    @class
    function isAccessible(f:FieldNode):Bit {
        return true
    }

    @private
    method createFieldReference(position:Position, var contextValue:Value, 
            f:FieldNode, allowNoArgFunctions:Bit):Value {
        inferFieldType(f)
        if allowNoArgFunctions {
            def result := context.testCall(position, contextValue, f.name, 
                    Array<Value>())
            if result != null & result->MethodCall.methodStub.methodType =
                    MethodNodeType.FUNCTION
                return result
        }
        def result := FieldReference(position, contextValue, f)
        return result
    }

    method getMember(position:Position, var contextValue:Value,
            var name:String):Value? {
        return getMember(position, contextValue, name, true)
    }

    method getMember(position:Position, var contextValue:Value,
            var name:String, allowNoArgFunctions:Bit):Value? {
        if name = "class"
            name := "$class"
        if contextValue-?>ClassLiteral {
            def type := contextValue->ClassLiteral.value->>ClassType
            def member := context.getSymbolTable(context.getStub(type))[name]
            if member != null
                return symbolReference(position, contextValue, member)
        }
        if contextValue-?>Super {
            def type := context.getStub(context.getSelf(position).type->ClassType).superclass->ClassType
            def member := context.getSymbolTable(context.getStub(type))[name]
            if member != null
                return symbolReference(position, contextValue, member)
        }
        def resolved := resolve(contextValue)
        if resolved != null
            contextValue := resolved
        else
            return null
        if contextValue.type-?>VoidType {
            context.errors.error("this expression does not have any members", 
                    position)
            return null
        }
        def type := contextValue.type->>ClassType
        def member := context.getSymbolTable(context.getStub(type))[name]
        if member != null {
            return symbolReference(position, contextValue.implicitCast(context,
                    type), member)
        }
        context.errors.error("'\{contextValue.type.displayName}' does not " +
                "have a member named '\{name}'", position)
        Panda.dumpStack()
        return null
    }

    method convertCallExpression(c:ASTCallExpression):Value? {
        var target := convertExpression(c.target)
        if target = null
            return null
        if target-?>ClassLiteral {
            def n := ASTNew(c.position, toASTType(c.position,
                    target->ClassLiteral.value), c.parameters)
            return convertNew(n)
        }
        if c.parameters.length = 0 & target-?>MethodCall
            return target
        def parameters := Array<Value>()
        for p in c.parameters {
            def converted := convertExpression(p)
            if converted = null
                return null
            parameters.add(converted)
        }
        if target-?>UnresolvedIdentifier {
            if context.isInstance {
                def test := context.testCall(c.position, context.getSelf(
                            c.position),
                        target->UnresolvedIdentifier.name, parameters)
                if test != null
                    return test
            }
            def test := context.testCall(c.position, ClassLiteral(
                    c.position, context.currentClass.type),
                    target->UnresolvedIdentifier.name, parameters)
            if test != null
                return test
        }
        if target-?>UnresolvedDotExpression {
            def u := target->UnresolvedDotExpression
            if u.left-?>Super {
                if !context.isInstance {
                    context.errors.error(SuperType.ERROR_MESSAGE, 
                            target.position)
                    return null
                }
                return context.call(c.position, u.left, u.right, parameters)
            }
            def left := resolve(u.left)
            if left = null
                return null
            return context.call(c.position, left, u.right, parameters)
        }
        if target-?>UnresolvedMethod {
            def u := target->UnresolvedMethod
            def finalTarget:Value
            if u.target != null 
                finalTarget := u.target->Value
            else if context.isInstance {
                finalTarget := InstanceContext(c.position, 
                        context.getSelf(c.position))
            }
            else {
                finalTarget := ClassLiteral(c.position, 
                        context.currentClass.type)
            }
            return context.call(c.position, finalTarget, u.methods, parameters)
        }
        if target-?>MethodReference {
            def m := target->MethodReference
            return context.call(c.position, m.target, m.methodStub, parameters)
        }
        target := resolve(target)
        if target = null
            return null
        def type := target.type.unwrapNullable
        if type-!>MethodType {
            context.errors.error("expected a method, but found " +
                    "'\{target.type.displayName}:\{target.class.name}'", target.position)
            return null
        }
        def unwrapped := target.implicitCast(context, type)
        def parameterTypes := type->MethodType.methodParameters
        if parameters.length != parameterTypes.length {
            def expected:String
            if parameterTypes.length = 1
                expected := "1 parameter"
            else
                expected := parameterTypes.length + " parameters"
            context.errors.error("'\{type.displayName}' expects \{expected}, " +
                    "but found \{parameters.length}", c.position)
            return null
        }
        def finalParams := Array<Value>()
        for (i, p) in parameters.enumeration()
            finalParams.add(p.implicitCast(context, parameterTypes[i]))
        return DynamicCall(unwrapped, finalParams)
    }

    method resolveClass(position:Position, name:String):Value? {
        def type := ASTClassType(position, name, null, false) 
        def resolved := context.resolveType(type)
        if resolved != null
            return ClassLiteral(position, resolved)
        return null
    }

    method convertDotExpression(d:ASTDotExpression):Value? {
        def left := convertExpression(d.left)
        if left = null
            return null
        if left-?>PackageReference {
            def p := left->PackageReference.value
            def child := p[d.right]
            if child != null
                return symbolReference(d.position, child)
            else {
                context.errors.error("package '\{p.name}' does not contain a " +
                        "member named '\{d.right}'", d.position)
                return null
            }
        }
        def resolved:Value?
        if left-!>Super
            resolved := resolve(left)
        else
            resolved := left
        if resolved = null
            return null
        return getMember(d.position, left, d.right)
    }

    method convertIdentifier(id:ASTIdentifier):Value? {
        return getIdentifier(id.position, id.identifier)
    }

    method convertClassLiteral(c:ASTClassLiteral):Value? {
        def type := resolve(c.type)
        if type != null
            return ClassLiteral(c.position, type)
        return null
    }

    method convertIntegerLiteral(i:ASTIntegerLiteral):Value? {
        return IntegerLiteral(i.position, i.value)
    }

    method convertRealLiteral(r:ASTRealLiteral):Value? {
        return RealLiteral(r.position, r.value)
    }

    ============================================================================
    Given a sequence of chars from a string literal (e.g. "Hello\n!"), returns a
    string representing the contents of the literal (e.g. "Hello<newline>!")

    If `interpolating` is true, permits the additional escape sequences `\:`,
    `\{`, and `\}`, passing them through unmodified.
    ============================================================================
    method convertStringChars(position:Position, s:String, 
            interpolating:Bit):String? {
        var result := MutableString()
        var i := 0
        loop {
            var next := s.indexOf("\\", i)
            if next = null {
                result.append(s[i..])
                break
            }
            result.append(s[i .. next])
            var c := s[next + 1]
            switch c {
                case "n":  result.append("\n")
                case "r":  result.append("\r")
                case "t":  result.append("\t")
                case '"':  result.append('"')
                case "\\": {
                    result.append("\\")
                    if interpolating
                        result.append("\\")
                }
                case "'":  result.append("'")
                case ":", "{", "}": {
                    if interpolating {
                        result.append("\\")
                        result.append(c)
                    }
                    else {
                        context.errors.error("invalid string escape '\\" + c + 
                                "'", Position(position.file, 
                                    position.offset + i))
                        return null
                    }
                }
                default: {
                    context.errors.error("invalid string escape '\\" + c + "'", 
                            Position(position.file, position.offset + i))
                    return null
                }
            }
            i := next + 2
        }
        return result->>String
    }

    method convertStringLiteral(string:ASTStringLiteral):Value? {
        var s := string.value
        def result := MutableString()
        def matcher := STRING_GROUP.matcher(s)
        def values := Array<Value>()
        var lastEnd := 0
        while matcher.find() {
            def chars := convertStringChars(string.position, 
                    s[lastEnd .. matcher.start], false)
            if chars != null {
                result.append(chars.replace(UNESCAPED_BRACE, 
                        "\\{"))
            }
            def text := s[matcher.start + 2 .. matcher.end - 1]
            def expr := PandaParser(context.errors).parseFormatExpression(
                    text, string.position)
            if expr = null
                return null
            def value := resolve(expr.expression)
            if value = null
                return null
            values.add(value)
            result.append("{")
            if expr.alignment != null {
                result.append(",")
                if expr.fill != null
                    result.append(expr.fill)
                switch expr.alignment {
                    case Alignment.LEFT: result.append("<")
                    case Alignment.CENTER: result.append("^")
                    case Alignment.RIGHT: result.append(">")
                }
                assert expr.width != null
                result.append(expr.width)
            }
            if expr.formatString != null {
                result.append(":")
                result.append(expr.formatString)
            }
            result.append("}")
            lastEnd := matcher.end()
        }
        if lastEnd > 0 {
            def chars := convertStringChars(string.position, s[lastEnd..], false)
            if chars != null
                result.append(chars.replace(UNESCAPED_BRACE, "\\{"))
            s := result->>String
            values.insert(0, StringLiteral(string.position, s))
            return context.call(string.position, ClassLiteral(
                    string.position, ClassType.STRING), "format", values)
        }
        else {
            def chars := convertStringChars(string.position, s, false)
            if chars = null
                return null
            return StringLiteral(string.position, chars)
        }
    }

    method convertBitLiteral(b:ASTBitLiteral):Value? {
        return BitLiteral(b.position, b.value)
    }

    method convertUnaryExpression(u:ASTUnaryExpression):Value? {
        var operand := resolve(u.expression)
        if operand = null
            return null
        if u.operation = UnaryOperationType.MINUS & operand-?>IntegerLiteral {
            def i := operand->IntegerLiteral
            switch i.value {
                case 128: operand := IntegerLiteral(i.position, i.value, 
                        IntType.INT8, false)
                case 32768: operand := IntegerLiteral(i.position, i.value, 
                        IntType.INT16, false)
                case 2147483648: operand := IntegerLiteral(i.position, 
                        i.value, IntType.INT32, false)
                case 9223372036854775808: operand := IntegerLiteral(
                        i.position, i.value, IntType.INT64, false)
            }
        }
        return UnaryOperation(u.position, u.operation, operand)
    }

    method convertBinaryExpression(b:ASTBinaryExpression):Value? {
        def left := resolve(b.left)
        if left = null
            return null
        def right := resolve(b.right)
        if right = null
            return null
        return getBinaryValue(b.position, left, b.operation, right)
    }

    method convertInstanceOf(position:Position, var object:Value, 
            var type:Type):Value? {
        if object.type = StringOrCharType.STRING_OR_CHAR {
            -- hardcode STRING_OR_CHAR-?>Char and STRING_OR_CHAR-?>String
            -- as true
            if type = CharType.CHAR | ClassType.STRING.canImplicitCastTo(
                    context, type)
                return BitLiteral(position, true)
        }
        def primitiveTarget := type.isPrimitive | type.isWrapper
        if primitiveTarget {
            if object.type = StringOrCharType.STRING_OR_CHAR
                object := object.implicitCast(context, CharType.CHAR)
            if object.type = CharType.CHAR & type.isNumber
                object := object.explicitCast(context, IntType.INT32)
        }
        def primitiveSource := object.type.isPrimitive | 
                object.type.isWrapper

        if object.type.isNumber & type.isReal
            return BitLiteral(position, true)

        if !primitiveSource & type.isPrimitive
            type := type->>ClassType

        if !object.canExplicitCastTo(context, type) {
            context.errors.error("'\{object.type.displayName}' " +
                    "cannot possibly be an instance of '\{type.displayName}'", 
                    position)
        }

        def parameters := Array<Value>()
        parameters.add(object)
        if !primitiveTarget
            parameters.add(ClassLiteral(position, type->>ClassType))

        var methodName := "instanceOf"
        if primitiveTarget {
            var target := type.unwrapNullable
            var name := target.name
            constant CORE := "panda.core."
            assert name.startsWith(CORE)
            name := name[CORE.length..]
            if target.isWrapper
                name := name.replace("Wrapper", "")
            methodName += name
        }
        def panda := ClassLiteral(position, ClassType.PANDA)
        var instanceOf:MethodStub? := null
        if !object.type.isNullable
            instanceOf := context.getMethod(panda, methodName, parameters)
        if instanceOf = null {
            parameters.add(BitLiteral(position, type.isNullable))
            instanceOf := context.getMethod(panda, methodName, parameters)
        }
        assert instanceOf != null
        return context.call(position, panda, instanceOf, parameters)
    }

    method convertArrowExpression(a:ASTArrowExpression):Value? {
        def left := resolve(a.left)
        if left = null
            return null
        def rightMatch := context.resolveTypeWithExtras(a.right)
        if rightMatch = null
            return null
        def right, extras := rightMatch
        if a.operation != ArrowOperationType.CONVERT &
                !left.canExplicitCastTo(context, right) {
            context.errors.error("'\{left.type.displayName}' cannot " +
                    "possibly be an instance of '\{right.displayName}'",
                    a.position)
            return null
        }
        var result:Value
        switch a.operation {
            case ArrowOperationType.CAST:
                result := left.explicitCast(a.position, context, right)
            case ArrowOperationType.INSTANCE_OF:
                result := convertInstanceOf(a.position, left, right)
            case ArrowOperationType.NOT_INSTANCE_OF: {
                def instanceOf := convertInstanceOf(a.position, left, right)
                if instanceOf = null
                    return null
                result := UnaryOperation(a.position, UnaryOperationType.NOT,
                        instanceOf)
            }
            case ArrowOperationType.CONVERT:
                result := left.convert(context, right)
            default:
                unreachable
        }
        for e in extras {
            result := getMember(result.position, result, e)
            if result = null
                return null
        }
        return result
    }

    function check(v:Value?):Bit {
        if v = null
            return true
        return v.type-!>UnresolvedType
    }

    method symbolReference(position:Position, s:Symbol):Value? {
        return symbolReference(position, null, s)
    }

    method symbolReference(position:Position, var target:Value?, 
            s:Symbol):Value? {
        if s-?>FieldNode {
            def f := s->FieldNode
            inferFieldType(f)
            if f.annotations.isClass | f.annotations.isThread {
                if target != null & target-!>ClassLiteral {
                    context.errors.error("cannot reference class field " +
                            "'\{f}' from an instance context", position)
                }
                return FieldReference(position, 
                            ClassLiteral(position, f.owner), f)
            }
            else {
                if target = null {
                    if context.isInstance {
                        return FieldReference(position, 
                                context.getSelf(position), f)
                    }
                    else {
                        context.errors.error("cannot reference instance " +
                                "field '\{f.name}' from a class context",
                                position)
                        return null
                    }
                }
                return FieldReference(position, target, f)
            }
        }
        if s-?>Methods {
            def methods := s->Methods.methods
            if target = null {
                if context.isInstance
                    target := InstanceContext(position, 
                            context.getSelf(position))
                else {
                    target := ClassLiteral(position,
                            context.currentClass.type)
                }
            }
            if methods.length = 1 {
                if methods[0].methodType = MethodNodeType.FUNCTION &
                        methods[0].parameters.length = 0 {
                    return context.call(position, target, methods[0], 
                            Array<Value>())
                }
                return MethodReference(context, position, target, 
                        methods[0])
            }
            return UnresolvedMethod(position, target, methods)
        }
        if s-?>Variable {
            def v := s->Variable
            if context.captures.length > 0 & 
                    (v-?>Parameter | v-?>LocalVariable) {
                def owner:MethodStub
                if v-?>Parameter
                    owner := v->Parameter.owner
                else
                    owner := v->LocalVariable.owner
                for i in 0 .. context.captures.length {
                    def capture := context.captures.peek(i)
                    if owner = capture[0]
                        break
                    capture[1].add(v)
                }
            }
            return VariableReference(position, s->Variable)
        }
        if s-?>Package
            return PackageReference(position, s->Package)
        if s-?>TypeSymbol
            return ClassLiteral(position, s->TypeSymbol.type)
        unreachable
    }

    method getIdentifier(position:Position, name:String):Value? {
        def result := context.symbolTable[name]
        if result != null
            return symbolReference(position, result)
        if context.isInstance
            return getMember(position, context.getSelf(position), name)
        return UnresolvedIdentifier(position, name, null)
    }

    method makeClosure(ref:MethodReference):Value {
        def parameters := Array<ASTParameter>()
        if ref.target-!>ClassLiteral
            unreachable
        for p in ref.methodStub.parameters {
            parameters.add(ASTParameter(p.position, p.name, 
                    toASTType(p.position, p.type), p.isVar, p.isVarArg))
        }
        def nameComps := ref.target->ClassLiteral.value.name.split(".")
        var classRef:ASTExpression := ASTIdentifier(ref.position, nameComps[0])
        for n in nameComps[1..]
            classRef := ASTDotExpression(classRef, n)
        def methodRef := ASTDotExpression(classRef, ref.methodStub.name)
        def parameterRefs := Array<ASTExpression>()
        for p in ref.methodStub.parameters
            parameterRefs.add(ASTIdentifier(ref.position, p.name))
        def call := ASTCallExpression(methodRef, parameterRefs)
        def statement:ASTStatement
        if ref.methodStub.returnType != VoidType.VOID
            statement := ASTReturn(ref.position, call)
        else
            statement := ASTExpressionStatement(call)
        def value := ASTMethodValue(ref.position, ref.methodStub.methodType, 
                parameters, toASTType(ref.position, ref.methodStub.returnType), 
                ASTBlock(ref.position, [statement]))
        return resolve(value)
    }

    method resolve(v:Value):Value? {
        if v.type-?>UnresolvedType {
            if !v.checkValid(context)
                return null
            def type := v.preferredType(context)
            return v.implicitCast(context, type)
        }
        return v
    }
    @post(@return = null | @return.type-!>UnresolvedType)

    method resolve(e:ASTExpression):Value? {
        var result := convertExpression(e)
        if result = null
            return null
        return resolve(result)
    }

    method resolve(t:ASTType):Type? {
        return context.resolveType(t) 
    }

    method convertNew(n:ASTNew):Value? {
        def type := resolve(n.type)
        if type = null
            return null
        def parameters := Array<Value>()
        for p in n.parameters {
            def expr := convertExpression(p)
            if expr = null
                return null
            parameters.add(expr)
        }
        if type-?>PrimitiveArrayType {
            def elementType := type->PrimitiveArrayType.parameters[0]
            if parameters.length = 1 &
                    parameters[0].canImplicitCastTo(context, IntType.INT32) {
                def cast := parameters[0].implicitCast(context, IntType.INT32)
                context.getStub(type->>PrimitiveArrayType)
                return NewPrimitiveArrayWithLength(n.position, 
                        type->>PrimitiveArrayType, cast)
            }
            else if parameters.length = 1 &
                    parameters[0].type.isPrimitiveArray &
                    parameters[0].type->PrimitiveArrayType.parameters[0] =
                        elementType {
                context.getStub(type->PrimitiveArrayType)
                return PrimitiveArrayCopy(n.position, 
                        type->PrimitiveArrayType, parameters[0])
            }
            else if parameters.length = 0 {
                context.getStub(type->>PrimitiveArrayType)
                return NewPrimitiveArrayWithLength(n.position, 
                        type->>PrimitiveArrayType, IntegerLiteral(
                            n.position, 0, IntType.INT32, true))
            }
            else {
                def casted := Array<Value>()
                for p in parameters
                    casted.add(p.implicitCast(context, elementType))
                return NewPrimitiveArrayWithValues(n.position, 
                        type->>PrimitiveArrayType, casted)
            }
        }
        if type-?>MethodType | type-?>TupleType {
            context.errors.error("type '\{type.displayName}' cannot be " +
                    "instantiated", n.position)
            return null
        }
        def stub := context.getStub(type->>ClassType)
        if stub.isInterface {
            context.errors.error("interfaces may not be instantiated",
                    n.position)
            return null
        }
        def symbolTable := context.getSymbolTable(stub)
        def constructors := symbolTable[MethodNode.CONSTRUCTOR_NAME]
        assert constructors != null
        def call := context.call(n.position, ClassLiteral(n.position, type), 
                constructors->Methods.methods, parameters)
        if call != null
            return Construct(call->MethodCall)
        else
            return null
    }

    method convertIndex(i:ASTIndex):Value? {
        def target := resolve(i.target)
        if target = null
            return null
        var index := convertExpression(i.index)
        if index = null
            return null
        if index-?>UnresolvedRange {
            def range := index->UnresolvedRange
            return UnresolvedSlice(context, i.position, target, range.left, 
                    range.right, range.step, range.endInclusive)
        }
        index := resolve(index)
        if index = null
            return null
        if target.type.unwrapNullable-?>TupleType & index-?>IntegerLiteral {
            return getMember(i.position, target, TupleType.FIELD_PREFIX + 
                    index->IntegerLiteral.value)
        }
        if target.type.unwrapNullable-?>PrimitiveArrayType {
            return PrimitiveArrayIndexValue(target, 
                    index.implicitCast(context, IntType.INT32))
        }
        return UnresolvedIndex(context, i.position, target, index)
    }

    method convertRangeExpression(r:ASTRangeExpression):Value? {
        def left:Value?
        if r.left != null {
            left := resolve(r.left->ASTExpression)
            if left = null
                return null
        }
        else
            left := null
        def right:Value?
        if r.right != null {
            right := resolve(r.right->ASTExpression)
            if right = null
                return null
        }
        else
            right := null
        def step:Value?
        if r.step != null {
            step := resolve(r.step->ASTExpression)
            if step = null
                return null
        }
        else
            step := null
        return UnresolvedRange(context, r.position, left, right, step, 
                r.endInclusive)
    }

    method convertRegex(r:ASTRegex):Value? {
        def result := context.call(r.position, ClassLiteral(r.position,
                ClassType.REGULAR_EXPRESSION), MethodNode.CONSTRUCTOR_NAME,
                [StringLiteral(r.position, r.value)])
        if result = null
            return null
        return Construct(result->MethodCall)
    }

    method convertArray(a:ASTArrayLiteral):Value? {
        def values := Array<Value>()
        for expr in a.values {
            def v := convertExpression(expr)
            if v = null
                return null
            values.add(v)
        }
        return UnresolvedArray(context, a.position, values)
    }

    method convertTuple(t:ASTTupleExpression):Value? {
        def values := Array<Value>()
        for expr in t.values {
            def v := convertExpression(expr)
            if v = null
                return null
            values.add(v)
        }
        return UnresolvedTuple(context, t.position, values)
    }

    method convertSuper(s:ASTSuper):Value? {
        if context.isInstance {
            return Super(s.position, context.currentClass.type)
        }
        context.errors.error(SuperType.ERROR_MESSAGE, s.position)
        return null
    }

    method convertSwitch(s:ASTSwitch):Statement? {
        def resolved := resolve(s.value)
        if resolved != null {
            def switchObject := ReusedValueDefinition(resolved)
            def statements := Array<Statement>()
            statements.add(ValueStatement(switchObject))
            var lastCase:Statement? := null
            def cases := Array<If>()
            if s.defaultCase != null {
                def defaultStatement := convertStatement(s.defaultCase->ASTStatement)
                if defaultStatement != null
                    lastCase := defaultStatement
                else
                    return null
            }
            for i in s.cases.length - 1 ... 0 by -1 {
                def c := s.cases[i]
                def start := resolve(c.values[0])
                if start != null {
                    var test := getBinaryValue(start.position, 
                            switchObject.createReference(), 
                            BinaryOperationType.EQUAL, 
                            start)
                    if test = null
                        return null
                    for v in c.values[1..] {
                        def next := resolve(v)
                        if next != null {
                            def equal := getBinaryValue(start.position, 
                                        switchObject.createReference(), 
                                        BinaryOperationType.EQUAL, 
                                        next)
                            if equal = null
                                return null
                            test := getBinaryValue(v.position, 
                                    test, BinaryOperationType.OR,
                                    equal)
                            if test = null
                                return null
                        }
                        else
                            return null
                    }
                    def statement := convertStatement(c.statement)
                    if statement != null {
                        lastCase := If(statement.position, test, 
                                statement, lastCase)
                    }
                    else
                        return null
                }
                else
                    return null
            }
            if lastCase = null
                return null
            statements.add(lastCase)
            return Block(s.position, statements)
        }
        return null
    }

    method convertExpression(e:ASTExpression):Value? {
        switch e.class {
            case ASTCallExpression:
                return convertCallExpression(e->ASTCallExpression)
            case ASTIdentifier:
                return convertIdentifier(e->ASTIdentifier)
            case ASTDotExpression:
                return convertDotExpression(e->ASTDotExpression)
            case ASTIntegerLiteral:
                return convertIntegerLiteral(e->ASTIntegerLiteral)
            case ASTRealLiteral:
                return convertRealLiteral(e->ASTRealLiteral)
            case ASTStringLiteral:
                return convertStringLiteral(e->ASTStringLiteral)
            case ASTBitLiteral:
                return convertBitLiteral(e->ASTBitLiteral)
            case ASTNullLiteral:
                return NullLiteral(e.position)
            case ASTUnaryExpression:
                return convertUnaryExpression(e->ASTUnaryExpression)
            case ASTBinaryExpression:
                return convertBinaryExpression(e->ASTBinaryExpression)
            case ASTArrowExpression:
                return convertArrowExpression(e->ASTArrowExpression)
            case ASTNew:
                return convertNew(e->ASTNew)
            case ASTSelf:
                return getIdentifier(e.position, "self")
            case ASTSuper:
                return convertSuper(e->ASTSuper)
            case ASTIndex:
                return convertIndex(e->ASTIndex)
            case ASTRangeExpression:
                return convertRangeExpression(e->ASTRangeExpression)
            case ASTRegex:
                return convertRegex(e->ASTRegex)
            case ASTArrayLiteral:
                return convertArray(e->ASTArrayLiteral)
            case ASTTupleExpression: 
                return convertTuple(e->ASTTupleExpression)
            case ASTClassLiteral:
                return convertClassLiteral(e->ASTClassLiteral)
            case ASTLambdaExpression:
                return convertLambda(e->ASTLambdaExpression)
            case ASTMethodValue:
                return convertMethodValue(e->ASTMethodValue)
            default:
                throw InternalCompilerException("unsupported expression: " +
                        e.class.name, e.position)
        }
    }

    method convertVarDeclaration(v:ASTVarDeclaration):Statement? {
        var initializer:Value?
        if v.initializer != null {
            initializer := convertExpression(v.initializer->ASTExpression)
            if initializer = null
                return null
        }
        else
            initializer := null
        def locals := Array<LocalVariable>()
        var allTyped := true
        for (i, decl) in v.vars.enumeration() {
            def type:Type?
            if decl.type != null {
                type := resolve(decl.type->ASTType)
                if type = null {
                    context.errors.error("unknown class '\{decl.type->ASTType}'",
                            decl.type->ASTType.position)
                    return null
                }
            }
            else {
                allTyped := false
                if initializer = null {
                    context.errors.error("variable has neither an " +
                            "initializer nor a type", decl.position)
                    return null
                }
                initializer := resolve(initializer)
                if initializer = null
                    return null
                def initializerType := initializer.preferredVariableType(
                        context)
                if v.vars.length > 1 {
                    if initializerType.unwrapNullable-!>TupleType {
                        context.errors.error("assigning to multiple " +
                                "variables from a non-tuple expression",
                                initializer.position)
                    }
                    type := initializerType.unwrapNullable->TupleType.types[i]
                }
                else
                    type := initializerType
            }
            def local := LocalVariable(decl.position, decl.identifier, type,
                    v.varType, context.currentMethod)
            if decl.identifier != "_" {
                context.localVariables.add(local)
                context.symbolTable.add(local)
            }
            locals.add(local)
        }
        if initializer != null {
            if v.vars.length = 1 {
                if locals[0].name = "_" {
                    context.errors.error("'_' is is only permitted in " +
                            "multiple assignments from a tuple", v.position)
                    return null
                }            
                return ValueStatement(VariableAssignment(v.position, 
                        locals[0], initializer.implicitCast(context, 
                            locals[0].type), 
                        true))
            }
            if allTyped {
                def types := Array<ASTType>()
                for local in locals
                    types.add(toASTType(v.position, local.type))
                initializer := initializer.implicitCast(context, 
                        context.resolveType(ASTTupleType(v.position, types, 
                            false)))
            }
            else
                initializer := resolve(initializer)
            def tuple := LocalVariable(v.position, "$tuple\{nameCount}",
                    initializer.type.unwrapNullable, VariableType.DEF,
                    context.currentMethod)
            context.localVariables.add(tuple)
            nameCount += 1
            def statements := Array<Statement>()
            statements.add(ValueStatement(VariableAssignment(
                    v.position, tuple, initializer.implicitCast(context,
                        tuple.type), 
                    true)))
            for (i, local) in locals.enumeration() {
                if local.name = "_"
                    continue
                def member := getMember(local.position, 
                        VariableReference(local.position, tuple), 
                        TupleType.FIELD_PREFIX + i)
                assert member != null
                statements.add(ValueStatement(VariableAssignment(
                        local.position, local, member.implicitCast(context, 
                            local.type), 
                        true)))
            }
            return Block(v.position, statements)
        }
        return null
    }

    method convertIf(i:ASTIf):Statement? {
        var test := resolve(i.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def thenStatement := convertStatement(i.thenStatement)
        if thenStatement = null
            return null
        def elseStatement:Statement?
        if i.elseStatement != null {
            elseStatement := convertStatement(i.elseStatement->ASTStatement)
            if elseStatement = null
                return null
        }
        else
            elseStatement := null
        return If(i.position, test, thenStatement, elseStatement)
    }

    @private
    method castToIterable(value:Value):Value? {
        def cl := context.getStub(value.type->>ClassType)
        for intf in cl.allInterfaces(context) {
            if intf.name.startsWith("panda.collections.Iterable<")
                return value.implicitCast(context, intf.type)
        }
        context.errors.error("expected 'panda.collections.Iterable<T>'" +
                ", but found '\{value.type.displayName}'", value.position)
        return null
    }

    method convertIteratorFor(f:ASTFor, iterator:Value):Statement? {
        def elementType := iterator.type->GenericType.parameters[0]
        def valueVars := Array<LocalVariable>()
        if f.valueVars.length > 1 {
            if !elementType.isTuple | 
                    elementType->>TupleType.types.length != f.valueVars.length {
                context.errors.error("'for' loop expected a list of " +
                        "tuples of length \{f.valueVars.length}, but found a " + 
                        "list of '\{elementType.displayName}'", f.position)
                return null
            }
        }
        for (i, v) in f.valueVars.enumeration() {
            var type:Type?
            if v.type != null {
                type := resolve(v.type->ASTType)
                if type = null
                    return null
            }
            else {
                if f.valueVars.length = 1
                    type := elementType
                else {
                    def tuple := elementType->TupleType
                    type := tuple.types[i]
                }
            }
            def valueVar := LocalVariable(v.position, v.identifier, type,
                    VariableType.DEF, context.currentMethod)
            valueVars.add(valueVar)
            if v.identifier != "_" {
                context.localVariables.add(valueVar)
                context.symbolTable.add(valueVar)
            }
        }
        def statements := Array<Statement>()
        def reused := ReusedValueDefinition(iterator)
        statements.add(ValueStatement(reused))
        def typeParams := Array<Type>()
        typeParams.add(elementType)
        def bodyStatements := Array<Statement>()
        def done := context.call(f.position, reused.createReference(), "done", 
                Array<Value>())
        assert done != null
        def test := If(f.position, done, Break(f.position), null)
        bodyStatements.add(test)
        def next := context.call(f.position, reused.createReference(), "next", 
                Array<Value>())
        assert next != null
        def tupleVar:LocalVariable
        if valueVars.length = 1 {
            tupleVar := valueVars[0]
        }
        else {
            tupleVar := LocalVariable(f.position, "$tuple", elementType,
                    VariableType.DEF, context.currentMethod)
            context.localVariables.add(tupleVar)
        }
        bodyStatements.add(ValueStatement(VariableAssignment(
                f.position, tupleVar, next, true)))
        if valueVars.length > 1 {
            for (i, v) in valueVars.enumeration() {
                if v.name = "_"
                    continue
                def value := getMember(f.position,
                        VariableReference(tupleVar.position, tupleVar), 
                        "$field" + i)
                assert value != null
                bodyStatements.add(ValueStatement(VariableAssignment(
                        f.position, valueVars[i], value, true)))
            }
        }
        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null
        bodyStatements.add(bodyStatement)
        def continueStatements := Array<Statement>()
        def w := LoopWithContinueBlock(f.position, f.label, 
                Block(f.position, bodyStatements), Block(f.position,
                continueStatements))
        statements.add(w)
        return Block(f.position, statements)
    }

    method convertIterableFor(f:ASTFor, rawList:Value):Statement? {
        def list := castToIterable(rawList)
        if list = null
            return null
        def getIterator := context.call(f.position, list, "iterator", 
                Array<Value>())
        assert getIterator != null
        return convertIteratorFor(f, getIterator)
    }

    @private
    function getLiteral(i:Int64, t:Type):Value {
        if t.isReal
            return RealLiteral(Position.INTERNAL, i, t->RealType)
        if i < 0 {
            return UnaryOperation(Position.INTERNAL, 
                    UnaryOperationType.MINUS,
                    IntegerLiteral(Position.INTERNAL, i.abs->UInt64, 
                    t->IntType, true))
        }        
        return IntegerLiteral(Position.INTERNAL, i->UInt64, 
                t->PrimitiveType, true)
    }

    @private
    function unsignedVersion(var t:Type):Type {
        t := t->>PrimitiveType
        switch t {
            case IntType.INT8: return IntType.UINT8
            case IntType.INT16: return IntType.UINT16
            case IntType.INT32: return IntType.UINT32
            case IntType.INT64: return IntType.UINT64
        }
        return t
    }

    -- "What the...? Why is this so complicated?!?"
    -- There's probably a simpler way to do this, but the problem of "loop from
    -- left to right by step" is harder than it sounds. Overflows are a real
    -- problem, particularly when you're looping to the minimum / maximum value
    -- supported by the type you're using, and even moreso when the step is
    -- greater than 1. So I have to jump through a lot of hoops to ensure that
    -- we correctly detect the end of the loop, never going past it and 
    -- overflowing. Feel free to figure out a better approach.

    ============================================================================
    Converts a numeric range `for` loop where the step is a compile-time 
    constant.
    ============================================================================
    method convertRangeForConstantStep(f:ASTFor, loopVar:Variable, start:Value, 
            rawEnd:Value, step:Int, endInclusive:Bit):Statement? {
        def statements := Array<Statement>()
        statements.add(ValueStatement(VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        def end := ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def testType:BinaryOperationType
        if endInclusive
            testType := BinaryOperationType.LESS_THAN_OR_EQUAL
        else        
            testType := BinaryOperationType.LESS_THAN
        def testLeft:Value
        def testRight:Value
        if step > 0 {
            testLeft := VariableReference(f.position, loopVar)
            testRight := end
        }
        else {
            testLeft := end
            testRight := VariableReference(f.position, loopVar)
        }
        def test := BinaryOperation(f.position, testType,
                testLeft, testRight)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null

        def breakTestType:BinaryOperationType
        if endInclusive
            breakTestType := BinaryOperationType.LESS_THAN
        else
            breakTestType := BinaryOperationType.LESS_THAN_OR_EQUAL
        def sub1 := Cast(f.position, end.createReference(),
                unsignedVersion(loopVar.type), CastType.CONVERT)
        def sub2 := Cast(f.position, VariableReference(f.position,
                loopVar), unsignedVersion(loopVar.type),
                CastType.CONVERT)
        def left:Value
        def right:Value
        if step > 0 {
            left := sub1
            right := sub2
        }
        else {
            left := sub2
            right := sub1
        }
        def sub := BinaryOperation(f.position, BinaryOperationType.SUBTRACT,
                left, right)
        def stepLiteral := getLiteral(step.abs, 
                unsignedVersion(loopVar.type))
        def breakTest := BinaryOperation(f.position, breakTestType, sub,
                stepLiteral)
        def label:String
        if f.label != null
            label := f.label->String
        else
            label := "$numericForLoops\{f.hash}"
        def breakIf := If(f.position, breakTest, Break(f.position, 
                label), null)
        def nextOp:BinaryOperationType
        if step > 0
            nextOp := BinaryOperationType.ADD
        else
            nextOp := BinaryOperationType.SUBTRACT
        def next := BinaryOperation(f.position, nextOp, 
                VariableReference(f.position, loopVar),
                getLiteral(step.abs, loopVar.type))
        def continueStatements := Array<Statement>()
        continueStatements.add(breakIf)
        continueStatements.add(ValueStatement(VariableAssignment(
                f.position, loopVar, next)))
        statements.add(If(f.position, test, LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                Block(f.position, continueStatements)), null))
        return Block(f.position, statements)
    }

    function getConvertCast(v:Value, t:Type):Value {
        if v.type = t
            return v
        return Cast(v.position, v, t, CastType.CONVERT)
    }

    ============================================================================
    Converts a numeric range `for` loop where the step is not a compile-time 
    constant.
    ============================================================================
    method convertRangeForVariableStep(f:ASTFor, loopVar:Variable, start:Value,
            rawEnd:Value, rawStep:Value, endInclusive:Bit):Statement? {
        def end := ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def stepCast:Value
        if loopVar.type = CharType.CHAR {
            def intermediate := rawStep.implicitCast(context, IntType.INT16)
            stepCast := getConvertCast(intermediate, CharType.CHAR)
        }
        else
            stepCast := rawStep.implicitCast(context, loopVar.type)
        def step := ReusedValueDefinition(stepCast)
        def statements := Array<Statement>()
        statements.add(ValueStatement(VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        statements.add(ValueStatement(end))
        statements.add(ValueStatement(step))
        def testLeftLeft := BinaryOperation(f.position,
                BinaryOperationType.GREATER_THAN, step.createReference(), 
                getLiteral(0, step.type))
        def testLeftRightType:BinaryOperationType
        if endInclusive
            testLeftRightType := BinaryOperationType.LESS_THAN_OR_EQUAL
        else
            testLeftRightType := BinaryOperationType.LESS_THAN
        def testLeftRight := BinaryOperation(f.position, testLeftRightType,
                VariableReference(f.position, loopVar), 
                end.createReference())
        def testLeft := BinaryOperation(f.position, BinaryOperationType.AND,
                testLeftLeft, testLeftRight)
        def testRightLeft := BinaryOperation(f.position,
                BinaryOperationType.LESS_THAN, step.createReference(), 
                getLiteral(0, step.type))
        def testRightRight := BinaryOperation(f.position,
                testLeftRightType, end.createReference(), 
                VariableReference(f.position, loopVar))
        def testRight := BinaryOperation(f.position, BinaryOperationType.AND,
                testRightLeft, testRightRight)
        def test := BinaryOperation(f.position, BinaryOperationType.OR,
                testLeft, testRight)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null

        def label:String
        if f.label != null
            label := f.label->String
        else
            label := "$numericForLoops\{f.hash}"

        def continueStatements := Array<Statement>()

        def breakLeftLeft := BinaryOperation(f.position,
                BinaryOperationType.GREATER_THAN, step.createReference(),
                getLiteral(0, step.type))
        def breakLeftRightType:BinaryOperationType
        if endInclusive
            breakLeftRightType := BinaryOperationType.LESS_THAN
        else
            breakLeftRightType := BinaryOperationType.LESS_THAN_OR_EQUAL
        def unsigned := unsignedVersion(loopVar.type)
        def leftSub := BinaryOperation(f.position, 
                BinaryOperationType.SUBTRACT, getConvertCast(
                    end.createReference(), unsigned),
                getConvertCast(VariableReference(f.position, loopVar),
                    unsigned))
        def breakLeftRight := BinaryOperation(f.position, 
                breakLeftRightType, leftSub, getConvertCast(
                    step.createReference(), unsigned))
        def breakLeft := BinaryOperation(f.position, 
                BinaryOperationType.AND, breakLeftLeft, breakLeftRight)
        def breakRightLeft := BinaryOperation(f.position,
                BinaryOperationType.LESS_THAN, step.createReference(),
                getLiteral(0, step.type))
        def rightSub := BinaryOperation(f.position, 
                BinaryOperationType.SUBTRACT, getConvertCast( 
                    VariableReference(f.position, loopVar), unsigned),
                getConvertCast(end.createReference(), unsigned))
        def breakRightRight := BinaryOperation(f.position, 
                breakLeftRightType, rightSub, UnaryOperation(f.position,
                    UnaryOperationType.MINUS, getConvertCast(
                    step.createReference(), unsigned)))
        def breakRight := BinaryOperation(f.position, 
                BinaryOperationType.AND, breakRightLeft, breakRightRight)
        def breakTest := BinaryOperation(f.position, BinaryOperationType.OR,
                breakLeft, breakRight)
        def breakIf := If(f.position, breakTest, Break(f.position, 
                label), null)
        continueStatements.add(breakIf)
        def next := BinaryOperation(f.position, BinaryOperationType.ADD,
                VariableReference(f.position, loopVar), 
                step.createReference())
        continueStatements.add(ValueStatement(VariableAssignment(
                f.position, loopVar, next)))

        statements.add(If(f.position, test, LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                Block(f.position, continueStatements)), null))
        return Block(f.position, statements)
    }

    ============================================================================
    Converts a numeric range `for` loop where the step is not specified.
    ============================================================================
    method convertRangeFor(f:ASTFor, loopVar:Variable, start:Value, 
            rawEnd:Value, endInclusive:Bit):Statement? {
        def statements := Array<Statement>()
        statements.add(ValueStatement(VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        def end := ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def testType:BinaryOperationType
        if endInclusive
            testType := BinaryOperationType.LESS_THAN_OR_EQUAL
        else        
            testType := BinaryOperationType.LESS_THAN
        def test := BinaryOperation(f.position, testType,
                VariableReference(f.position, loopVar),
                end)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null

        def inc := BinaryOperation(f.position, BinaryOperationType.ADD,
                VariableReference(f.position, loopVar), 
                getLiteral(1, loopVar.type))
        def continueStatements := Array<Statement>()
        def label:String
        if f.label != null
            label := f.label->String
        else
            label := "$numericForLoops\{f.hash}"
        if loopVar.type.isReal {
            -- reals are simpler: we can just add 1 and then check whether we've
            -- gone past our bounds (since we can safely assume that the loop
            -- bound is nowhere near the max real). For ints, that wouldn't work 
            -- if we were iterating to, say, 127 in an Int8: we can't actually 
            -- go past our bound because it would overflow, so we need to handle
            -- things a bit differently there (and the handling we do there 
            -- won't work for reals, because you can skip past a real when
            -- incrementing by 1, and that isn't true for ints)
            def breakTestType:BinaryOperationType
            if endInclusive
                breakTestType := BinaryOperationType.GREATER_THAN
            else
                breakTestType := BinaryOperationType.GREATER_THAN_OR_EQUAL
            def breakTest := BinaryOperation(f.position, breakTestType,
                    VariableReference(f.position, loopVar), 
                    end.createReference())
            def breakIf := If(f.position, breakTest, 
                    Break(f.position, label), null)
            continueStatements.add(ValueStatement(VariableAssignment(
                    f.position, loopVar, inc)))
            continueStatements.add(breakIf)
        }
        else {
            def breakTest := BinaryOperation(f.position, 
                    BinaryOperationType.EQUAL, 
                    VariableReference(f.position, loopVar),
                    end.createReference())
            def breakIf := If(f.position, breakTest, 
                    Break(f.position, label), null)
            if endInclusive
                continueStatements.add(breakIf)
            continueStatements.add(ValueStatement(VariableAssignment(
                    f.position, loopVar, inc)))
            if !endInclusive
                continueStatements.add(breakIf)
        }
        statements.add(If(f.position, test, LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                Block(f.position, continueStatements)), null))
        return Block(f.position, statements)
    }

    ============================================================================
    Converts a numeric range `for` loop (a loop which operates over an 
    numeric range, such as `for i in 1 ... 10`). This is essentially an
    optimization, as obviously the "normal" mechanism of expanding `1 ... 10` to
    a call to the range operator defined in `Int` and then iterating over the
    resulting list would work, but would be very slow.

    However, this particular transformation is *required*, so it's a bit more
    than just "an optimization". The range operators in the various `Int` 
    classes are actually defined using numeric `for` loops, trusting the 
    compiler to convert the ranges to this sort of loop. If this transformation
    were disabled, the various range operators would be defined in terms of the
    various range operators, which would not be good.
    ============================================================================
    method convertRangeFor(f:ASTFor, range:UnresolvedRange):Statement? {
        if f.valueVars.length > 1 {
            context.errors.error("'for' loop expected a list of tuples " +
                    "containing \{f.valueVars.length} elements each, found " +
                    "'\{range.type}'", f.position)
            return null
        }
        def v := f.valueVars[0]
        var type:Type?
        if v.type != null {
            type := resolve(v.type->ASTType)
            if type = null
                return null
        }
        else {
            type := range.value->Value.type->GenericType.parameters[0]
        }
        def loopVar := LocalVariable(v.position, v.identifier, type,
                VariableType.DEF, context.currentMethod)
        context.localVariables.add(loopVar)
        context.symbolTable.add(loopVar)
        def step := range.step
        if step = null {
            return convertRangeFor(f, loopVar, range.left->Value, 
                    range.right->Value, range.endInclusive)
        }
        else if step-?>IntegerLiteral {
            return convertRangeForConstantStep(f, loopVar, range.left->Value, 
                    range.right->Value, 
                    step->IntegerLiteral.value->>Int32, range.endInclusive)
        }
        else if step-?>UnaryOperation {
            def u := step->UnaryOperation
            if u.operation = UnaryOperationType.MINUS & 
                    u.operand-?>IntegerLiteral {
                return convertRangeForConstantStep(f, loopVar, 
                        range.left->Value, range.right->Value, 
                        -u.operand->IntegerLiteral.value->>Int32,
                        range.endInclusive)
            }
        }
        return convertRangeForVariableStep(f, loopVar, range.left->Value, 
                range.right->Value, step, range.endInclusive)
    }

    method convertPrimitiveArrayFor(f:ASTFor, rawArray:Value):Statement? {
        def array := ReusedValueDefinition(rawArray)
        def elementType := array.type->>PrimitiveArrayType.elementType
        def valueVars := Array<Variable>()
        for v in f.valueVars {
            var type:Type?
            if v.type != null {
                type := resolve(v.type->ASTType)
                if type = null
                    return null
            }
            else
                type := elementType
            def valueVar := LocalVariable(v.position, v.identifier, type,
                    VariableType.DEF, context.currentMethod)
            valueVars.add(valueVar)
            context.localVariables.add(valueVar)
            context.symbolTable.add(valueVar)
        }
        def statements := Array<Statement>()
        statements.add(ValueStatement(array))
        def indexVar := LocalVariable(f.position, "$index", IntType.INT32,
                    VariableType.VAR, context.currentMethod)
        context.localVariables.add(indexVar)
        statements.add(ValueStatement(VariableAssignment(f.position, 
                indexVar, IntegerLiteral(f.position, 0, indexVar.type, 
                true), true)))
        def lengthVar := LocalVariable(f.position, "$length", IntType.INT32,
                    VariableType.VAR, context.currentMethod)
        context.localVariables.add(lengthVar)
        statements.add(ValueStatement(VariableAssignment(f.position, 
                lengthVar, getMember(f.position, array.createReference(), 
                    "length")->Value, 
                true)))
        def typeParams := Array<Type>()
        typeParams.add(elementType)
        def bodyStatements := Array<Statement>()
        def done := BinaryOperation(f.position, 
                BinaryOperationType.GREATER_THAN_OR_EQUAL, 
                    VariableReference(f.position, indexVar),
                    VariableReference(f.position, lengthVar))
        def test := If(f.position, done, Break(f.position), null)
        bodyStatements.add(test)
        bodyStatements.add(ValueStatement(VariableAssignment(f.position,
                valueVars[0], PrimitiveArrayIndexValue(
                        array.createReference(), 
                        VariableReference(f.position, indexVar)).implicitCast(context, valueVars[0].type))))
        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null
        bodyStatements.add(bodyStatement)
        def continueStatements := Array<Statement>()
        def plusOne := BinaryOperation(f.position, 
                BinaryOperationType.ADD, VariableReference(f.position,
                        indexVar), IntegerLiteral(f.position, 1, 
                        indexVar.type, true))
        continueStatements.add(ValueStatement(VariableAssignment(
                f.position, indexVar, plusOne, false)))
        def w := LoopWithContinueBlock(f.position, f.label, 
                Block(f.position, bodyStatements), Block(f.position,
                continueStatements))
        statements.add(w)
        return Block(f.position, statements)
    }

    method convertFor(f:ASTFor):Statement? {
        var list := convertExpression(f.list)
        if list = null
            return null
        if list-?>UnresolvedRange
            return convertRangeFor(f, list->UnresolvedRange)
        list := resolve(list)
        if list = null
            return null
        if list.type.name.startsWith("panda.collections.PrimitiveArray<") |
                list.type.name.startsWith("panda.collections.ImmutablePrimitiveArray<")
            return convertPrimitiveArrayFor(f, list)
        if list.type.name.startsWith("panda.collections.Iterator<")
            return convertIteratorFor(f, list)
        return convertIterableFor(f, list)
    }

    method convertLoop(l:ASTLoop):Statement? {
        def statement := convertStatement(l.statement)
        if statement = null
            return null
        return Loop(l.position, l.label, statement)
    }

    method convertWhile(w:ASTWhile):Statement? {
        var test := resolve(w.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def statement := convertStatement(w.statement)
        if statement = null
            return null
        return While(w.position, w.label, test, statement)
    }

    method convertDo(d:ASTDo):Statement? {
        var test := resolve(d.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def statement := convertStatement(d.statement)
        if statement = null
            return null
        return Do(d.position, d.label, test, statement)
    }

    method convertBreak(b:ASTBreak):Statement? {
        return Break(b.position, b.label)
    }

    method convertContinue(c:ASTContinue):Statement? {
        return Continue(c.position, c.label)
    }

    ============================================================================
    As implicitCast, but with the ability to toggle whether we care about 
    signedness. If `signMatters` is false, the signedness is not considered
    important and will not stop a cast that would normally not be allowed.

    Note that the source and destination types are not necessarily integers; if
    not, we ignore the signMatters flag altogether and just perform a normal
    implicitCast.
    ============================================================================
    @private
    method signMattersCast(position:Position, v:Value, t:Type, 
            signMatters:Bit):Value? {
        if !signMatters {
            def srcType := v.type->>PrimitiveType
            if srcType.isInteger & t.isInteger & 
                    srcType->IntType.signed != t->IntType.signed & 
                    srcType->>PrimitiveType.size <= t->>PrimitiveType.size
                return v.explicitCast(context, t)
        }
        return v.implicitCast(context, t)
    }

    method power(position:Position, left:Value, right:Value):Value? {
        def target := ClassLiteral(position, ClassType.PANDA)
        def params := Array<Value>()
        params.add(left)
        params.add(right)
        return context.call(position, target, "pow", params)
    }
    
    ============================================================================
    Returns `<left> <op> <right>`, where `op` is the type of a token 
    representing a binary operator.
    
    @param node the position, for error reporting purposes
    @param left the left operand
    @param op the token type of a binary operator
    @param right the right operand
    ============================================================================
    method getBinaryValue(position:Position, var left:Value, 
            op:BinaryOperationType, var right:Value):Value? {
        def methodName:String
        switch op {
            case BinaryOperationType.ADD:                   methodName := "+"
            case BinaryOperationType.SUBTRACT:              methodName := "-"
            case BinaryOperationType.MULTIPLY:              methodName := "*"
            case BinaryOperationType.DIVIDE:                methodName := "/"
            case BinaryOperationType.INT_DIVIDE:            methodName := "//"
            case BinaryOperationType.REMAINDER:             methodName := "%"
            case BinaryOperationType.SHIFT_LEFT:            methodName := "<<"
            case BinaryOperationType.SHIFT_RIGHT:           methodName := ">>"
            case BinaryOperationType.AND:                   methodName := "&"
            case BinaryOperationType.OR:                    methodName := "|"
            case BinaryOperationType.XOR:                   methodName := "~"
            case BinaryOperationType.BITWISE_AND:           methodName := "&&"
            case BinaryOperationType.BITWISE_OR:            methodName := "||"
            case BinaryOperationType.BITWISE_XOR:           methodName := "~~"
            case BinaryOperationType.EQUAL:                 methodName := "="
            case BinaryOperationType.NOT_EQUAL:             methodName := "!="
            case BinaryOperationType.IDENTITY:              methodName := "=="
            case BinaryOperationType.NOT_IDENTITY:          methodName := "!=="
            case BinaryOperationType.LESS_THAN:             methodName := "<"
            case BinaryOperationType.GREATER_THAN:          methodName := ">"
            case BinaryOperationType.LESS_THAN_OR_EQUAL:    methodName := "<="
            case BinaryOperationType.GREATER_THAN_OR_EQUAL: methodName := ">="
            case BinaryOperationType.POWER: return power(position, left, right)
            default: {
                context.errors.error("unsupported binary operator '\{op}'",
                        position)
                return null
            }
        }
        def resolvedLeft := resolve(left)
        if resolvedLeft != null
            left := resolvedLeft
        else
            return null 
        def resolvedRight := resolve(right)
        if resolvedRight != null
            right := resolvedRight
        else
            return null
        var value := context.callOverloadedOperator(position, methodName, left,
                right)
        if value = null {
            def operandType := BinaryOperation.operandType(context, op, left, 
                    right)
            if operandType = null {
                context.errors.error("'\{methodName}' cannot operate on " +
                        "'\{left.type.displayName}', "+ 
                        "'\{right.type.displayName}'", position)
                return null
            }
            def leftCast := signMattersCast(position, left, operandType, 
                    BinaryOperation.signMatters(op))
            if leftCast != null
                left := leftCast
            else
                return null
            def rightCast := signMattersCast(position, right, operandType, 
                    BinaryOperation.signMatters(op))
            if rightCast != null
                right := rightCast
            else
                return null
            value := BinaryOperation(position, op, left, right)
        }
        return value
    }

    @class
    method unwrapCast(v:Value):Value {
        if v-?>Cast
            return unwrapCast(v->Cast.value)
        return v
    }

    @private
    method getSliceAssignmentCall(u:UnresolvedSlice, 
            params:Array<Value>):Value? {
        def name:String
        if u.endInclusive
            name := "[...]:="
        else
            name := "[..]:="
        return context.testCall(u.position, u.contextValue, name, 
                params)
    }

    @private
    method getSliceAssignmentCall(u:UnresolvedSlice, v:Value):Value? {
        if u.left = null & u.right = null & u.step = null {
            def params := Array<Value>()
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        if u.right = null & u.step = null {
            def params := Array<Value>()
            if u.left != null
                params.add(u.left->Value)
            else
                params.add(NullLiteral(u.position))
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        if u.step = null {
            def params := Array<Value>()
            if u.left != null
                params.add(u.left->Value)
            else
                params.add(NullLiteral(u.position))
            if u.right != null
                params.add(u.right->Value)
            else
                params.add(NullLiteral(u.position))
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        def params := Array<Value>()
        if u.left != null
            params.add(u.left->Value)
        else
            params.add(NullLiteral(u.position))
        if u.right != null
            params.add(u.right->Value)
        else
            params.add(NullLiteral(u.position))
        if u.step != null
            params.add(u.step->Value)
        else
            params.add(IntegerLiteral(u.position, 1))
        params.add(v)
        return getSliceAssignmentCall(u, params)
    }

    method findAssignmentMethod(target:Value, name:String, 
            params:ListView<Value>):Value? {
        if name = "[..]" | name = "[...]" {
            -- check for reduced argument methods first
            if params.length = 4 & params[2]-?>IntegerLiteral & 
                    params[2]->IntegerLiteral.value = 1 {
                def newParams := Array<Value>()
                newParams.add(params[0])
                newParams.add(params[1])
                newParams.add(params[3])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null
                    return result
            }
            else if params.length = 3 & params[1]-?>NullLiteral {
                def newParams := Array<Value>()
                newParams.add(params[0])
                newParams.add(params[2])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null
                    return result
            }
            else if params.length = 2 & params[0]-?>NullLiteral {
                def newParams := Array<Value>()
                newParams.add(params[1])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null
                    return result
            }
        }
        return context.testCall(target.position, target, name + ":=", params)
    }

    -- FIXME refactoring required! I did this all wrong and dumb. When I first
    -- started working on Panda, all lvalues were also rvalues. Then one
    -- situation crept in where the two weren't exactly the same, so I hacked it
    -- a bit to get it working. Then another cropped up, and another, and slowly
    -- this nice simple method turned into this hellish monstrosity. It needs to
    -- be killed with extreme prejudice, and I apologize to anyone reading this
    -- code. It just built up a bit at a time until it was completely out of
    -- control.
    --
    -- The basic idea is that (due to the original simplicity) the processing
    -- originally just figured out the rvalue on the left side of the assignment
    -- operator, ran into an assignment operator, made sure the rvalue worked as
    -- an lvalue, and continued on its merry way. Since then, this has gotten so 
    -- hellishly complicated that it absolutely needs to be rewritten so as to 
    -- know up front to be looking for an lvalue, so we can eliminate all of 
    -- these special cases and cut this at least in half.
    --
    -- UPDATE:
    -- Oh god I made it even worse. It's so awful. Please don't judge me by this
    -- method, I'm better than this, I swear :-(
    --
    -- FURTHER UPDATE:
    -- Actually, I don't think the refactoring is as simple as I outlined. I 
    -- hadn't considered the complexities introduced by compound assignment. We
    -- can't just process the assignment target twice (once in "lvalue mode" and
    -- once in "rvalue mode"), because that would involve duplicate evaluations
    -- of things that are only supposed to be evaluated once. It can certainly
    -- be done simpler than it's being done, but I don't think it's possible to
    -- eliminate quite as much complexity as I had hoped.
    method processSingleAssignment(var left:Value, right:Value, 
            reuse:Bit):Statement? {
        if left-?>UnresolvedIndex {
            def index := left->UnresolvedIndex
            def params := Array<Value>()
            params.add(index.index)
            params.add(right)
            def call := context.testCall(index.position, index.contextValue, 
                    "[]:=", params)
            if call != null
                return ValueStatement(call)
            context.errors.error("'\{index.contextValue.type.displayName}' " +
                    "does not define the '[]:=' operator for " +
                    "'\{index.index.type.displayName}', " +
                    "'\{right.type.displayName}'", index.index.position)
            return null
        }
        else if left-?>UnresolvedSlice {
            def slice := left->UnresolvedSlice
            def call := getSliceAssignmentCall(slice, right)
            if call != null
                return ValueStatement(call)
            def name:String
            if slice.endInclusive
                name := "'[...]:=' (inclusive slice assignment)"
            else
                name := "'[..]:=' (exclusive slice assignment)"
            def types := Array<String>()
            if slice.left != null
                types.add(slice.left->Value.type.displayName)
            else
                types.add("null")
            if slice.right != null
                types.add(slice.right->Value.type.displayName)
            else
                types.add("null")
            if slice.step != null
                types.add(slice.step->Value.type.displayName)
            else
                types.add("null")
            types.add(right.type.displayName)
            context.errors.error("'\{slice.contextValue.type.displayName}' " +
                    "does not define the \{name} operator for \{types}",
                    right.position)
            return null
        }

        var resolvedLeft := resolve(left)
        if resolvedLeft = null
            return null
        resolvedLeft := unwrapCast(resolvedLeft)
-*        if left-?>Unresolved {
            -- could be an assignment method
            var contextValue := left->Unresolved.contextValue
            def name := left->Unresolved.name
            if contextValue = null {
                if context.isInstance
                    contextValue := context.getSelf(left.position)
                else {
                    -- we're in a class context, so there can't possibly be an
                    -- assignment method. Go ahead and report the error.
                    return null
                }
            }
            def call := callAssignmentMethod(contextValue, name, 
                    PrimitiveArray<Value>(right))
            if call != null
                currentNode.add(call)
            else {
                -- no assignment method, trigger the exception
                resolve(left)
            }
        }
        else if left-?>AmbiguousReference {
            var a := left->AmbiguousReference
            var object := a.context
            if reuse {
                def reusable := makeReusable(object)
                reusable.replace(reusable.createReference())
                currentNode.add(ValueStatement(reusable))
                object := reusable.createReference()
            }
            checkAssignment(a.field, a.position)
            open(FieldAssignment(left.position, object, a.field))
            currentNode.add(implicitCast(right.position, right, a.type))
            close(FieldAssignment)
        } *-
        if resolvedLeft-?>VariableReference {
            def variable := resolvedLeft->VariableReference.variable
            def cast := right.implicitCast(context, variable.type)
            def assignment := VariableAssignment(left.position,
                    variable, cast)
            return ValueStatement(assignment)
        }
        else if resolvedLeft-?>FieldReference {
            def fv := resolvedLeft->FieldReference
            def object:Value
            def finalRight:Value
            if reuse & fv.object-!>ClassLiteral {
                def old := unwrapCast(right)->BinaryOperation
                assert old.left = fv
                object := ReusedValueDefinition(fv.object)
                def newRight := BinaryOperation(old.position, old.operation,
                        FieldReference(old.position, object, fv.field), 
                        old.right)
                def cast := newRight.implicitCast(context, fv.field.type)
                finalRight := cast
            }
            else {
                object := fv.object
                finalRight := right.implicitCast(context, fv.field.type)
            }
            def name := fv.field.name
            return FieldAssignment(fv.position, object, fv.field,
                    finalRight)
        }
        else if resolvedLeft-?>PrimitiveArrayIndexValue {
            def iv := left->PrimitiveArrayIndexValue
            if reuse {
                def old := unwrapCast(right)->BinaryOperation
                assert old.left = iv
                def array := ReusedValueDefinition(iv.array)
                def index := ReusedValueDefinition(iv.index)
                def newRight := BinaryOperation(old.position, old.operation,
                        PrimitiveArrayIndexValue(array, index), old.right)
                def cast := newRight.implicitCast(context,
                        array.type->>PrimitiveArrayType.elementType)
                return PrimitiveArrayIndexAssignment(left.position,
                        array.createReference(), index.createReference(), cast)
            }
            else {
                def array := iv.array
                def index := iv.index
                def cast := right.implicitCast(context,
                        array.type->>PrimitiveArrayType.elementType)
                return PrimitiveArrayIndexAssignment(left.position, 
                        array, index, cast)
            }
        }
-*
        else if left-?>PossibleIndexedAssignment {
            var pia := left->PossibleIndexedAssignment
            var params := [pia.index, right]
            var call := callAssignmentMethod(pia.context, "[]", params)
            if call != null
                currentNode.add(call)
            else {
                -- FIXME use map
                var types := PrimitiveArray<String>()
                for p in params
                    types.append(p.type.displayName)
                throw CompilerException("'\{pia.context.type.displayName}' does " + 
                        "not define the indexed assignment ([]:=) operator " +
                        "for \{types}", pia.position)
            }
        }
*-
        else if left-?>MethodCall {
            -- assigning to a method call. We need to look for a corresponding
            -- assignment method / field.
            def mc := left->MethodCall
            def methodStub := mc.methodStub
            if !methodStub.annotations.isClass & (mc.parameters.length = 0 | 
                    methodStub.name = "[]" | methodStub.name = "[..]" |
                    methodStub.name = "[...]") {
                def oldParams := mc.parameters
                def testParams := Array<Value>(oldParams)
                -- undo implicit casts that happened as part of setting up the
                -- original method call
                for (i, p) in testParams.enumeration() {
                    testParams[i] := unwrapCast(p)
                }
                if methodStub.name = "[..]" | methodStub.name = "[...]" {
                    -- restore parameters that might have been stripped when we
                    -- matched the initial slice. Such a hack, I'm so sorry.
                    if testParams.length = 0
                        testParams.add(NullLiteral(left.position))
                    if testParams.length = 1
                        testParams.add(NullLiteral(left.position))
                    if testParams.length = 2
                        testParams.add(IntegerLiteral(left.position, 1))
                }
                testParams.add(right)
                def target := unwrapCast(mc.target)
                def result := findAssignmentMethod(target, methodStub.name, 
                        testParams)
                if result != null
                    return ValueStatement(result)
                else {
                    -- no assignment method
                    if methodStub.name = "[]" {
                        def types := Array<String>()
                        for p in testParams
                            types.add(p.type.displayName)
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the indexed assignment ([]:=) " +
                                "operator for \{types}", mc.position)
                    }
                    else if methodStub.name = "[..]" {
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the exclusive slice assignment ([..]:=) " +
                                "operator for these types", mc.position)
                    }
                    else if methodStub.name = "[...]" {
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the inclusive slice assignment ([...]:=) " +
                                "operator for these types", mc.position)
                    }
                    else {
                        context.errors.error("cannot assign to '\{left}'", 
                                left.position)
                    }
                }
            }
            else {
                context.errors.error("cannot assign to '\{left}'", 
                        left.position)
            }
        }
        else
            context.errors.error("cannot assign to '\{left}'", left.position)
        return null
    }

    method processAssignment(position:Position, var left:ListView<Value?>, 
            assignmentOp:BinaryOperationType?, var right:Value):Statement? {
        def cm := context.currentMethod
        def reuse:Bit
        if assignmentOp = null {
            reuse := false
        }
        else {
            reuse := true
            if left.length > 1 {
                context.errors.error("compound assignment cannot " +
                        " assign to multiple values at once", 
                        position)
                return null
            }
            var lvalue := left[0]
            if lvalue = null {
                context.errors.error("'_' is only permitted in " +
                        "multiple assignments from a tuple", 
                        position)
                return null
            }
            def finalRight := getBinaryValue(position, lvalue, assignmentOp, 
                    right)
            if finalRight = null
                return null
            right := finalRight
            -- deal with situations like int8 += 1 (which resolves into
            -- int8 := int8 + 1, and the right side promotes to an Int32, so we
            -- need to downcast)
            def resolved := resolve(lvalue)->Value
            if right.type.isInteger & resolved.type.isInteger
                right := right.explicitCast(context, resolved.type)
            def newLeft := Array<Value?>()
            newLeft.add(lvalue)
            left := newLeft
        }

        if left.length > 1 {
-*            var result := Array<Statement>()
            def reused := ReusedValueDefinition(right)
            result.add(ValueStatement(reused))
            for (i, lvalue) in left.enumeration() {
                if lvalue != null {
                    def tupleValue := getMember(right.position, 
                            reused.createReference(), 
                            TupleType.FIELD_PREFIX + i)
                    assert tupleValue != null : "can't-happen tuple failure"
                    def assignment := processSingleAssignment(lvalue, 
                            assignmentOp, tupleValue, reuse)
                    if assignments = null
                        return null
                }
            }
            return Block(position, result)*-
            unreachable
        }
        else {
            def lvalue := left[0]
            assert lvalue != null
            return processSingleAssignment(lvalue, right, reuse)
        }
    }

    method convertAssignment(a:ASTAssignment):Statement? {
        def lvalues := Array<Value?>()
        for lvalue in a.lvalues {
            def converted := convertExpression(lvalue)
            if converted = null
                return null
            lvalues.add(converted)
        }
        assert lvalues.length = 1 : "tuples not supported"
        def rvalue := convertExpression(a.rvalue)
        if rvalue = null
            return null
        return processAssignment(a.position, lvalues, a.operator, rvalue)
    }

    method convertReturn(r:ASTReturn):Statement? {
        if r.value = null {
            if context.currentMethod.returnType != VoidType.VOID {
                context.errors.error("return expected a value of type '" +
                        context.currentMethod.returnType.displayName + "'", 
                        r.position)
            }
            return Return(r.position)
        }
        if context.currentMethod.returnType = VoidType.VOID {
            context.errors.error("cannot return a value in a method with no " +
                    "return type", r.position)
            return null
        }
        def converted := convertExpression(r.value->ASTExpression)
        if converted = null
            return null
        def cast := converted.implicitCast(context, 
                context.currentMethod.returnType)
        return Return(r.position, cast)
    }

    method convertAssert(a:ASTAssert):Statement? {
        def test := resolve(a.test->ASTExpression)
        if test = null
            return null
        def error:Value?
        if a.error != null {
            def resolved := resolve(a.error->ASTExpression)
            if resolved = null
                return null
            if resolved.canImplicitCastTo(context, ClassType.STRING)
                error := resolved.implicitCast(context, ClassType.STRING)
            else
                error := resolved.implicitCast(context, ClassType.ERROR)
        }
        else
            error := null
        return Assert(a.position, test.implicitCast(context, BitType.BIT),
                error)
    }

    method convertUnreachable(u:ASTUnreachable):Statement? {
        return Unreachable(u.position)
    }

    method convertStatement(s:ASTStatement):Statement? {
        switch s.class {
            case ASTExpressionStatement: {
                def expr := resolve(s->ASTExpressionStatement.expression)
                if expr != null
                    return ValueStatement(expr)
                return null
            }
            case ASTIf:
                return convertIf(s->ASTIf)
            case ASTFor:
                return convertFor(s->ASTFor)
            case ASTLoop:
                return convertLoop(s->ASTLoop)
            case ASTWhile:
                return convertWhile(s->ASTWhile)
            case ASTDo:
                return convertDo(s->ASTDo)
            case ASTSwitch:
                return convertSwitch(s->ASTSwitch)
            case ASTBreak:
                return convertBreak(s->ASTBreak)
            case ASTContinue:
                return convertContinue(s->ASTContinue)
            case ASTVarDeclaration:
                return convertVarDeclaration(s->ASTVarDeclaration)
            case ASTAssignment:
                return convertAssignment(s->ASTAssignment)
            case ASTReturn:
                return convertReturn(s->ASTReturn)
            case ASTBlock:
                return convertBlock(s->ASTBlock)
            case ASTTry:
                return convertTry(s->ASTTry)
            case ASTThrow:
                return convertThrow(s->ASTThrow)
            case ASTAssert:
                return convertAssert(s->ASTAssert)
            case ASTUnreachable:
                return convertUnreachable(s->ASTUnreachable)
            default:
                throw InternalCompilerException("unsupported statement: " +
                        s.class.name, s.position)
        }
    }

    method convertBlock(b:ASTBlock):Block {
        context.pushSymbolTable()
        def statements := Array<Statement>()
        for s in b.statements {
            def converted := convertStatement(s)
            if converted != null
                statements.add(converted)
        }
        context.popSymbolTable()
        return Block(b.position, statements)
    }

    method convertCatch(c:ASTCatch):Catch? {
        def type := resolve(c.type)
        if type = null
            return null
        def error := LocalVariable(c.position, c.name, type, 
                VariableType.DEF, context.currentMethod)
        context.localVariables.add(error)
        context.pushSymbolTable()
        context.symbolTable.add(error)
        def statement := convertStatement(c.statement)
        context.popSymbolTable()
        if statement = null
            return null
        return Catch(c.position, error, statement)
    }

    method convertTry(t:ASTTry):Try? {
        def statement := convertStatement(t.statement)
        if statement = null
            return null
        def catches := Array<Catch>()
        for astCatch in t.catches {
            def c := convertCatch(astCatch)
            if c != null
                catches.add(c)
        }
        return Try(t.position, statement, catches)
    }

    method convertThrow(t:ASTThrow):Statement? {
        def error := resolve(t.error)
        if error = null
            return null
        return Throw(t.position, error.implicitCast(context, 
                ClassType.ERROR))
    }

    @class
    function toASTType(position:Position, var t:Type):ASTType? {
        if t = VoidType.VOID
            return null
        def nullable:Bit
        if t-?>NullableType {
            nullable := true
            t := t->NullableType.base
        }
        else
            nullable := false
        if t-?>MethodType {
            def m := t->MethodType
            def parameters := Array<ASTType>()
            for p in m.methodParameters
                parameters.add(toASTType(position, p))
            return ASTMethodType(position, parameters, 
                    toASTType(position, m.returnType), nullable, m.isFunction, 
                    m.immutableMethod)
        }
        else if t-?>TupleType {
            def tuple := t->TupleType
            def types := Array<ASTType>()
            for type in tuple.types
                types.add(toASTType(position, type))
            return ASTTupleType(position, types, nullable)
        }
        else if t-?>GenericType {
            def g := t->GenericType
            def parameters := Array<ASTType>()
            for p in g.parameters
                parameters.add(toASTType(position, p))
            return ASTClassType(position, g.base.name, parameters, nullable)
        }
        return ASTClassType(position, t.name, null, nullable)
    }

    method convertLambda(l:ASTLambdaExpression):Value? {
        def allTyped := l.parameters.filter(p => p.type = null).length = 0
        def value:Value?
        if allTyped {
            context.pushSymbolTable()
            def parameters := Array<ASTParameter>()
            for p in l.parameters {
                parameters.add(ASTParameter(p.position, p.identifier, 
                        p.type->ASTType, false, false))
                def type := resolve(p.type->ASTType)
                if type = null
                    return null
                context.symbolTable.add(LocalVariable(
                        p.position, p.identifier, type, VariableType.DEF,
                        context.currentMethod))
            }
            def ir := IRGenerator(context.root, context.classes,
                    context.stubGenerator, context.compilerSettings,
                    context.errors)
            ir.context.pushSymbolTable(context.symbolTable)
            ir.context.pushSymbolTable()
            ir.context.symbolTable.addAll(context.symbolTable.mySymbols)
            def expr := ir.resolve(l.value)
            if expr = null
                return null
            context.popSymbolTable()
            var returnType := expr.type
            if returnType = VoidType.VOID {
                context.errors.error("lambda must return a value",
                        expr.position)
                return null
            }
            if returnType = StringOrCharType.STRING_OR_CHAR
                returnType := CharType.CHAR
            def statements := Array<ASTStatement>()
            statements.add(ASTReturn(l.position, l.value))
            def body := ASTBlock(l.position, statements)
            def methodValue := ASTMethodValue(l.position, 
                    MethodNodeType.FUNCTION, parameters, 
                    toASTType(l.position, returnType), body)
            value := convertMethodValue(methodValue)
        }
        else
            value := null
        def names := Array<String>()
        def types := Array<ASTType?>()
        for p in l.parameters {
            names.add(p.identifier)
            types.add(p.type)
        }
        return UnresolvedLambda(context, l.position, names, types, l.value,
                value)
    }

    function methodNames():ListView<String> {
        def result := Array<String>()
        for m in context.methods
            result.add(m.stub.name)
        return result
    }

    function createClosureConstructorAndFields(position:Position,
            captures:Set<Variable>, owner:ClassType):(MethodStub, ListView<FieldNode>) {
        def parameters := Array<FormalParameter>()
        def fields := Array<FieldNode>()
        for v in captures {
            parameters.add(FormalParameter(position, v.name, v.type, false, 
                    false))
            fields.add(FieldNode(position, owner, v.name, 
                    Annotations(position), VariableType.DEF, v.type, null,
                    null))
        }
        def body := Array<ASTStatement>()
        for (i, field) in fields.enumeration() {
            def lvalues := Array<ASTExpression>()
            lvalues.add(ASTDotExpression(ASTIdentifier(position, 
                    Parameter.SELF_NAME), field.name))
            body.add(ASTAssignment(lvalues, null,
                    ASTIdentifier(position, field.name)))
        }
        def stub := MethodStub(position, MethodNode.CONSTRUCTOR_NAME, 
                Annotations(position), MethodNodeType.CONSTRUCTOR, 
                parameters, VoidType.VOID, ASTBlock(position, body), 
                owner)
        return (stub, fields)
    }

    method convertMethodValue(m:ASTMethodValue):Value? {
        def className := context.currentClass.name + "$closure" + nameCount
        nameCount += 1
        def closureType := ClassType(className)
        def oldLocals := Array<LocalVariable>(context.localVariables)
        context.localVariables.clear()
        def lastMethod := context.currentMethod
        def formalParameters := Array<FormalParameter>()
        for p in m.parameters {
            def type := resolve(p.type)
            if type = null
                return null
            formalParameters.add(FormalParameter(p.position, p.name, type, 
                    p.isVar, p.isVarArg))
        }
        def returnType:Type?
        if m.returnType != null {
            returnType := resolve(m.returnType->ASTType)
            if returnType = null
                return null
        }
        else
            returnType := VoidType.VOID
        constant RAW_NAME := "raw"
        constant SHIMMED_NAME := "shimmed"
        def rawStub := MethodStub(m.position, RAW_NAME, 
                Annotations(m.position), m.methodType, formalParameters, 
                returnType, m.body, closureType)
        context.currentMethod := rawStub
        context.pushSymbolTable()
        def parameters := Array<Parameter>()
        for formal in m.parameters {
            def type := resolve(formal.type)
            if type = null {
                context.currentMethod := lastMethod
                return null
            }
            def p := Parameter(formal.position, formal.name, type, 
                    formal.isVar, formal.isVarArg, rawStub)
            parameters.add(p)
            context.symbolTable.add(p)
        }
        if !lastMethod.annotations.isClass {
            def selfType := lastMethod.owner
            def selfParam := Parameter(m.position, Parameter.SELF_NAME,
                    selfType, false, false, rawStub)
            context.symbolTable.add(selfParam)
        }
        context.captures.push((rawStub, HashSet<Variable>()))
        -- need to convertBlock in order to grab captures
        def oldAdd := addMethods
        addMethods := false
        convertBlock(m.body->ASTBlock)
        addMethods := oldAdd
        def closureSymbols := OrderedMap<String, Symbol>()
        def closureConstructor, closureFields := createClosureConstructorAndFields(
                m.position, context.captures.peek()[1], closureType)
        def closureAnnotations := Array<AnnotationType>()
        closureAnnotations.add(AnnotationType.SYNTHETIC)

        def shimmedStub:MethodStub
        if returnType.isPrimitive {
            def shimParameters := Array<ASTExpression>()
            for p in formalParameters
                shimParameters.add(ASTIdentifier(m.position, p.name))
            def call := ASTCallExpression(ASTIdentifier(m.position,
                    RAW_NAME), shimParameters)
            def statements := Array<ASTStatement>()
            statements.add(ASTReturn(m.position, call))
            def shimBody := ASTBlock(m.position, statements)
            shimmedStub := MethodStub(m.position, SHIMMED_NAME, 
                    Annotations(m.position), m.methodType, formalParameters, 
                    ClassType.OBJECT, shimBody, closureType)
        }
        else {
            shimmedStub := MethodStub(m.position, "shimmed", 
                    Annotations(m.position), m.methodType, formalParameters, 
                    returnType, m.body, closureType)

        }

        closureSymbols[rawStub.name] := Methods(rawStub)
        closureSymbols[shimmedStub.name] := Methods(shimmedStub)
        closureSymbols[closureConstructor.name] := 
                Methods(closureConstructor)
        for f in closureFields
            closureSymbols[f.name] := f
        def lookupContext := context.currentClass.lookupContext
        def superclass := ClassType.METHOD
        def closureStub := ClassStub(m.position, closureType, 
                false, Annotations(m.position, closureAnnotations), 
                superclass, Array<ClassType>(), closureSymbols, lookupContext,
                Array<ASTInvariant>(), null, false, 
                context.currentClass.type)
        if addMethods
            context.classes[closureStub.name] := closureStub
        context.popSymbolTable()
        context.localVariables.clear()
        context.localVariables.addAll(oldLocals)
        context.currentMethod := lastMethod
        def constructorParameters := Array<Value>()
        for v in context.captures.peek[1]
            constructorParameters.add(VariableReference(m.position, v))
        def closureInstance := Construct(MethodCall(m.position, 
                ClassLiteral(m.position, closureType), 
                closureConstructor, constructorParameters))
        context.captures.pop()
        return Cast(m.position, closureInstance, rawStub.type(context),
                CastType.IMPLICIT)
    }

    function callsOtherSelfConstructor(owner:ClassType,
            statements:ListView<Statement>):Bit {
        if statements.length > 0 {
            if statements[0]-?>ValueStatement {
                var value := statements[0]->ValueStatement.value
                if value-?>MethodCall {
                    var call := value->MethodCall
                    if call.methodStub.methodType = MethodNodeType.CONSTRUCTOR
                        return call.methodStub.owner = owner
                }
            }
        }
        return false
    }
    
    function callsSuperConstructor(owner:ClassType,
            statements:ListView<Statement>):Bit {
        if statements.length > 0 {
            if statements[0]-?>ValueStatement {
                var value := statements[0]->ValueStatement.value
                if value-?>MethodCall {
                    var call := value->MethodCall
                    if call.methodStub.methodType = MethodNodeType.CONSTRUCTOR
                        return call.target.type != owner
                }
            }
        }
        return false
    }   

    method convertMethod(m:MethodStub):MethodNode {
        context.localVariables.clear()
        context.currentMethod := m
        context.pushSymbolTable()
        def parameters := Array<Parameter>()
        for formal in m.parameters {
            def p := Parameter(formal.position, formal.name, formal.type, 
                    formal.isVar, formal.isVarArg, context.currentMethod)
            parameters.add(p)
            context.symbolTable.add(p)
        }
        if !m.annotations.isClass {
            def selfType:Type
            if m.annotations.isWrapperMethod
                selfType := m.owner->>PrimitiveType
            else
                selfType := m.owner
            def selfParam := Parameter(m.position, Parameter.SELF_NAME,
                    selfType, false, false, context.currentMethod)
            context.symbolTable.add(selfParam)
        }
        var body := convertBlock(m.body->ASTBlock)
        if m.methodType = MethodNodeType.CONSTRUCTOR {
            def callsOther := callsOtherSelfConstructor(m.owner, 
                    body.statements)
            def callsSuper := callsSuperConstructor(m.owner, body.statements)
            if !callsOther {
                def reusedTuples := HashMap<Value, ReusedValueDefinition>()
                def initializers := HashMap<ASTExpression, Value>()
                def statements := Array<Statement>()
                for f in context.currentClass.fields {
                    if !f.annotations.isClass & !f.annotations.isThread {
                        if f.initialValue != null {
                            var initialValue := initializers[f.initialValue]
                            if initialValue = null {
                                initialValue := resolve(f.initialValue)
                                initializers[f.initialValue] := initialValue
                            }
                            if initialValue != null {
                                if f.tuplePosition != null {
                                    var reused := reusedTuples[initialValue]
                                    def reference:Value
                                    if reused = null {
                                        reused := ReusedValueDefinition(
                                                initialValue)
                                        reusedTuples[initialValue] := reused
                                        reference := reused
                                    }
                                    else
                                        reference := reused.createReference()
                                    initialValue := getMember(f.position, 
                                            reference, 
                                            TupleType.FIELD_PREFIX + 
                                                f.tuplePosition)
                                }
                                statements.add(FieldAssignment(f.position,
                                        context.getSelf(f.position), f,
                                        initialValue.implicitCast(context, 
                                            f.type)))
                            }
                        }
                    }
                }
                statements.addAll(body.statements)
                body := Block(body.position, statements)
            }
            if !callsOther & !callsSuper & m.owner != ClassType.OBJECT {
                def statements := Array<Statement>()
                def superCall := context.call(m.position, 
                        Super(m.position, m.owner),
                        MethodNode.CONSTRUCTOR_NAME, 
                        Array<Value>())
                if superCall != null
                    statements.add(ValueStatement(superCall))
                statements.addAll(body.statements)
                body := Block(body.position, statements)
            }
        }
        def result := MethodNode(m, body, parameters, 
                context.localVariables)
        context.popSymbolTable()
        return result
    }

    method pushSymbols(cl:ClassStub) {
        context.currentClass := cl
        context.pushSymbolTable(context.getSymbolTable(cl))
    }

    method convertClass(cl:ClassStub):ClassNode {
        context.methods.clear()
        pushSymbols(cl)
        for f in cl.fields
            inferFieldType(f)
        for m in cl.methods.filter(m => m.body != null) {
            if cl.annotations.isUnspecified & !m.annotations.isClass
                continue
            context.methods.add(convertMethod(m))
        }
        context.popSymbolTable()
        return ClassNode(cl, context.methods)
    }

    method inferFieldType(f:FieldNode) {
        if f.type-!>UnresolvedType
            return
        if f.initialValue = null {
            context.errors.error("field '\{f.name}' has neither an explicit " +
                    "type nor an initial value", f.position)
            f.type := VoidType.VOID
            return
        }
        if currentlyInferring.contains(f) {
            def msg := MutableString("unable to resolve field types due " +
                    "to a circular dependency involving:")
            for msgField in currentlyInferring
                msg.append("\n    '\{msgField.name}': \{msgField.position}")
            context.errors.error(msg->>String, f.position)
            f.type := VoidType.VOID
            return
        }
        currentlyInferring.add(f)
        def old := context.currentClass
        pushSymbols(context.getStub(f.owner))
        if !f.annotations.isClass & !f.annotations.isThread {
            def selfParam := Parameter(f.position, Parameter.SELF_NAME,
                    f.owner, false, false, context.currentMethod)
            context.symbolTable.add(selfParam)
        }
        def expr := resolve(f.initialValue->ASTExpression)
        context.popSymbolTable()
        context.currentClass := old
        if expr != null {
            if expr.checkValid(context) {
                def type := expr.preferredVariableType(context)
                if f.tuplePosition = null
                    f.type := type
                else {
                    if type.isTuple {
                        def tupleType := type->>TupleType
                        if f.tuplePosition < tupleType.types.length
                            f.type := tupleType.types[f.tuplePosition]
                        else {
                            context.errors.error("tuple length mismatch in " +
                                    "destructuring assignment", expr.position)
                        }
                    }
                    else {
                        context.errors.error("expected tuple for " +
                                "destructuring assignment, but found " +
                                "'\{type.unwrapNullable}'", expr.position)
                    }
                }
            }
        }
        else
            f.type := VoidType.VOID
        currentlyInferring.remove(f)
    }

    method createStub(t:Type) {
        if !t.isPrimitive & t != VoidType.VOID & 
                t != NativePointerType.NATIVE_POINTER
        context.getStub(t->>ClassType)
    }

    @private
    method createAllStubs() {
        def types := HashMap<String, Type>(context.stubGenerator.types)
        for (_, cl) in types {
            if cl-?>ClassType & cl-!>GenericParameterType {
                def astClass := context.stubGenerator.astClasses[cl.name]
                if astClass != null {
                    if !astClass[0].isExternal
                        createStub(cl->ClassType)  
                } 
                else {
                    def astEnum := context.stubGenerator.astEnums[cl.name]
                    if astEnum != null & !astEnum[0].isExternal
                        createStub(cl->ClassType)  
                }
            }
        }
        createStub(ClassType.CLASS)
        createStub(ClassType.METHOD)
        var progress:Bit
        def checked := HashSet<ClassStub>()
        do {
            progress := false
            def classes := HashMap<String, ClassStub>(context.classes)
            for (_, cl) in classes {
                if checked.contains(cl)
                    continue
                checked.add(cl)
                progress := true
                if cl.annotations.isUnspecified | cl.annotations.isExternal
                    continue
                for f in cl.fields {
                    inferFieldType(f)
                    createStub(f.type)
                }
                for m in cl.methods {
                    for p in m.parameters
                        createStub(p.type)
                    createStub(m.returnType)
                }
                def sc := cl.superclass
                if sc != null
                    createStub(sc)
                for intf in cl.interfaces
                    createStub(intf)
            }
        }
        while progress
    }

    method addClass(cl:ClassStub, root:MutablePackage) {
        var currentPackage := root
        def components := cl.name.split(".")
        def currentName := MutableString()
        for (i, c) in components.enumeration() {
            if i > 0
                currentName.append(".")
            currentName.append(c)
            if i < components.length - 1 {
                var next := currentPackage[c]
                if next = null {
                    next := MutablePackage(currentName->>String)
                    currentPackage[c] := next
                }
                else if next-!>MutablePackage
                    unreachable
                currentPackage := next->MutablePackage
            }
            else {
                if currentPackage[c] = null
                    currentPackage[c] := TypeSymbol(cl.type)
            }
        }
    }

    @pre(f.varType = VariableType.PROPERTY)
    @pre(f.name.endsWith("$PROPERTY"))
    function needsGetter(f:FieldNode, cl:ClassStub):Bit {
        def name := f.name[0 .. f.name.length - "$PROPERTY".length]
        for m in cl.methods {
            if m.name = name & m.methodType = MethodNodeType.FUNCTION &
                    m.parameters.length = 0
                return false
        }
        return true
    }

    @pre(f.varType = VariableType.PROPERTY)
    @pre(f.name.endsWith("$PROPERTY"))
    function needsSetter(f:FieldNode, cl:ClassStub):Bit {
        if f.annotations.isReadOnly
            return false
        def name := f.name[0 .. f.name.length - "$PROPERTY".length] + ":="
        for m in cl.methods {
            if m.name = name & m.methodType = MethodNodeType.METHOD &
                    m.parameters.length = 1
                return false
        }
        return true
    }

    method createProperties(cl:ClassStub) {
        for f in cl.fields {
            if f.varType = VariableType.PROPERTY {
                inferFieldType(f)
                context.symbolTables.remove(cl)
                cl.symbols.remove(f.name)
                def name := f.name[0 .. f.name.length - "$PROPERTY".length]
                def field := FieldNode(f.position, cl.type, "_" + 
                        name, f.annotations, VariableType.VAR, f.type, 
                        f.initialValue, f.tuplePosition)
                StubGenerator.addSymbol(field, field.position, cl.symbols, 
                        context.errors)

                if needsGetter(f, cl) {
                    def getterStatements := Array<ASTStatement>()
                    getterStatements.add(ASTReturn(f.position, 
                            ASTIdentifier(f.position, field.name)))
                    def getterBody := ASTBlock(f.position, 
                            getterStatements)
                    def getter := MethodStub(f.position, name, 
                            Annotations(f.position), 
                            MethodNodeType.FUNCTION, 
                            Array<FormalParameter>(), f.type, 
                            getterBody, cl.type)
                    StubGenerator.addSymbol(getter, cl.symbols, 
                            context.errors)
                }

                if needsSetter(f, cl) {
                    def setterStatements := Array<ASTStatement>()
                    def parameters := Array<FormalParameter>()
                    def parameter := FormalParameter(f.position, "value", 
                            f.type, false, false)
                    parameters.add(parameter)
                    def lvalues := Array<ASTExpression>()
                    lvalues.add(ASTIdentifier(f.position, field.name))
                    setterStatements.add(ASTAssignment(lvalues, null, 
                            ASTIdentifier(f.position, parameter.name)))
                    def setterBody := ASTBlock(f.position, 
                            setterStatements)
                    def annotationTypes := Array<AnnotationType>()
                    annotationTypes.add(AnnotationType.SELF)
                    def setterAnnotations := Annotations(f.position, 
                            annotationTypes)
                    def setter := MethodStub(f.position, 
                            name + ":=", setterAnnotations, 
                            MethodNodeType.METHOD, parameters, 
                            VoidType.VOID, setterBody, cl.type)
                    StubGenerator.addSymbol(setter, cl.symbols, 
                            context.errors)
                }
            }
        }
    }

    method createProperties() {
        for cl in context.classes.values
            createProperties(cl)
    }

    @class
    function getThreadLocalInitializerName(f:FieldNode):String {
        return "$init\{f.name}"
    }

    method createThreadLocalInitializers() {
        for cl in context.classes.values {
            for f in cl.fields.filter(f => f.annotations.isThread) {
                inferFieldType(f)
                def name := getThreadLocalInitializerName(f)
                if cl.symbols[name] != null
                    continue
                context.symbolTables.remove(cl)
                def body := Array<ASTStatement>()
                body.add(ASTReturn(f.position, f.initialValue))
                def annotations := Array<AnnotationType>()
                annotations.add(AnnotationType.CLASS)
                annotations.add(AnnotationType.SYNTHETIC)
                def m := MethodStub(f.position, 
                        name, Annotations(f.position, annotations),
                        MethodNodeType.METHOD, Array<FormalParameter>(), 
                        f.type, ASTBlock(f.position, body), f.owner)
                StubGenerator.addSymbol(m, cl.symbols, context.errors)
            }
        }
    }

    method generateProgram():Program {
        for symbol in context.root {
            def simpleName := symbol.name[0 .. symbol.name.indexOf(".")]
            context.symbolTable.add(simpleName, symbol)
        }
        def classes := HashMap<String, ClassNode>()
        var madeProgress:Bit
        do {
            madeProgress := false
            createAllStubs()
            createProperties()
            createThreadLocalInitializers()
            def filtered := context.classes.values.filter(cl => !cl.isExternal & 
                    !classes.contains(cl.name))
            for cl in filtered {
                classes[cl.name] := convertClass(cl)
                madeProgress := true
            }
        }
        while madeProgress
        def root := MutablePackage("")
        for cl in context.classes.values
            addClass(cl, root)
        return Program(root->>Package, context.classes, classes, 
                context.stubGenerator)
    }
}