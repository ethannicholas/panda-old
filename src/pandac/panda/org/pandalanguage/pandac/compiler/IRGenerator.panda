package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ArrowOperationType
uses org.pandalanguage.pandac.ast.ASTArrayLiteral
uses org.pandalanguage.pandac.ast.ASTArrowExpression
uses org.pandalanguage.pandac.ast.ASTAssert
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBinaryExpression
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTBreak
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTContinue
uses org.pandalanguage.pandac.ast.ASTDo
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTFor
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTIndex
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTLoop
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTNullLiteral
uses org.pandalanguage.pandac.ast.ASTPlugin
uses org.pandalanguage.pandac.ast.ASTRangeExpression
uses org.pandalanguage.pandac.ast.ASTRealLiteral
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTTupleExpression
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnaryExpression
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTVarDeclaration
uses org.pandalanguage.pandac.ast.ASTWhile
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedDotExpression
uses org.pandalanguage.pandac.tree.UnresolvedIdentifier
uses org.pandalanguage.pandac.tree.UnresolvedIndex
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedSlice
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.VarDeclaration
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.SuperType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType

class IRGenerator {
    constant SHIM_PREFIX := "$shim_"

    constant STRING_GROUP := #/(?<!\\)\\\{.*?(?<!\\)\}/#

    constant UNESCAPED_BRACE := #/(?<!\\)\{/#

    var context:Context

    def currentlyInferring := new HashSet<FieldNode>()

    constructor(classes:ImmutableHashMap<String, ClassStub>, 
            typeResolver:TypeResolver, compilerSettings:CompilerSettings,
            errors:ErrorReporter) {
        context := new Context(typeResolver, classes, errors, compilerSettings)
    }

    @class
    function makeExplicit(v:Value):Value {
        if v-?>(Cast) {
            return new Cast(v.position, v->(Cast).value, v.type, 
                    CastType.EXPLICIT)
        }
        return v
    }
    
    @class
    function isAccessible(f:FieldNode):Bit {
        return true
    }

    @private
    method createFieldReference(position:Position, var contextValue:Value, 
            f:FieldNode, allowNoArgFunctions:Bit):Value {
        inferFieldType(f)
        if allowNoArgFunctions {
            def result := context.testCall(position, contextValue, f.name, 
                    new Array<Value>())
            if result != null & result->(MethodCall).methodStub.methodType =
                    MethodNodeType.FUNCTION
                return result
        }
        def result := new FieldReference(position, contextValue, f)
        return result
    }

    method getField(position:Position, var contextValue:Value,
            var name:String):Value? {
        return getField(position, contextValue, name, true)
    }

    method getField(position:Position, var contextValue:Value,
            var name:String, allowNoArgFunctions:Bit):Value? {
        if name = "class"
            name := "$class"
        var cl:ClassStub
        def resolved:Value?
        if contextValue-!>(Super)
            resolved := resolve(contextValue)
        else
            resolved := contextValue
        if resolved != null
            contextValue := resolved
        else
            return null
        if contextValue.type = StringOrCharType.STRING_OR_CHAR {
            contextValue := contextValue.implicitCast(context, 
                    CharType.CHAR)
        }
        if contextValue-!>(Super) {
            if contextValue.type.isPrimitive {
                def casted:Value?
                casted := contextValue.implicitCast(context,
                        contextValue.type->>(ClassType))
                return getField(position, casted, name, allowNoArgFunctions)
            }
            else {
                var contextValueClass := context.getStub(
                        contextValue.type->>(ClassType))
                cl := contextValueClass
            }
            if contextValue-!>(ClassLiteral) {
                def noArg := context.testCall(position, contextValue, name, 
                        new Array<Value>())
                if noArg-?>(MethodCall) & noArg->(MethodCall).methodStub.methodType =
                        MethodNodeType.FUNCTION
                    return noArg
                def fields := cl.instanceFields(context)
                -- need to search backwards since ancestor classes are at the
                -- beginning of the array, and we may be shadowing fields
                for i in fields.length - 1  ... 0 by -1 {
                    def f := fields[i]
                    if f.name = name & !f.annotations.isClass &
                            !f.annotations.isThread & isAccessible(f) {
                        if contextValue-?>(UnresolvedClassLiteral) {
                            contextValue := new ClassObjectLiteral(
                                    contextValue.position,
                                    contextValue->(UnresolvedClassLiteral).value)
                        }
                        return createFieldReference(position, contextValue, f, 
                                allowNoArgFunctions)
                    }
                }
            }
            if contextValue-?>(UnresolvedClassLiteral) {
                contextValue := new ClassLiteral(contextValue.position,
                        contextValue->(UnresolvedClassLiteral).value)
            }
            if contextValue-?>(ClassLiteral) {
                var type := contextValue->(ClassLiteral).value
                if type.isPrimitive
                    type := type->>(ClassType)
                cl := context.getStub(type->>(ClassType))
                for f in cl.fields {
                    if f.name = name & (f.annotations.isClass |
                            f.annotations.isThread) &
                            isAccessible(f) {
                        return createFieldReference(position, contextValue, f, 
                                allowNoArgFunctions)
                    }
                }
            }
        }
        return new UnresolvedDotExpression(position, contextValue, name, null)
    }

    method convertCallExpression(c:ASTCallExpression):Value? {
        var target := convertExpression(c.target)
        if target = null
            return null
        if c.parameters.length = 0 & target-?>(MethodCall) {
            Console.writeLine("no arg method hack")
            return target
        }
        def parameters := new Array<Value>()
        for p in c.parameters {
            def converted := convertExpression(p)
            if converted = null
                return null
            parameters.add(converted)
        }
        if target-?>(UnresolvedIdentifier) {
            if context.isInstance {
                def test := context.testCall(c.position, context.getSelf(
                            c.position),
                        target->(UnresolvedIdentifier).name, parameters)
                if test != null
                    return test
            }
            def test := context.testCall(c.position, new ClassLiteral(
                    c.position, context.currentClass.type),
                    target->(UnresolvedIdentifier).name, parameters)
            if test != null
                return test
        }
        if target-?>(UnresolvedDotExpression) {
            def u := target->(UnresolvedDotExpression)
            if u.left-?>(Super) {
                if !context.isInstance {
                    context.errors.error(SuperType.ERROR_MESSAGE, 
                            target.position)
                    return null
                }
                return context.call(c.position, u.left, u.right, parameters)
            }
            def left := resolve(u.left)
            if left = null
                return null
            return context.call(c.position, left, u.right, parameters)
        }
        target := resolve(target)
        if target = null
            return null
        def type := target.type.unwrapNullable
        if type-!>(MethodType) {
            context.errors.error("expected a method, but found " +
                    "'\{target.type.displayName}'", target.position)
            return null
        }
        def unwrapped := target.implicitCast(context, type)
        def parameterTypes := type->(MethodType).methodParameters
        if parameters.length != parameterTypes.length {
            def expected:String
            if parameterTypes.length = 1
                expected := "1 parameter"
            else
                expected := parameterTypes.length + " parameters"
            context.errors.error("'\{type.displayName}' expects \{expected}, " +
                    "but found \{parameters.length}", c.position)
            return null
        }
        def finalParams := new Array<Value>()
        for i, p in parameters
            finalParams.add(p.implicitCast(context, parameterTypes[i]))
        return new DynamicCall(unwrapped, finalParams)
    }

    method resolveClass(position:Position, name:String):Value? {
        def type := new ASTClassType(position, name, null, false) 
        def resolved := context.typeResolver.resolve(type, 
                context.currentClass.lookupContext)
        if resolved != null
            return new ClassLiteral(position, resolved)
        return null
    }

    method convertDotExpression(d:ASTDotExpression):Value? {
        def left := convertExpression(d.left)
        if left = null
            return null
        if left-?>(UnresolvedIdentifier) {
            def v := context.symbolTable[left->(UnresolvedIdentifier).name]
            if v != null {
                def resolved := resolve(left)
                if resolved = null
                    return resolved
                def field := getField(d.position, resolved, d.right, true)
                if field-?>(UnresolvedDotExpression) {
                    return new UnresolvedDotExpression(d.position, resolved, 
                            d.right, null)
                }
                else {
                    return new UnresolvedDotExpression(d.position, resolved, 
                            d.right, field)
                }
            }
            def name := left->(UnresolvedIdentifier).name + "." + d.right
            def cl := resolveClass(d.position, name)
            if cl != null
                return cl
            return new UnresolvedIdentifier(d.position, name, null)
        }
        def resolved:Value?
        if left-!>(Super)
            resolved := resolve(left)
        else
            resolved := left
        if resolved = null
            return null
        return getField(d.position, left, d.right)
    }

    method convertIdentifier(id:ASTIdentifier):Value? {
        def cl := resolveClass(id.position, id.identifier)
        if cl != null
            return cl
        return getIdentifier(id.position, id.identifier)
    }

    method convertIntegerLiteral(i:ASTIntegerLiteral):Value? {
        return new IntegerLiteral(i.position, i.value)
    }

    method convertRealLiteral(r:ASTRealLiteral):Value? {
        return new RealLiteral(r.position, r.value)
    }

    ============================================================================
    Given a sequence of chars from a string literal (e.g. "Hello\n!"), returns a
    string representing the contents of the literal (e.g. "Hello<newline>!")

    If `interpolating` is true, permits the additional escape sequences `\:`,
    `\{`, and `\}`, passing them through unmodified.
    ============================================================================
    method convertStringChars(position:Position, s:String, 
            interpolating:Bit):String? {
        var result := new MutableString()
        var i := 0
        loop {
            var next := s.indexOf("\\", i)
            if next = null {
                result.append(s[i..])
                break
            }
            result.append(s[i .. next])
            var c := s[next + 1]
            switch c {
                case "n":  result.append("\n")
                case "r":  result.append("\r")
                case "t":  result.append("\t")
                case '"':  result.append('"')
                case "\\": {
                    result.append("\\")
                    if interpolating
                        result.append("\\")
                }
                case "'":  result.append("'")
                case ":", "{", "}": {
                    if interpolating {
                        result.append("\\")
                        result.append(c)
                    }
                    else {
                        context.errors.error("invalid string escape '\\" + c + 
                                "'", new Position(position.file, position.line, 
                                position.column + i))
                        return null
                    }
                }
                default: {
                    context.errors.error("invalid string escape '\\" + c + "'", 
                            new Position(position.file, position.line, 
                            position.column + i))
                    return null
                }
            }
            i := next + 2
        }
        return result->>(String)
    }

    method convertStringLiteral(string:ASTStringLiteral):Value? {
        var s := string.value
        def result := new MutableString()
        def matcher := STRING_GROUP.matcher(s)
        def values := new Array<Value>()
        var lastEnd := 0
        while matcher.find() {
            var chars := convertStringChars(string.position, 
                    s[lastEnd .. matcher.start], false)
            if chars != null {
                result.append(chars.replace(UNESCAPED_BRACE, 
                        "\\{"))
            }
            def text := s[matcher.start + 2 .. matcher.end - 1]
            var expr, remaining := new PandaParser(context.errors).parseExpressionWithExtraText(
                    text, string.position)
            if expr = null
                return null
            def value := resolve(expr)
            if value = null
                return null
            values.add(value)
            def token:String?
            token := convertStringChars(string.position, remaining, 
                    true)
            if token != null
                result.append("{\{token}}")
            lastEnd := matcher.end()
        }
        if lastEnd > 0 {
            def chars := convertStringChars(string.position, s[lastEnd..], false)
            if chars != null
                result.append(chars.replace(UNESCAPED_BRACE, "\\{"))
            s := result->>(String)
            values.insert(0, new StringLiteral(string.position, s))
            return context.call(string.position, new ClassLiteral(
                    string.position, ClassType.STRING), "format", values)
        }
        else {
            def chars := convertStringChars(string.position, s, false)
            if chars = null
                return null
            return new StringLiteral(string.position, chars)
        }
    }

    method convertBitLiteral(b:ASTBitLiteral):Value? {
        return new BitLiteral(b.position, b.value)
    }

    method convertUnaryExpression(u:ASTUnaryExpression):Value? {
        def operand := resolve(u.expression)
        if operand = null
            return null
        return new UnaryOperation(u.position, u.operation, operand)
    }

    method convertBinaryExpression(b:ASTBinaryExpression):Value? {
        def left := resolve(b.left)
        if left = null
            return null
        def right := resolve(b.right)
        if right = null
            return null
        return getBinaryValue(b.position, left, b.operation, right)
    }

    method convertInstanceOf(position:Position, var object:Value, 
            var type:Type):Value? {
        if object.type = StringOrCharType.STRING_OR_CHAR {
            -- hardcode STRING_OR_CHAR-?>(Char) and STRING_OR_CHAR-?>(String)
            -- as true
            if type = CharType.CHAR | ClassType.STRING.canImplicitCastTo(
                    context, type)
                return new BitLiteral(position, true)
        }
        def primitiveTarget := type.isPrimitive | type.isWrapper
        if primitiveTarget {
            if object.type = StringOrCharType.STRING_OR_CHAR
                object := object.implicitCast(context, CharType.CHAR)
            if object.type = CharType.CHAR & type.isNumber
                object := object.explicitCast(context, IntType.INT32)
        }
        def primitiveSource := object.type.isPrimitive | 
                object.type.isWrapper

        if object.type.isNumber & type.isReal
            return new BitLiteral(position, true)

        if !primitiveSource & type.isPrimitive
            type := type->>(ClassType)

        if !object.canExplicitCastTo(context, type) {
            context.errors.error("'\{object}' (\{object.type.displayName}) " +
                    "cannot possibly be an instance of '\{type.displayName}'", 
                    position)
        }

        def parameters := new Array<Value>()
        parameters.add(object)
        if !primitiveTarget {
            parameters.add(new ClassObjectLiteral(position, 
                    type->>(ClassType)))
        }

        var methodName := "instanceOf"
        if primitiveTarget {
            var target := type.unwrapNullable
            var name := target.name
            constant CORE := "panda.core."
            assert name.startsWith(CORE)
            name := name[CORE.length..]
            if target.isWrapper
                name := name.replace("Wrapper", "")
            methodName += name
        }
        def panda := new ClassLiteral(position, ClassType.PANDA)
        var instanceOf:MethodStub? := null
        if !object.type.isNullable
            instanceOf := context.getMethod(panda, methodName, parameters)
        if instanceOf = null {
            parameters.add(new BitLiteral(position, type.isNullable))
            instanceOf := context.getMethod(panda, methodName, parameters)
        }
        assert instanceOf != null
        return context.call(position, instanceOf, false, parameters)
    }

    method convertArrowExpression(a:ASTArrowExpression):Value? {
        def left := resolve(a.left)
        if left = null
            return null
        def right := context.typeResolver.resolve(a.right, 
                context.currentClass.lookupContext)
        if right = null
            return null
        switch a.operation {
            case ArrowOperationType.CAST: {
                if !left.canExplicitCastTo(context, right) {
                    context.errors.error("'\{left.type.displayName}' cannot " +
                            "possibly be an instance of '\{right.displayName}'",
                            a.position)
                }
                return left.explicitCast(a.position, context, right)
            }
            case ArrowOperationType.INSTANCE_OF:
                return convertInstanceOf(a.position, left, right)
            case ArrowOperationType.NOT_INSTANCE_OF: {
                def instanceOf := convertInstanceOf(a.position, left, right)
                if instanceOf = null
                    return null
                return new UnaryOperation(a.position, UnaryOperationType.NOT,
                        instanceOf)
            }
            case ArrowOperationType.CONVERT:
                return left.convert(context, right)
            default:
                unreachable
        }
    }

    function check(v:Value?):Bit {
        if v = null
            return true
        return v.type-!>(UnresolvedType)
    }

    method getIdentifier(position:Position, name:String):Value? {
        def result := context.symbolTable[name]
        if result != null {
            if result-?>(FieldNode) {
                def f := result->(FieldNode)
                if !f.annotations.isClass & !f.annotations.isThread {
                    if !context.isInstance {
                        context.errors.error("cannot reference field '" +
                                f.name + "' from a class context",
                                position)
                        return new UnresolvedIdentifier(position, name,
                                new Dummy(position, f.type))
                    }
                    return new UnresolvedIdentifier(position, name,
                            new FieldReference(position, 
                                context.getSelf(position), f))
                }
                return new UnresolvedIdentifier(position, name,
                        new FieldReference(position, 
                            new ClassLiteral(position, f.owner), f))
            }
            return new UnresolvedIdentifier(position, name,
                    new VariableReference(position, result))
        }
        -- call getField, so as to allow for no-argument functions
        if context.isInstance()
            return getField(position, context.getSelf(position), name)
        return new UnresolvedIdentifier(position, name, null)
    }

    method resolve(v:Value):Value? {
        if v.type-?>(UnresolvedType) {
            if !v.checkValid(context)
                return null
            def type := v.preferredType(context)
            return v.implicitCast(context, type)
        }
        return v
    }
--    @post(@return = null | @return.type-!>(UnresolvedType))

    method resolve(e:ASTExpression):Value? {
        var result := convertExpression(e)
        if result = null
            return null
        return resolve(result)
    }

    method resolve(t:ASTType):Type? {
        return context.typeResolver.resolve(t, 
                context.currentClass.lookupContext) 
    }

    method convertNew(n:ASTNew):Value? {
        def type := context.typeResolver.resolve(n.type, 
                context.currentClass.lookupContext)
        if type = null
            return null
        def parameters := new Array<Value>()
        for p in n.parameters {
            def resolved := resolve(p)
            if resolved = null
                return null
            parameters.add(resolved)
        }
        return context.call(n.position, new ClassLiteral(n.position, type), 
                MethodNode.CONSTRUCTOR_NAME, parameters)
    }

    method convertIndex(i:ASTIndex):Value? {
        def target := resolve(i.target)
        if target = null
            return null
        var index := convertExpression(i.index)
        if index = null
            return null
        if index-?>(UnresolvedRange) {
            def range := index->(UnresolvedRange)
            return new UnresolvedSlice(context, i.position, target, range.left, 
                    range.right, range.step, range.endInclusive)
        }
        index := resolve(index)
        if index = null
            return null
        if target.type.unwrapNullable-?>(PrimitiveArrayType)
            return new PrimitiveArrayIndexValue(target, 
                    index.implicitCast(context, IntType.INT32))
        return new UnresolvedIndex(context, i.position, target, index)
    }

    method convertRangeExpression(r:ASTRangeExpression):Value? {
        def left:Value?
        if r.left != null {
            left := resolve(r.left->(ASTExpression))
            if left = null
                return null
        }
        else
            left := null
        def right:Value?
        if r.right != null {
            right := resolve(r.right->(ASTExpression))
            if right = null
                return null
        }
        else
            right := null
        def step:Value?
        if r.step != null {
            step := resolve(r.step->(ASTExpression))
            if step = null
                return null
        }
        else
            step := null
        return new UnresolvedRange(context, r.position, left, right, step, 
                r.endInclusive)
    }

    method convertPlugin(p:ASTPlugin):Value? {
        var s := p.value
        if s.startsWith("/") & s.endsWith("/") {
            s := s[1 .. s.length - 1]
            def parameters := new Array<Value>()
            parameters.add(new StringLiteral(p.position, s))
            return context.call(p.position, new ClassLiteral(p.position,
                    ClassType.REGULAR_EXPRESSION), MethodNode.CONSTRUCTOR_NAME,
                    parameters)
        }
        throw new CompilerException("unsupported plugin: \{s}", p.position)    
    }

    method convertArray(a:ASTArrayLiteral):Value? {
        def values := new Array<Value>()
        for expr in a.values {
            def v := convertExpression(expr)
            if v = null
                return null
            values.add(v)
        }
        return new UnresolvedArray(context, a.position, values)
    }

    method convertTuple(t:ASTTupleExpression):Value? {
        def values := new Array<Value>()
        for expr in t.values {
            def v := convertExpression(expr)
            if v = null
                return null
            values.add(v)
        }
        return new UnresolvedTuple(context, t.position, values)
    }

    method convertSuper(s:ASTSuper):Value? {
        if context.symbolTable[Parameter.SELF_NAME] != null {
            return new Super(s.position)
        }
        context.errors.error(SuperType.ERROR_MESSAGE, s.position)
        return null
    }

    method convertExpression(e:ASTExpression):Value? {
        switch e.class {
            case class(ASTCallExpression):
                return convertCallExpression(e->(ASTCallExpression))
            case class(ASTIdentifier):
                return convertIdentifier(e->(ASTIdentifier))
            case class(ASTDotExpression):
                return convertDotExpression(e->(ASTDotExpression))
            case class(ASTIntegerLiteral):
                return convertIntegerLiteral(e->(ASTIntegerLiteral))
            case class(ASTRealLiteral):
                return convertRealLiteral(e->(ASTRealLiteral))
            case class(ASTStringLiteral):
                return convertStringLiteral(e->(ASTStringLiteral))
            case class(ASTBitLiteral):
                return convertBitLiteral(e->(ASTBitLiteral))
            case class(ASTNullLiteral):
                return new NullLiteral(e.position)
            case class(ASTUnaryExpression):
                return convertUnaryExpression(e->(ASTUnaryExpression))
            case class(ASTBinaryExpression):
                return convertBinaryExpression(e->(ASTBinaryExpression))
            case class(ASTArrowExpression):
                return convertArrowExpression(e->(ASTArrowExpression))
            case class(ASTNew):
                return convertNew(e->(ASTNew))
            case class(ASTSelf):
                return getIdentifier(e.position, "self")
            case class(ASTSuper):
                return convertSuper(e->(ASTSuper))
            case class(ASTIndex):
                return convertIndex(e->(ASTIndex))
            case class(ASTRangeExpression):
                return convertRangeExpression(e->(ASTRangeExpression))
            case class(ASTPlugin):
                return convertPlugin(e->(ASTPlugin))
            case class(ASTArrayLiteral):
                return convertArray(e->(ASTArrayLiteral))
            case class(ASTTupleExpression): 
                return convertTuple(e->(ASTTupleExpression))
            default:
                throw new InternalCompilerException("unsupported expression: " +
                        e.class.name, e.position)
        }
    }

    method convertVarDeclaration(v:ASTVarDeclaration):Statement? {
        var initializer:Value?
        if v.initializer != null {
            initializer := convertExpression(v.initializer->(ASTExpression))
            if initializer = null
                return null
        }
        else
            initializer := null
        for decl in v.vars {
            def type:Type?
            if decl.type != null {
                type := context.typeResolver.resolve(decl.type->(ASTType),
                        context.currentClass.lookupContext)
                if type = null {
                    context.errors.error("unknown class '\{decl.type->(ASTType)}'",
                            decl.type->(ASTType).position)
                    return null
                }
            }
            else {
                if initializer = null {
                    context.errors.error("variable has neither an " +
                            "initializer nor a type", decl.position)
                    return null
                }
                initializer := resolve(initializer)
                if initializer = null
                    return null
                type := initializer.preferredVariableType(context)
            }
            def local := new LocalVariable(decl.position, decl.identifier, type,
                    v.varType)
            context.localVariables.add(local)
            context.symbolTable[local.name] := local
            if initializer != null {
                -- no support for tuples yet!
                return new ValueStatement(new VariableAssignment(decl.position, 
                        local, initializer.implicitCast(context, type), true))
            }
        }
        return null
    }

    method convertIf(i:ASTIf):Statement? {
        var test := resolve(i.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def thenStatement := convertStatement(i.thenStatement)
        if thenStatement = null
            return null
        def elseStatement:Statement?
        if i.elseStatement != null {
            elseStatement := convertStatement(i.elseStatement->(ASTStatement))
            if elseStatement = null
                return null
        }
        else
            elseStatement := null
        return new If(i.position, test, thenStatement, elseStatement)
    }

    @private
    method castToIterable(value:Value):Value? {
        def cl := context.getStub(value.type->>(ClassType))
        for intf in cl.allInterfaces(context) {
            if intf.name.startsWith("panda.collections.Iterable<")
                return value.implicitCast(context, intf.type)
        }
        context.errors.error("expected 'panda.collections.Iterable<T>'" +
                ", but found '\{value.type.displayName}'", value.position)
        return null
    }

    method convertIterableFor(f:ASTFor, rawList:Value, 
            indexVar:Variable?):Statement? {
        def list := castToIterable(rawList)
        if list = null
            return null
        def elementType := list.type->(GenericType).parameters[0]
        def valueVars := new Array<LocalVariable>()
        if f.valueVars.length > 1 {
            if elementType-!>(TupleType) | 
                    elementType->(TupleType).types.length != f.valueVars.length {
                context.errors.error("'for' loop expected a list of " +
                        "tuples of length \{f.valueVars.length}, but found " + 
                        "'\{rawList.type.displayName}'", f.position)
                return null
            }
        }
        for i, v in f.valueVars {
            var type:Type?
            if v.type != null {
                type := resolve(v.type->(ASTType))
                if type = null
                    return null
            }
            else {
                if f.valueVars.length = 1
                    type := elementType
                else {
                    def tuple := elementType->(TupleType)
                    type := tuple.types[i]
                }
            }
            def valueVar := new LocalVariable(v.position, v.identifier, type,
                    VariableType.DEF)
            valueVars.add(valueVar)
            context.localVariables.add(valueVar)
            context.symbolTable[valueVar.name] := valueVar
        }
        def statements := new Array<Statement>()
        if indexVar != null {
            statements.add(new ValueStatement(new VariableAssignment(f.position, 
                    indexVar, new IntegerLiteral(f.position, 0, indexVar.type, 
                    true), true)))
        }
        def typeParams := new Array<Type>()
        typeParams.add(elementType)
        def iteratorVar := new LocalVariable(f.position, "$iterator", 
                new GenericType(new ClassType("panda.collections.Iterator"), 
                typeParams), VariableType.DEF)
        def getIterator := context.call(f.position, list, "iterator", 
                new Array<Value>())
        assert getIterator != null
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                iteratorVar, getIterator, true)))
        context.localVariables.add(iteratorVar)
        def bodyStatements := new Array<Statement>()
        def done := context.call(f.position, new VariableReference(f.position, 
                iteratorVar), "done", new Array<Value>())
        assert done != null
        def test := new If(f.position, done, new Break(f.position), null)
        bodyStatements.add(test)
        def next := context.call(f.position, new VariableReference(f.position, 
                iteratorVar), "next", new Array<Value>())
        assert next != null
        def tupleVar:LocalVariable
        if valueVars.length = 1 {
            tupleVar := valueVars[0]
        }
        else {
            tupleVar := new LocalVariable(f.position, "$tuple", elementType,
                    VariableType.DEF)
            context.localVariables.add(tupleVar)
        }
        bodyStatements.add(new ValueStatement(new VariableAssignment(
                f.position, tupleVar, next, true)))
        if valueVars.length > 1 {
            for i, v in valueVars {
                def value := getField(f.position,
                        new VariableReference(tupleVar.position, tupleVar), 
                        "$field" + i)
                assert value != null
                bodyStatements.add(new ValueStatement(new VariableAssignment(
                        f.position, valueVars[i], value, true)))
            }
        }
        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null
        bodyStatements.add(bodyStatement)
        def continueStatements := new Array<Statement>()
        if indexVar != null {
            def plusOne := new BinaryOperation(f.position, 
                    BinaryOperationType.ADD, new VariableReference(f.position,
                        indexVar), new IntegerLiteral(f.position, 1, 
                        indexVar.type, true))
            continueStatements.add(new ValueStatement(new VariableAssignment(
                    f.position, indexVar, plusOne, false)))
        }
        def w := new LoopWithContinueBlock(f.position, f.label, 
                new Block(f.position, bodyStatements), new Block(f.position,
                continueStatements))
        statements.add(w)
        return new Block(f.position, statements)
    }

    method convertPrimitiveArrayFor(f:ASTFor, rawArray:Value,
            var indexVar:LocalVariable?):Statement? {
        def array := new ReusedValueDefinition(rawArray)
        def elementType := array.type->>(PrimitiveArrayType).elementType
        def valueVars := new Array<Variable>()
        for v in f.valueVars {
            var type:Type?
            if v.type != null {
                type := resolve(v.type->(ASTType))
                if type = null
                    return null
            }
            else
                type := elementType
            def valueVar := new LocalVariable(v.position, v.identifier, type,
                    VariableType.DEF)
            valueVars.add(valueVar)
            context.localVariables.add(valueVar)
            context.symbolTable[valueVar.name] := valueVar
        }
        def statements := new Array<Statement>()
        statements.add(new ValueStatement(array))
        if indexVar = null {
            indexVar := new LocalVariable(f.position, "$index", IntType.INT32,
                    VariableType.VAR)
            context.localVariables.add(indexVar)
        }
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                indexVar, new IntegerLiteral(f.position, 0, indexVar.type, 
                true), true)))
        def lengthVar := new LocalVariable(f.position, "$length", IntType.INT32,
                    VariableType.VAR)
        context.localVariables.add(lengthVar)
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                lengthVar, getField(f.position, array.createReference(), 
                    "length")->(Value), 
                true)))
        def typeParams := new Array<Type>()
        typeParams.add(elementType)
        def bodyStatements := new Array<Statement>()
        def done := new BinaryOperation(f.position, 
                BinaryOperationType.GREATER_THAN_OR_EQUAL, 
                    new VariableReference(f.position, indexVar),
                    new VariableReference(f.position, lengthVar))
        def test := new If(f.position, done, new Break(f.position), null)
        bodyStatements.add(test)
        bodyStatements.add(new ValueStatement(new VariableAssignment(f.position,
                valueVars[0], new PrimitiveArrayIndexValue(
                        array.createReference(), 
                        new VariableReference(f.position, indexVar)))))
        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null
        bodyStatements.add(bodyStatement)
        def continueStatements := new Array<Statement>()
        def plusOne := new BinaryOperation(f.position, 
                BinaryOperationType.ADD, new VariableReference(f.position,
                        indexVar), new IntegerLiteral(f.position, 1, 
                        indexVar.type, true))
        continueStatements.add(new ValueStatement(new VariableAssignment(
                f.position, indexVar, plusOne, false)))
        def w := new LoopWithContinueBlock(f.position, f.label, 
                new Block(f.position, bodyStatements), new Block(f.position,
                continueStatements))
        statements.add(w)
        return new Block(f.position, statements)
    }

    method convertFor(f:ASTFor):Statement? {
        def indexVar:LocalVariable?
        if f.indexVar != null {
            def astVar := f.indexVar->(ASTTypedIdentifier)
            def type:Type?
            if astVar.type != null {
                type := resolve(astVar.type->(ASTType))
                if type = null
                    return null
            }
            else
                type := IntType.INT32
            indexVar := new LocalVariable(astVar.position, astVar.identifier, 
                    type, VariableType.DEF)
            context.localVariables.add(indexVar)
            context.symbolTable[indexVar.name] := indexVar
        }
        else
            indexVar := null
        var list := resolve(f.list)
        if list = null
            return null
        if list.type.name.startsWith("panda.collections.PrimitiveArray<") |
                list.type.name.startsWith("panda.collections.ImmutablePrimitiveArray<")
            return convertPrimitiveArrayFor(f, list, indexVar)
        return convertIterableFor(f, list, indexVar)
    }

    method convertLoop(l:ASTLoop):Statement? {
        def statement := convertStatement(l.statement)
        if statement = null
            return null
        return new Loop(l.position, l.label, statement)
    }

    method convertWhile(w:ASTWhile):Statement? {
        var test := resolve(w.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def statement := convertStatement(w.statement)
        if statement = null
            return null
        return new While(w.position, w.label, test, statement)
    }

    method convertDo(d:ASTDo):Statement? {
        var test := resolve(d.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def statement := convertStatement(d.statement)
        if statement = null
            return null
        return new Do(d.position, d.label, test, statement)
    }

    method convertBreak(b:ASTBreak):Statement? {
        return new Break(b.position, b.label)
    }

    method convertContinue(c:ASTContinue):Statement? {
        return new Continue(c.position, c.label)
    }

    ============================================================================
    As implicitCast, but with the ability to toggle whether we care about 
    signedness. If `signMatters` is false, the signedness is not considered
    important and will not stop a cast that would normally not be allowed.

    Note that the source and destination types are not necessarily integers; if
    not, we ignore the signMatters flag altogether and just perform a normal
    implicitCast.
    ============================================================================
    @private
    method signMattersCast(position:Position, v:Value, t:Type, 
            signMatters:Bit):Value? {
        if !signMatters {
            def srcType := v.type->>(PrimitiveType)
            if srcType.isInteger & t.isInteger & 
                    srcType->(IntType).signed != t->(IntType).signed & 
                    srcType->>(PrimitiveType).size <= t->>(PrimitiveType).size
                return v.explicitCast(context, t)
        }
        return v.implicitCast(context, t)
    }
    
    ============================================================================
    Returns `<left> <op> <right>`, where `op` is the type of a token 
    representing a binary operator.
    
    @param node the position, for error reporting purposes
    @param left the left operand
    @param op the token type of a binary operator
    @param right the right operand
    ============================================================================
    method getBinaryValue(position:Position, var left:Value, 
            op:BinaryOperationType, var right:Value):Value? {
        var methodName:String
        switch op {
            case BinaryOperationType.ADD:                   methodName := "+"
            case BinaryOperationType.SUBTRACT:              methodName := "-"
            case BinaryOperationType.MULTIPLY:              methodName := "*"
            case BinaryOperationType.DIVIDE:                methodName := "/"
            case BinaryOperationType.INT_DIVIDE:            methodName := "//"
            case BinaryOperationType.REMAINDER:             methodName := "%"
            case BinaryOperationType.SHIFT_LEFT:            methodName := "<<"
            case BinaryOperationType.SHIFT_RIGHT:           methodName := ">>"
            case BinaryOperationType.AND:                   methodName := "&"
            case BinaryOperationType.OR:                    methodName := "|"
            case BinaryOperationType.XOR:                   methodName := "~"
            case BinaryOperationType.BITWISE_AND:           methodName := "&&"
            case BinaryOperationType.BITWISE_OR:            methodName := "||"
            case BinaryOperationType.BITWISE_XOR:           methodName := "~~"
            case BinaryOperationType.POWER:                 methodName := "^"
            case BinaryOperationType.EQUAL:                 methodName := "="
            case BinaryOperationType.NOT_EQUAL:             methodName := "!="
            case BinaryOperationType.IDENTITY:              methodName := "=="
            case BinaryOperationType.NOT_IDENTITY:          methodName := "!=="
            case BinaryOperationType.LESS_THAN:             methodName := "<"
            case BinaryOperationType.GREATER_THAN:          methodName := ">"
            case BinaryOperationType.LESS_THAN_OR_EQUAL:    methodName := "<="
            case BinaryOperationType.GREATER_THAN_OR_EQUAL: methodName := ">="
            default: {
                context.errors.error("unsupported binary operator '\{op}'",
                        position)
                return null
            }
        }
        def resolvedLeft := resolve(left)
        if resolvedLeft != null
            left := resolvedLeft
        else
            return null 
        def resolvedRight := resolve(right)
        if resolvedRight != null
            right := resolvedRight
        else
            return null
        var value := context.callOverloadedOperator(position, methodName, left,
                right)
        if value = null {
            def operandType := BinaryOperation.operandType(context, op, left, 
                    right)
            if operandType = null {
                context.errors.error("'\{methodName}' cannot operate on " +
                        "'\{left.type.displayName}', "+ 
                        "'\{right.type.displayName}'", position)
                return null
            }
            def leftCast := signMattersCast(position, left, operandType, 
                    BinaryOperation.signMatters(op))
            if leftCast != null
                left := leftCast
            else
                return null
            def rightCast := signMattersCast(position, right, operandType, 
                    BinaryOperation.signMatters(op))
            if rightCast != null
                right := rightCast
            else
                return null
            value := new BinaryOperation(position, op, left, right)
        }
        return value
    }

    method unwrapCast(v:Value):Value {
        if v-?>(Cast)
            return unwrapCast(v->(Cast).value)
        return v
    }

    @private
    method getSliceAssignmentCall(u:UnresolvedSlice, 
            params:Array<Value>):Value? {
        def name:String
        if u.endInclusive
            name := "[...]:="
        else
            name := "[..]:="
        return context.testCall(u.position, u.contextValue, name, 
                params)
    }

    @private
    method getSliceAssignmentCall(u:UnresolvedSlice, v:Value):Value? {
        if u.left = null & u.right = null & u.step = null {
            def params := new Array<Value>()
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        if u.right = null & u.step = null {
            def params := new Array<Value>()
            if u.left != null
                params.add(u.left->(Value))
            else
                params.add(new NullLiteral(u.position))
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        if u.step = null {
            def params := new Array<Value>()
            if u.left != null
                params.add(u.left->(Value))
            else
                params.add(new NullLiteral(u.position))
            if u.right != null
                params.add(u.right->(Value))
            else
                params.add(new NullLiteral(u.position))
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        def params := new Array<Value>()
        if u.left != null
            params.add(u.left->(Value))
        else
            params.add(new NullLiteral(u.position))
        if u.right != null
            params.add(u.right->(Value))
        else
            params.add(new NullLiteral(u.position))
        if u.step != null
            params.add(u.step->(Value))
        else
            params.add(new IntegerLiteral(u.position, 1))
        params.add(v)
        return getSliceAssignmentCall(u, params)
    }

    -- FIXME refactoring required! I did this all wrong and dumb. When I first
    -- started working on Panda, all lvalues were also rvalues. Then one
    -- situation crept in where the two weren't exactly the same, so I hacked it
    -- a bit to get it working. Then another cropped up, and another, and slowly
    -- this nice simple method turned into this hellish monstrosity. It needs to
    -- be killed with extreme prejudice, and I apologize to anyone reading this
    -- code. It just built up a bit at a time until it was completely out of
    -- control.
    --
    -- The basic idea is that (due to the original simplicity) the processing
    -- originally just figured out the rvalue on the left side of the assignment
    -- operator, ran into an assignment operator, made sure the rvalue worked as
    -- an lvalue, and continued on its merry way. Since then, this has gotten so 
    -- hellishly complicated that it absolutely needs to be rewritten so as to 
    -- know up front to be looking for an lvalue, so we can eliminate all of 
    -- these special cases and cut this at least in half.
    --
    -- UPDATE:
    -- Oh god I made it even worse. It's so awful. Please don't judge me by this
    -- method, I'm better than this, I swear :-(
    --
    -- FURTHER UPDATE:
    -- Actually, I don't think the refactoring is as simple as I outlined. I 
    -- hadn't considered the complexities introduced by compound assignment. We
    -- can't just process the assignment target twice (once in "lvalue mode" and
    -- once in "rvalue mode"), because that would involve duplicate evaluations
    -- of things that are only supposed to be evaluated once. It can certainly
    -- be done simpler than it's being done, but I don't think it's possible to
    -- eliminate quite as much complexity as I had hoped.
    method processSingleAssignment(var left:Value, right:Value, 
            reuse:Bit):Statement? {
        if left-?>(UnresolvedIndex) {
            def index := left->(UnresolvedIndex)
            def params := new Array<Value>()
            params.add(index.index)
            params.add(right)
            def call := context.testCall(index.position, index.contextValue, 
                    "[]:=", params)
            if call != null
                return new ValueStatement(call)
            context.errors.error("'\{index.contextValue.type.displayName}' " +
                    "does not define the '[]' operator for '" +
                    index.index.type.displayName + "'", index.index.position)
            return null
        }
        else if left-?>(UnresolvedSlice) {
            def slice := left->(UnresolvedSlice)
            def call := getSliceAssignmentCall(slice, right)
            if call != null
                return new ValueStatement(call)
            def name:String
            if slice.endInclusive
                name := "'[...]:=' (inclusive slice assignment)"
            else
                name := "'[..]:=' (exclusive slice assignment)"
            def types := new Array<String>()
            if slice.left != null
                types.add(slice.left->(Value).type.displayName)
            else
                types.add("null")
            if slice.right != null
                types.add(slice.right->(Value).type.displayName)
            else
                types.add("null")
            if slice.step != null
                types.add(slice.step->(Value).type.displayName)
            else
                types.add("null")
            types.add(right.type.displayName)
            context.errors.error("'\{slice.contextValue.type.displayName}' " +
                    "does not define the \{name} operator for \{types}",
                    right.position)
            return null
        }

        var resolvedLeft := resolve(left)
        if resolvedLeft = null
            return null
        resolvedLeft := unwrapCast(resolvedLeft)
-*        if left-?>(Unresolved) {
            -- could be an assignment method
            var contextValue := left->(Unresolved).contextValue
            def name := left->(Unresolved).name
            if contextValue = null {
                if context.isInstance
                    contextValue := context.getSelf(left.position)
                else {
                    -- we're in a class context, so there can't possibly be an
                    -- assignment method. Go ahead and report the error.
                    return null
                }
            }
            def call := callAssignmentMethod(contextValue, name, 
                    new PrimitiveArray<Value>(right))
            if call != null
                currentNode.add(call)
            else {
                -- no assignment method, trigger the exception
                resolve(left)
            }
        }
        else if left-?>(AmbiguousReference) {
            var a := left->(AmbiguousReference)
            var object := a.context
            if reuse {
                def reusable := makeReusable(object)
                reusable.replace(reusable.createReference())
                currentNode.add(new ValueStatement(reusable))
                object := reusable.createReference()
            }
            checkAssignment(a.field, a.position)
            open(new FieldAssignment(left.position, object, a.field))
            currentNode.add(implicitCast(right.position, right, a.type))
            close(class(FieldAssignment))
        } *-
        if resolvedLeft-?>(VariableReference) {
            def variable := resolvedLeft->(VariableReference).variable
            def cast := right.implicitCast(context, variable.type)
            def assignment := new VariableAssignment(left.position,
                    variable, cast)
            return new ValueStatement(assignment)
        }
        else if resolvedLeft-?>(FieldReference) {
            def fv := resolvedLeft->(FieldReference)
            def object:Value
            def finalRight:Value
            if reuse {
                def old := unwrapCast(right)->(BinaryOperation)
                assert old.left = fv
                object := new ReusedValueDefinition(fv.object)
                def newRight := new BinaryOperation(old.position, old.operation,
                        new FieldReference(old.position, object, fv.field), 
                        old.right)
                def cast := newRight.implicitCast(context, fv.field.type)
                finalRight := cast
            }
            else {
                object := fv.object
                finalRight := right.implicitCast(context, fv.field.type)
            }
            def name := fv.field.name
-*            var call := callAssignmentMethod(object, name, 
                    new PrimitiveArray<Value>(right))
            if call != null {
                if currentClass != fv.field.parent & 
                        !fv.field.annotations.isReadOnly &
                        !fv.field.annotations.isFinal {
                    throw new CompilerException("reference to '\{name}' is " +
                            "ambiguous, both field \{name} (of type " +
                            "\{fv.field.type.displayName}) and method " +
                            "\{name}:=() match", fv.position)
                }
                currentNode.add(call)
            }*-
            return new FieldAssignment(fv.position, object, fv.field,
                    finalRight)
        }
        else if resolvedLeft-?>(PrimitiveArrayIndexValue) {
            def iv := left->(PrimitiveArrayIndexValue)
            if reuse {
                def old := unwrapCast(right)->(BinaryOperation)
                assert old.left = iv
                def array := new ReusedValueDefinition(iv.array)
                def index := new ReusedValueDefinition(iv.index)
                def newRight := new BinaryOperation(old.position, old.operation,
                        new PrimitiveArrayIndexValue(array, index), old.right)
                def cast := newRight.implicitCast(context,
                        array.type->>(PrimitiveArrayType).elementType)
                return new PrimitiveArrayIndexAssignment(left.position,
                        array.createReference(), index.createReference(), cast)
            }
            else {
                def array := iv.array
                def index := iv.index
                def cast := right.implicitCast(context,
                        array.type->>(PrimitiveArrayType).elementType)
                return new PrimitiveArrayIndexAssignment(left.position, 
                        array, index, cast)
            }
        }
-*
        else if left-?>(PossibleIndexedAssignment) {
            var pia := left->(PossibleIndexedAssignment)
            var params := [pia.index, right]
            var call := callAssignmentMethod(pia.context, "[]", params)
            if call != null
                currentNode.add(call)
            else {
                -- FIXME use map
                var types := new PrimitiveArray<String>()
                for p in params
                    types.append(p.type.displayName)
                throw new CompilerException("'\{pia.context.type.displayName}' does " + 
                        "not define the indexed assignment ([]:=) operator " +
                        "for \{types}", pia.position)
            }
        }
        else if left-?>(MethodCall) {
            -- assigning to a method call. We need to look for a corresponding
            -- assignment method / field.
            var mc := left->(MethodCall)
            var methodNode := mc.methodNode
            if !methodNode.annotations.isClass & (mc.parameters.length = 1 | 
                    methodNode.name = "[]" | methodNode.name = "[..]" |
                    methodNode.name = "[...]") {
                var cl := mc.methodNode.parent->(ClassNode)
                var oldParams := mc.parameters
                var testParams := oldParams[1..]
                -- undo implicit casts that happened as part of setting up the
                -- original method call
                for i, p in testParams {
                    testParams[i] := unwrapCast(p)
                }
                if methodNode.name = "[..]" | methodNode.name = "[...]" {
                    -- restore parameters that might have been stripped when we
                    -- matched the initial slice. Such a hack, I'm so sorry.
                    if testParams.length = 0
                        testParams.append(new NullLiteral(left.position))
                    if testParams.length = 1
                        testParams.append(new NullLiteral(left.position))
                    if testParams.length = 2
                        testParams.append(new IntegerLiteral(left.position, 1))
                }
                testParams.append(right)
                def src := unwrapCast(oldParams[0])
                def m := findAssignmentMethod(src, methodNode.name, 
                        testParams, mc.isSuper)
                if m != null {
                    -- found assignment method
                    -- promote our parameters, call it and we're done
                    var params := new PrimitiveArray<Value>()
                    if reuse
                        cm.add(right)
                    else
                        cm.add(mc)
                    for i, p in m.params {
                        if i = m.params.length - 1
                            break
                        if reuse {
                            def getMethod := left->(MethodCall).methodNode
                            var reusable := makeReusable(p)
                            reusable.replace(implicitCast(p.position,
                                    reusable.createReference(),
                                    getMethod.parameters[i].type))
                            params.append(reusable)
                        }
                        else
                            params.append(p)
                        if params[i].parent != null
                            params[i].removeFromParent()
                    }
                    if reuse
                        right.removeFromParent()
                    else
                        mc.removeFromParent()
                    params.append(right)
                    currentNode.add(new ValueStatement(context.call(
                            left.position, m.methodNode, 
                            m.methodNode.isDeclaredVirtual() & !mc.isSuper, 
                            params)))
                }
                else {
                    -- no assignment method
                    if methodNode.name = "[]" {
                        var types := new PrimitiveArray<String>()
                        for p in testParams
                            types.append(p.type.displayName)
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the indexed assignment ([]:=) " +
                                "operator for \{types}", mc.position)
                    }
                    else if methodNode.name = "[..]" {
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the exclusive slice assignment ([..]:=) " +
                                "operator for these types", mc.position)
                    }
                    else if methodNode.name = "[...]" {
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the inclusive slice assignment ([...]:=) " +
                                "operator for these types", mc.position)
                    }
                    else {
                        -- check for a field by this name
                        if oldParams.length = 1 {
                            var object := oldParams[0]
                            def field := getField(left.position, 
                                    new Dummy(object.type), 
                                    mc.methodNode.name, false)
                            if field-?>(FieldReference) {
                                if reuse {
                                    cm.add(right)
                                    def reusable := makeReusable(object)
                                    reusable.replace(reusable.createReference())
                                    object := reusable
                                    right.removeFromParent()
                                }
                                else
                                    object.removeFromParent()
                                checkAssignment(field->(FieldReference).field,
                                        field.position)
                                open(new FieldAssignment(left.position, 
                                        object, field->(FieldReference).field))
                                currentNode.add(implicitCast(right.position, 
                                        right, field.type))
                                close(class(FieldAssignment))
                                return
                            }
                        }
                        error("cannot assign to '\{left}'", left.position)
                    }
                }
            }
            else
                error("cannot assign to '\{left}'", left.position)
        }*-
        else {
            context.errors.error("cannot assign to '\{left}'", left.position)
            return null
        }
    }

    method processAssignment(position:Position, var left:ListView<Value?>, 
            assignmentOp:BinaryOperationType?, var right:Value):Statement? {
        def cm := context.currentMethod
        def reuse:Bit
        if assignmentOp = null {
            reuse := false
        }
        else {
            reuse := true
            if left.length > 1 {
                context.errors.error("compound assignment cannot " +
                        " assign to multiple values at once", 
                        position)
                return null
            }
            var lvalue := left[0]
            if lvalue = null {
                context.errors.error("'_' is only permitted in " +
                        "multiple assignments from a tuple", 
                        position)
                return null
            }
            def finalRight := getBinaryValue(position, lvalue, assignmentOp, 
                    right)
            if finalRight = null
                return null
            right := finalRight
            -- deal with situations like int8 += 1 (which resolves into
            -- int8 := int8 + 1, and the right side promotes to an Int32, so we
            -- need to downcast)
            if right.type.isInteger & lvalue.type.isInteger
                right := right.explicitCast(context, lvalue.type)
            def newLeft := new Array<Value?>()
            newLeft.add(lvalue)
            left := newLeft
        }

        if left.length > 1 {
-*            var result := new Array<Statement>()
            def reused := new ReusedValueDefinition(right)
            result.add(new ValueStatement(reused))
            for i, lvalue in left {
                if lvalue != null {
                    def tupleValue := getField(right.position, 
                            reused.createReference(), "$field" + i)
                    assert tupleValue != null : "can't-happen tuple failure"
                    def assignment := processSingleAssignment(lvalue, 
                            assignmentOp, tupleValue, reuse)
                    if assignments = null
                        return null
                }
            }
            return new Block(position, result)*-
            unreachable
        }
        else {
            def lvalue := left[0]
            assert lvalue != null
            return processSingleAssignment(lvalue, right, reuse)
        }
    }

    method convertAssignment(a:ASTAssignment):Statement? {
        def lvalues := new Array<Value?>()
        for lvalue in a.lvalues {
            def converted := convertExpression(lvalue)
            if converted = null
                return null
            lvalues.add(converted)
        }
        assert lvalues.length = 1 : "tuples not supported"
        def rvalue := convertExpression(a.rvalue)
        if rvalue = null
            return null
        return processAssignment(a.position, lvalues, a.operator, rvalue)
    }

    method convertReturn(r:ASTReturn):Statement? {
        if r.value = null
            return new Return(r.position)
        def resolved := resolve(r.value->(ASTExpression))
        if resolved = null
            return null
        def cast := resolved.implicitCast(context, 
                context.currentMethod.returnType)
        return new Return(r.position, cast)
    }

    method convertAssert(a:ASTAssert):Statement? {
        def test := resolve(a.test->(ASTExpression))
        if test = null
            return null
        def error:Value?
        if a.error != null {
            def resolved := resolve(a.error->(ASTExpression))
            if resolved = null
                return null
            if resolved.canImplicitCastTo(context, ClassType.STRING)
                error := resolved.implicitCast(context, ClassType.STRING)
            else
                error := resolved.implicitCast(context, ClassType.SAFETY_ERROR)
        }
        else
            error := null
        return new Assert(a.position, test.implicitCast(context, BitType.BIT),
                error)
    }

    method convertUnreachable(u:ASTUnreachable):Statement? {
        return new Unreachable(u.position)
    }

    method convertStatement(s:ASTStatement):Statement? {
        switch s.class {
            case class(ASTExpressionStatement): {
                def expr := resolve(s->(ASTExpressionStatement).expression)
                if expr != null
                    return new ValueStatement(expr)
                return null
            }
            case class(ASTIf):
                return convertIf(s->(ASTIf))
            case class(ASTFor):
                return convertFor(s->(ASTFor))
            case class(ASTLoop):
                return convertLoop(s->(ASTLoop))
            case class(ASTWhile):
                return convertWhile(s->(ASTWhile))
            case class(ASTDo):
                return convertDo(s->(ASTDo))
            case class(ASTBreak):
                return convertBreak(s->(ASTBreak))
            case class(ASTContinue):
                return convertContinue(s->(ASTContinue))
            case class(ASTVarDeclaration):
                return convertVarDeclaration(s->(ASTVarDeclaration))
            case class(ASTAssignment):
                return convertAssignment(s->(ASTAssignment))
            case class(ASTReturn):
                return convertReturn(s->(ASTReturn))
            case class(ASTBlock):
                return convertBlock(s->(ASTBlock))
            case class(ASTAssert):
                return convertAssert(s->(ASTAssert))
            case class(ASTUnreachable):
                return convertUnreachable(s->(ASTUnreachable))
            default:
                throw new InternalCompilerException("unsupported statement: " +
                        s.class.name, s.position)
        }
    }

    method convertBlock(b:ASTBlock):Block {
        context.pushSymbolTable()
        def statements := new Array<Statement>()
        for s in b.statements {
            def converted := convertStatement(s)
            if converted != null
                statements.add(converted)
        }
        context.popSymbolTable()
        return new Block(b.position, statements)
    }

    function callsOtherSelfConstructor(owner:ClassType,
            statements:ListView<Statement>):Bit {
        if statements.length > 0 {
            if statements[0]-?>(ValueStatement) {
                var value := statements[0]->(ValueStatement).value
                if value-?>(MethodCall) {
                    var call := value->(MethodCall)
                    if call.methodStub.methodType = MethodNodeType.CONSTRUCTOR
                        return call.parameters[0].type = owner
                }
            }
        }
        return false
    }
    
    function callsSuperConstructor(owner:ClassType,
            statements:ListView<Statement>):Bit {
        if statements.length > 0 {
            if statements[0]-?>(ValueStatement) {
                var value := statements[0]->(ValueStatement).value
                if value-?>(MethodCall) {
                    var call := value->(MethodCall)
                    if call.methodStub.methodType = MethodNodeType.CONSTRUCTOR
                        return call.parameters[0].type != owner
                }
            }
        }
        return false
    }   

    method convertMethod(m:MethodStub):MethodNode {
        context.localVariables.clear()
        context.currentMethod := m
        context.pushSymbolTable()
        def parameters := new Array<Parameter>()
        for formal in m.parameters {
            def p := new Parameter(formal.position, formal.name, formal.type, 
                    formal.isVar, formal.isConvert, formal.isVarArg)
            parameters.add(p)
            context.symbolTable[p.name] := p
        }
        var body := convertBlock(m.body->(ASTBlock))
        if m.methodType = MethodNodeType.CONSTRUCTOR & 
                !callsOtherSelfConstructor(m.owner, body.statements) {
            def statements := new Array<Statement>()
            for f in context.currentClass.fields {
                if !f.annotations.isClass & !f.annotations.isThread {
                    if f.initialValue != null {
                        def initialValue := resolve(f.initialValue->(ASTExpression))
                        if initialValue != null {
                            statements.add(new FieldAssignment(f.position,
                                    context.getSelf(f.position), f,
                                    initialValue.implicitCast(context, f.type)))
                        }
                    }
                }
            }
            statements.addAll(body.statements)
            body := new Block(body.position, statements)
        }
        def result := new MethodNode(m, body, parameters, 
                context.localVariables)
        context.popSymbolTable()
        return result
    }

    method addFields(type:ClassType) {
        def stub := context.getStub(type)
        def superclass := stub.superclass
        if superclass != null
            addFields(superclass)
        for intf in stub.interfaces
            addFields(intf)
        if type-?>(GenericType)
            addFields(type->(GenericType).base)
        for f in stub.fields
            context.symbolTable[f.name] := f
    }

    method convertClass(cl:ClassStub):ClassNode {
        def methods := new Array<MethodNode>()
        context.currentClass := cl
        context.pushSymbolTable()
        addFields(cl.type)
        for f in cl.fields
            inferFieldType(f)
        for m in cl.methods.filter(m => m.body != null)
            methods.add(convertMethod(m))
        context.popSymbolTable()
        return new ClassNode(cl, methods)
    }

    method inferFieldType(f:FieldNode) {
        if f.type-!>(UnresolvedType)
            return
        if f.initialValue = null {
            context.errors.error("field '\{f.name}' has neither an explicit " +
                    "type nor an initial value", f.position)
            f.type := VoidType.VOID
        }
        if currentlyInferring.contains(f) {
            def msg := new MutableString("unable to resolve field types due " +
                    "to a circular dependency involving:")
            for msgField in currentlyInferring
                msg.append("\n    '\{msgField.name}': \{msgField.position}")
            context.errors.error(msg->>(String), f.position)
            f.type := VoidType.VOID
            return
        }
        currentlyInferring.add(f)
        def expr := resolve(f.initialValue->(ASTExpression))
        if expr != null {
            if expr.checkValid(context)
                f.type := expr.preferredVariableType(context)
        }
        currentlyInferring.remove(f)
    }

    @private
    method createAllStubs() {
        def createStub := method(t:Type) {
            if !t.isPrimitive & t != VoidType.VOID & 
                    t != NativePointerType.NATIVE_POINTER
                context.getStub(t->>(ClassType))
        }
        var progress:Bit
        def checked := new HashSet<ClassStub>()
        do {
            progress := false
            for (_, cl) in context.classes {
                if checked.contains(cl)
                    continue
                checked.add(cl)
                progress := true
                if cl.annotations.isUnspecified
                    continue
                for f in cl.fields {
                    inferFieldType(f)
                    createStub(f.type)
                }
                for m in cl.methods {
                    for p in m.parameters
                        createStub(p.type)
                    createStub(m.returnType)
                }
                def sc := cl.superclass
                if sc != null
                    createStub(sc)
                for intf in cl.interfaces
                    createStub(intf)
            }
        }
        while progress
    }

    method generateProgram():Program {
        def classes := new HashMap<String, ClassNode>()
        var madeProgress:Bit
        do {
            madeProgress := false
            createAllStubs()
            def filtered := context.classes.values.filter(cl => !cl.isExternal & 
                    !classes.contains(cl.name) & !cl.annotations.isUnspecified)
            for cl in filtered {
                classes[cl.name] := convertClass(cl)
                madeProgress := true
            }
        }
        while madeProgress
        return new Program(context.classes.values, classes.values, 
                context.typeResolver)
    }
}