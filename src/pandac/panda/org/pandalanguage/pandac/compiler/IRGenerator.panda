package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTArrayLiteral
uses org.pandalanguage.pandac.ast.ASTArrowExpression
uses org.pandalanguage.pandac.ast.ASTAssert
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBinaryExpression
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTBreak
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTCatch
uses org.pandalanguage.pandac.ast.ASTClassLiteral
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTContinue
uses org.pandalanguage.pandac.ast.ASTDo
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTFor
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTIndex
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTLambdaExpression
uses org.pandalanguage.pandac.ast.ASTLoop
uses org.pandalanguage.pandac.ast.ASTMethodType
uses org.pandalanguage.pandac.ast.ASTMethodValue
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTNullLiteral
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTRangeExpression
uses org.pandalanguage.pandac.ast.ASTRealLiteral
uses org.pandalanguage.pandac.ast.ASTRegex
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTSwitch
uses org.pandalanguage.pandac.ast.ASTThrow
uses org.pandalanguage.pandac.ast.ASTTry
uses org.pandalanguage.pandac.ast.ASTTupleExpression
uses org.pandalanguage.pandac.ast.ASTTupleType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnaryExpression
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTValueWrapper
uses org.pandalanguage.pandac.ast.ASTVarDeclaration
uses org.pandalanguage.pandac.ast.ASTWhile
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.Package
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.stubs.TypeSymbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Closure
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.InstanceContext
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodReference
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.PackageReference
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.PropertyGet
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.SkippedValue
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedDotExpression
uses org.pandalanguage.pandac.tree.UnresolvedIndex
uses org.pandalanguage.pandac.tree.UnresolvedLambda
uses org.pandalanguage.pandac.tree.UnresolvedMethod
uses org.pandalanguage.pandac.tree.UnresolvedMethodCall
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedSlice
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.SuperType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class IRGenerator {
    constant SHIM_PREFIX := "$shim_"

    constant STRING_GROUP := /(?<!\\)\\\{.*?(?<!\\)\}/

    constant UNESCAPED_BRACE := /(?<!\\)\{/

    constant GET_PATTERN := "get_{}"

    constant SET_PATTERN := "set_{}"

    var context:Context

    def currentlyInferring := HashSet<FieldNode>()

    var addMethods := true

    @thread
    var nameCount := 0

    init(root:Package, classes:MapView<String, ClassStub>,
            stubGenerator:StubGenerator, compilerSettings:CompilerSettings,
            errors:ErrorReporter) {
        context := Context(self, stubGenerator, root, errors, compilerSettings)
    }

    @class
    function makeExplicit(v:Value):Value {
        if v-?>Cast {
            return Cast(v.position, v->Cast.value, v.type, 
                    Cast.Kind.EXPLICIT)
        }
        return v
    }
    
    @class
    function isAccessible(f:FieldNode):Bit {
        return true
    }

    @private
    method createFieldReference(position:Position, rawContextValue:Value, 
            f:FieldNode):Value {
        inferFieldType(f)
        def contextValue:Value
        if !f.annotations.isClass & !f.annotations.isThread {
            if !rawContextValue.canImplicitCastTo(context, f.owner) {
                context.errors.error("cannot reference instance field " +
                        "'\{f.name}' belonging to class " +
                        "'\{f.owner.displayName}' from an instance of " +
                        "'\{rawContextValue.type.displayName}'", position)
                return Dummy(position, f.type)
            }
            contextValue := rawContextValue.implicitCast(context, f.owner)
        }
        else {
            contextValue := rawContextValue
        }
        if f.kind = Variable.Kind.PROPERTY {
            return PropertyGet(context, position, contextValue, f)
        }
        var result:Value := FieldReference(position, contextValue, f)
        if rawContextValue.type.unwrapNullable-?>GenericType {
            def g := rawContextValue.type.unwrapNullable->GenericType
            if context.getStub(g).isUnspecialized {
                def symbols := SymbolTable()
                def formalParameters := context.getStub(g).genericParameters
                assert formalParameters.count = g.parameters.count
                for i in 0 .. formalParameters.count {
                    symbols.add(formalParameters[i][0], 
                            TypeSymbol(g.parameters[i]))
                }
                result := result.explicitCast(context, 
                        GenericType.getType(f.type, symbols))
            }
        }
        return result
    }

    method getMember(position:Position, var contextValue:Value,
            var name:String):Value? {
        if contextValue-?>IntegerLiteral {
            contextValue := contextValue.implicitCast(context,
                    contextValue.preferredType(context))
        }
        if name = "class" {
            name := "$class"
        }
        if contextValue-?>ClassLiteral {
            def type := contextValue->ClassLiteral.value.convert()->ClassType
            def member := context.getSymbolTable(type)[name]
            if member != null {
                return symbolReference(position, contextValue, member)
            }
        }
        if contextValue-?>Super {
            def type := context.getStub(implicitSelf(position).type->ClassType).superclass->ClassType
            def member := context.getSymbolTable(type)[name]
            if member != null {
                return symbolReference(position, contextValue, member)
            }
        }
        def resolved := resolve(contextValue)
        if resolved != null {
            contextValue := resolved
        }
        else {
            return null
        }
        if contextValue.type-?>VoidType {
            context.errors.error("this expression does not have any members", 
                    position)
            return null
        }
        def type := contextValue.type.convert()->ClassType
        def member := context.getSymbolTable(type)[name]
        if member != null {
            return symbolReference(position, contextValue.implicitCast(context,
                    type), member)
        }
        if contextValue-?>ClassLiteral {
            context.errors.error("'\{contextValue.type.displayName}(" + 
                    "\{contextValue})' does not have a member named '\{name}'", 
                    position)
        }
        else {
            context.errors.error("'\{contextValue.type.displayName}' does " +
                    "not have a member named '\{name}'", position)
        }
        return null
    }

    method convertCallExpression(c:ASTCallExpression):Value? {
        var target := convertExpression(c.target)
        if target = null {
            return null
        }
        if target-?>ClassLiteral {
            def n := ASTNew(c.position, toASTType(c.position,
                    target->ClassLiteral.value), c.parameters)
            return convertNew(n)
        }
        def parameters := Array<Value>()
        for p in c.parameters {
            def converted := convertExpression(p)
            if converted = null {
                return null
            }
            parameters.add(converted)
        }
        if target-?>UnresolvedMethod {
            def u := target->UnresolvedMethod
            def finalTarget:Value
            if u.target != null {
                finalTarget := u.target->Value
            }
            else if context.isInstance {
                finalTarget := InstanceContext(c.position, 
                        implicitSelf(c.position))
            }
            else {
                finalTarget := ClassLiteral(c.position, 
                        context.currentClass.type)
            }
            def methods := Array<MethodStub>()
            for m in u.methods.entries {
                if context.matchCost(finalTarget, m, parameters, null) != null {
                    methods.add(m)
                }
            }
            if methods.count <= 1 {
                return context.call(c.position, finalTarget, u.methods.entries, 
                        parameters)
            }
            return UnresolvedMethodCall(context, c.position, finalTarget, 
                    Methods(methods), parameters)
        }
        if target-?>MethodReference {
            def m := target->MethodReference
            if m.methodStub.annotations.isClass | m.target-!>ClassLiteral {
                return context.call(c.position, m.target, m.methodStub, 
                        parameters)
            }
            -- otherwise it's an instance method reference on a class, such as 
            -- String.+, and we need to treat it as an actual method reference
        }
        target := resolve(target)
        if target = null {
            return null
        }
        def type := target.type.unwrapNullable
        if type-!>MethodType {
            context.errors.error("expected a method, but found " +
                    "'\{target.type.displayName}'", target.position)
            return null
        }
        def unwrapped := target.implicitCast(context, type)
        def parameterTypes := type->MethodType.methodParameters
        if parameters.count != parameterTypes.count {
            def expected:String
            if parameterTypes.count = 1 {
                expected := "1 parameter"
            }
            else {
                expected := parameterTypes.count + " parameters"
            }
            context.errors.error("'\{type.displayName}' expects \{expected}, " +
                    "but found \{parameters.count}", c.position)
            return null
        }
        def finalParams := Array<Value>()
        for (i, p) in parameters.enumeration {
            finalParams.add(p.implicitCast(context, parameterTypes[i]))
        }
        return DynamicCall(unwrapped, finalParams)
    }

    method resolveClass(position:Position, name:String):Value? {
        def type := ASTClassType(position, name, null, false) 
        def resolved := context.resolveType(type)
        if resolved != null {
            return ClassLiteral(position, resolved)
        }
        return null
    }

    method convertDotExpression(d:ASTDotExpression):Value? {
        def left := convertExpression(d.left)
        if left = null {
            return null
        }
        if left-?>PackageReference {
            def p := left->PackageReference.value
            def child := p[d.right]
            if child != null {
                return symbolReference(d.position, child)
            }
            else {
                context.errors.error("package '\{p.name}' does not contain a " +
                        "member named '\{d.right}'", d.position)
                return null
            }
        }
        def resolved:Value?
        if left-!>Super {
            resolved := resolve(left)
        }
        else {
            resolved := left
        }
        if resolved = null {
            return null
        }
        return getMember(d.position, left, d.right)
    }

    method convertIdentifier(id:ASTIdentifier):Value? {
        return getIdentifier(id.position, id.identifier)
    }

    method convertClassLiteral(c:ASTClassLiteral):Value? {
        def type := resolve(c.type)
        if type != null {
            context.getStub(type.convert()->ClassType)
            return ClassLiteral(c.position, type)
        }
        return null
    }

    method convertIntegerLiteral(i:ASTIntegerLiteral):Value? {
        if i.signForced {
            return IntegerLiteral(i.position, i.value)
        }
        else {
            return IntegerLiteral(i.position, i.value, 
                    IntegerLiteral.TypeForce.NONE)
        }
    }

    method convertRealLiteral(r:ASTRealLiteral):Value? {
        return RealLiteral(r.position, r.value)
    }

    ============================================================================
    Given a sequence of chars from a string literal (e.g. "Hello\n!"), returns a
    string representing the contents of the literal (e.g. "Hello<newline>!")

    If `interpolating` is true, permits the additional escape sequences `\:`,
    `\{`, and `\}`, passing them through unmodified.
    ============================================================================
    method convertStringChars(position:Position, s:String, 
            interpolating:Bit):String? {
        var result := MutableString()
        var i := 0
        loop {
            var next := s.indexOf("\\", i)
            if next = null {
                result.append(s[i..])
                break
            }
            result.append(s[i .. next])
            var c := s[next + 1]
            switch c {
                case "n":  result.append("\n")
                case "r":  result.append("\r")
                case "t":  result.append("\t")
                case '"':  result.append('"')
                case "\\":
                    result.append("\\")
                    if interpolating {
                        result.append("\\")
                    }
                case "'":  result.append("'")
                case ":", "{", "}":
                    if interpolating {
                        result.append("\\")
                        result.append(c)
                    }
                    else {
                        context.errors.error("invalid string escape '\\" + c + 
                                "'", Position(position.file, position.row,
                                    position.column + i))
                        return null
                    }
                default:
                    context.errors.error("invalid string escape '\\" + c + "'", 
                            Position(position.file, position.row, 
                            position.column + i))
                    return null
            }
            i := next + 2
        }
        return result.convert()
    }

    method convertStringLiteral(string:ASTStringLiteral):Value? {
        var s := string.value
        def result := MutableString()
        def matcher := STRING_GROUP.matcher(s)
        def values := Array<Value>()
        var lastEnd := 0
        while matcher.find() {
            def chars := convertStringChars(string.position, 
                    s[lastEnd .. matcher.start], false)
            if chars != null {
                result.append(chars.replace(UNESCAPED_BRACE, 
                        "\\{"))
            }
            def text := s[matcher.start + 2 .. matcher.end - 1]
            def expr := PandaParser(context.errors).parseFormatExpression(
                    text, string.position)
            if expr = null {
                return null
            }
            def value := resolve(expr.expression)
            if value = null {
                return null
            }
            values.add(value)
            result.append("{")
            if expr.alignment != null {
                result.append(",")
                if expr.fill != null {
                    result.append(expr.fill)
                }
                switch expr.alignment {
                    case org.pandalanguage.pandac.ast.ASTFormatExpression.Alignment.LEFT: result.append("<")
                    case org.pandalanguage.pandac.ast.ASTFormatExpression.Alignment.CENTER: result.append("^")
                    case org.pandalanguage.pandac.ast.ASTFormatExpression.Alignment.RIGHT: result.append(">")
                }
                assert expr.width != null
                result.append(expr.width)
            }
            if expr.formatString != null {
                result.append(":")
                result.append(expr.formatString)
            }
            result.append("}")
            lastEnd := matcher.end
        }
        if lastEnd > 0 {
            def chars := convertStringChars(string.position, s[lastEnd..], false)
            if chars != null {
                result.append(chars.replace(UNESCAPED_BRACE, "\\{"))
            }
            s := result.convert()
            values.insert(0, StringLiteral(string.position, s))
            return context.call(string.position, ClassLiteral(
                    string.position, ClassType.STRING), "format", values)
        }
        else {
            def chars := convertStringChars(string.position, s, false)
            if chars = null {
                return null
            }
            return StringLiteral(string.position, chars)
        }
    }

    method convertBitLiteral(b:ASTBitLiteral):Value? {
        return BitLiteral(b.position, b.value)
    }

    method convertUnaryExpression(u:ASTUnaryExpression):Value? {
        var operand := resolve(u.expression)
        if operand = null {
            return null
        }
        if u.kind = UnaryOperation.Kind.MINUS & operand-?>IntegerLiteral {
            def i := operand->IntegerLiteral
            switch i.value {
                case 128: operand := IntegerLiteral(i.position, i.value, 
                        IntType.INT8)
                case 32768: operand := IntegerLiteral(i.position, i.value, 
                        IntType.INT16)
                case 2147483648: operand := IntegerLiteral(i.position, 
                        i.value, IntType.INT32)
                case 9223372036854775808: operand := IntegerLiteral(
                        i.position, i.value, IntType.INT64)
            }
        }
        if u.kind = UnaryOperation.Kind.MINUS & operand-?>RealLiteral {
            def r := operand->RealLiteral
            return RealLiteral(r.position, -r.value)
        }
        def operator:String
        switch u.kind {
            case UnaryOperation.Kind.MINUS:
                operator := "-"
                if operand.type.isPrimitive | operand.type.isWrapper {
                    def type := operand.type.convert()->PrimitiveType
                    if type.isNumber {
                        return UnaryOperation(u.position, u.kind, 
                                operand.implicitCast(context, type))
                    }
                }
            case UnaryOperation.Kind.NOT:
                return UnaryOperation(u.position, u.kind, 
                                operand.implicitCast(context, BitType.BIT))
            case UnaryOperation.Kind.BITWISE_NOT:
                operator := "!!"
                if operand.type.isPrimitive | operand.type.isWrapper {
                    def type := operand.type.convert()->PrimitiveType
                    if type.isInteger {
                        return UnaryOperation(u.position, u.kind, 
                                operand.implicitCast(context, type))
                    }
                }
            case UnaryOperation.Kind.FORCE_NON_NULLABLE:
                if operand.type.isNullable {
                    return operand.implicitCast(u.position, context,
                            operand.type.unwrapNullable)
                }
                context.errors.error("postfix '!' expected a nullable type, " +
                        "but found '\{operand.type.displayName}'", u.position)
                return operand
            default: unreachable
        }
        context.errors.error("unary '\{operator}' cannot operate on " +
                "'\{operand.type.displayName}'", u.position)
        return null
    }

    method convertBinaryExpression(b:ASTBinaryExpression):Value? {
        def left := resolve(b.left)
        if left = null {
            return null
        }
        def right := resolve(b.right)
        if right = null {
            return null
        }
        return getBinaryValue(b.position, left, b.kind, right)
    }

    method convertInstanceOf(position:Position, var object:Value, 
            var type:Type):Value? {
        if object.type = StringOrCharType.STRING_OR_CHAR {
            -- hardcode STRING_OR_CHAR-?>Char and STRING_OR_CHAR-?>String
            -- as true
            if type = CharType.CHAR | ClassType.STRING.canImplicitCastTo(
                    context, type) {
                return BitLiteral(position, true)
            }
        }
        def primitiveTarget := type.isPrimitive | type.isWrapper
        if primitiveTarget {
            if object.type = StringOrCharType.STRING_OR_CHAR {
                object := object.implicitCast(context, CharType.CHAR)
            }
            if object.type = CharType.CHAR & type.isNumber {
                object := object.explicitCast(context, IntType.INT32)
            }
        }
        def primitiveSource := object.type.isPrimitive | 
                object.type.isWrapper

        if object.type.isNumber & type.isReal {
            return BitLiteral(position, true)
        }

        if !primitiveSource & type.isPrimitive {
            type := type.convert()->ClassType
        }

        if !object.canExplicitCastTo(context, type) {
            context.errors.error("'\{object.type.displayName}' " +
                    "cannot possibly be an instance of '\{type.displayName}'", 
                    position)
        }

        def parameters := Array<Value>()
        parameters.add(object)
        if !primitiveTarget {
            parameters.add(ClassLiteral(position, type.convert()->ClassType))
        }

        var methodName := "instanceOf"
        if primitiveTarget {
            var target := type.unwrapNullable
            var name := target.name
            constant CORE := "panda.core."
            assert name.startsWith(CORE)
            name := name[CORE.length..]
            if target.isWrapper {
                name := name.replace("Wrapper", "")
            }
            methodName += name
        }
        def panda := ClassLiteral(position, ClassType.PANDA)
        var instanceOf:MethodStub? := null
        if !object.type.isNullable {
            instanceOf := context.getMethod(panda, methodName, parameters, null)
        }
        if instanceOf = null {
            parameters.add(BitLiteral(position, type.isNullable))
            instanceOf := context.getMethod(panda, methodName, parameters, null)
        }
        assert instanceOf != null
        return context.call(position, panda, instanceOf, parameters)
    }

    method convertArrowExpression(a:ASTArrowExpression):Value? {
        def left := convertExpression(a.left)
        if left = null {
            return null
        }
        def rightMatch := context.resolveTypeWithExtras(a.right)
        if rightMatch = null {
            return null
        }
        def right, extras := rightMatch
        var result:Value?
        switch a.kind {
            case ASTArrowExpression.Kind.CAST:
                result := left.explicitCast(a.position, context, right)
            case ASTArrowExpression.Kind.FORCE_CAST:
                if left.canExplicitCastTo(context, right) {
                    result := left.explicitCast(a.position, context, right)
                }
                else {
                    def src:Value
                    if left.type.isPrimitive & !right.isPrimitive {
                        src := left.implicitCast(context, 
                                left.type.convert()->ClassType)
                    }
                    else {
                        src := left
                    }
                    result := Cast(a.position, src, right, Cast.Kind.EXPLICIT)
                    result->Cast.safe := true
                }
            case ASTArrowExpression.Kind.INSTANCE_OF:
                result := convertInstanceOf(a.position, left, right)
            case ASTArrowExpression.Kind.NOT_INSTANCE_OF:
                def instanceOf := convertInstanceOf(a.position, left, right)
                if instanceOf = null {
                    return null
                }
                result := UnaryOperation(a.position, UnaryOperation.Kind.NOT,
                        instanceOf)
            default:
                unreachable
        }
        if result = null {
            return null
        }
        for e in extras {
            result := getMember(result.position, result, e)
            if result = null {
                return null
            }
        }
        return result
    }

    function check(v:Value?):Bit {
        if v = null {
            return true
        }
        return v.type-!>UnresolvedType
    }

    @pre(context.isInstance)
    method implicitSelf(position:Position):Value {
        if context.inClosure {
            context.errors.error("cannot implicitly reference 'self' within " +
                    "a closure. Use an explicit 'self.' to make the capture " +
                    "semantics explicit.", position)
        }
        return getIdentifier(position, "self")
    }

    method capture(v:Variable) {
        if context.captures.count > 0 {
            if (v-?>Parameter | v-?>LocalVariable) {
                def owner:MethodStub
                if v-?>Parameter {
                    owner := v->Parameter.owner
                }
                else {
                    owner := v->LocalVariable.owner
                }
                for i in 0 .. context.captures.count {
                    def capture := context.captures.peek(i)
                    if owner = capture[0] {
                        if v.name = "$self" {
                            capture[1].add(v)
                        }
                        break
                    }
                    capture[1].add(v)
                }
            }
            else if (v-?>FieldNode & isClosure(v->FieldNode.owner)) {
                def owner := v->FieldNode.owner
                for i in 0 .. context.captures.count {
                    def capture := context.captures.peek(i)
                    if owner = capture[0].owner {
                        break
                    }
                    capture[1].add(v)
                }
            }
        }
    }

    function isClosure(t:Type):Bit {
        return t.name.contains("$closure")
    }

    method symbolReference(position:Position, s:Symbol):Value? {
        return symbolReference(position, null, s)
    }

    method symbolReference(position:Position, var target:Value?, 
            s:Symbol):Value? {
        if s-?>FieldNode {
            def f := s->FieldNode
            inferFieldType(f)
            if f.annotations.isClass | f.annotations.isThread {
                if target != null & target-!>ClassLiteral {
                    context.errors.error("cannot reference class field " +
                            "'\{f}' from an instance context", position)
                }
                return createFieldReference(position, 
                        ClassLiteral(position, f.owner), f)
            }
            else {
                if target = null {
                    if context.isInstance {
                        if isClosure(f.owner) {
                            if context.inClosure {
                                capture(f)
                                -- only happens during capture pre-scan, so we can
                                -- just return a dummy value
                                return Dummy(position, f.type)
                            }
                            def s := VariableReference(position, 
                                    context.symbolTable[Parameter.SELF_NAME]->Variable)
                            return createFieldReference(position, s, f)
                        }
                        return createFieldReference(position, 
                                implicitSelf(position), f)
                    }
                    else {
                        context.errors.error("cannot reference instance " +
                                "field '\{f.name}' from a class context",
                                position)
                        return null
                    }
                }
                return createFieldReference(position, target, f)
            }
        }
        if s-?>Methods {
            def methods := s->Methods
            if target = null {
                if context.isInstance {
                    target := InstanceContext(position, 
                            VariableReference(position,
                                context.symbolTable[Parameter.SELF_NAME]->Variable))
                }
                else {
                    target := ClassLiteral(position,
                            context.currentClass.type)
                }
            }
            if methods.entries.count = 1 {
                return MethodReference(context, position, 
                        getMethodTarget(methods.entries[0], target), 
                        methods.entries[0])
            }
            return UnresolvedMethod(position, target, methods)
        }
        if s-?>Variable {
            def v := s->Variable
            capture(v)
            return VariableReference(position, v)
        }
        if s-?>Package {
            return PackageReference(position, s->Package)
        }
        if s-?>TypeSymbol {
            return ClassLiteral(position, s->TypeSymbol.type)
        }
        unreachable
    }

    method getIdentifier(position:Position, name:String):Value? {
        def result := context.symbolTable[name]
        if result != null {
            return symbolReference(position, result)
        }
        if context.isInstance {
            return getMember(position, implicitSelf(position), name)
        }
        context.errors.error("unknown identifier '\{name}'", position)
        return null
    }

    method getMethodTarget(m:MethodStub, target:Value):Value {
        if target-?>InstanceContext {
            if m.annotations.isClass {
                return target->InstanceContext.classLiteral
            }
            else {
                return target->InstanceContext.selfParam
            }
        }
        def resolved := resolve(target)
        if resolved != null {
            return resolved
        }
        return target
    }

    method makeClosure(ref:MethodReference):Value {
        def parameters := Array<ASTParameter>()
        constant IMPLICIT_SELF := "$implicitSelf"
        if !ref.methodStub.annotations.isClass & ref.target-?>ClassLiteral {
            def owner:Type
            if ref.methodStub.annotations.isWrapperMethod {
                owner := ref.methodStub.owner.convert()->PrimitiveType
            }
            else {
                owner := ref.methodStub.owner
            }
            parameters.add(ASTParameter(ref.position, IMPLICIT_SELF, 
                    toASTType(ref.position, owner), false, 
                    false))
        }
        for p in ref.methodStub.parameters {
            parameters.add(ASTParameter(p.position, p.name, 
                    toASTType(p.position, p.type), p.isVar, p.isVarArg))
        }
        def nameComps := ref.methodStub.owner.name.split(".")
        def target:ASTExpression
        def discardedValue:Value?
        if ref.target-?>ClassLiteral {
            if ref.methodStub.annotations.isClass {
                var classRef:ASTExpression := ASTIdentifier(ref.position, 
                        nameComps[0])
                for n in nameComps[1..] {
                    classRef := ASTDotExpression(classRef, n)
                }
                target := classRef

            }
            else {
                target := ASTIdentifier(ref.position, IMPLICIT_SELF)
            }
            discardedValue := null
        }
        else {
            def finalTarget := getMethodTarget(ref.methodStub, ref.target)
            def targetVar := LocalVariable(ref.position, 
                    "$closureTarget" + nameCount, finalTarget.type, 
                    Variable.Kind.VAR, context.currentMethod)
            nameCount += 1
            context.localVariables.add(targetVar)
            context.symbolTable.add(targetVar)
            target := ASTIdentifier(ref.position, targetVar.name)
            discardedValue := VariableAssignment(ref.position, targetVar,
                    ref.target)
        }
        def methodRef := ASTDotExpression(target, ref.methodStub.name)
        def parameterRefs := Array<ASTExpression>()
        for p in ref.methodStub.parameters {
            parameterRefs.add(ASTIdentifier(ref.position, p.name))
        }
        def call := ASTCallExpression(methodRef, parameterRefs)
        def statement:ASTStatement
        if ref.methodStub.returnType != VoidType.VOID {
            statement := ASTReturn(ref.position, call)
        }
        else {
            statement := ASTExpressionStatement(call)
        }
        def value := ASTMethodValue(ref.position, ref.methodStub.kind, 
                parameters, toASTType(ref.position, ref.methodStub.returnType), 
                ASTBlock(ref.position, [statement]))
        def resolved := resolve(value)
        if discardedValue != null {
            return SkippedValue(discardedValue, resolved)
        }
        else {
            return resolved
        }
    }

    method resolve(v:Value):Value? {
        if v.type-?>UnresolvedType {
            if !v.checkValid(context) {
                return null
            }
            def type := v.preferredType(context)
            return v.implicitCast(context, type)
        }
        return v
    }
    @post(@return = null | @return.type-!>UnresolvedType)

    method resolve(e:ASTExpression):Value? {
        var result := convertExpression(e)
        if result = null {
            return null
        }
        return resolve(result)
    }

    method resolve(t:ASTType):Type? {
        return context.resolveType(t) 
    }

    method convertNew(n:ASTNew):Value? {
        def type := resolve(n.type)
        if type = null {
            return null
        }
        def parameters := Array<Value>()
        for p in n.parameters {
            def expr := convertExpression(p)
            if expr = null {
                return null
            }
            parameters.add(expr)
        }
        if type-?>PrimitiveArrayType {
            def elementType := type->PrimitiveArrayType.parameters[0]
            if parameters.count = 1 &
                    parameters[0].canImplicitCastTo(context, IntType.INT) {
                def cast := parameters[0].implicitCast(context, IntType.INT)
                context.getStub(type.convert()->PrimitiveArrayType)
                return NewPrimitiveArrayWithLength(n.position, 
                        type.convert()->PrimitiveArrayType, cast)
            }
            else if parameters.count = 1 &
                    parameters[0].type.isPrimitiveArray &
                    parameters[0].type->PrimitiveArrayType.parameters[0] =
                        elementType {
                context.getStub(type->PrimitiveArrayType)
                return PrimitiveArrayCopy(n.position, 
                        type->PrimitiveArrayType, parameters[0])
            }
            else if parameters.count = 0 {
                context.getStub(type.convert()->PrimitiveArrayType)
                return NewPrimitiveArrayWithLength(n.position, 
                        type.convert()->PrimitiveArrayType, IntegerLiteral(
                            n.position, 0, IntType.INT))
            }
            else {
                def casted := Array<Value>()
                for p in parameters {
                    casted.add(p.implicitCast(context, elementType))
                }
                return NewPrimitiveArrayWithValues(n.position, 
                        type.convert()->PrimitiveArrayType, casted)
            }
        }
        if type-?>MethodType | type-?>TupleType {
            context.errors.error("type '\{type.displayName}' cannot be " +
                    "instantiated", n.position)
            return null
        }
        def cl := type.convert()->ClassType
        def stub := context.getStub(cl)
        if stub.kind = ClassStub.Kind.INTERFACE {
            context.errors.error("interfaces may not be instantiated",
                    n.position)
            return null
        }
        def symbolTable := context.getSymbolTable(cl)
        def inits := symbolTable[MethodNode.INIT_NAME]
        assert inits != null
        def methods := Array<MethodStub>()
        for m in inits->Methods.entries {
            methods.add(m)
        }
        def call := context.call(n.position, ClassLiteral(n.position, type), 
                methods, parameters)
        if call != null {
            return Construct(call->MethodCall, type)
        }
        else {
            return null
        }
    }

    method convertIndex(i:ASTIndex):Value? {
        def target := resolve(i.target)
        if target = null {
            return null
        }
        var index := convertExpression(i.index)
        if index = null {
            return null
        }
        if index-?>UnresolvedRange {
            def range := index->UnresolvedRange
            return UnresolvedSlice(context, i.position, target, range.left, 
                    range.right, range.step, range.endInclusive)
        }
        if target.type.unwrapNullable-?>TupleType & index-?>IntegerLiteral {
            return getMember(i.position, target, TupleType.FIELD_PREFIX + 
                    index->IntegerLiteral.value)
        }
        if target.type.unwrapNullable-?>PrimitiveArrayType {
            return PrimitiveArrayIndexValue(target, 
                    index.implicitCast(context, IntType.INT))
        }
        return UnresolvedIndex(context, i.position, target, index)
    }

    method convertRangeExpression(r:ASTRangeExpression):Value? {
        def left:Value?
        if r.left != null {
            left := resolve(r.left->ASTExpression)
            if left = null {
                return null
            }
        }
        else {
            left := null
        }
        def right:Value?
        if r.right != null {
            right := resolve(r.right->ASTExpression)
            if right = null {
                return null
            }
        }
        else {
            right := null
        }
        def step:Value?
        if r.step != null {
            step := resolve(r.step->ASTExpression)
            if step = null {
                return null
            }
        }
        else {
            step := null
        }
        return UnresolvedRange(context, r.position, left, right, step, 
                r.endInclusive)
    }

    method convertRegex(r:ASTRegex):Value? {
        def result := context.call(r.position, ClassLiteral(r.position,
                ClassType.REGULAR_EXPRESSION), MethodNode.INIT_NAME,
                [StringLiteral(r.position, r.value)])
        if result = null {
            return null
        }
        return Construct(result->MethodCall)
    }

    method convertArray(a:ASTArrayLiteral):Value? {
        def values := Array<Value>()
        for expr in a.values {
            def v := convertExpression(expr)
            if v = null {
                return null
            }
            values.add(v)
        }
        return UnresolvedArray(context, a.position, values)
    }

    method convertTuple(t:ASTTupleExpression):Value? {
        def values := Array<Value>()
        for expr in t.values {
            def v := convertExpression(expr)
            if v = null {
                return null
            }
            values.add(v)
        }
        return UnresolvedTuple(context, t.position, values)
    }

    method convertSelf(s:ASTSelf):Value? {
        if isClosureMethod(context.currentMethod) {
            def v := context.symbolTable["$" + Parameter.SELF_NAME]
            return symbolReference(s.position, v->Variable)
        }
        if context.isInstance {
            def v := context.symbolTable[Parameter.SELF_NAME]
            return symbolReference(s.position, v->Variable)
        }
        else {
            context.errors.error("cannot reference 'self' outside of an " +
                    "instance context", s.position)
            return null
        }
    }

    method convertSuper(s:ASTSuper):Value? {
        if context.isInstance {
            return Super(s.position, context.currentClass.type)
        }
        context.errors.error(SuperType.ERROR_MESSAGE, s.position)
        return null
    }

    method convertSwitch(s:ASTSwitch):Statement? {
        def resolved := resolve(s.value)
        if resolved != null {
            def switchObject := ReusedValueDefinition(resolved)
            def statements := Array<Statement>()
            statements.add(ValueStatement(switchObject))
            var lastCase:Statement? := null
            def cases := Array<If>()
            if s.defaultCase != null {
                def defaultStatement := convertStatement(s.defaultCase->ASTStatement)
                if defaultStatement != null {
                    lastCase := defaultStatement
                }
                else {
                    return null
                }
            }
            for i in s.cases.count - 1 ... 0 by -1 {
                def c := s.cases[i]
                def start := resolve(c.values[0])
                if start != null {
                    var test := getBinaryValue(start.position, 
                            switchObject.createReference(), 
                            BinaryOperation.Kind.EQUAL, 
                            start)
                    if test = null {
                        return null
                    }
                    for v in c.values[1..] {
                        def next := resolve(v)
                        if next != null {
                            def equal := getBinaryValue(start.position, 
                                        switchObject.createReference(), 
                                        BinaryOperation.Kind.EQUAL, 
                                        next)
                            if equal = null {
                                return null
                            }
                            test := getBinaryValue(v.position, 
                                    test, BinaryOperation.Kind.OR,
                                    equal)
                            if test = null {
                                return null
                            }
                        }
                        else {
                            return null
                        }
                    }
                    def statement := convertStatement(c.statement)
                    if statement != null {
                        lastCase := If(statement.position, test, 
                                statement, lastCase)
                    }
                    else {
                        return null
                    }
                }
                else {
                    return null
                }
            }
            if lastCase = null {
                return null
            }
            statements.add(lastCase)
            return Block(s.position, statements)
        }
        return null
    }

    method convertExpression(e:ASTExpression):Value? {
        switch e.class {
            case ASTCallExpression:
                return convertCallExpression(e->ASTCallExpression)
            case ASTIdentifier:
                return convertIdentifier(e->ASTIdentifier)
            case ASTDotExpression:
                return convertDotExpression(e->ASTDotExpression)
            case ASTIntegerLiteral:
                return convertIntegerLiteral(e->ASTIntegerLiteral)
            case ASTRealLiteral:
                return convertRealLiteral(e->ASTRealLiteral)
            case ASTStringLiteral:
                return convertStringLiteral(e->ASTStringLiteral)
            case ASTBitLiteral:
                return convertBitLiteral(e->ASTBitLiteral)
            case ASTNullLiteral:
                return NullLiteral(e.position)
            case ASTUnaryExpression:
                return convertUnaryExpression(e->ASTUnaryExpression)
            case ASTBinaryExpression:
                return convertBinaryExpression(e->ASTBinaryExpression)
            case ASTArrowExpression:
                return convertArrowExpression(e->ASTArrowExpression)
            case ASTNew:
                return convertNew(e->ASTNew)
            case ASTSelf:
                return convertSelf(e->ASTSelf)
            case ASTSuper:
                return convertSuper(e->ASTSuper)
            case ASTIndex:
                return convertIndex(e->ASTIndex)
            case ASTRangeExpression:
                return convertRangeExpression(e->ASTRangeExpression)
            case ASTRegex:
                return convertRegex(e->ASTRegex)
            case ASTArrayLiteral:
                return convertArray(e->ASTArrayLiteral)
            case ASTTupleExpression: 
                return convertTuple(e->ASTTupleExpression)
            case ASTClassLiteral:
                return convertClassLiteral(e->ASTClassLiteral)
            case ASTLambdaExpression:
                return convertLambda(e->ASTLambdaExpression)
            case ASTMethodValue:
                return convertMethodValue(e->ASTMethodValue)
            case ASTValueWrapper:
                return e->ASTValueWrapper.value
            default:
                throw InternalCompilerException("unsupported expression: " +
                        e.class.name, e.position)
        }
    }

    method convertVarDeclaration(v:ASTVarDeclaration):Statement? {
        var initializer:Value?
        if v.initializer != null {
            initializer := convertExpression(v.initializer->ASTExpression)
            if initializer = null {
                return null
            }
        }
        else {
            initializer := null
        }
        def locals := Array<LocalVariable>()
        var allTyped := true
        for (i, decl) in v.vars.enumeration {
            def type:Type?
            if decl.type != null {
                type := resolve(decl.type->ASTType)
                if type = null {
                    context.errors.error("unknown class '\{decl.type->ASTType}'",
                            decl.type->ASTType.position)
                    return null
                }
            }
            else {
                allTyped := false
                if initializer = null {
                    context.errors.error("variable has neither an " +
                            "initializer nor a type", decl.position)
                    return null
                }
                if !initializer.checkValid(context) {
                    return null
                }
                def initializerType := initializer.preferredVariableType(
                        context)
                initializer := initializer.implicitCast(context, 
                        initializerType)
                if v.vars.count > 1 {
                    if initializerType.unwrapNullable-!>TupleType {
                        context.errors.error("expected a tuple of length " +
                                "\{v.vars.count} for multi-valued assignment",
                                initializer.position)
                        return null
                    }
                    type := initializerType.unwrapNullable->TupleType.types[i]
                }
                else {
                    type := initializerType
                }
            }
            def local := LocalVariable(decl.position, decl.identifier, type,
                    v.kind, context.currentMethod)
            if decl.identifier != "_" {
                context.localVariables.add(local)
                context.symbolTable.add(local)
            }
            locals.add(local)
        }
        if initializer != null {
            if v.vars.count = 1 {
                if locals[0].name = "_" {
                    context.errors.error("'_' is only permitted in " +
                            "multiple assignments from a tuple", v.position)
                    return null
                }            
                return ValueStatement(VariableAssignment(v.position, 
                        locals[0], initializer.implicitCast(context, 
                            locals[0].type), 
                        true))
            }
            if allTyped {
                def types := Array<Type>()
                for local in locals {
                    types.add(local.type)
                }
                initializer := initializer.implicitCast(context, 
                        TupleType(types))
            }
            else {
                initializer := resolve(initializer)
            }
            def tuple := LocalVariable(initializer.position, 
                    "$tuple\{nameCount}", initializer.type.unwrapNullable, 
                    Variable.Kind.DEF, context.currentMethod)
            if tuple.type->TupleType.types.count != locals.count {
                context.errors.error("expected a tuple of length " +
                        "\{locals.count} for multi-valued assignment",
                        tuple.position)
                return null
            }
            context.localVariables.add(tuple)
            nameCount += 1
            def statements := Array<Statement>()
            statements.add(ValueStatement(VariableAssignment(
                    v.position, tuple, initializer.implicitCast(context,
                        tuple.type), 
                    true)))
            for (i, local) in locals.enumeration {
                if local.name = "_" {
                    continue
                }
                def member := getMember(local.position, 
                        VariableReference(local.position, tuple), 
                        TupleType.FIELD_PREFIX + i)
                assert member != null
                statements.add(ValueStatement(VariableAssignment(
                        local.position, local, member.implicitCast(context, 
                            local.type), 
                        true)))
            }
            return Block(v.position, statements)
        }
        return null
    }

    method convertIf(i:ASTIf):Statement? {
        var test := resolve(i.test)
        if test = null {
            return null
        }
        test := test.implicitCast(context, BitType.BIT)
        def thenStatement := convertStatement(i.thenStatement)
        if thenStatement = null {
            return null
        }
        def elseStatement:Statement?
        if i.elseStatement != null {
            elseStatement := convertStatement(i.elseStatement->ASTStatement)
            if elseStatement = null {
                return null
            }
        }
        else {
            elseStatement := null
        }
        return If(i.position, test, thenStatement, elseStatement)
    }

    @private
    method castToIterable(value:Value):Value? {
        for intf in value.type.convert()->ClassType.allInterfaces(context) {
            if intf.name.startsWith("panda.collections.Iterable<") {
                return value.implicitCast(context, intf)
            }
        }
        context.errors.error("expected 'panda.collections.Iterable<T>'" +
                ", but found '\{value.type.displayName}'", value.position)
        return null
    }

    method convertIteratorFor(f:ASTFor, iterator:Value):Statement? {
        def elementType := iterator.type->GenericType.parameters[0]
        def valueVars := Array<LocalVariable>()
        if f.valueVars.count > 1 {
            if !elementType.isTuple | 
                    elementType.convert()->TupleType.types.count != f.valueVars.count {
                context.errors.error("'for' loop expected a list of " +
                        "tuples of length \{f.valueVars.count}, but found a " + 
                        "list of '\{elementType.displayName}'", f.position)
                return null
            }
        }
        for (i, v) in f.valueVars.enumeration {
            var type:Type?
            if v.type != null {
                type := resolve(v.type->ASTType)
                if type = null {
                    return null
                }
            }
            else {
                if f.valueVars.count = 1 {
                    type := elementType
                }
                else {
                    def tuple := elementType->TupleType
                    type := tuple.types[i]
                }
            }
            def valueVar := LocalVariable(v.position, v.identifier, type,
                    Variable.Kind.DEF, context.currentMethod)
            valueVars.add(valueVar)
            if v.identifier != "_" {
                context.localVariables.add(valueVar)
                context.symbolTable.add(valueVar)
            }
        }
        def statements := Array<Statement>()
        def reused := ReusedValueDefinition(iterator)
        statements.add(ValueStatement(reused))
        def typeParams := Array<Type>()
        typeParams.add(elementType)
        def bodyStatements := Array<Statement>()
        def done := context.call(f.position, reused.createReference(), 
                "get_done", Array<Value>())
        assert done != null
        def test := If(f.position, done, Break(f.position), null)
        bodyStatements.add(test)
        def next := context.call(f.position, reused.createReference(), "next", 
                Array<Value>())
        assert next != null
        def tupleVar:LocalVariable
        if valueVars.count = 1 {
            tupleVar := valueVars[0]
        }
        else {
            tupleVar := LocalVariable(f.position, "$tuple", elementType,
                    Variable.Kind.DEF, context.currentMethod)
            context.localVariables.add(tupleVar)
        }
        bodyStatements.add(ValueStatement(VariableAssignment(
                f.position, tupleVar, next, true)))
        if valueVars.count > 1 {
            for (i, v) in valueVars.enumeration {
                if v.name = "_" {
                    continue
                }
                def value := getMember(f.position,
                        VariableReference(tupleVar.position, tupleVar), 
                        "$field" + i)
                assert value != null
                bodyStatements.add(ValueStatement(VariableAssignment(
                        f.position, valueVars[i], value, true)))
            }
        }
        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null {
            return null
        }
        bodyStatements.add(bodyStatement)
        def continueStatements := Array<Statement>()
        def w := LoopWithContinueBlock(f.position, f.label, 
                Block(f.position, bodyStatements), Block(f.position,
                continueStatements))
        statements.add(w)
        return Block(f.position, statements)
    }

    method convertIterableFor(f:ASTFor, rawList:Value):Statement? {
        def list := castToIterable(rawList)
        if list = null {
            return null
        }
        def getIterator := context.call(f.position, list, "get_iterator", 
                Array<Value>())
        assert getIterator != null
        return convertIteratorFor(f, getIterator)
    }

    @private
    function getLiteral(i:Int64, t:Type):Value {
        if t.isReal {
            return RealLiteral(Position.INTERNAL, i, t->RealType)
        }
        if i < 0 {
            return UnaryOperation(Position.INTERNAL, 
                    UnaryOperation.Kind.MINUS,
                    IntegerLiteral(Position.INTERNAL, i.abs->UInt64, 
                    t->IntType))
        }        
        return IntegerLiteral(Position.INTERNAL, i->UInt64, t->PrimitiveType)
    }

    @private
    function unsignedVersion(var t:Type):Type {
        t := t.convert()->PrimitiveType
        switch t {
            case IntType.INT8: return IntType.UINT8
            case IntType.INT16: return IntType.UINT16
            case IntType.INT32: return IntType.UINT32
            case IntType.INT64: return IntType.UINT64
        }
        return t
    }

    -- "What the...? Why is this so complicated?!?"
    -- There's probably a simpler way to do this, but the problem of "loop from
    -- left to right by step" is harder than it sounds. Overflows are a real
    -- problem, particularly when you're looping to the minimum / maximum value
    -- supported by the type you're using, and even moreso when the step is
    -- greater than 1. So I have to jump through a lot of hoops to ensure that
    -- we correctly detect the end of the loop, never going past it and 
    -- overflowing. Feel free to figure out a better approach.

    ============================================================================
    Converts a numeric range `for` loop where the step is a compile-time 
    constant.
    ============================================================================
    method convertRangeForConstantStep(f:ASTFor, loopVar:Variable, start:Value, 
            rawEnd:Value, step:Int, endInclusive:Bit):Statement? {
        def statements := Array<Statement>()
        statements.add(ValueStatement(VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        def end := ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def testType:BinaryOperation.Kind
        if endInclusive {
            testType := BinaryOperation.Kind.LESS_THAN_OR_EQUAL
        }
        else {
            testType := BinaryOperation.Kind.LESS_THAN
        }
        def testLeft:Value
        def testRight:Value
        if step > 0 {
            testLeft := VariableReference(f.position, loopVar)
            testRight := end
        }
        else {
            testLeft := end
            testRight := VariableReference(f.position, loopVar)
        }
        def test := BinaryOperation(f.position, testType,
                testLeft, testRight)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null {
            return null
        }

        def breakTestType:BinaryOperation.Kind
        if endInclusive {
            breakTestType := BinaryOperation.Kind.LESS_THAN
        }
        else {
            breakTestType := BinaryOperation.Kind.LESS_THAN_OR_EQUAL
        }
        def sub1 := Cast(f.position, end.createReference(),
                unsignedVersion(loopVar.type), Cast.Kind.CONVERT)
        def sub2 := Cast(f.position, VariableReference(f.position,
                loopVar), unsignedVersion(loopVar.type),
                Cast.Kind.CONVERT)
        def left:Value
        def right:Value
        if step > 0 {
            left := sub1
            right := sub2
        }
        else {
            left := sub2
            right := sub1
        }
        def sub := BinaryOperation(f.position, BinaryOperation.Kind.SUBTRACT,
                left, right)
        def stepLiteral := getLiteral(step.abs, 
                unsignedVersion(loopVar.type))
        def breakTest := BinaryOperation(f.position, breakTestType, sub,
                stepLiteral)
        def label:String
        if f.label != null {
            label := f.label->String
        }
        else {
            label := "$numericForLoops\{f.hash}"
        }
        def breakIf := If(f.position, breakTest, Break(f.position, 
                label), null)
        def nextOp:BinaryOperation.Kind
        if step > 0 {
            nextOp := BinaryOperation.Kind.ADD
        }
        else {
            nextOp := BinaryOperation.Kind.SUBTRACT
        }
        def next := BinaryOperation(f.position, nextOp, 
                VariableReference(f.position, loopVar),
                getLiteral(step.abs, loopVar.type))
        def continueStatements := Array<Statement>()
        continueStatements.add(breakIf)
        continueStatements.add(ValueStatement(VariableAssignment(
                f.position, loopVar, next)))
        statements.add(If(f.position, test, LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                Block(f.position, continueStatements)), null))
        return Block(f.position, statements)
    }

    function getConvertCast(v:Value, t:Type):Value {
        if v.type = t {
            return v
        }
        return Cast(v.position, v, t, Cast.Kind.CONVERT)
    }

    ============================================================================
    Converts a numeric range `for` loop where the step is not a compile-time 
    constant.
    ============================================================================
    method convertRangeForVariableStep(f:ASTFor, loopVar:Variable, start:Value,
            rawEnd:Value, rawStep:Value, endInclusive:Bit):Statement? {
        def end := ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def stepCast:Value
        if loopVar.type = CharType.CHAR {
            def intermediate := rawStep.implicitCast(context, IntType.INT16)
            stepCast := getConvertCast(intermediate, CharType.CHAR)
        }
        else {
            stepCast := rawStep.implicitCast(context, loopVar.type)
        }
        def step := ReusedValueDefinition(stepCast)
        def statements := Array<Statement>()
        statements.add(ValueStatement(VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        statements.add(ValueStatement(end))
        statements.add(ValueStatement(step))
        def testLeftLeft := BinaryOperation(f.position,
                BinaryOperation.Kind.GREATER_THAN, step.createReference(), 
                getLiteral(0, step.type))
        def testLeftRightType:BinaryOperation.Kind
        if endInclusive {
            testLeftRightType := BinaryOperation.Kind.LESS_THAN_OR_EQUAL
        }
        else {
            testLeftRightType := BinaryOperation.Kind.LESS_THAN
        }
        def testLeftRight := BinaryOperation(f.position, testLeftRightType,
                VariableReference(f.position, loopVar), 
                end.createReference())
        def testLeft := BinaryOperation(f.position, BinaryOperation.Kind.AND,
                testLeftLeft, testLeftRight)
        def testRightLeft := BinaryOperation(f.position,
                BinaryOperation.Kind.LESS_THAN, step.createReference(), 
                getLiteral(0, step.type))
        def testRightRight := BinaryOperation(f.position,
                testLeftRightType, end.createReference(), 
                VariableReference(f.position, loopVar))
        def testRight := BinaryOperation(f.position, BinaryOperation.Kind.AND,
                testRightLeft, testRightRight)
        def test := BinaryOperation(f.position, BinaryOperation.Kind.OR,
                testLeft, testRight)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null {
            return null
        }

        def label:String
        if f.label != null {
            label := f.label->String
        }
        else {
            label := "$numericForLoops\{f.hash}"
        }

        def continueStatements := Array<Statement>()

        def breakLeftLeft := BinaryOperation(f.position,
                BinaryOperation.Kind.GREATER_THAN, step.createReference(),
                getLiteral(0, step.type))
        def breakLeftRightType:BinaryOperation.Kind
        if endInclusive {
            breakLeftRightType := BinaryOperation.Kind.LESS_THAN
        }
        else {
            breakLeftRightType := BinaryOperation.Kind.LESS_THAN_OR_EQUAL
        }
        def unsigned := unsignedVersion(loopVar.type)
        def leftSub := BinaryOperation(f.position, 
                BinaryOperation.Kind.SUBTRACT, getConvertCast(
                    end.createReference(), unsigned),
                getConvertCast(VariableReference(f.position, loopVar),
                    unsigned))
        def breakLeftRight := BinaryOperation(f.position, 
                breakLeftRightType, leftSub, getConvertCast(
                    step.createReference(), unsigned))
        def breakLeft := BinaryOperation(f.position, 
                BinaryOperation.Kind.AND, breakLeftLeft, breakLeftRight)
        def breakRightLeft := BinaryOperation(f.position,
                BinaryOperation.Kind.LESS_THAN, step.createReference(),
                getLiteral(0, step.type))
        def rightSub := BinaryOperation(f.position, 
                BinaryOperation.Kind.SUBTRACT, getConvertCast( 
                    VariableReference(f.position, loopVar), unsigned),
                getConvertCast(end.createReference(), unsigned))
        def breakRightRight := BinaryOperation(f.position, 
                breakLeftRightType, rightSub, UnaryOperation(f.position,
                    UnaryOperation.Kind.MINUS, getConvertCast(
                    step.createReference(), unsigned)))
        def breakRight := BinaryOperation(f.position, 
                BinaryOperation.Kind.AND, breakRightLeft, breakRightRight)
        def breakTest := BinaryOperation(f.position, BinaryOperation.Kind.OR,
                breakLeft, breakRight)
        def breakIf := If(f.position, breakTest, Break(f.position, 
                label), null)
        continueStatements.add(breakIf)
        def next := BinaryOperation(f.position, BinaryOperation.Kind.ADD,
                VariableReference(f.position, loopVar), 
                step.createReference())
        continueStatements.add(ValueStatement(VariableAssignment(
                f.position, loopVar, next)))

        statements.add(If(f.position, test, LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                Block(f.position, continueStatements)), null))
        return Block(f.position, statements)
    }

    ============================================================================
    Converts a numeric range `for` loop where the step is not specified.
    ============================================================================
    method convertRangeFor(f:ASTFor, loopVar:Variable, start:Value, 
            rawEnd:Value, endInclusive:Bit):Statement? {
        def statements := Array<Statement>()
        statements.add(ValueStatement(VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        def end := ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def testType:BinaryOperation.Kind
        if endInclusive {
            testType := BinaryOperation.Kind.LESS_THAN_OR_EQUAL
        }
        else {
            testType := BinaryOperation.Kind.LESS_THAN
        }
        def test := BinaryOperation(f.position, testType,
                VariableReference(f.position, loopVar),
                end)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null {
            return null
        }

        def inc := BinaryOperation(f.position, BinaryOperation.Kind.ADD,
                VariableReference(f.position, loopVar), 
                getLiteral(1, loopVar.type))
        def continueStatements := Array<Statement>()
        def label:String
        if f.label != null {
            label := f.label->String
        }
        else {
            label := "$numericForLoops\{f.hash}"
        }
        if loopVar.type.isReal {
            -- reals are simpler: we can just add 1 and then check whether we've
            -- gone past our bounds (since we can safely assume that the loop
            -- bound is nowhere near the max real). For ints, that wouldn't work 
            -- if we were iterating to, say, 127 in an Int8: we can't actually 
            -- go past our bound because it would overflow, so we need to handle
            -- things a bit differently there (and the handling we do there 
            -- won't work for reals, because you can skip past a real when
            -- incrementing by 1, and that isn't true for ints)
            def breakTestType:BinaryOperation.Kind
            if endInclusive {
                breakTestType := BinaryOperation.Kind.GREATER_THAN
            }
            else {
                breakTestType := BinaryOperation.Kind.GREATER_THAN_OR_EQUAL
            }
            def breakTest := BinaryOperation(f.position, breakTestType,
                    VariableReference(f.position, loopVar), 
                    end.createReference())
            def breakIf := If(f.position, breakTest, 
                    Break(f.position, label), null)
            continueStatements.add(ValueStatement(VariableAssignment(
                    f.position, loopVar, inc)))
            continueStatements.add(breakIf)
        }
        else {
            def breakTest := BinaryOperation(f.position, 
                    BinaryOperation.Kind.EQUAL, 
                    VariableReference(f.position, loopVar),
                    end.createReference())
            def breakIf := If(f.position, breakTest, 
                    Break(f.position, label), null)
            if endInclusive {
                continueStatements.add(breakIf)
            }
            continueStatements.add(ValueStatement(VariableAssignment(
                    f.position, loopVar, inc)))
            if !endInclusive {
                continueStatements.add(breakIf)
            }
        }
        statements.add(If(f.position, test, LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                Block(f.position, continueStatements)), null))
        return Block(f.position, statements)
    }

    ============================================================================
    Converts a numeric range `for` loop (a loop which operates over an 
    numeric range, such as `for i in 1 ... 10`). This is essentially an
    optimization, as obviously the "normal" mechanism of expanding `1 ... 10` to
    a call to the range operator defined in `Int` and then iterating over the
    resulting list would work, but would be very slow.

    However, this particular transformation is *required*, so it's a bit more
    than just "an optimization". The range operators in the various `Int` 
    classes are actually defined using numeric `for` loops, trusting the 
    compiler to convert the ranges to this sort of loop. If this transformation
    were disabled, the various range operators would be defined in terms of the
    various range operators, which would not be good.
    ============================================================================
    method convertRangeFor(f:ASTFor, range:UnresolvedRange):Statement? {
        if f.valueVars.count > 1 {
            context.errors.error("'for' loop expected a list of tuples " +
                    "containing \{f.valueVars.count} elements each, found " +
                    "'\{range.type}'", f.position)
            return null
        }
        def v := f.valueVars[0]
        var type:Type?
        if v.type != null {
            type := resolve(v.type->ASTType)
            if type = null {
                return null
            }
        }
        else {
            type := range.value->Value.type->GenericType.parameters[0]
        }
        def loopVar := LocalVariable(v.position, v.identifier, type,
                Variable.Kind.DEF, context.currentMethod)
        context.localVariables.add(loopVar)
        context.symbolTable.add(loopVar)
        def step := range.step
        if step = null {
            return convertRangeFor(f, loopVar, range.left->Value, 
                    range.right->Value, range.endInclusive)
        }
        else if step-?>IntegerLiteral {
            return convertRangeForConstantStep(f, loopVar, range.left->Value, 
                    range.right->Value, 
                    step->IntegerLiteral.value.convert()->Int32, 
                    range.endInclusive)
        }
        else if step-?>UnaryOperation {
            def u := step->UnaryOperation
            if u.kind = UnaryOperation.Kind.MINUS & 
                    u.operand-?>IntegerLiteral {
                return convertRangeForConstantStep(f, loopVar, 
                        range.left->Value, range.right->Value, 
                        -u.operand->IntegerLiteral.value.convert()->Int32,
                        range.endInclusive)
            }
        }
        return convertRangeForVariableStep(f, loopVar, range.left->Value, 
                range.right->Value, step, range.endInclusive)
    }

    method convertPrimitiveArrayFor(f:ASTFor, rawArray:Value):Statement? {
        def array := ReusedValueDefinition(rawArray)
        def elementType := array.type.convert()->PrimitiveArrayType.elementType
        def valueVars := Array<Variable>()
        for v in f.valueVars {
            var type:Type?
            if v.type != null {
                type := resolve(v.type->ASTType)
                if type = null {
                    return null
                }
            }
            else {
                type := elementType
            }
            def valueVar := LocalVariable(v.position, v.identifier, type,
                    Variable.Kind.DEF, context.currentMethod)
            valueVars.add(valueVar)
            context.localVariables.add(valueVar)
            context.symbolTable.add(valueVar)
        }
        def statements := Array<Statement>()
        statements.add(ValueStatement(array))
        def indexVar := LocalVariable(f.position, "$index", IntType.INT,
                    Variable.Kind.VAR, context.currentMethod)
        context.localVariables.add(indexVar)
        statements.add(ValueStatement(VariableAssignment(f.position, 
                indexVar, IntegerLiteral(f.position, 0, indexVar.type))))
        def lengthVar := LocalVariable(f.position, "$length", IntType.INT,
                    Variable.Kind.VAR, context.currentMethod)
        context.localVariables.add(lengthVar)
        statements.add(ValueStatement(VariableAssignment(f.position, 
                lengthVar, getMember(f.position, array.createReference(), 
                    "$length")->Value)))
        def typeParams := Array<Type>()
        typeParams.add(elementType)
        def bodyStatements := Array<Statement>()
        def done := BinaryOperation(f.position, 
                BinaryOperation.Kind.GREATER_THAN_OR_EQUAL, 
                    VariableReference(f.position, indexVar),
                    VariableReference(f.position, lengthVar))
        def test := If(f.position, done, Break(f.position), null)
        bodyStatements.add(test)
        bodyStatements.add(ValueStatement(VariableAssignment(f.position,
                valueVars[0], PrimitiveArrayIndexValue(
                        array.createReference(), 
                        VariableReference(f.position, indexVar)).implicitCast(context, valueVars[0].type))))
        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null {
            return null
        }
        bodyStatements.add(bodyStatement)
        def continueStatements := Array<Statement>()
        def plusOne := BinaryOperation(f.position, 
                BinaryOperation.Kind.ADD, VariableReference(f.position,
                        indexVar), IntegerLiteral(f.position, 1, indexVar.type))
        continueStatements.add(ValueStatement(VariableAssignment(
                f.position, indexVar, plusOne, false)))
        def w := LoopWithContinueBlock(f.position, f.label, 
                Block(f.position, bodyStatements), Block(f.position,
                continueStatements))
        statements.add(w)
        return Block(f.position, statements)
    }

    method convertFor(f:ASTFor):Statement? {
        context.pushSymbolTable()
        var list := convertExpression(f.list)
        if list = null {
            return null
        }
        if list-?>UnresolvedRange {
            def range := list->UnresolvedRange
            if range.left != null & range.right != null {
                def result := convertRangeFor(f, list->UnresolvedRange)
                context.popSymbolTable()
                return result
            }
        }
        list := resolve(list)
        if list = null {
            return null
        }
        if list.type.name.startsWith("panda.collections.PrimitiveArray<") |
                list.type.name.startsWith("panda.collections.ImmutablePrimitiveArray<") {
            def result := convertPrimitiveArrayFor(f, list)
            context.popSymbolTable()
            return result
        }
        if list.type.name.startsWith("panda.collections.Iterator<") {
            def result := convertIteratorFor(f, list)
            context.popSymbolTable()
            return result
        }
        def result := convertIterableFor(f, list)
        context.popSymbolTable()
        return result
    }

    method convertLoop(l:ASTLoop):Statement? {
        def statement := convertStatement(l.statement)
        if statement = null {
            return null
        }
        return Loop(l.position, l.label, statement)
    }

    method convertWhile(w:ASTWhile):Statement? {
        var test := resolve(w.test)
        if test = null {
            return null
        }
        test := test.implicitCast(context, BitType.BIT)
        def statement := convertStatement(w.statement)
        if statement = null {
            return null
        }
        return While(w.position, w.label, test, statement)
    }

    method convertDo(d:ASTDo):Statement? {
        var test := resolve(d.test)
        if test = null {
            return null
        }
        test := test.implicitCast(context, BitType.BIT)
        def statement := convertStatement(d.statement)
        if statement = null {
            return null
        }
        return Do(d.position, d.label, test, statement)
    }

    method convertBreak(b:ASTBreak):Statement? {
        return Break(b.position, b.label)
    }

    method convertContinue(c:ASTContinue):Statement? {
        return Continue(c.position, c.label)
    }

    ============================================================================
    As implicitCast, but with the ability to toggle whether we care about 
    signedness. If `signMatters` is false, the signedness is not considered
    important and will not stop a cast that would normally not be allowed.

    Note that the source and destination types are not necessarily integers; if
    not, we ignore the signMatters flag altogether and just perform a normal
    implicitCast.
    ============================================================================
    @private
    method signMattersCast(position:Position, v:Value, t:Type, 
            signMatters:Bit):Value? {
        if !signMatters {
            def srcType := v.type.convert()->PrimitiveType
            if srcType.isInteger & t.isInteger & 
                    srcType->IntType.signed != t->IntType.signed & 
                    srcType.convert()->PrimitiveType.size <= t.convert()->PrimitiveType.size {
                return v.explicitCast(context, t)
            }
        }
        return v.implicitCast(context, t)
    }

    method power(position:Position, left:Value, right:Value):Value? {
        def target := ClassLiteral(position, ClassType.PANDA)
        def params := Array<Value>()
        params.add(left)
        params.add(right)
        return context.call(position, target, "pow", params)
    }
    
    ============================================================================
    Returns `<left> <op> <right>`, where `op` is the type of a token 
    representing a binary operator.
    
    @param node the position, for error reporting purposes
    @param left the left operand
    @param op the token type of a binary operator
    @param right the right operand
    ============================================================================
    method getBinaryValue(position:Position, var left:Value, 
            op:BinaryOperation.Kind, var right:Value):Value? {
        def methodName:String
        switch op {
            case BinaryOperation.Kind.ADD:                   methodName := "+"
            case BinaryOperation.Kind.SUBTRACT:              methodName := "-"
            case BinaryOperation.Kind.MULTIPLY:              methodName := "*"
            case BinaryOperation.Kind.DIVIDE:                methodName := "/"
            case BinaryOperation.Kind.INT_DIVIDE:            methodName := "//"
            case BinaryOperation.Kind.REMAINDER:             methodName := "%"
            case BinaryOperation.Kind.SHIFT_LEFT:            methodName := "<<"
            case BinaryOperation.Kind.SHIFT_RIGHT:           methodName := ">>"
            case BinaryOperation.Kind.AND:                   methodName := "&"
            case BinaryOperation.Kind.OR:                    methodName := "|"
            case BinaryOperation.Kind.XOR:                   methodName := "~"
            case BinaryOperation.Kind.BITWISE_AND:           methodName := "&&"
            case BinaryOperation.Kind.BITWISE_OR:            methodName := "||"
            case BinaryOperation.Kind.BITWISE_XOR:           methodName := "~~"
            case BinaryOperation.Kind.EQUAL:                 methodName := "="
            case BinaryOperation.Kind.NOT_EQUAL:             methodName := "!="
            case BinaryOperation.Kind.IDENTITY:              methodName := "=="
            case BinaryOperation.Kind.NOT_IDENTITY:          methodName := "!=="
            case BinaryOperation.Kind.LESS_THAN:             methodName := "<"
            case BinaryOperation.Kind.GREATER_THAN:          methodName := ">"
            case BinaryOperation.Kind.LESS_THAN_OR_EQUAL:    methodName := "<="
            case BinaryOperation.Kind.GREATER_THAN_OR_EQUAL: methodName := ">="
            case BinaryOperation.Kind.POWER: return power(position, left, right)
            default: assert false : "unsupported binary operator '\{op}'"
        }
        def resolvedLeft := resolve(left)
        if resolvedLeft != null {
            left := resolvedLeft
        }
        else {
            return null 
        }
        def resolvedRight := resolve(right)
        if resolvedRight != null {
            right := resolvedRight
        }
        else {
            return null
        }
        var value := context.callOverloadedOperator(position, methodName, left,
                right)
        if value = null {
            def operandType := BinaryOperation.operandType(context.stubGenerator,
                    op, left, right)
            if operandType = null {
                context.errors.error("'\{methodName}' cannot operate on " +
                        "'\{left.type.displayName}', "+ 
                        "'\{right.type.displayName}'", position)
                return null
            }
            def leftCast := signMattersCast(position, left, operandType, 
                    BinaryOperation.signMatters(op))
            if leftCast != null {
                left := leftCast
            }
            else {
                return null
            }
            def rightCast := signMattersCast(position, right, operandType, 
                    BinaryOperation.signMatters(op))
            if rightCast != null {
                right := rightCast
            }
            else {
                return null
            }
            value := BinaryOperation(position, op, left, right)
        }
        return value
    }

    @class
    method unwrapCast(v:Value):Value {
        if v-?>Cast {
            return unwrapCast(v->Cast.value)
        }
        return v
    }

    @private
    method getSliceAssignmentCall(u:UnresolvedSlice, 
            params:Array<Value>):Value? {
        def name:String
        if u.endInclusive {
            name := "[...]:="
        }
        else {
            name := "[..]:="
        }
        return context.call(u.position, u.contextValue, name, params, 
                VoidType.VOID, false)
    }

    @private
    method getSliceAssignmentCall(u:UnresolvedSlice, v:Value):Value? {
        if u.left = null & u.right = null & u.step = null {
            def params := Array<Value>()
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null {
                return null
            }
        }
        if u.right = null & u.step = null {
            def params := Array<Value>()
            if u.left != null {
                params.add(u.left->Value)
            }
            else {
                params.add(NullLiteral(u.position))
            }
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null {
                return null
            }
        }
        if u.step = null {
            def params := Array<Value>()
            if u.left != null {
                params.add(u.left->Value)
            }
            else {
                params.add(NullLiteral(u.position))
            }
            if u.right != null {
                params.add(u.right->Value)
            }
            else {
                params.add(NullLiteral(u.position))
            }
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null {
                return null
            }
        }
        def params := Array<Value>()
        if u.left != null {
            params.add(u.left->Value)
        }
        else {
            params.add(NullLiteral(u.position))
        }
        if u.right != null {
            params.add(u.right->Value)
        }
        else {
            params.add(NullLiteral(u.position))
        }
        if u.step != null {
            params.add(u.step->Value)
        }
        else {
            params.add(IntegerLiteral(u.position, 1))
        }
        params.add(v)
        return getSliceAssignmentCall(u, params)
    }

    method findAssignmentMethod(target:Value, name:String, 
            params:ListView<Value>):Value? {
        if name = "[..]" | name = "[...]" {
            -- check for reduced argument methods first
            if params.count = 4 & params[2]-?>IntegerLiteral & 
                    params[2]->IntegerLiteral.value = 1 {
                def newParams := Array<Value>()
                newParams.add(params[0])
                newParams.add(params[1])
                newParams.add(params[3])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null {
                    return result
                }
            }
            else if params.count = 3 & params[1]-?>NullLiteral {
                def newParams := Array<Value>()
                newParams.add(params[0])
                newParams.add(params[2])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null {
                    return result
                }
            }
            else if params.count = 2 & params[0]-?>NullLiteral {
                def newParams := Array<Value>()
                newParams.add(params[1])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null {
                    return result
                }
            }
        }
        return context.call(target.position, target, name + ":=", params,
                VoidType.VOID, false)
    }

    function getBinaryOperationKind(name:String):BinaryOperation.Kind {
        switch name {
            case "+":   return BinaryOperation.Kind.ADD
            case "-":   return BinaryOperation.Kind.SUBTRACT
            case "*":   return BinaryOperation.Kind.MULTIPLY
            case "/":   return BinaryOperation.Kind.DIVIDE
            case "//":  return BinaryOperation.Kind.INT_DIVIDE
            case "%":   return BinaryOperation.Kind.REMAINDER
            case "<<":  return BinaryOperation.Kind.SHIFT_LEFT
            case ">>":  return BinaryOperation.Kind.SHIFT_RIGHT
            case "&":   return BinaryOperation.Kind.AND
            case "|":   return BinaryOperation.Kind.OR
            case "~":   return BinaryOperation.Kind.XOR
            case "&&":  return BinaryOperation.Kind.BITWISE_AND
            case "||":  return BinaryOperation.Kind.BITWISE_OR
            case "~~":  return BinaryOperation.Kind.BITWISE_XOR
            case "=":   return BinaryOperation.Kind.EQUAL
            case "!=":  return BinaryOperation.Kind.NOT_EQUAL
            case "==":  return BinaryOperation.Kind.IDENTITY
            case "!==": return BinaryOperation.Kind.NOT_IDENTITY
            case "<":   return BinaryOperation.Kind.LESS_THAN
            case ">":   return BinaryOperation.Kind.GREATER_THAN
            case "<=":  return BinaryOperation.Kind.LESS_THAN_OR_EQUAL
            case ">=":  return BinaryOperation.Kind.GREATER_THAN_OR_EQUAL
            case "^":   return BinaryOperation.Kind.POWER
            default: unreachable
        }
    }

    function unwrapBinary(var v:Value):(Value, BinaryOperation.Kind, Value) {
        v := unwrapCast(v)
        if v-?>BinaryOperation {
            def b := v->BinaryOperation
            return (b.left, b.kind, b.right)
        }
        assert v-?>MethodCall : "expected MethodCall at \{v.position}, but found \{v}:\{v.class.name}"
        def m := v->MethodCall
        def op := getBinaryOperationKind(m.methodStub.name)
        def left:Value
        if m.methodStub.annotations.isClass {
            left := m.parameters[0]
        }
        else {
            left := m.target
        }
        def right := m.parameters[m.parameters.count - 1]
        return (left, op, right)
    }

    -- FIXME refactoring required! I did this all wrong and dumb. When I first
    -- started working on Panda, all lvalues were also rvalues. Then one
    -- situation crept in where the two weren't exactly the same, so I hacked it
    -- a bit to get it working. Then another cropped up, and another, and slowly
    -- this nice simple method turned into this hellish monstrosity. It needs to
    -- be killed with extreme prejudice, and I apologize to anyone reading this
    -- code. It just built up a bit at a time until it was completely out of
    -- control.
    --
    -- The basic idea is that (due to the original simplicity) the processing
    -- originally just figured out the rvalue on the left side of the assignment
    -- operator, ran into an assignment operator, made sure the rvalue worked as
    -- an lvalue, and continued on its merry way. Since then, this has gotten so 
    -- hellishly complicated that it absolutely needs to be rewritten so as to 
    -- know up front to be looking for an lvalue, so we can eliminate all of 
    -- these special cases and cut this at least in half.
    --
    -- UPDATE:
    -- Oh god I made it even worse. It's so awful. Please don't judge me by this
    -- method, I'm better than this, I swear :-(
    --
    -- FURTHER UPDATE:
    -- Actually, I don't think the refactoring is as simple as I outlined. I 
    -- hadn't considered the complexities introduced by compound assignment. We
    -- can't just process the assignment target twice (once in "lvalue mode" and
    -- once in "rvalue mode"), because that would involve duplicate evaluations
    -- of things that are only supposed to be evaluated once. It can certainly
    -- be done simpler than it's being done, but I don't think it's possible to
    -- eliminate quite as much complexity as I had hoped.
    method processSingleAssignment(var left:Value, right:Value, 
            reuse:Bit):Statement? {
        if left-?>UnresolvedIndex {
            def index := left->UnresolvedIndex
            def params := Array<Value>()
            params.add(index.index)
            params.add(right)
            def call := context.call(index.position, index.contextValue, 
                    "[]:=", params, VoidType.VOID, false)
            if call != null {
                return ValueStatement(call)
            }
            context.errors.error("'\{index.contextValue.type.displayName}' " +
                    "does not define the '[]:=' operator for " +
                    "'\{index.index.type.displayName}', " +
                    "'\{right.type.displayName}'", index.index.position)
            return null
        }
        else if left-?>UnresolvedSlice {
            def slice := left->UnresolvedSlice
            def call := getSliceAssignmentCall(slice, right)
            if call != null {
                return ValueStatement(call)
            }
            def name:String
            if slice.endInclusive {
                name := "'[...]:=' (inclusive slice assignment)"
            }
            else {
                name := "'[..]:=' (exclusive slice assignment)"
            }
            def types := Array<String>()
            if slice.left != null {
                types.add(slice.left->Value.type.displayName)
            }
            else {
                types.add("null")
            }
            if slice.right != null {
                types.add(slice.right->Value.type.displayName)
            }
            else {
                types.add("null")
            }
            if slice.step != null {
                types.add(slice.step->Value.type.displayName)
            }
            else {
                types.add("null")
            }
            types.add(right.type.displayName)
            context.errors.error("'\{slice.contextValue.type.displayName}' " +
                    "does not define the \{name} operator for \{types}",
                    right.position)
            return null
        }
        else if left-?>PropertyGet {
            def p := left->PropertyGet
            def setName := String.format(SET_PATTERN, p.field.name)
            return ValueStatement(context.call(p.position, p.object, setName, 
                    [right], null, true))
        }

        var resolvedLeft := resolve(left)
        if resolvedLeft = null {
            return null
        }
        resolvedLeft := unwrapCast(resolvedLeft)
-*        if left-?>Unresolved {
            -- could be an assignment method
            var contextValue := left->Unresolved.contextValue
            def name := left->Unresolved.name
            if contextValue = null {
                if context.isInstance
                    contextValue := implicitSelf(left.position)
                else {
                    -- we're in a class context, so there can't possibly be an
                    -- assignment method. Go ahead and report the error.
                    return null
                }
            }
            def call := callAssignmentMethod(contextValue, name, 
                    PrimitiveArray<Value>(right))
            if call != null
                currentNode.add(call)
            else {
                -- no assignment method, trigger the exception
                resolve(left)
            }
        }
        else if left-?>AmbiguousReference {
            var a := left->AmbiguousReference
            var object := a.context
            if reuse {
                def reusable := makeReusable(object)
                reusable.replace(reusable.createReference())
                currentNode.add(ValueStatement(reusable))
                object := reusable.createReference()
            }
            checkAssignment(a.field, a.position)
            open(FieldAssignment(left.position, object, a.field))
            currentNode.add(implicitCast(right.position, right, a.type))
            close(FieldAssignment)
        } *-
        if resolvedLeft-?>VariableReference {
            def variable := resolvedLeft->VariableReference.variable
            def cast := right.implicitCast(context, variable.type)
            def assignment := VariableAssignment(left.position,
                    variable, cast)
            return ValueStatement(assignment)
        }
        else if resolvedLeft-?>FieldReference {
            def fv := resolvedLeft->FieldReference
            def object:Value
            def finalRight:Value
            if reuse & fv.object-!>ClassLiteral {
                def oldLeft, oldOp, oldRight := unwrapBinary(right)
                object := ReusedValueDefinition(fv.object)
                def newRight := getBinaryValue(right.position,
                        FieldReference(right.position, object, fv.field), oldOp, 
                        oldRight)
                def cast := newRight.implicitCast(context, fv.field.type)
                finalRight := cast
            }
            else {
                object := fv.object
                finalRight := right.implicitCast(context, fv.field.type)
            }
            def name := fv.field.name
            return FieldAssignment(fv.position, object, fv.field,
                    finalRight)
        }
        else if resolvedLeft-?>PrimitiveArrayIndexValue {
            def iv := left->PrimitiveArrayIndexValue
            if reuse {
                def oldLeft, oldOp, oldRight := unwrapBinary(right)
                def array := ReusedValueDefinition(iv.array)
                def index := ReusedValueDefinition(iv.index)
                def newRight := getBinaryValue(right.position, 
                        PrimitiveArrayIndexValue(array, index), oldOp, oldRight)
                def cast := newRight.implicitCast(context,
                        array.type.convert()->PrimitiveArrayType.elementType)
                return PrimitiveArrayIndexAssignment(left.position,
                        array.createReference(), index.createReference(), cast)
            }
            else {
                def array := iv.array
                def index := iv.index
                def cast := right.implicitCast(context,
                        array.type.convert()->PrimitiveArrayType.elementType)
                return PrimitiveArrayIndexAssignment(left.position, 
                        array, index, cast)
            }
        }
        else if left-?>MethodCall {
            -- assigning to a method call. We need to look for a corresponding
            -- assignment method / field.
            def mc := left->MethodCall
            def methodStub := mc.methodStub
            if !methodStub.annotations.isClass & (mc.parameters.count = 0 | 
                    methodStub.name = "[]" | methodStub.name = "[..]" |
                    methodStub.name = "[...]") {
                def oldParams := mc.parameters
                def testParams := Array<Value>(oldParams)
                -- undo implicit casts that happened as part of setting up the
                -- original method call
                for (i, p) in testParams.enumeration {
                    testParams[i] := unwrapCast(p)
                }
                if methodStub.name = "[..]" | methodStub.name = "[...]" {
                    -- restore parameters that might have been stripped when we
                    -- matched the initial slice. Such a hack, I'm so sorry.
                    if testParams.count = 0 {
                        testParams.add(NullLiteral(left.position))
                    }
                    if testParams.count = 1 {
                        testParams.add(NullLiteral(left.position))
                    }
                    if testParams.count = 2 {
                        testParams.add(IntegerLiteral(left.position, 1))
                    }
                }
                testParams.add(right)
                def target := unwrapCast(mc.target)
                def result := findAssignmentMethod(target, methodStub.name, 
                        testParams)
                if result != null {
                    return ValueStatement(result)
                }
                else {
                    -- no assignment method
                    if methodStub.name = "[]" {
                        def types := Array<String>()
                        for p in testParams {
                            types.add(p.type.displayName)
                        }
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the indexed assignment ([]:=) " +
                                "operator for \{types}", mc.position)
                    }
                    else if methodStub.name = "[..]" {
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the exclusive slice assignment ([..]:=) " +
                                "operator for these types", mc.position)
                    }
                    else if methodStub.name = "[...]" {
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the inclusive slice assignment ([...]:=) " +
                                "operator for these types", mc.position)
                    }
                    else {
                        context.errors.error("cannot assign to '\{left}'", 
                                left.position)
                    }
                }
            }
            else {
                context.errors.error("cannot assign to '\{left}'", 
                        left.position)
            }
        }
        else {
            context.errors.error("cannot assign to '\{left}'", left.position)
        }
        return null
    }

    method processAssignment(position:Position, var left:ListView<Value?>, 
            assignmentOp:BinaryOperation.Kind?, var right:Value):Statement? {
        def cm := context.currentMethod
        def reuse:Bit
        if assignmentOp = null {
            reuse := false
        }
        else {
            reuse := true
            if left.count > 1 {
                context.errors.error("compound assignment cannot " +
                        " assign to multiple values at once", 
                        position)
                return null
            }
            var lvalue := left[0]
            if lvalue = null {
                context.errors.error("'_' is only permitted in " +
                        "multiple assignments from a tuple", 
                        position)
                return null
            }
            def finalRight := getBinaryValue(position, lvalue, assignmentOp, 
                    right)
            if finalRight = null {
                return null
            }
            right := finalRight
            -- deal with situations like int8 += 1 (which resolves into
            -- int8 := int8 + 1, and the right side promotes to an Int32, so we
            -- need to downcast)
            def resolved := resolve(lvalue)->Value
            if right.type.isInteger & resolved.type.isInteger {
                right := right.explicitCast(context, resolved.type)
            }
            def newLeft := Array<Value?>()
            newLeft.add(lvalue)
            left := newLeft
        }

        if left.count > 1 {
            def result := Array<Statement>()
            def types := Array<Type>()
            for l in left {
                types.add(l.preferredType(context))
            }
            def type := TupleType(types)
            right := right.implicitCast(context, type)
            def reused := ReusedValueDefinition(right)
            result.add(ValueStatement(reused))
            for (i, lvalue) in left.enumeration {
                if lvalue != null {
                    def tupleValue := getMember(right.position, 
                            reused.createReference(), 
                            TupleType.FIELD_PREFIX + i)
                    assert tupleValue != null : "can't-happen tuple failure"
                    def assignment := processSingleAssignment(lvalue, 
                            tupleValue, reuse)
                    if assignment = null {
                        return null
                    }
                    result.add(assignment)
                }
            }
            return Block(position, result)
        }
        else {
            def lvalue := left[0]
            assert lvalue != null : "singleAssignment missing lvalue"
            return processSingleAssignment(lvalue, right, reuse)
        }
    }

    method convertAssignment(a:ASTAssignment):Statement? {
        def lvalues := Array<Value?>()
        for lvalue in a.lvalues {
            def converted := convertExpression(lvalue)
            if converted = null {
                return null
            }
            lvalues.add(converted)
        }
        def rvalue := convertExpression(a.rvalue)
        if rvalue = null {
            return null
        }
        return processAssignment(a.position, lvalues, a.operator, rvalue)
    }

    method convertReturn(r:ASTReturn):Statement? {
        if r.value = null {
            if context.currentMethod.returnType != VoidType.VOID {
                context.errors.error("return expected a value of type '" +
                        context.currentMethod.returnType.displayName + "'", 
                        r.position)
            }
            return Return(r.position)
        }
        if context.currentMethod.returnType = VoidType.VOID {
            context.errors.error("cannot return a value in a method with no " +
                    "return type", r.position)
            return null
        }
        def converted := convertExpression(r.value->ASTExpression)
        if converted = null {
            return null
        }
        def cast := converted.implicitCast(context, 
                context.currentMethod.returnType)
        return Return(r.position, cast)
    }

    method convertAssert(a:ASTAssert):Statement? {
        def test := resolve(a.test->ASTExpression)
        if test = null {
            return null
        }
        def error:Value?
        if a.error != null {
            def resolved := resolve(a.error->ASTExpression)
            if resolved = null {
                return null
            }
            if resolved.canImplicitCastTo(context, ClassType.STRING) {
                error := resolved.implicitCast(context, ClassType.STRING)
            }
            else {
                error := resolved.implicitCast(context, ClassType.ERROR)
            }
        }
        else {
            error := null
        }
        return Assert(a.position, test.implicitCast(context, BitType.BIT),
                error)
    }

    method convertUnreachable(u:ASTUnreachable):Statement? {
        def error:Value?
        if u.error != null {
            error := resolve(u.error)
        }
        else {
            error := null
        }
        return Unreachable(u.position, error)
    }

    method convertStatement(s:ASTStatement):Statement? {
        switch s.class {
            case ASTExpressionStatement:
                def expr := resolve(s->ASTExpressionStatement.expression)
                if expr != null {
                    return ValueStatement(expr)
                }
                return null
            case ASTIf:
                return convertIf(s->ASTIf)
            case ASTFor:
                return convertFor(s->ASTFor)
            case ASTLoop:
                return convertLoop(s->ASTLoop)
            case ASTWhile:
                return convertWhile(s->ASTWhile)
            case ASTDo:
                return convertDo(s->ASTDo)
            case ASTSwitch:
                return convertSwitch(s->ASTSwitch)
            case ASTBreak:
                return convertBreak(s->ASTBreak)
            case ASTContinue:
                return convertContinue(s->ASTContinue)
            case ASTVarDeclaration: 
                return convertVarDeclaration(s->ASTVarDeclaration)
            case ASTAssignment:
                return convertAssignment(s->ASTAssignment)
            case ASTReturn:
                return convertReturn(s->ASTReturn)
            case ASTBlock:
                return convertBlock(s->ASTBlock)
            case ASTTry:
                return convertTry(s->ASTTry)
            case ASTThrow:
                return convertThrow(s->ASTThrow)
            case ASTAssert:
                return convertAssert(s->ASTAssert)
            case ASTUnreachable:
                return convertUnreachable(s->ASTUnreachable)
            default:
                throw InternalCompilerException("unsupported statement: " +
                        s.class.name, s.position)
        }
    }

    method convertBlock(b:ASTBlock):Block {
        context.pushSymbolTable()
        def statements := Array<Statement>()
        for s in b.statements {
            def converted := convertStatement(s)
            if converted != null {
                statements.add(converted)
            }
        }
        context.popSymbolTable()
        return Block(b.position, statements)
    }

    method convertCatch(c:ASTCatch):Catch? {
        def type := resolve(c.type)
        if type = null {
            return null
        }
        context.getStub(type.convert()->ClassType)
        def error := LocalVariable(c.position, c.name, type, 
                Variable.Kind.DEF, context.currentMethod)
        context.localVariables.add(error)
        context.pushSymbolTable()
        context.symbolTable.add(error)
        def statement := convertStatement(c.statement)
        context.popSymbolTable()
        if statement = null {
            return null
        }
        return Catch(c.position, error, statement)
    }

    method convertTry(t:ASTTry):Try? {
        def statement := convertStatement(t.statement)
        if statement = null {
            return null
        }
        def catches := Array<Catch>()
        for astCatch in t.catches {
            def c := convertCatch(astCatch)
            if c != null {
                catches.add(c)
            }
        }
        return Try(t.position, statement, catches)
    }

    method convertThrow(t:ASTThrow):Statement? {
        def error := resolve(t.error)
        if error = null {
            return null
        }
        return Throw(t.position, error.implicitCast(context, 
                ClassType.ERROR))
    }

    class ASTWrappedType : ASTType {
        def type:Type

        init(position:Position, type:Type) {
            super.init(position, false)
            self.type := type
        }

        @override
        function convert():String {
            return type.convert()
        }
    }

    @class
    function toASTType(position:Position, var t:Type):ASTType? {
        return ASTWrappedType(position, t)
    }

    method convertLambda(l:ASTLambdaExpression):Value? {
        def allTyped := l.parameters.filter(p => p.type = null).count = 0
        def value:Value?
        if allTyped {
            context.pushSymbolTable()
            def parameters := Array<ASTParameter>()
            for p in l.parameters {
                parameters.add(ASTParameter(p.position, p.identifier, 
                        p.type->ASTType, false, false))
                def type := resolve(p.type->ASTType)
                if type = null {
                    return null
                }
                context.symbolTable.add(LocalVariable(
                        p.position, p.identifier, type, Variable.Kind.DEF,
                        context.currentMethod))
            }
            def ir := IRGenerator(context.root, context.stubGenerator.stubs,
                    context.stubGenerator, context.compilerSettings,
                    context.errors)
            ir.context.currentClass := context.currentClass
            ir.context.currentMethod := context.currentMethod
            ir.context.pushSymbolTable(context.symbolTable)
            ir.context.pushSymbolTable()
            ir.context.symbolTable.addAll(context.symbolTable.mySymbols)
            def expr := ir.resolve(l.value)
            if expr = null {
                return null
            }
            context.popSymbolTable()
            var returnType := expr.type
            if returnType = VoidType.VOID {
                context.errors.error("lambda must return a value",
                        expr.position)
                return null
            }
            if returnType = StringOrCharType.STRING_OR_CHAR {
                returnType := CharType.CHAR
            }
            def statements := Array<ASTStatement>()
            statements.add(ASTReturn(l.position, l.value))
            def body := ASTBlock(l.position, statements)
            def methodValue := ASTMethodValue(l.position, 
                    MethodStub.Kind.FUNCTION, parameters, 
                    toASTType(l.position, returnType), body)
            value := convertMethodValue(methodValue)
        }
        else {
            value := null
        }
        def names := Array<String>()
        def types := Array<Type?>()
        for p in l.parameters {
            names.add(p.identifier)
            if p.type != null {
                def resolved := resolve(p.type)
                if resolved = null {
                    return null
                }
                types.add(resolved)
            }
            else {
                types.add(null)
            }
        }
        return UnresolvedLambda(context, l.position, names, types, l.value,
                value)
    }

    function methodNames():ListView<String> {
        def result := Array<String>()
        for m in context.methods {
            result.add(m.stub.name)
        }
        return result
    }

    function createClosureInitAndFields(position:Position,
            captures:CollectionView<Variable>, 
            owner:ClassType):(MethodStub, ListView<FieldNode>) {
        def parameters := Array<FormalParameter>()
        def fields := Array<FieldNode>()
        for v in captures {
            parameters.add(FormalParameter(position, v.name, v.type, false, 
                    false))
            fields.add(FieldNode(position, owner, v.name, 
                    Annotations(position), Variable.Kind.DEF, v.type, null,
                    null))
        }
        def body := Array<ASTStatement>()
        for (i, field) in fields.enumeration {
            def lvalues := Array<ASTExpression>()
            lvalues.add(ASTDotExpression(ASTIdentifier(position, 
                    Parameter.SELF_NAME), field.name))
            body.add(ASTAssignment(lvalues, null,
                    ASTIdentifier(position, field.name)))
        }
        def stub := MethodStub(position, MethodNode.INIT_NAME, 
                Annotations(position), MethodStub.Kind.INIT, parameters, null, 
                VoidType.VOID, ASTBlock(position, body), owner)
        return (stub, fields)
    }

    method convertMethodValue(m:ASTMethodValue):Value? {
        def className := context.currentClass.name + "$closure" + nameCount
        nameCount += 1
        def closureType := ClassType(className)
        def oldLocals := Array<LocalVariable>(context.localVariables)
        context.localVariables.clear()
        def lastMethod := context.currentMethod
        def formalParameters := Array<FormalParameter>()
        for p in m.parameters {
            def type := resolve(p.type)
            if type = null {
                return null
            }
            formalParameters.add(FormalParameter(p.position, p.name, type, 
                    p.isVar, p.isVarArg))
        }
        def returnType:Type?
        if m.returnType != null {
            returnType := resolve(m.returnType->ASTType)
            if returnType = null {
                return null
            }
        }
        else {
            returnType := VoidType.VOID
        }
        def stub := MethodStub(m.position, MethodNode.CLOSURE_NAME, 
                Annotations(m.position), m.kind, formalParameters, null,
                returnType, m.body, closureType)
        context.currentMethod := stub
        context.pushSymbolTable()
        def parameters := Array<Parameter>()
        for formal in m.parameters {
            def type := resolve(formal.type)
            if type = null {
                context.currentMethod := lastMethod
                return null
            }
            def p := Parameter(formal.position, formal.name, type, 
                    formal.isVar, formal.isVarArg, stub)
            parameters.add(p)
            context.symbolTable.add(p)
        }
        if !lastMethod.annotations.isClass {
            var selfType := lastMethod.owner
            def index := selfType.name.indexOf("$closure")
            if index != null {
                selfType := resolveClass(m.position, selfType.name[..index])->ClassLiteral.value
            }
            def selfParam := Parameter(m.position, "$" + Parameter.SELF_NAME,
                    selfType, false, false, stub)
            context.symbolTable.add(selfParam)
        }
        context.captures.push((stub, HashSet<Variable>()))
        -- need to convertBlock in order to grab captures
        def oldAdd := addMethods
        addMethods := false
        def oldInClosure := context.inClosure
        context.inClosure := true
        convertBlock(m.body->ASTBlock)
        context.inClosure := oldInClosure
        def captures := context.captures.peek()[1]
        addMethods := oldAdd
        def closureSymbols := OrderedMap<String, Symbol>()
        def closureInit, closureFields := createClosureInitAndFields(
                m.position, captures, closureType)
        closureSymbols[stub.name] := Methods(stub)
        closureSymbols[closureInit.name] := Methods(closureInit)
        for f in closureFields {
            closureSymbols[f.name] := f
        }
        def lookupContext := context.currentClass.lookupContext
        def superclass := ClassType.METHOD
        def closureStub := ClassStub(m.position, closureType, 
                ClassStub.Kind.CLASS, Annotations(m.position, 
                    [Annotations.Kind.SYNTHETIC]), 
                superclass, Array<ClassType>(), closureSymbols, lookupContext,
                Array<ASTInvariant>(), null, false, 
                context.currentClass.type)
        if addMethods {
            context.stubGenerator.stubs[closureStub.name] := closureStub
        }
        context.popSymbolTable()
        context.localVariables.clear()
        context.localVariables.addAll(oldLocals)
        context.currentMethod := lastMethod
        def initParameters := Array<Value>()
        for v in captures {
            if v.name = "$" + Parameter.SELF_NAME {
                initParameters.add(convertSelf(ASTSelf(m.position)))
            }
            else if v-?>FieldNode {
                def f := v->FieldNode
                initParameters.add(FieldReference(m.position, 
                        VariableReference(m.position, context.symbolTable[
                            Parameter.SELF_NAME]->Variable),
                        f))
            }
            else {
                initParameters.add(VariableReference(m.position, v))
            }
        }
        def closureInstance := Construct(MethodCall(m.position, 
                ClassLiteral(m.position, closureType), 
                closureInit, initParameters))
        context.liveMethods.add(closureInit)
        context.captures.pop()
        return Closure(m.position, closureInstance, stub.type)
    }

    function callsOtherSelfInit(owner:ClassType,
            statements:ListView<Statement>):Bit {
        if statements.count > 0 {
            if statements[0]-?>ValueStatement {
                var value := statements[0]->ValueStatement.value
                if value-?>MethodCall {
                    var call := value->MethodCall
                    if call.methodStub.kind = MethodStub.Kind.INIT {
                        return call.methodStub.owner = owner
                    }
                }
            }
        }
        return false
    }
    
    function callsSuperInit(owner:ClassType,
            statements:ListView<Statement>):Bit {
        if statements.count > 0 {
            if statements[0]-?>ValueStatement {
                var value := statements[0]->ValueStatement.value
                if value-?>MethodCall {
                    var call := value->MethodCall
                    if call.methodStub.kind = MethodStub.Kind.INIT {
                        return call.target.type != owner
                    }
                }
            }
        }
        return false
    }   

    function isClosureMethod(m:MethodStub):Bit {
        return m.kind != MethodStub.Kind.INIT & 
                m.owner.name.contains("$closure")
    }

    method convertMethod(m:MethodStub):MethodNode {
        if m.name = MethodNode.MAIN_NAME | (context.compilerSettings.isLibrary &
                !m.annotations.isPrivate) {
            context.liveMethods.add(m)
        }
        context.localVariables.clear()
        context.currentMethod := m
        context.pushSymbolTable()
        def parameters := Array<Parameter>()
        for formal in m.parameters {
            def p := Parameter(formal.position, formal.name, formal.type, 
                    formal.isVar, formal.isVarArg, context.currentMethod)
            parameters.add(p)
            context.symbolTable.add(p)
        }
        if isClosureMethod(m) {
            def selfParam := context.symbolTable["$self"]
            if selfParam != null {
                context.symbolTable.add(Parameter.SELF_NAME, selfParam)
            }
        }
        if !m.annotations.isClass {
            def selfType:Type
            if m.annotations.isWrapperMethod {
                selfType := m.owner.convert()->PrimitiveType
            }
            else {
                if context.currentClass.isUnspecialized {
                    def types := Array<Type>()
                    for (name, bound) in 
                            context.currentClass.genericParameters! {
                        def finalBound:Type
                        if bound != null {
                            finalBound := bound
                        }
                        else {
                            finalBound := NullableType.ANY
                        }
                        types.add(GenericParameterType(m.owner.name + "." + 
                                name, finalBound))
                    }
                    selfType := GenericType(m.owner, types)
                }
                else {
                    selfType := context.currentClass.type
                }
            }
            def selfParam := Parameter(m.position, Parameter.SELF_NAME,
                    selfType, false, false, context.currentMethod)
            context.symbolTable.add(selfParam)
        }
        var body := convertBlock(m.body->ASTBlock)
        if m.kind = MethodStub.Kind.INIT {
            def callsOther := callsOtherSelfInit(m.owner, 
                    body.statements)
            def callsSuper := callsSuperInit(m.owner, body.statements)
            if !callsOther {
                def reusedTuples := HashMap<Value, ReusedValueDefinition>()
                def initializers := HashMap<ASTExpression, Value>()
                def statements := Array<Statement>()
                for f in context.currentClass.fields {
                    if !f.annotations.isClass & !f.annotations.isThread {
                        if f.initialValue != null {
                            var initialValue := initializers[f.initialValue]
                            if initialValue = null {
                                initialValue := convertExpression(
                                        f.initialValue)
                                initializers[f.initialValue] := initialValue
                            }
                            if initialValue != null {
                                if f.tuplePosition != null {
                                    var reused := reusedTuples[initialValue]
                                    def reference:Value
                                    if reused = null {
                                        def resolved := resolve(initialValue)
                                        if resolved = null {
                                            break
                                        }
                                        reused := ReusedValueDefinition(
                                                initialValue)
                                        reusedTuples[initialValue] := reused
                                        reference := reused
                                    }
                                    else {
                                        reference := reused.createReference()
                                    }
                                    initialValue := getMember(f.position, 
                                            reference, 
                                            TupleType.FIELD_PREFIX + 
                                                f.tuplePosition)
                                }
                                statements.add(FieldAssignment(f.position,
                                        implicitSelf(f.position), f,
                                        initialValue.implicitCast(context, 
                                            f.type)))
                            }
                        }
                    }
                }
                statements.addAll(body.statements)
                body := Block(body.position, statements)
            }
            if !callsOther & !callsSuper & m.owner != ClassType.OBJECT {
                def statements := Array<Statement>()
                def superCall := context.call(m.position, 
                        Super(m.position, m.owner),
                        MethodNode.INIT_NAME, 
                        Array<Value>())
                if superCall != null {
                    statements.add(ValueStatement(superCall))
                }
                statements.addAll(body.statements)
                body := Block(body.position, statements)
            }
        }
        def result := MethodNode(m, body, parameters, 
                context.localVariables)
        context.popSymbolTable()
        return result
    }

    method pushSymbols(cl:ClassType) {
        context.currentClass := context.getStub(cl)
        context.pushSymbolTable(context.getSymbolTable(cl))
    }

    method checkProperties(cl:ClassStub) {
        def properties := cl.fields.filter(
                f => f.kind = Variable.Kind.PROPERTY)
        def methods := cl.methods
        for p in properties {
            def getName := String.format(GET_PATTERN, p.name)
            def getters := methods.filter(m => m.name = getName)
            if getters.count > 1 {
                def error := MutableString("expected only one '\{getName}' " +
                        "method, but found:")
                for g in getters {
                    error.append("\n    \{g}")
                }
                context.errors.error(error.convert(), cl.position)
            }
            if getters.count = 1 {
                def getter := getters.iterator.next()
                if getter.kind != MethodStub.Kind.FUNCTION {
                    context.errors.error("property getters must be functions",
                            getter.position)
                }
                if getter.parameters.count > 0 {
                    context.errors.error("property getters must take zero " +
                            "parameters", getter.position)
                }
                if getter.returnType != p.type {
                    context.errors.error("property '\{p.name}' has type " +
                            "'\{p.type.displayName}', but " +
                            "'\{getter.name}' returns " +
                            "'\{getter.returnType.displayName}'", 
                            getter.position)
                }
            }
            def setName := String.format(SET_PATTERN, p.name)
            def setters := methods.filter(m => m.name = setName)
            if setters.count > 1 {
                def error := MutableString("expected only one '\{setName}' " +
                        "method, but found:")
                for s in setters {
                    error.append("\n    \{s}")
                }
                context.errors.error(error.convert(), cl.position)
            }
            if setters.count = 1 {
                def setter := setters.iterator.next()
                if setter.parameters.count = 1 {
                    def type := setter.parameters[0].type
                    if type != p.type {
                        context.errors.error("property '\{p.name}' has type " +
                            "'\{p.type.displayName}', but " +
                            "'\{setter.name}' accepts '\{type.displayName}'", 
                            setter.position)
                    }
                }
                else {
                    context.errors.error("property setters must take one " +
                            "parameter", setter.position)
                }
                if setter.returnType != VoidType.VOID {
                    context.errors.error("property setters may not have a " +
                            "return type", setter.position)

                }
            }
            if getters.count = 0 & setters.count = 0 {
                context.errors.error("property '\{p.name}' has neither a " +
                        "getter nor a setter", p.position)
            }
        }
    }

    method convertClass(cl:ClassStub):ClassNode {
        context.methods.clear()
        pushSymbols(cl.type)
        checkProperties(cl)
        cl.fields.apply(inferFieldType)
        for m in cl.methods.filter(m => m.body != null) {
            if cl.annotations.isUnspecified & !m.annotations.isClass {
                continue
            }
            context.methods.add(convertMethod(m))
        }
        context.popSymbolTable()
        if cl.kind != ClassStub.Kind.INTERFACE & 
                !cl.annotations.isAbstract {
            for m in cl.type.virtualMethods(context) {
                if m.annotations.isAbstract {
                    context.errors.error("non-abstract class '\{cl.name}' " +
                            "does not implement abstract \{m}", cl.position)
                }
            }
        }
        return ClassNode(cl, context.methods)
    }

    method inferFieldType(f:FieldNode) {
        if f.type-!>UnresolvedType {
            return
        }
        if f.initialValue = null {
            context.errors.error("field '\{f.name}' has neither an explicit " +
                    "type nor an initial value", f.position)
            f.type := VoidType.VOID
            return
        }
        if currentlyInferring.contains(f) {
            def msg := MutableString("unable to resolve field types due " +
                    "to a circular dependency involving:")
            for msgField in currentlyInferring {
                msg.append("\n    '\{msgField.name}': \{msgField.position}")
            }
            context.errors.error(msg.convert(), f.position)
            f.type := VoidType.VOID
            return
        }
        currentlyInferring.add(f)
        def old := context.currentClass
        pushSymbols(f.owner)
        context.pushSymbolTable()
        if !f.annotations.isClass & !f.annotations.isThread {
            def selfParam := Parameter(f.position, Parameter.SELF_NAME,
                    f.owner, false, false, context.currentMethod)
            context.symbolTable.add(selfParam)
        }
        def expr := convertExpression(f.initialValue->ASTExpression)
        context.popSymbolTable()
        context.popSymbolTable()
        context.currentClass := old
        if expr != null {
            if expr.checkValid(context) {
                def immutable := f.kind = Variable.Kind.CONSTANT | 
                        f.owner.isImmutable(context.stubGenerator)
                def type := expr.preferredVariableType(context, immutable)
                if f.tuplePosition = null {
                    f.type := type
                }
                else {
                    if type.isTuple {
                        def tupleType := type.convert()->TupleType
                        if f.tuplePosition < tupleType.types.count {
                            f.type := tupleType.types[f.tuplePosition]
                        }
                        else {
                            context.errors.error("tuple length mismatch in " +
                                    "destructuring assignment", expr.position)
                        }
                    }
                    else {
                        context.errors.error("expected tuple for " +
                                "destructuring assignment, but found " +
                                "'\{type.unwrapNullable}'", expr.position)
                    }
                }
            }
        }
        else {
            f.type := VoidType.VOID
        }
        currentlyInferring.remove(f)
    }

    method createStub(t:Type) {
        if !t.isPrimitive & t != VoidType.VOID & 
                t != NativePointerType.NATIVE_POINTER {
            context.getStub(t.convert()->ClassType)
        }
    }

    @private
    method createAllStubs() {
        def types := HashMap<String, Type>(context.stubGenerator.types)
        for (_, cl) in types {
            if cl-?>ClassType & cl-!>GenericParameterType {
                def astClass := context.stubGenerator.astClasses[cl.name]
                if astClass != null {
                    if !astClass[0].isExternal {
                        createStub(cl->ClassType)  
                    }
                } 
                else {
                    def astChoice := context.stubGenerator.astChoices[cl.name]
                    if astChoice != null & !astChoice[0].isExternal {
                        createStub(cl->ClassType)  
                    }
                }
            }
        }
        createStub(ClassType.OBJECT)
        createStub(ClassType.CLASS)
        createStub(ClassType.METHOD)
        var progress:Bit
        def checked := HashSet<ClassStub>()
        do {
            progress := false
            def classes := HashMap<String, ClassStub>(
                    context.stubGenerator.stubs)
            for (_, cl) in classes {
                if checked.contains(cl) {
                    continue
                }
                checked.add(cl)
                progress := true
                if cl.annotations.isUnspecified | cl.annotations.isExternal {
                    continue
                }
                for f in cl.fields {
                    inferFieldType(f)
                    createStub(f.type)
                }
                for m in cl.methods {
                    for p in m.parameters {
                        createStub(p.type)
                    }
                    createStub(m.returnType)
                }
                def sc := cl.superclass
                if sc != null {
                    createStub(sc)
                }
                for intf in cl.interfaces {
                    createStub(intf)
                }
            }
        }
        while progress
    }

    method addClass(cl:ClassStub, root:MutablePackage) {
        if cl.containingClass != null {
            return
        }
        var currentPackage := root
        def components := cl.name.split(".")
        def currentName := MutableString()
        for (i, c) in components.enumeration {
            if i > 0 {
                currentName.append(".")
            }
            currentName.append(c)
            if i < components.count - 1 {
                var next := currentPackage[c]
                if next = null {
                    next := MutablePackage(currentName.convert())
                    currentPackage[c] := next
                }
                else if next-!>MutablePackage {
                    unreachable
                }
                currentPackage := next->MutablePackage
            }
            else {
                if currentPackage[c] = null {
                    currentPackage[c] := TypeSymbol(cl.type)
                }
            }
        }
    }

    @class
    function getThreadLocalInitializerName(f:FieldNode):String {
        return "$init\{f.name}"
    }

    method createThreadLocalInitializers() {
        for cl in context.stubGenerator.stubs.values {
            for f in cl.fields.filter(f => f.annotations.isThread) {
                inferFieldType(f)
                def name := getThreadLocalInitializerName(f)
                if cl.symbols[name] != null {
                    continue
                }
                context.stubGenerator.symbolTables.remove(cl.type)
                def body := Array<ASTStatement>()
                body.add(ASTReturn(f.position, f.initialValue))
                def m := MethodStub(f.position, 
                        name, Annotations(f.position, [Annotations.Kind.CLASS,
                            Annotations.Kind.SYNTHETIC]),
                        MethodStub.Kind.METHOD, Array<FormalParameter>(), null,
                        f.type, ASTBlock(f.position, body), f.owner)
                StubGenerator.addSymbol(m, cl.symbols, context.errors)
            }
        }
    }

    method generateProgram():Program {
        for symbol in context.root {
            def simpleName := symbol.name[0 .. symbol.name.indexOf(".")]
            context.symbolTable.add(simpleName, symbol)
        }
        def classes := HashMap<String, ClassNode>()
        var madeProgress:Bit
        do {
            madeProgress := false
            createAllStubs()
            createThreadLocalInitializers()
            def filtered := context.stubGenerator.stubs.values.filter(
                    cl => !cl.isExternal & !classes.contains(cl.name))
            for cl in filtered {
                classes[cl.name] := convertClass(cl)
                madeProgress := true
            }
        }
        while madeProgress
        def root := MutablePackage("")
        def modules := Array<Module>()
        for cl in context.stubGenerator.stubs.values {
            addClass(cl, root)
            -- HACK, need a more general way of dealing with modules
            if cl.name.startsWith("panda.ui.") | 
                    cl.name.startsWith("panda.gl.") {
                modules.add(Module.PANDAUI)
            }
        }
        return Program(root.convert()->Package, context.stubGenerator.stubs, 
                classes, modules, context.liveMethods, context.stubGenerator)
    }
}