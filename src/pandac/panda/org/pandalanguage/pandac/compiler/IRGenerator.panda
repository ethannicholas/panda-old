package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ArrowOperationType
uses org.pandalanguage.pandac.ast.ASTArrayLiteral
uses org.pandalanguage.pandac.ast.ASTArrowExpression
uses org.pandalanguage.pandac.ast.ASTAssert
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBinaryExpression
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTBreak
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTCatch
uses org.pandalanguage.pandac.ast.ASTClassLiteral
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTContinue
uses org.pandalanguage.pandac.ast.ASTDo
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTFor
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTIndex
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTLambdaExpression
uses org.pandalanguage.pandac.ast.ASTLoop
uses org.pandalanguage.pandac.ast.ASTMethodType
uses org.pandalanguage.pandac.ast.ASTMethodValue
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTNullLiteral
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTPlugin
uses org.pandalanguage.pandac.ast.ASTRangeExpression
uses org.pandalanguage.pandac.ast.ASTRealLiteral
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTSwitch
uses org.pandalanguage.pandac.ast.ASTThrow
uses org.pandalanguage.pandac.ast.ASTTry
uses org.pandalanguage.pandac.ast.ASTTupleExpression
uses org.pandalanguage.pandac.ast.ASTTupleType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnaryExpression
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTVarDeclaration
uses org.pandalanguage.pandac.ast.ASTWhile
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.Package
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.stubs.TypeSymbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.InstanceContext
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodReference
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.PackageReference
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedDotExpression
uses org.pandalanguage.pandac.tree.UnresolvedIdentifier
uses org.pandalanguage.pandac.tree.UnresolvedIndex
uses org.pandalanguage.pandac.tree.UnresolvedLambda
uses org.pandalanguage.pandac.tree.UnresolvedMethod
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedSlice
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.SuperType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class IRGenerator {
    constant SHIM_PREFIX := "$shim_"

    constant STRING_GROUP := #/(?<!\\)\\\{.*?(?<!\\)\}/#

    constant UNESCAPED_BRACE := #/(?<!\\)\{/#

    var context:Context

    def currentlyInferring := new HashSet<FieldNode>()

    @thread
    var nameCount := 0

    constructor(root:Package, classes:MapView<String, ClassStub>,
            stubGenerator:StubGenerator, compilerSettings:CompilerSettings,
            errors:ErrorReporter) {
        context := new Context(stubGenerator, root, classes, errors, 
                compilerSettings)
    }

    @class
    function makeExplicit(v:Value):Value {
        if v-?>(Cast) {
            return new Cast(v.position, v->(Cast).value, v.type, 
                    CastType.EXPLICIT)
        }
        return v
    }
    
    @class
    function isAccessible(f:FieldNode):Bit {
        return true
    }

    @private
    method createFieldReference(position:Position, var contextValue:Value, 
            f:FieldNode, allowNoArgFunctions:Bit):Value {
        inferFieldType(f)
        if allowNoArgFunctions {
            def result := context.testCall(position, contextValue, f.name, 
                    new Array<Value>())
            if result != null & result->(MethodCall).methodStub.methodType =
                    MethodNodeType.FUNCTION
                return result
        }
        def result := new FieldReference(position, contextValue, f)
        return result
    }

    method getMember(position:Position, var contextValue:Value,
            var name:String):Value? {
        return getMember(position, contextValue, name, true)
    }

    method getMember(position:Position, var contextValue:Value,
            var name:String, allowNoArgFunctions:Bit):Value? {
        if name = "class"
            name := "$class"
        if contextValue-?>(ClassLiteral) {
            def type := contextValue->(ClassLiteral).value->>(ClassType)
            def member := context.getSymbolTable(context.getStub(type))[name]
            if member != null
                return symbolReference(position, contextValue, member)
        }
        if contextValue-?>(Super) {
            def type := context.getStub(context.getSelf(position).type->(ClassType)).superclass->(ClassType)
            def member := context.getSymbolTable(context.getStub(type))[name]
            if member != null
                return symbolReference(position, contextValue, member)
        }
        def resolved := resolve(contextValue)
        if resolved != null
            contextValue := resolved
        else
            return null
        if contextValue.type-?>(VoidType) {
            context.errors.error("this expression does not have any members", 
                    position)
            return null
        }
        def type := contextValue.type->>(ClassType)
        def member := context.getSymbolTable(context.getStub(type))[name]
        if member != null {
            return symbolReference(position, contextValue.implicitCast(context,
                    type), member)
        }
        context.errors.error("'\{contextValue.type.displayName}' does not " +
                "have a member named '\{name}'", position)
        return null
    }

    method convertCallExpression(c:ASTCallExpression):Value? {
        var target := convertExpression(c.target)
        if target = null
            return null
        if c.parameters.length = 0 & target-?>(MethodCall)
            return target
        def parameters := new Array<Value>()
        for p in c.parameters {
            def converted := convertExpression(p)
            if converted = null
                return null
            parameters.add(converted)
        }
        if target-?>(UnresolvedIdentifier) {
            if context.isInstance {
                def test := context.testCall(c.position, context.getSelf(
                            c.position),
                        target->(UnresolvedIdentifier).name, parameters)
                if test != null
                    return test
            }
            def test := context.testCall(c.position, new ClassLiteral(
                    c.position, context.currentClass.type),
                    target->(UnresolvedIdentifier).name, parameters)
            if test != null
                return test
        }
        if target-?>(UnresolvedDotExpression) {
            def u := target->(UnresolvedDotExpression)
            if u.left-?>(Super) {
                if !context.isInstance {
                    context.errors.error(SuperType.ERROR_MESSAGE, 
                            target.position)
                    return null
                }
                return context.call(c.position, u.left, u.right, parameters)
            }
            def left := resolve(u.left)
            if left = null
                return null
            return context.call(c.position, left, u.right, parameters)
        }
        if target-?>(UnresolvedMethod) {
            def u := target->(UnresolvedMethod)
            def finalTarget:Value
            if u.target != null 
                finalTarget := u.target->(Value)
            else if context.isInstance {
                finalTarget := new InstanceContext(c.position, 
                        context.getSelf(c.position))
            }
            else {
                finalTarget := new ClassLiteral(c.position, 
                        context.currentClass.type)
            }
            return context.call(c.position, finalTarget, u.methods, parameters)
        }
        if target-?>(MethodReference) {
            def m := target->(MethodReference)
            return context.call(c.position, m.target, m.methodStub, parameters)
        }
        target := resolve(target)
        if target = null
            return null
        def type := target.type.unwrapNullable
        if type-!>(MethodType) {
            context.errors.error("expected a method, but found " +
                    "'\{target.type.displayName}'", target.position)
            return null
        }
        def unwrapped := target.implicitCast(context, type)
        def parameterTypes := type->(MethodType).methodParameters
        if parameters.length != parameterTypes.length {
            def expected:String
            if parameterTypes.length = 1
                expected := "1 parameter"
            else
                expected := parameterTypes.length + " parameters"
            context.errors.error("'\{type.displayName}' expects \{expected}, " +
                    "but found \{parameters.length}", c.position)
            return null
        }
        def finalParams := new Array<Value>()
        for i, p in parameters
            finalParams.add(p.implicitCast(context, parameterTypes[i]))
        return new DynamicCall(unwrapped, finalParams)
    }

    method resolveClass(position:Position, name:String):Value? {
        def type := new ASTClassType(position, name, null, false) 
        def resolved := context.resolveType(type)
        if resolved != null
            return new ClassLiteral(position, resolved)
        return null
    }

    method convertDotExpression(d:ASTDotExpression):Value? {
        def left := convertExpression(d.left)
        if left = null
            return null
        if left-?>(PackageReference) {
            def p := left->(PackageReference).value
            def child := p[d.right]
            if child != null
                return symbolReference(d.position, child)
            else {
                context.errors.error("package '\{p.name}' does not contain a " +
                        "member named '\{d.right}'", d.position)
                return null
            }
        }
        def resolved:Value?
        if left-!>(Super)
            resolved := resolve(left)
        else
            resolved := left
        if resolved = null
            return null
        return getMember(d.position, left, d.right)
    }

    method convertIdentifier(id:ASTIdentifier):Value? {
        return getIdentifier(id.position, id.identifier)
    }

    method convertClassLiteral(c:ASTClassLiteral):Value? {
        def type := resolve(c.type)
        if type != null
            return new ClassLiteral(c.position, type)
        return null
    }

    method convertIntegerLiteral(i:ASTIntegerLiteral):Value? {
        return new IntegerLiteral(i.position, i.value)
    }

    method convertRealLiteral(r:ASTRealLiteral):Value? {
        return new RealLiteral(r.position, r.value)
    }

    ============================================================================
    Given a sequence of chars from a string literal (e.g. "Hello\n!"), returns a
    string representing the contents of the literal (e.g. "Hello<newline>!")

    If `interpolating` is true, permits the additional escape sequences `\:`,
    `\{`, and `\}`, passing them through unmodified.
    ============================================================================
    method convertStringChars(position:Position, s:String, 
            interpolating:Bit):String? {
        var result := new MutableString()
        var i := 0
        loop {
            var next := s.indexOf("\\", i)
            if next = null {
                result.append(s[i..])
                break
            }
            result.append(s[i .. next])
            var c := s[next + 1]
            switch c {
                case "n":  result.append("\n")
                case "r":  result.append("\r")
                case "t":  result.append("\t")
                case '"':  result.append('"')
                case "\\": {
                    result.append("\\")
                    if interpolating
                        result.append("\\")
                }
                case "'":  result.append("'")
                case ":", "{", "}": {
                    if interpolating {
                        result.append("\\")
                        result.append(c)
                    }
                    else {
                        context.errors.error("invalid string escape '\\" + c + 
                                "'", new Position(position.file, position.line, 
                                position.column + i))
                        return null
                    }
                }
                default: {
                    context.errors.error("invalid string escape '\\" + c + "'", 
                            new Position(position.file, position.line, 
                            position.column + i))
                    return null
                }
            }
            i := next + 2
        }
        return result->>(String)
    }

    method convertStringLiteral(string:ASTStringLiteral):Value? {
        var s := string.value
        def result := new MutableString()
        def matcher := STRING_GROUP.matcher(s)
        def values := new Array<Value>()
        var lastEnd := 0
        while matcher.find() {
            def chars := convertStringChars(string.position, 
                    s[lastEnd .. matcher.start], false)
            if chars != null {
                result.append(chars.replace(UNESCAPED_BRACE, 
                        "\\{"))
            }
            def text := s[matcher.start + 2 .. matcher.end - 1]
            def expr, remaining := new PandaParser(context.errors).parseExpressionWithExtraText(
                    text, string.position)
            if expr = null
                return null
            def value := resolve(expr)
            if value = null
                return null
            values.add(value)
            def token:String?
            token := convertStringChars(string.position, remaining, 
                    true)
            if token != null
                result.append("{\{token}}")
            lastEnd := matcher.end()
        }
        if lastEnd > 0 {
            def chars := convertStringChars(string.position, s[lastEnd..], false)
            if chars != null
                result.append(chars.replace(UNESCAPED_BRACE, "\\{"))
            s := result->>(String)
            values.insert(0, new StringLiteral(string.position, s))
            return context.call(string.position, new ClassLiteral(
                    string.position, ClassType.STRING), "format", values)
        }
        else {
            def chars := convertStringChars(string.position, s, false)
            if chars = null
                return null
            return new StringLiteral(string.position, chars)
        }
    }

    method convertBitLiteral(b:ASTBitLiteral):Value? {
        return new BitLiteral(b.position, b.value)
    }

    method convertUnaryExpression(u:ASTUnaryExpression):Value? {
        var operand := resolve(u.expression)
        if operand = null
            return null
        if u.operation = UnaryOperationType.MINUS & operand-?>(IntegerLiteral) {
            def i := operand->(IntegerLiteral)
            switch i.value {
                case 128: operand := new IntegerLiteral(i.position, i.value, 
                        IntType.INT8, false)
                case 32768: operand := new IntegerLiteral(i.position, i.value, 
                        IntType.INT16, false)
                case 2147483648: operand := new IntegerLiteral(i.position, 
                        i.value, IntType.INT32, false)
                case 9223372036854775808: operand := new IntegerLiteral(
                        i.position, i.value, IntType.INT64, false)
            }
        }
        return new UnaryOperation(u.position, u.operation, operand)
    }

    method convertBinaryExpression(b:ASTBinaryExpression):Value? {
        def left := resolve(b.left)
        if left = null
            return null
        def right := resolve(b.right)
        if right = null
            return null
        return getBinaryValue(b.position, left, b.operation, right)
    }

    method convertInstanceOf(position:Position, var object:Value, 
            var type:Type):Value? {
        if object.type = StringOrCharType.STRING_OR_CHAR {
            -- hardcode STRING_OR_CHAR-?>(Char) and STRING_OR_CHAR-?>(String)
            -- as true
            if type = CharType.CHAR | ClassType.STRING.canImplicitCastTo(
                    context, type)
                return new BitLiteral(position, true)
        }
        def primitiveTarget := type.isPrimitive | type.isWrapper
        if primitiveTarget {
            if object.type = StringOrCharType.STRING_OR_CHAR
                object := object.implicitCast(context, CharType.CHAR)
            if object.type = CharType.CHAR & type.isNumber
                object := object.explicitCast(context, IntType.INT32)
        }
        def primitiveSource := object.type.isPrimitive | 
                object.type.isWrapper

        if object.type.isNumber & type.isReal
            return new BitLiteral(position, true)

        if !primitiveSource & type.isPrimitive
            type := type->>(ClassType)

        if !object.canExplicitCastTo(context, type) {
            context.errors.error("'\{object.type.displayName}' " +
                    "cannot possibly be an instance of '\{type.displayName}'", 
                    position)
        }

        def parameters := new Array<Value>()
        parameters.add(object)
        if !primitiveTarget
            parameters.add(new ClassLiteral(position, type->>(ClassType)))

        var methodName := "instanceOf"
        if primitiveTarget {
            var target := type.unwrapNullable
            var name := target.name
            constant CORE := "panda.core."
            assert name.startsWith(CORE)
            name := name[CORE.length..]
            if target.isWrapper
                name := name.replace("Wrapper", "")
            methodName += name
        }
        def panda := new ClassLiteral(position, ClassType.PANDA)
        var instanceOf:MethodStub? := null
        if !object.type.isNullable
            instanceOf := context.getMethod(panda, methodName, parameters)
        if instanceOf = null {
            parameters.add(new BitLiteral(position, type.isNullable))
            instanceOf := context.getMethod(panda, methodName, parameters)
        }
        assert instanceOf != null
        return context.call(position, panda, instanceOf, parameters)
    }

    method convertArrowExpression(a:ASTArrowExpression):Value? {
        def left := resolve(a.left)
        if left = null
            return null
        def right := context.resolveType(a.right)
        if right = null
            return null
        if a.operation != ArrowOperationType.CONVERT &
                !left.canExplicitCastTo(context, right) {
            context.errors.error("'\{left.type.displayName}' cannot " +
                    "possibly be an instance of '\{right.displayName}'",
                    a.position)
            return null
        }
        switch a.operation {
            case ArrowOperationType.CAST:
                return left.explicitCast(a.position, context, right)
            case ArrowOperationType.INSTANCE_OF:
                return convertInstanceOf(a.position, left, right)
            case ArrowOperationType.NOT_INSTANCE_OF: {
                def instanceOf := convertInstanceOf(a.position, left, right)
                if instanceOf = null
                    return null
                return new UnaryOperation(a.position, UnaryOperationType.NOT,
                        instanceOf)
            }
            case ArrowOperationType.CONVERT:
                return left.convert(context, right)
            default:
                unreachable
        }
    }

    function check(v:Value?):Bit {
        if v = null
            return true
        return v.type-!>(UnresolvedType)
    }

    method symbolReference(position:Position, s:Symbol):Value? {
        return symbolReference(position, null, s)
    }

    method symbolReference(position:Position, var target:Value?, 
            s:Symbol):Value? {
        if s-?>(FieldNode) {
            def f := s->(FieldNode)
            inferFieldType(f)
            if f.annotations.isClass | f.annotations.isThread {
                if target != null & target-!>(ClassLiteral) {
                    context.errors.error("cannot reference class field " +
                            "'\{f}' from an instance context", position)
                }
                return new FieldReference(position, 
                            new ClassLiteral(position, f.owner), f)
            }
            else {
                if target = null {
                    return new FieldReference(position, 
                            context.getSelf(position), f)
                }
                return new FieldReference(position, target, f)
            }
        }
        if s-?>(Methods) {
            def methods := s->(Methods).methods
            if target = null {
                if context.isInstance
                    target := new InstanceContext(position, 
                            context.getSelf(position))
                else {
                    target := new ClassLiteral(position,
                            context.currentClass.type)
                }
            }
            if methods.length = 1 {
                if methods[0].methodType = MethodNodeType.FUNCTION &
                        methods[0].parameters.length = 0 {
                    return context.call(position, target, methods[0], 
                            new Array<Value>())
                }
                return new MethodReference(context, position, target, 
                        methods[0])
            }
            return new UnresolvedMethod(position, target, methods)
        }
        if s-?>(Variable) {
            def v := s->(Variable)
            if v-?>(Parameter) & v->(Parameter).owner != context.currentMethod
                context.captures.peek.add(v)
            else if v-?>(LocalVariable) & 
                    v->(LocalVariable).owner != context.currentMethod
                context.captures.peek.add(v)
            return new VariableReference(position, s->(Variable))
        }
        if s-?>(Package)
            return new PackageReference(position, s->(Package))
        if s-?>(TypeSymbol)
            return new ClassLiteral(position, s->(TypeSymbol).type)
        unreachable
    }

    method getIdentifier(position:Position, name:String):Value? {
        def result := context.symbolTable[name]
        if result != null
            return symbolReference(position, result)
        if context.isInstance
            return getMember(position, context.getSelf(position), name)
        return new UnresolvedIdentifier(position, name, null)
    }

    method resolve(v:Value):Value? {
        if v.type-?>(UnresolvedType) {
            if !v.checkValid(context)
                return null
            def type := v.preferredType(context)
            return v.implicitCast(context, type)
        }
        return v
    }
--    @post(@return = null | @return.type-!>(UnresolvedType))

    method resolve(e:ASTExpression):Value? {
        var result := convertExpression(e)
        if result = null
            return null
        return resolve(result)
    }

    method resolve(t:ASTType):Type? {
        return context.resolveType(t) 
    }

    method convertNew(n:ASTNew):Value? {
        def type := resolve(n.type)
        if type = null
            return null
        def parameters := new Array<Value>()
        for p in n.parameters {
            def expr := convertExpression(p)
            if expr = null
                return null
            parameters.add(expr)
        }
        if type-?>(PrimitiveArrayType) {
            def elementType := type->(PrimitiveArrayType).parameters[0]
            if parameters.length = 1 &
                    parameters[0].canImplicitCastTo(context, IntType.INT32) {
                def cast := parameters[0].implicitCast(context, IntType.INT32)
                context.getStub(type->>(PrimitiveArrayType))
                return new NewPrimitiveArrayWithLength(n.position, 
                        type->>(PrimitiveArrayType), cast)
            }
            else if parameters.length = 1 &
                    parameters[0].type.isPrimitiveArray &
                    parameters[0].type->(PrimitiveArrayType).parameters[0] =
                        elementType {
                context.getStub(type->(PrimitiveArrayType))
                return new PrimitiveArrayCopy(n.position, 
                        type->(PrimitiveArrayType), parameters[0])
            }
            else if parameters.length = 0 {
                context.getStub(type->>(PrimitiveArrayType))
                return new NewPrimitiveArrayWithLength(n.position, 
                        type->>(PrimitiveArrayType), new IntegerLiteral(
                            n.position, 0, IntType.INT32, true))
            }
            else {
                def casted := new Array<Value>()
                for p in parameters
                    casted.add(p.implicitCast(context, elementType))
                return new NewPrimitiveArrayWithValues(n.position, 
                        type->>(PrimitiveArrayType), casted)
            }
        }
        def stub := context.getStub(type->>(ClassType))
        if stub.isInterface {
            context.errors.error("interfaces may not be instantiated",
                    n.position)
            return null
        }
        def symbolTable := context.getSymbolTable(stub)
        def constructors := symbolTable[MethodNode.CONSTRUCTOR_NAME]
        assert constructors != null
        def call := context.call(n.position, new ClassLiteral(n.position, type), 
                constructors->(Methods).methods, parameters)
        if call != null
            return new Construct(call->(MethodCall))
        else
            return null
    }

    method convertIndex(i:ASTIndex):Value? {
        def target := resolve(i.target)
        if target = null
            return null
        var index := convertExpression(i.index)
        if index = null
            return null
        if index-?>(UnresolvedRange) {
            def range := index->(UnresolvedRange)
            return new UnresolvedSlice(context, i.position, target, range.left, 
                    range.right, range.step, range.endInclusive)
        }
        index := resolve(index)
        if index = null
            return null
        if target.type.unwrapNullable-?>(TupleType) & index-?>(IntegerLiteral) {
            return getMember(i.position, target, TupleType.FIELD_PREFIX + 
                    index->(IntegerLiteral).value)
        }
        if target.type.unwrapNullable-?>(PrimitiveArrayType)
            return new PrimitiveArrayIndexValue(target, 
                    index.implicitCast(context, IntType.INT32))
        return new UnresolvedIndex(context, i.position, target, index)
    }

    method convertRangeExpression(r:ASTRangeExpression):Value? {
        def left:Value?
        if r.left != null {
            left := resolve(r.left->(ASTExpression))
            if left = null
                return null
        }
        else
            left := null
        def right:Value?
        if r.right != null {
            right := resolve(r.right->(ASTExpression))
            if right = null
                return null
        }
        else
            right := null
        def step:Value?
        if r.step != null {
            step := resolve(r.step->(ASTExpression))
            if step = null
                return null
        }
        else
            step := null
        return new UnresolvedRange(context, r.position, left, right, step, 
                r.endInclusive)
    }

    method convertPlugin(p:ASTPlugin):Value? {
        var s := p.value
        if s.startsWith("/") & s.endsWith("/") {
            s := s[1 .. s.length - 1]
            def parameters := new Array<Value>()
            parameters.add(new StringLiteral(p.position, s))
            def result := context.call(p.position, new ClassLiteral(p.position,
                    ClassType.REGULAR_EXPRESSION), MethodNode.CONSTRUCTOR_NAME,
                    parameters)
            if result = null
                return null
            return new Construct(result->(MethodCall))
        }
        throw new CompilerException("unsupported plugin: \{s}", p.position)    
    }

    method convertArray(a:ASTArrayLiteral):Value? {
        def values := new Array<Value>()
        for expr in a.values {
            def v := convertExpression(expr)
            if v = null
                return null
            values.add(v)
        }
        return new UnresolvedArray(context, a.position, values)
    }

    method convertTuple(t:ASTTupleExpression):Value? {
        def values := new Array<Value>()
        for expr in t.values {
            def v := convertExpression(expr)
            if v = null
                return null
            values.add(v)
        }
        return new UnresolvedTuple(context, t.position, values)
    }

    method convertSuper(s:ASTSuper):Value? {
        if context.isInstance {
            return new Super(s.position, context.currentClass.type)
        }
        context.errors.error(SuperType.ERROR_MESSAGE, s.position)
        return null
    }

    method convertSwitch(s:ASTSwitch):Statement? {
        def resolved := resolve(s.value)
        if resolved != null {
            def switchObject := new ReusedValueDefinition(resolved)
            def statements := new Array<Statement>()
            statements.add(new ValueStatement(switchObject))
            var lastCase:Statement? := null
            def cases := new Array<If>()
            if s.defaultCase != null {
                def defaultStatement := convertStatement(s.defaultCase->(ASTStatement))
                if defaultStatement != null
                    lastCase := defaultStatement
                else
                    return null
            }
            for i in s.cases.length - 1 ... 0 by -1 {
                def c := s.cases[i]
                def start := resolve(c.values[0])
                if start != null {
                    var test := getBinaryValue(start.position, 
                            switchObject.createReference(), 
                            BinaryOperationType.EQUAL, 
                            start)
                    if test = null
                        return null
                    for v in c.values[1..] {
                        def next := resolve(v)
                        if next != null {
                            def equal := getBinaryValue(start.position, 
                                        switchObject.createReference(), 
                                        BinaryOperationType.EQUAL, 
                                        next)
                            if equal = null
                                return null
                            test := getBinaryValue(v.position, 
                                    test, BinaryOperationType.OR,
                                    equal)
                            if test = null
                                return null
                        }
                        else
                            return null
                    }
                    def statement := convertStatement(c.statement)
                    if statement != null {
                        lastCase := new If(statement.position, test, 
                                statement, lastCase)
                    }
                    else
                        return null
                }
                else
                    return null
            }
            if lastCase = null
                return null
            statements.add(lastCase)
            return new Block(s.position, statements)
        }
        return null
    }

    method convertExpression(e:ASTExpression):Value? {
        switch e.class {
            case class(ASTCallExpression):
                return convertCallExpression(e->(ASTCallExpression))
            case class(ASTIdentifier):
                return convertIdentifier(e->(ASTIdentifier))
            case class(ASTDotExpression):
                return convertDotExpression(e->(ASTDotExpression))
            case class(ASTIntegerLiteral):
                return convertIntegerLiteral(e->(ASTIntegerLiteral))
            case class(ASTRealLiteral):
                return convertRealLiteral(e->(ASTRealLiteral))
            case class(ASTStringLiteral):
                return convertStringLiteral(e->(ASTStringLiteral))
            case class(ASTBitLiteral):
                return convertBitLiteral(e->(ASTBitLiteral))
            case class(ASTNullLiteral):
                return new NullLiteral(e.position)
            case class(ASTUnaryExpression):
                return convertUnaryExpression(e->(ASTUnaryExpression))
            case class(ASTBinaryExpression):
                return convertBinaryExpression(e->(ASTBinaryExpression))
            case class(ASTArrowExpression):
                return convertArrowExpression(e->(ASTArrowExpression))
            case class(ASTNew):
                return convertNew(e->(ASTNew))
            case class(ASTSelf):
                return getIdentifier(e.position, "self")
            case class(ASTSuper):
                return convertSuper(e->(ASTSuper))
            case class(ASTIndex):
                return convertIndex(e->(ASTIndex))
            case class(ASTRangeExpression):
                return convertRangeExpression(e->(ASTRangeExpression))
            case class(ASTPlugin):
                return convertPlugin(e->(ASTPlugin))
            case class(ASTArrayLiteral):
                return convertArray(e->(ASTArrayLiteral))
            case class(ASTTupleExpression): 
                return convertTuple(e->(ASTTupleExpression))
            case class(ASTClassLiteral):
                return convertClassLiteral(e->(ASTClassLiteral))
            case class(ASTLambdaExpression):
                return convertLambda(e->(ASTLambdaExpression))
            case class(ASTMethodValue):
                return convertMethodValue(e->(ASTMethodValue))
            default:
                throw new InternalCompilerException("unsupported expression: " +
                        e.class.name, e.position)
        }
    }

    method convertVarDeclaration(v:ASTVarDeclaration):Statement? {
        var initializer:Value?
        if v.initializer != null {
            initializer := convertExpression(v.initializer->(ASTExpression))
            if initializer = null
                return null
        }
        else
            initializer := null
        def locals := new Array<LocalVariable>()
        for i, decl in v.vars {
            def type:Type?
            if decl.type != null {
                type := resolve(decl.type->(ASTType))
                if type = null {
                    context.errors.error("unknown class '\{decl.type->(ASTType)}'",
                            decl.type->(ASTType).position)
                    return null
                }
            }
            else {
                if initializer = null {
                    context.errors.error("variable has neither an " +
                            "initializer nor a type", decl.position)
                    return null
                }
                initializer := resolve(initializer)
                if initializer = null
                    return null
                def initializerType := initializer.preferredVariableType(
                        context)
                if v.vars.length > 1 {
                    if initializerType.unwrapNullable-!>(TupleType) {
                        context.errors.error("assigning to multiple " +
                                "variables from a non-tuple expression",
                                initializer.position)
                    }
                    type := initializerType.unwrapNullable->(TupleType).types[i]
                }
                else
                    type := initializerType
            }
            def local := new LocalVariable(decl.position, decl.identifier, type,
                    v.varType, context.currentMethod)
            context.localVariables.add(local)
            context.symbolTable[local.name] := local
            locals.add(local)
        }
        if initializer != null {
            if v.vars.length = 1 {
                return new ValueStatement(new VariableAssignment(v.position, 
                        locals[0], initializer.implicitCast(context, 
                            locals[0].type), 
                        true))
            }
            def tuple := new LocalVariable(v.position, "$tuple\{nameCount}",
                    initializer.type.unwrapNullable, VariableType.DEF,
                    context.currentMethod)
            context.localVariables.add(tuple)
            nameCount += 1
            def statements := new Array<Statement>()
            statements.add(new ValueStatement(new VariableAssignment(
                    v.position, tuple, initializer.implicitCast(context,
                        tuple.type), 
                    true)))
            for i, local in locals {
                def member := getMember(local.position, 
                        new VariableReference(local.position, tuple), 
                        TupleType.FIELD_PREFIX + i)
                assert member != null
                statements.add(new ValueStatement(new VariableAssignment(
                        local.position, local, member.implicitCast(context, 
                            local.type), 
                        true)))
            }
            return new Block(v.position, statements)
        }
        return null
    }

    method convertIf(i:ASTIf):Statement? {
        var test := resolve(i.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def thenStatement := convertStatement(i.thenStatement)
        if thenStatement = null
            return null
        def elseStatement:Statement?
        if i.elseStatement != null {
            elseStatement := convertStatement(i.elseStatement->(ASTStatement))
            if elseStatement = null
                return null
        }
        else
            elseStatement := null
        return new If(i.position, test, thenStatement, elseStatement)
    }

    @private
    method castToIterable(value:Value):Value? {
        def cl := context.getStub(value.type->>(ClassType))
        for intf in cl.allInterfaces(context) {
            if intf.name.startsWith("panda.collections.Iterable<")
                return value.implicitCast(context, intf.type)
        }
        context.errors.error("expected 'panda.collections.Iterable<T>'" +
                ", but found '\{value.type.displayName}'", value.position)
        return null
    }

    method convertIterableFor(f:ASTFor, rawList:Value, 
            indexVar:Variable?):Statement? {
        def list := castToIterable(rawList)
        if list = null
            return null
        def elementType := list.type->(GenericType).parameters[0]
        def valueVars := new Array<LocalVariable>()
        if f.valueVars.length > 1 {
            if elementType-!>(TupleType) | 
                    elementType->(TupleType).types.length != f.valueVars.length {
                context.errors.error("'for' loop expected a list of " +
                        "tuples of length \{f.valueVars.length}, but found " + 
                        "'\{rawList.type.displayName}'", f.position)
                return null
            }
        }
        for i, v in f.valueVars {
            var type:Type?
            if v.type != null {
                type := resolve(v.type->(ASTType))
                if type = null
                    return null
            }
            else {
                if f.valueVars.length = 1
                    type := elementType
                else {
                    def tuple := elementType->(TupleType)
                    type := tuple.types[i]
                }
            }
            def valueVar := new LocalVariable(v.position, v.identifier, type,
                    VariableType.DEF, context.currentMethod)
            valueVars.add(valueVar)
            context.localVariables.add(valueVar)
            context.symbolTable[valueVar.name] := valueVar
        }
        def statements := new Array<Statement>()
        if indexVar != null {
            statements.add(new ValueStatement(new VariableAssignment(f.position, 
                    indexVar, new IntegerLiteral(f.position, 0, indexVar.type, 
                    true), true)))
        }
        def typeParams := new Array<Type>()
        typeParams.add(elementType)
        def iteratorVar := new LocalVariable(f.position, "$iterator", 
                new GenericType(new ClassType("panda.collections.Iterator"), 
                typeParams), VariableType.DEF, context.currentMethod)
        def getIterator := context.call(f.position, list, "iterator", 
                new Array<Value>())
        assert getIterator != null
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                iteratorVar, getIterator, true)))
        context.localVariables.add(iteratorVar)
        def bodyStatements := new Array<Statement>()
        def done := context.call(f.position, new VariableReference(f.position, 
                iteratorVar), "done", new Array<Value>())
        assert done != null
        def test := new If(f.position, done, new Break(f.position), null)
        bodyStatements.add(test)
        def next := context.call(f.position, new VariableReference(f.position, 
                iteratorVar), "next", new Array<Value>())
        assert next != null
        def tupleVar:LocalVariable
        if valueVars.length = 1 {
            tupleVar := valueVars[0]
        }
        else {
            tupleVar := new LocalVariable(f.position, "$tuple", elementType,
                    VariableType.DEF, context.currentMethod)
            context.localVariables.add(tupleVar)
        }
        bodyStatements.add(new ValueStatement(new VariableAssignment(
                f.position, tupleVar, next, true)))
        if valueVars.length > 1 {
            for i, v in valueVars {
                def value := getMember(f.position,
                        new VariableReference(tupleVar.position, tupleVar), 
                        "$field" + i)
                assert value != null
                bodyStatements.add(new ValueStatement(new VariableAssignment(
                        f.position, valueVars[i], value, true)))
            }
        }
        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null
        bodyStatements.add(bodyStatement)
        def continueStatements := new Array<Statement>()
        if indexVar != null {
            def plusOne := new BinaryOperation(f.position, 
                    BinaryOperationType.ADD, new VariableReference(f.position,
                        indexVar), new IntegerLiteral(f.position, 1, 
                        indexVar.type, true))
            continueStatements.add(new ValueStatement(new VariableAssignment(
                    f.position, indexVar, plusOne, false)))
        }
        def w := new LoopWithContinueBlock(f.position, f.label, 
                new Block(f.position, bodyStatements), new Block(f.position,
                continueStatements))
        statements.add(w)
        return new Block(f.position, statements)
    }

    @private
    function getLiteral(i:Int64, t:Type):Value {
        if t.isReal
            return new RealLiteral(Position.INTERNAL, i, t->(RealType))
        if i < 0 {
            return new UnaryOperation(Position.INTERNAL, 
                    UnaryOperationType.MINUS,
                    new IntegerLiteral(Position.INTERNAL, i.abs->(UInt64), 
                    t->(IntType), true))
        }        
        return new IntegerLiteral(Position.INTERNAL, i->(UInt64), 
                t->(PrimitiveType), true)
    }

    @private
    function unsignedVersion(var t:Type):Type {
        t := t->>(PrimitiveType)
        switch t {
            case IntType.INT8: return IntType.UINT8
            case IntType.INT16: return IntType.UINT16
            case IntType.INT32: return IntType.UINT32
            case IntType.INT64: return IntType.UINT64
        }
        return t
    }

    -- "What the...? Why is this so complicated?!?"
    -- There's probably a simpler way to do this, but the problem of "loop from
    -- left to right by step" is harder than it sounds. Overflows are a real
    -- problem, particularly when you're looping to the minimum / maximum value
    -- supported by the type you're using, and even moreso when the step is
    -- greater than 1. So I have to jump through a lot of hoops to ensure that
    -- we correctly detect the end of the loop, never going past it and 
    -- overflowing. Feel free to figure out a better approach.

    ============================================================================
    Converts a numeric range `for` loop where the step is a compile-time 
    constant.
    ============================================================================
    method convertRangeForConstantStep(f:ASTFor, loopVar:Variable, start:Value, 
            rawEnd:Value, step:Int, endInclusive:Bit):Statement? {
        def statements := new Array<Statement>()
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        def end := new ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def testType:BinaryOperationType
        if endInclusive
            testType := BinaryOperationType.LESS_THAN_OR_EQUAL
        else        
            testType := BinaryOperationType.LESS_THAN
        def testLeft:Value
        def testRight:Value
        if step > 0 {
            testLeft := new VariableReference(f.position, loopVar)
            testRight := end
        }
        else {
            testLeft := end
            testRight := new VariableReference(f.position, loopVar)
        }
        def test := new BinaryOperation(f.position, testType,
                testLeft, testRight)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null

        def breakTestType:BinaryOperationType
        if endInclusive
            breakTestType := BinaryOperationType.LESS_THAN
        else
            breakTestType := BinaryOperationType.LESS_THAN_OR_EQUAL
        def sub1 := new Cast(f.position, end.createReference(),
                unsignedVersion(loopVar.type), CastType.CONVERT)
        def sub2 := new Cast(f.position, new VariableReference(f.position,
                loopVar), unsignedVersion(loopVar.type),
                CastType.CONVERT)
        def left:Value
        def right:Value
        if step > 0 {
            left := sub1
            right := sub2
        }
        else {
            left := sub2
            right := sub1
        }
        def sub := new BinaryOperation(f.position, BinaryOperationType.SUBTRACT,
                left, right)
        def stepLiteral := getLiteral(step.abs, 
                unsignedVersion(loopVar.type))
        def breakTest := new BinaryOperation(f.position, breakTestType, sub,
                stepLiteral)
        def label:String
        if f.label != null
            label := f.label->(String)
        else
            label := "$numericForLoops\{f.hash}"
        def breakIf := new If(f.position, breakTest, new Break(f.position, 
                label), null)
        def nextOp:BinaryOperationType
        if step > 0
            nextOp := BinaryOperationType.ADD
        else
            nextOp := BinaryOperationType.SUBTRACT
        def next := new BinaryOperation(f.position, nextOp, 
                new VariableReference(f.position, loopVar),
                getLiteral(step.abs, loopVar.type))
        def continueStatements := new Array<Statement>()
        continueStatements.add(breakIf)
        continueStatements.add(new ValueStatement(new VariableAssignment(
                f.position, loopVar, next)))
        statements.add(new If(f.position, test, new LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                new Block(f.position, continueStatements)), null))
        return new Block(f.position, statements)
    }

    function getConvertCast(v:Value, t:Type):Value {
        if v.type = t
            return v
        return new Cast(v.position, v, t, CastType.CONVERT)
    }

    ============================================================================
    Converts a numeric range `for` loop where the step is not a compile-time 
    constant.
    ============================================================================
    method convertRangeForVariableStep(f:ASTFor, loopVar:Variable, start:Value,
            rawEnd:Value, rawStep:Value, endInclusive:Bit):Statement? {
        def end := new ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def stepCast:Value
        if loopVar.type = CharType.CHAR {
            def intermediate := rawStep.implicitCast(context, IntType.INT16)
            stepCast := getConvertCast(intermediate, CharType.CHAR)
        }
        else
            stepCast := rawStep.implicitCast(context, loopVar.type)
        def step := new ReusedValueDefinition(stepCast)
        def statements := new Array<Statement>()
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        statements.add(new ValueStatement(end))
        statements.add(new ValueStatement(step))
        def testLeftLeft := new BinaryOperation(f.position,
                BinaryOperationType.GREATER_THAN, step.createReference(), 
                getLiteral(0, step.type))
        def testLeftRightType:BinaryOperationType
        if endInclusive
            testLeftRightType := BinaryOperationType.LESS_THAN_OR_EQUAL
        else
            testLeftRightType := BinaryOperationType.LESS_THAN
        def testLeftRight := new BinaryOperation(f.position, testLeftRightType,
                new VariableReference(f.position, loopVar), 
                end.createReference())
        def testLeft := new BinaryOperation(f.position, BinaryOperationType.AND,
                testLeftLeft, testLeftRight)
        def testRightLeft := new BinaryOperation(f.position,
                BinaryOperationType.LESS_THAN, step.createReference(), 
                getLiteral(0, step.type))
        def testRightRight := new BinaryOperation(f.position,
                testLeftRightType, end.createReference(), 
                new VariableReference(f.position, loopVar))
        def testRight := new BinaryOperation(f.position, BinaryOperationType.AND,
                testRightLeft, testRightRight)
        def test := new BinaryOperation(f.position, BinaryOperationType.OR,
                testLeft, testRight)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null

        def label:String
        if f.label != null
            label := f.label->(String)
        else
            label := "$numericForLoops\{f.hash}"

        def continueStatements := new Array<Statement>()

        def breakLeftLeft := new BinaryOperation(f.position,
                BinaryOperationType.GREATER_THAN, step.createReference(),
                getLiteral(0, step.type))
        def breakLeftRightType:BinaryOperationType
        if endInclusive
            breakLeftRightType := BinaryOperationType.LESS_THAN
        else
            breakLeftRightType := BinaryOperationType.LESS_THAN_OR_EQUAL
        def unsigned := unsignedVersion(loopVar.type)
        def leftSub := new BinaryOperation(f.position, 
                BinaryOperationType.SUBTRACT, getConvertCast(
                    end.createReference(), unsigned),
                getConvertCast(new VariableReference(f.position, loopVar),
                    unsigned))
        def breakLeftRight := new BinaryOperation(f.position, 
                breakLeftRightType, leftSub, getConvertCast(
                    step.createReference(), unsigned))
        def breakLeft := new BinaryOperation(f.position, 
                BinaryOperationType.AND, breakLeftLeft, breakLeftRight)
        def breakRightLeft := new BinaryOperation(f.position,
                BinaryOperationType.LESS_THAN, step.createReference(),
                getLiteral(0, step.type))
        def rightSub := new BinaryOperation(f.position, 
                BinaryOperationType.SUBTRACT, getConvertCast( 
                    new VariableReference(f.position, loopVar), unsigned),
                getConvertCast(end.createReference(), unsigned))
        def breakRightRight := new BinaryOperation(f.position, 
                breakLeftRightType, rightSub, new UnaryOperation(f.position,
                    UnaryOperationType.MINUS, getConvertCast(
                    step.createReference(), unsigned)))
        def breakRight := new BinaryOperation(f.position, 
                BinaryOperationType.AND, breakRightLeft, breakRightRight)
        def breakTest := new BinaryOperation(f.position, BinaryOperationType.OR,
                breakLeft, breakRight)
        def breakIf := new If(f.position, breakTest, new Break(f.position, 
                label), null)
        continueStatements.add(breakIf)
        def next := new BinaryOperation(f.position, BinaryOperationType.ADD,
                new VariableReference(f.position, loopVar), 
                step.createReference())
        continueStatements.add(new ValueStatement(new VariableAssignment(
                f.position, loopVar, next)))

        statements.add(new If(f.position, test, new LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                new Block(f.position, continueStatements)), null))
        return new Block(f.position, statements)
    }

    ============================================================================
    Converts a numeric range `for` loop where the step is not specified.
    ============================================================================
    method convertRangeFor(f:ASTFor, loopVar:Variable, start:Value, 
            rawEnd:Value, endInclusive:Bit):Statement? {
        def statements := new Array<Statement>()
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                loopVar, start.implicitCast(context, loopVar.type))))
        def end := new ReusedValueDefinition(rawEnd.implicitCast(context, 
                loopVar.type))
        def testType:BinaryOperationType
        if endInclusive
            testType := BinaryOperationType.LESS_THAN_OR_EQUAL
        else        
            testType := BinaryOperationType.LESS_THAN
        def test := new BinaryOperation(f.position, testType,
                new VariableReference(f.position, loopVar),
                end)

        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null

        def inc := new BinaryOperation(f.position, BinaryOperationType.ADD,
                new VariableReference(f.position, loopVar), 
                getLiteral(1, loopVar.type))
        def continueStatements := new Array<Statement>()
        def label:String
        if f.label != null
            label := f.label->(String)
        else
            label := "$numericForLoops\{f.hash}"
        if loopVar.type.isReal {
            -- reals are simpler: we can just add 1 and then check whether we've
            -- gone past our bounds (since we can safely assume that the loop
            -- bound is nowhere near the max real). For ints, that wouldn't work 
            -- if we were iterating to, say, 127 in an Int8: we can't actually 
            -- go past our bound because it would overflow, so we need to handle
            -- things a bit differently there (and the handling we do there 
            -- won't work for reals, because you can skip past a real when
            -- incrementing by 1, and that isn't true for ints)
            def breakTestType:BinaryOperationType
            if endInclusive
                breakTestType := BinaryOperationType.GREATER_THAN
            else
                breakTestType := BinaryOperationType.GREATER_THAN_OR_EQUAL
            def breakTest := new BinaryOperation(f.position, breakTestType,
                    new VariableReference(f.position, loopVar), 
                    end.createReference())
            def breakIf := new If(f.position, breakTest, 
                    new Break(f.position, label), null)
            continueStatements.add(new ValueStatement(new VariableAssignment(
                    f.position, loopVar, inc)))
            continueStatements.add(breakIf)
        }
        else {
            def breakTest := new BinaryOperation(f.position, 
                    BinaryOperationType.EQUAL, 
                    new VariableReference(f.position, loopVar),
                    end.createReference())
            def breakIf := new If(f.position, breakTest, 
                    new Break(f.position, label), null)
            if endInclusive
                continueStatements.add(breakIf)
            continueStatements.add(new ValueStatement(new VariableAssignment(
                    f.position, loopVar, inc)))
            if !endInclusive
                continueStatements.add(breakIf)
        }
        statements.add(new If(f.position, test, new LoopWithContinueBlock(
                f.position, label, bodyStatement, 
                new Block(f.position, continueStatements)), null))
        return new Block(f.position, statements)
    }

    ============================================================================
    Converts a numeric range `for` loop (a loop which operates over an 
    numeric range, such as `for i in 1 ... 10`). This is essentially an
    optimization, as obviously the "normal" mechanism of expanding `1 ... 10` to
    a call to the range operator defined in `Int` and then iterating over the
    resulting list would work, but would be very slow.

    However, this particular transformation is *required*, so it's a bit more
    than just "an optimization". The range operators in the various `Int` 
    classes are actually defined using numeric `for` loops, trusting the 
    compiler to convert the ranges to this sort of loop. If this transformation
    were disabled, the various range operators would be defined in terms of the
    various range operators, which would not be good.
    ============================================================================
    method convertRangeFor(f:ASTFor, range:UnresolvedRange):Statement? {
        if f.valueVars.length > 1 {
            context.errors.error("'for' loop expected a list of tuples " +
                    "containing \{f.valueVars.length} elements each, found " +
                    "'\{range.type}'", f.position)
            return null
        }
        def v := f.valueVars[0]
        var type:Type?
        if v.type != null {
            type := resolve(v.type->(ASTType))
            if type = null
                return null
        }
        else {
            type := range.value->(Value).type->(GenericType).parameters[0]
        }
        def loopVar := new LocalVariable(v.position, v.identifier, type,
                VariableType.DEF, context.currentMethod)
        context.localVariables.add(loopVar)
        context.symbolTable[loopVar.name] := loopVar
        def step := range.step
        if step = null {
            return convertRangeFor(f, loopVar, range.left->(Value), 
                    range.right->(Value), range.endInclusive)
        }
        else if step-?>(IntegerLiteral) {
            return convertRangeForConstantStep(f, loopVar, range.left->(Value), 
                    range.right->(Value), 
                    step->(IntegerLiteral).value->>(Int32), range.endInclusive)
        }
        else if step-?>(UnaryOperation) {
            def u := step->(UnaryOperation)
            if u.operation = UnaryOperationType.MINUS & 
                    u.operand-?>(IntegerLiteral) {
                return convertRangeForConstantStep(f, loopVar, 
                        range.left->(Value), range.right->(Value), 
                        -u.operand->(IntegerLiteral).value->>(Int32),
                        range.endInclusive)
            }
        }
        return convertRangeForVariableStep(f, loopVar, range.left->(Value), 
                range.right->(Value), step, range.endInclusive)
    }

    method convertPrimitiveArrayFor(f:ASTFor, rawArray:Value,
            var indexVar:LocalVariable?):Statement? {
        def array := new ReusedValueDefinition(rawArray)
        def elementType := array.type->>(PrimitiveArrayType).elementType
        def valueVars := new Array<Variable>()
        for v in f.valueVars {
            var type:Type?
            if v.type != null {
                type := resolve(v.type->(ASTType))
                if type = null
                    return null
            }
            else
                type := elementType
            def valueVar := new LocalVariable(v.position, v.identifier, type,
                    VariableType.DEF, context.currentMethod)
            valueVars.add(valueVar)
            context.localVariables.add(valueVar)
            context.symbolTable[valueVar.name] := valueVar
        }
        def statements := new Array<Statement>()
        statements.add(new ValueStatement(array))
        if indexVar = null {
            indexVar := new LocalVariable(f.position, "$index", IntType.INT32,
                    VariableType.VAR, context.currentMethod)
            context.localVariables.add(indexVar)
        }
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                indexVar, new IntegerLiteral(f.position, 0, indexVar.type, 
                true), true)))
        def lengthVar := new LocalVariable(f.position, "$length", IntType.INT32,
                    VariableType.VAR, context.currentMethod)
        context.localVariables.add(lengthVar)
        statements.add(new ValueStatement(new VariableAssignment(f.position, 
                lengthVar, getMember(f.position, array.createReference(), 
                    "length")->(Value), 
                true)))
        def typeParams := new Array<Type>()
        typeParams.add(elementType)
        def bodyStatements := new Array<Statement>()
        def done := new BinaryOperation(f.position, 
                BinaryOperationType.GREATER_THAN_OR_EQUAL, 
                    new VariableReference(f.position, indexVar),
                    new VariableReference(f.position, lengthVar))
        def test := new If(f.position, done, new Break(f.position), null)
        bodyStatements.add(test)
        bodyStatements.add(new ValueStatement(new VariableAssignment(f.position,
                valueVars[0], new PrimitiveArrayIndexValue(
                        array.createReference(), 
                        new VariableReference(f.position, indexVar)).implicitCast(context, valueVars[0].type))))
        def bodyStatement := convertStatement(f.statement)
        if bodyStatement = null
            return null
        bodyStatements.add(bodyStatement)
        def continueStatements := new Array<Statement>()
        def plusOne := new BinaryOperation(f.position, 
                BinaryOperationType.ADD, new VariableReference(f.position,
                        indexVar), new IntegerLiteral(f.position, 1, 
                        indexVar.type, true))
        continueStatements.add(new ValueStatement(new VariableAssignment(
                f.position, indexVar, plusOne, false)))
        def w := new LoopWithContinueBlock(f.position, f.label, 
                new Block(f.position, bodyStatements), new Block(f.position,
                continueStatements))
        statements.add(w)
        return new Block(f.position, statements)
    }

    method convertFor(f:ASTFor):Statement? {
        def indexVar:LocalVariable?
        if f.indexVar != null {
            def astVar := f.indexVar->(ASTTypedIdentifier)
            def type:Type?
            if astVar.type != null {
                type := resolve(astVar.type->(ASTType))
                if type = null
                    return null
            }
            else
                type := IntType.INT32
            indexVar := new LocalVariable(astVar.position, astVar.identifier, 
                    type, VariableType.DEF, context.currentMethod)
            context.localVariables.add(indexVar)
            context.symbolTable[indexVar.name] := indexVar
        }
        else
            indexVar := null
        var list := convertExpression(f.list)
        if list = null
            return null
        if indexVar = null & list-?>(UnresolvedRange)
            return convertRangeFor(f, list->(UnresolvedRange))
        list := resolve(list)
        if list = null
            return null
        if list.type.name.startsWith("panda.collections.PrimitiveArray<") |
                list.type.name.startsWith("panda.collections.ImmutablePrimitiveArray<")
            return convertPrimitiveArrayFor(f, list, indexVar)
        return convertIterableFor(f, list, indexVar)
    }

    method convertLoop(l:ASTLoop):Statement? {
        def statement := convertStatement(l.statement)
        if statement = null
            return null
        return new Loop(l.position, l.label, statement)
    }

    method convertWhile(w:ASTWhile):Statement? {
        var test := resolve(w.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def statement := convertStatement(w.statement)
        if statement = null
            return null
        return new While(w.position, w.label, test, statement)
    }

    method convertDo(d:ASTDo):Statement? {
        var test := resolve(d.test)
        if test = null
            return null
        test := test.implicitCast(context, BitType.BIT)
        def statement := convertStatement(d.statement)
        if statement = null
            return null
        return new Do(d.position, d.label, test, statement)
    }

    method convertBreak(b:ASTBreak):Statement? {
        return new Break(b.position, b.label)
    }

    method convertContinue(c:ASTContinue):Statement? {
        return new Continue(c.position, c.label)
    }

    ============================================================================
    As implicitCast, but with the ability to toggle whether we care about 
    signedness. If `signMatters` is false, the signedness is not considered
    important and will not stop a cast that would normally not be allowed.

    Note that the source and destination types are not necessarily integers; if
    not, we ignore the signMatters flag altogether and just perform a normal
    implicitCast.
    ============================================================================
    @private
    method signMattersCast(position:Position, v:Value, t:Type, 
            signMatters:Bit):Value? {
        if !signMatters {
            def srcType := v.type->>(PrimitiveType)
            if srcType.isInteger & t.isInteger & 
                    srcType->(IntType).signed != t->(IntType).signed & 
                    srcType->>(PrimitiveType).size <= t->>(PrimitiveType).size
                return v.explicitCast(context, t)
        }
        return v.implicitCast(context, t)
    }

    method power(position:Position, left:Value, right:Value):Value? {
        def target := new ClassLiteral(position, ClassType.PANDA)
        def params := new Array<Value>()
        params.add(left)
        params.add(right)
        return context.call(position, target, "pow", params)
    }
    
    ============================================================================
    Returns `<left> <op> <right>`, where `op` is the type of a token 
    representing a binary operator.
    
    @param node the position, for error reporting purposes
    @param left the left operand
    @param op the token type of a binary operator
    @param right the right operand
    ============================================================================
    method getBinaryValue(position:Position, var left:Value, 
            op:BinaryOperationType, var right:Value):Value? {
        def methodName:String
        switch op {
            case BinaryOperationType.ADD:                   methodName := "+"
            case BinaryOperationType.SUBTRACT:              methodName := "-"
            case BinaryOperationType.MULTIPLY:              methodName := "*"
            case BinaryOperationType.DIVIDE:                methodName := "/"
            case BinaryOperationType.INT_DIVIDE:            methodName := "//"
            case BinaryOperationType.REMAINDER:             methodName := "%"
            case BinaryOperationType.SHIFT_LEFT:            methodName := "<<"
            case BinaryOperationType.SHIFT_RIGHT:           methodName := ">>"
            case BinaryOperationType.AND:                   methodName := "&"
            case BinaryOperationType.OR:                    methodName := "|"
            case BinaryOperationType.XOR:                   methodName := "~"
            case BinaryOperationType.BITWISE_AND:           methodName := "&&"
            case BinaryOperationType.BITWISE_OR:            methodName := "||"
            case BinaryOperationType.BITWISE_XOR:           methodName := "~~"
            case BinaryOperationType.EQUAL:                 methodName := "="
            case BinaryOperationType.NOT_EQUAL:             methodName := "!="
            case BinaryOperationType.IDENTITY:              methodName := "=="
            case BinaryOperationType.NOT_IDENTITY:          methodName := "!=="
            case BinaryOperationType.LESS_THAN:             methodName := "<"
            case BinaryOperationType.GREATER_THAN:          methodName := ">"
            case BinaryOperationType.LESS_THAN_OR_EQUAL:    methodName := "<="
            case BinaryOperationType.GREATER_THAN_OR_EQUAL: methodName := ">="
            case BinaryOperationType.POWER: return power(position, left, right)
            default: {
                context.errors.error("unsupported binary operator '\{op}'",
                        position)
                return null
            }
        }
        def resolvedLeft := resolve(left)
        if resolvedLeft != null
            left := resolvedLeft
        else
            return null 
        def resolvedRight := resolve(right)
        if resolvedRight != null
            right := resolvedRight
        else
            return null
        var value := context.callOverloadedOperator(position, methodName, left,
                right)
        if value = null {
            def operandType := BinaryOperation.operandType(context, op, left, 
                    right)
            if operandType = null {
                context.errors.error("'\{methodName}' cannot operate on " +
                        "'\{left.type.displayName}', "+ 
                        "'\{right.type.displayName}'", position)
                return null
            }
            def leftCast := signMattersCast(position, left, operandType, 
                    BinaryOperation.signMatters(op))
            if leftCast != null
                left := leftCast
            else
                return null
            def rightCast := signMattersCast(position, right, operandType, 
                    BinaryOperation.signMatters(op))
            if rightCast != null
                right := rightCast
            else
                return null
            value := new BinaryOperation(position, op, left, right)
        }
        return value
    }

    @class
    method unwrapCast(v:Value):Value {
        if v-?>(Cast)
            return unwrapCast(v->(Cast).value)
        return v
    }

    @private
    method getSliceAssignmentCall(u:UnresolvedSlice, 
            params:Array<Value>):Value? {
        def name:String
        if u.endInclusive
            name := "[...]:="
        else
            name := "[..]:="
        return context.testCall(u.position, u.contextValue, name, 
                params)
    }

    @private
    method getSliceAssignmentCall(u:UnresolvedSlice, v:Value):Value? {
        if u.left = null & u.right = null & u.step = null {
            def params := new Array<Value>()
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        if u.right = null & u.step = null {
            def params := new Array<Value>()
            if u.left != null
                params.add(u.left->(Value))
            else
                params.add(new NullLiteral(u.position))
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        if u.step = null {
            def params := new Array<Value>()
            if u.left != null
                params.add(u.left->(Value))
            else
                params.add(new NullLiteral(u.position))
            if u.right != null
                params.add(u.right->(Value))
            else
                params.add(new NullLiteral(u.position))
            params.add(v)
            def test := getSliceAssignmentCall(u, params)
            if test != null
                return null
        }
        def params := new Array<Value>()
        if u.left != null
            params.add(u.left->(Value))
        else
            params.add(new NullLiteral(u.position))
        if u.right != null
            params.add(u.right->(Value))
        else
            params.add(new NullLiteral(u.position))
        if u.step != null
            params.add(u.step->(Value))
        else
            params.add(new IntegerLiteral(u.position, 1))
        params.add(v)
        return getSliceAssignmentCall(u, params)
    }

    method findAssignmentMethod(target:Value, name:String, 
            params:ListView<Value>):Value? {
        if name = "[..]" | name = "[...]" {
            -- check for reduced argument methods first
            if params.length = 4 & params[2]-?>(IntegerLiteral) & 
                    params[2]->(IntegerLiteral).value = 1 {
                def newParams := new Array<Value>()
                newParams.add(params[0])
                newParams.add(params[1])
                newParams.add(params[3])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null
                    return result
            }
            else if params.length = 3 & params[1]-?>(NullLiteral) {
                def newParams := new Array<Value>()
                newParams.add(params[0])
                newParams.add(params[2])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null
                    return result
            }
            else if params.length = 2 & params[0]-?>(NullLiteral) {
                def newParams := new Array<Value>()
                newParams.add(params[1])
                var result := findAssignmentMethod(target, name, newParams)
                if result != null
                    return result
            }
        }
        return context.testCall(target.position, target, name + ":=", params)
    }

    -- FIXME refactoring required! I did this all wrong and dumb. When I first
    -- started working on Panda, all lvalues were also rvalues. Then one
    -- situation crept in where the two weren't exactly the same, so I hacked it
    -- a bit to get it working. Then another cropped up, and another, and slowly
    -- this nice simple method turned into this hellish monstrosity. It needs to
    -- be killed with extreme prejudice, and I apologize to anyone reading this
    -- code. It just built up a bit at a time until it was completely out of
    -- control.
    --
    -- The basic idea is that (due to the original simplicity) the processing
    -- originally just figured out the rvalue on the left side of the assignment
    -- operator, ran into an assignment operator, made sure the rvalue worked as
    -- an lvalue, and continued on its merry way. Since then, this has gotten so 
    -- hellishly complicated that it absolutely needs to be rewritten so as to 
    -- know up front to be looking for an lvalue, so we can eliminate all of 
    -- these special cases and cut this at least in half.
    --
    -- UPDATE:
    -- Oh god I made it even worse. It's so awful. Please don't judge me by this
    -- method, I'm better than this, I swear :-(
    --
    -- FURTHER UPDATE:
    -- Actually, I don't think the refactoring is as simple as I outlined. I 
    -- hadn't considered the complexities introduced by compound assignment. We
    -- can't just process the assignment target twice (once in "lvalue mode" and
    -- once in "rvalue mode"), because that would involve duplicate evaluations
    -- of things that are only supposed to be evaluated once. It can certainly
    -- be done simpler than it's being done, but I don't think it's possible to
    -- eliminate quite as much complexity as I had hoped.
    method processSingleAssignment(var left:Value, right:Value, 
            reuse:Bit):Statement? {
        if left-?>(UnresolvedIndex) {
            def index := left->(UnresolvedIndex)
            def params := new Array<Value>()
            params.add(index.index)
            params.add(right)
            def call := context.testCall(index.position, index.contextValue, 
                    "[]:=", params)
            if call != null
                return new ValueStatement(call)
            context.errors.error("'\{index.contextValue.type.displayName}' " +
                    "does not define the '[]:=' operator for " +
                    "'\{index.index.type.displayName}', " +
                    "'\{right.type.displayName}'", index.index.position)
            return null
        }
        else if left-?>(UnresolvedSlice) {
            def slice := left->(UnresolvedSlice)
            def call := getSliceAssignmentCall(slice, right)
            if call != null
                return new ValueStatement(call)
            def name:String
            if slice.endInclusive
                name := "'[...]:=' (inclusive slice assignment)"
            else
                name := "'[..]:=' (exclusive slice assignment)"
            def types := new Array<String>()
            if slice.left != null
                types.add(slice.left->(Value).type.displayName)
            else
                types.add("null")
            if slice.right != null
                types.add(slice.right->(Value).type.displayName)
            else
                types.add("null")
            if slice.step != null
                types.add(slice.step->(Value).type.displayName)
            else
                types.add("null")
            types.add(right.type.displayName)
            context.errors.error("'\{slice.contextValue.type.displayName}' " +
                    "does not define the \{name} operator for \{types}",
                    right.position)
            return null
        }

        var resolvedLeft := resolve(left)
        if resolvedLeft = null
            return null
        resolvedLeft := unwrapCast(resolvedLeft)
-*        if left-?>(Unresolved) {
            -- could be an assignment method
            var contextValue := left->(Unresolved).contextValue
            def name := left->(Unresolved).name
            if contextValue = null {
                if context.isInstance
                    contextValue := context.getSelf(left.position)
                else {
                    -- we're in a class context, so there can't possibly be an
                    -- assignment method. Go ahead and report the error.
                    return null
                }
            }
            def call := callAssignmentMethod(contextValue, name, 
                    new PrimitiveArray<Value>(right))
            if call != null
                currentNode.add(call)
            else {
                -- no assignment method, trigger the exception
                resolve(left)
            }
        }
        else if left-?>(AmbiguousReference) {
            var a := left->(AmbiguousReference)
            var object := a.context
            if reuse {
                def reusable := makeReusable(object)
                reusable.replace(reusable.createReference())
                currentNode.add(new ValueStatement(reusable))
                object := reusable.createReference()
            }
            checkAssignment(a.field, a.position)
            open(new FieldAssignment(left.position, object, a.field))
            currentNode.add(implicitCast(right.position, right, a.type))
            close(class(FieldAssignment))
        } *-
        if resolvedLeft-?>(VariableReference) {
            def variable := resolvedLeft->(VariableReference).variable
            def cast := right.implicitCast(context, variable.type)
            def assignment := new VariableAssignment(left.position,
                    variable, cast)
            return new ValueStatement(assignment)
        }
        else if resolvedLeft-?>(FieldReference) {
            def fv := resolvedLeft->(FieldReference)
            def object:Value
            def finalRight:Value
            if reuse & fv.object-!>(ClassLiteral) {
                def old := unwrapCast(right)->(BinaryOperation)
                assert old.left = fv
                object := new ReusedValueDefinition(fv.object)
                def newRight := new BinaryOperation(old.position, old.operation,
                        new FieldReference(old.position, object, fv.field), 
                        old.right)
                def cast := newRight.implicitCast(context, fv.field.type)
                finalRight := cast
            }
            else {
                object := fv.object
                finalRight := right.implicitCast(context, fv.field.type)
            }
            def name := fv.field.name
            return new FieldAssignment(fv.position, object, fv.field,
                    finalRight)
        }
        else if resolvedLeft-?>(PrimitiveArrayIndexValue) {
            def iv := left->(PrimitiveArrayIndexValue)
            if reuse {
                def old := unwrapCast(right)->(BinaryOperation)
                assert old.left = iv
                def array := new ReusedValueDefinition(iv.array)
                def index := new ReusedValueDefinition(iv.index)
                def newRight := new BinaryOperation(old.position, old.operation,
                        new PrimitiveArrayIndexValue(array, index), old.right)
                def cast := newRight.implicitCast(context,
                        array.type->>(PrimitiveArrayType).elementType)
                return new PrimitiveArrayIndexAssignment(left.position,
                        array.createReference(), index.createReference(), cast)
            }
            else {
                def array := iv.array
                def index := iv.index
                def cast := right.implicitCast(context,
                        array.type->>(PrimitiveArrayType).elementType)
                return new PrimitiveArrayIndexAssignment(left.position, 
                        array, index, cast)
            }
        }
-*
        else if left-?>(PossibleIndexedAssignment) {
            var pia := left->(PossibleIndexedAssignment)
            var params := [pia.index, right]
            var call := callAssignmentMethod(pia.context, "[]", params)
            if call != null
                currentNode.add(call)
            else {
                -- FIXME use map
                var types := new PrimitiveArray<String>()
                for p in params
                    types.append(p.type.displayName)
                throw new CompilerException("'\{pia.context.type.displayName}' does " + 
                        "not define the indexed assignment ([]:=) operator " +
                        "for \{types}", pia.position)
            }
        }
*-
        else if left-?>(MethodCall) {
            -- assigning to a method call. We need to look for a corresponding
            -- assignment method / field.
            def mc := left->(MethodCall)
            def methodStub := mc.methodStub
            if !methodStub.annotations.isClass & (mc.parameters.length = 0 | 
                    methodStub.name = "[]" | methodStub.name = "[..]" |
                    methodStub.name = "[...]") {
                def oldParams := mc.parameters
                def testParams := new Array<Value>(oldParams)
                -- undo implicit casts that happened as part of setting up the
                -- original method call
                for i, p in testParams {
                    testParams[i] := unwrapCast(p)
                }
                if methodStub.name = "[..]" | methodStub.name = "[...]" {
                    -- restore parameters that might have been stripped when we
                    -- matched the initial slice. Such a hack, I'm so sorry.
                    if testParams.length = 0
                        testParams.add(new NullLiteral(left.position))
                    if testParams.length = 1
                        testParams.add(new NullLiteral(left.position))
                    if testParams.length = 2
                        testParams.add(new IntegerLiteral(left.position, 1))
                }
                testParams.add(right)
                def target := unwrapCast(mc.target)
                def result := findAssignmentMethod(target, methodStub.name, 
                        testParams)
                if result != null
                    return new ValueStatement(result)
                else {
                    -- no assignment method
                    if methodStub.name = "[]" {
                        def types := new Array<String>()
                        for p in testParams
                            types.add(p.type.displayName)
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the indexed assignment ([]:=) " +
                                "operator for \{types}", mc.position)
                    }
                    else if methodStub.name = "[..]" {
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the exclusive slice assignment ([..]:=) " +
                                "operator for these types", mc.position)
                    }
                    else if methodStub.name = "[...]" {
                        context.errors.error("'\{target.type.displayName}' " +
                                "does not define the inclusive slice assignment ([...]:=) " +
                                "operator for these types", mc.position)
                    }
                    else {
                        context.errors.error("cannot assign to '\{left}'", 
                                left.position)
                    }
                }
            }
            else {
                context.errors.error("cannot assign to '\{left}'", 
                        left.position)
            }
        }
        else
            context.errors.error("cannot assign to '\{left}'", left.position)
        return null
    }

    method processAssignment(position:Position, var left:ListView<Value?>, 
            assignmentOp:BinaryOperationType?, var right:Value):Statement? {
        def cm := context.currentMethod
        def reuse:Bit
        if assignmentOp = null {
            reuse := false
        }
        else {
            reuse := true
            if left.length > 1 {
                context.errors.error("compound assignment cannot " +
                        " assign to multiple values at once", 
                        position)
                return null
            }
            var lvalue := left[0]
            if lvalue = null {
                context.errors.error("'_' is only permitted in " +
                        "multiple assignments from a tuple", 
                        position)
                return null
            }
            def finalRight := getBinaryValue(position, lvalue, assignmentOp, 
                    right)
            if finalRight = null
                return null
            right := finalRight
            -- deal with situations like int8 += 1 (which resolves into
            -- int8 := int8 + 1, and the right side promotes to an Int32, so we
            -- need to downcast)
            def resolved := resolve(lvalue)->(Value)
            if right.type.isInteger & resolved.type.isInteger
                right := right.explicitCast(context, resolved.type)
            def newLeft := new Array<Value?>()
            newLeft.add(lvalue)
            left := newLeft
        }

        if left.length > 1 {
-*            var result := new Array<Statement>()
            def reused := new ReusedValueDefinition(right)
            result.add(new ValueStatement(reused))
            for i, lvalue in left {
                if lvalue != null {
                    def tupleValue := getMember(right.position, 
                            reused.createReference(), 
                            TupleType.FIELD_PREFIX + i)
                    assert tupleValue != null : "can't-happen tuple failure"
                    def assignment := processSingleAssignment(lvalue, 
                            assignmentOp, tupleValue, reuse)
                    if assignments = null
                        return null
                }
            }
            return new Block(position, result)*-
            unreachable
        }
        else {
            def lvalue := left[0]
            assert lvalue != null
            return processSingleAssignment(lvalue, right, reuse)
        }
    }

    method convertAssignment(a:ASTAssignment):Statement? {
        def lvalues := new Array<Value?>()
        for lvalue in a.lvalues {
            def converted := convertExpression(lvalue)
            if converted = null
                return null
            lvalues.add(converted)
        }
        assert lvalues.length = 1 : "tuples not supported"
        def rvalue := convertExpression(a.rvalue)
        if rvalue = null
            return null
        return processAssignment(a.position, lvalues, a.operator, rvalue)
    }

    method convertReturn(r:ASTReturn):Statement? {
        if r.value = null
            return new Return(r.position)
        def converted := convertExpression(r.value->(ASTExpression))
        if converted = null
            return null
        def cast := converted.implicitCast(context, 
                context.currentMethod.returnType)
        return new Return(r.position, cast)
    }

    method convertAssert(a:ASTAssert):Statement? {
        def test := resolve(a.test->(ASTExpression))
        if test = null
            return null
        def error:Value?
        if a.error != null {
            def resolved := resolve(a.error->(ASTExpression))
            if resolved = null
                return null
            if resolved.canImplicitCastTo(context, ClassType.STRING)
                error := resolved.implicitCast(context, ClassType.STRING)
            else
                error := resolved.implicitCast(context, ClassType.SAFETY_ERROR)
        }
        else
            error := null
        return new Assert(a.position, test.implicitCast(context, BitType.BIT),
                error)
    }

    method convertUnreachable(u:ASTUnreachable):Statement? {
        return new Unreachable(u.position)
    }

    method convertStatement(s:ASTStatement):Statement? {
        switch s.class {
            case class(ASTExpressionStatement): {
                def expr := resolve(s->(ASTExpressionStatement).expression)
                if expr != null
                    return new ValueStatement(expr)
                return null
            }
            case class(ASTIf):
                return convertIf(s->(ASTIf))
            case class(ASTFor):
                return convertFor(s->(ASTFor))
            case class(ASTLoop):
                return convertLoop(s->(ASTLoop))
            case class(ASTWhile):
                return convertWhile(s->(ASTWhile))
            case class(ASTDo):
                return convertDo(s->(ASTDo))
            case class(ASTSwitch):
                return convertSwitch(s->(ASTSwitch))
            case class(ASTBreak):
                return convertBreak(s->(ASTBreak))
            case class(ASTContinue):
                return convertContinue(s->(ASTContinue))
            case class(ASTVarDeclaration):
                return convertVarDeclaration(s->(ASTVarDeclaration))
            case class(ASTAssignment):
                return convertAssignment(s->(ASTAssignment))
            case class(ASTReturn):
                return convertReturn(s->(ASTReturn))
            case class(ASTBlock):
                return convertBlock(s->(ASTBlock))
            case class(ASTTry):
                return convertTry(s->(ASTTry))
            case class(ASTThrow):
                return convertThrow(s->(ASTThrow))
            case class(ASTAssert):
                return convertAssert(s->(ASTAssert))
            case class(ASTUnreachable):
                return convertUnreachable(s->(ASTUnreachable))
            default:
                throw new InternalCompilerException("unsupported statement: " +
                        s.class.name, s.position)
        }
    }

    method convertBlock(b:ASTBlock):Block {
        context.pushSymbolTable()
        def statements := new Array<Statement>()
        for s in b.statements {
            def converted := convertStatement(s)
            if converted != null
                statements.add(converted)
        }
        context.popSymbolTable()
        return new Block(b.position, statements)
    }

    method convertCatch(c:ASTCatch):Catch? {
        def type := resolve(c.type)
        if type = null
            return null
        def error := new LocalVariable(c.position, c.name, type, 
                VariableType.DEF, context.currentMethod)
        context.localVariables.add(error)
        context.pushSymbolTable()
        context.symbolTable[c.name] := error
        def statement := convertStatement(c.statement)
        context.popSymbolTable()
        if statement = null
            return null
        return new Catch(c.position, error, statement)
    }

    method convertTry(t:ASTTry):Try? {
        def statement := convertStatement(t.statement)
        if statement = null
            return null
        def catches := new Array<Catch>()
        for astCatch in t.catches {
            def c := convertCatch(astCatch)
            if c != null
                catches.add(c)
        }
        return new Try(t.position, statement, catches)
    }

    method convertThrow(t:ASTThrow):Statement? {
        def error := resolve(t.error)
        if error = null
            return null
        return new Throw(t.position, error)
    }

    @class
    function toASTType(position:Position, var t:Type):ASTType {
        def nullable:Bit
        if t-?>(NullableType) {
            nullable := true
            t := t->(NullableType).base
        }
        else
            nullable := false
        if t-?>(MethodType) {
            def m := t->(MethodType)
            def parameters := new Array<ASTType>()
            for p in m.methodParameters
                parameters.add(toASTType(position, p))
            return new ASTMethodType(position, parameters, 
                    toASTType(position, m.returnType), nullable, m.isFunction, 
                    m.immutableMethod)
        }
        else if t-?>(TupleType) {
            def tuple := t->(TupleType)
            def types := new Array<ASTType>()
            for type in tuple.types
                types.add(toASTType(position, type))
            return new ASTTupleType(position, types, nullable)
        }
        else if t-?>(GenericType) {
            def g := t->(GenericType)
            def parameters := new Array<ASTType>()
            for p in g.parameters
                parameters.add(toASTType(position, p))
            return new ASTClassType(position, g.base.name, parameters, nullable)
        }
        return new ASTClassType(position, t.name, null, nullable)
    }

    method convertLambda(l:ASTLambdaExpression):Value? {
        def allTyped := l.parameters.filter(p => p.type = null).length = 0
        def value:Value?
        if allTyped {
            context.pushSymbolTable()
            def parameters := new Array<ASTParameter>()
            for p in l.parameters {
                parameters.add(new ASTParameter(p.position, p.identifier, 
                        p.type->(ASTType), false, false, false))
                def type := resolve(p.type->(ASTType))
                if type = null
                    return null
                context.symbolTable[p.identifier] := new LocalVariable(
                        p.position, p.identifier, type, VariableType.DEF,
                        context.currentMethod)
            }
            def expr := resolve(l.value)
            if expr = null
                return null
            context.popSymbolTable()
            def statements := new Array<ASTStatement>()
            statements.add(new ASTReturn(l.position, l.value))
            def body := new ASTBlock(l.position, statements)
            def methodValue := new ASTMethodValue(l.position, 
                    MethodNodeType.FUNCTION, parameters, 
                    toASTType(l.position, expr.type), body)
            value := convertMethodValue(methodValue)
        }
        else
            value := null
        def names := new Array<String>()
        def types := new Array<ASTType?>()
        for p in l.parameters {
            names.add(p.identifier)
            types.add(p.type)
        }
        return new UnresolvedLambda(context, l.position, names, types, l.value,
                value)
    }

    function methodNames():ListView<String> {
        def result := new Array<String>()
        for m in context.methods
            result.add(m.stub.name)
        return result
    }

    function createClosureConstructorAndFields(position:Position,
            captures:Set<Variable>, owner:ClassType):(MethodStub, ListView<FieldNode>) {
        def parameters := new Array<FormalParameter>()
        def fields := new Array<FieldNode>()
        for v in captures {
            parameters.add(new FormalParameter(position, v.name, v.type, 
                    false, false, false))
            fields.add(new FieldNode(position, owner, v.name, 
                    new Annotations(position), VariableType.DEF, v.type, null,
                    null))
        }
        def body := new Array<ASTStatement>()
        for i, field in fields {
            def lvalues := new Array<ASTExpression>()
            lvalues.add(new ASTDotExpression(new ASTIdentifier(position, 
                    Parameter.SELF_NAME), field.name))
            body.add(new ASTAssignment(lvalues, null,
                    new ASTIdentifier(position, field.name)))
        }
        def stub := new MethodStub(position, MethodNode.CONSTRUCTOR_NAME, 
                new Annotations(position), MethodNodeType.CONSTRUCTOR, 
                parameters, VoidType.VOID, new ASTBlock(position, body), 
                owner)
        return (stub, fields)
    }

    method convertMethodValue(m:ASTMethodValue):Value? {
        def className := context.currentClass.name + "$closure" + nameCount
        nameCount += 1
        def closureType := new ClassType(className)
        def oldLocals := new Array<LocalVariable>(context.localVariables)
        context.localVariables.clear()
        def lastMethod := context.currentMethod
        def formalParameters := new Array<FormalParameter>()
        for p in m.parameters {
            def type := resolve(p.type)
            if type = null
                return null
            formalParameters.add(new FormalParameter(p.position, p.name, type, 
                    p.isVar, p.isConvert, p.isVarArg))
        }
        def returnType:Type?
        if m.returnType != null {
            returnType := resolve(m.returnType->(ASTType))
            if returnType = null
                return null
        }
        else
            returnType := VoidType.VOID
        constant RAW_NAME := "raw"
        constant SHIMMED_NAME := "shimmed"
        def rawStub := new MethodStub(m.position, RAW_NAME, 
                new Annotations(m.position), m.methodType, formalParameters, 
                returnType, m.body, closureType)
        context.currentMethod := rawStub
        context.pushSymbolTable()
        def parameters := new Array<Parameter>()
        for formal in m.parameters {
            def type := resolve(formal.type)
            if type = null
                return null
            def p := new Parameter(formal.position, formal.name, type, 
                    formal.isVar, formal.isConvert, formal.isVarArg, 
                    rawStub)
            parameters.add(p)
            context.symbolTable[p.name] := p
        }
        if !lastMethod.annotations.isClass {
            def selfType := lastMethod.owner
            def selfParam := new Parameter(m.position, Parameter.SELF_NAME,
                    selfType, false, false, false, rawStub)
            context.symbolTable[selfParam.name] := selfParam
        }
        context.captures.push(new HashSet<Variable>())
        -- need to convertBlock in order to grab captures
        convertBlock(m.body->(ASTBlock))
        for f in context.captures.peek
            if f.name = "self"
                Console.writeLine("CAPTURED SELF AT: \{m.position}")
        def closureSymbols := new OrderedMap<String, Symbol>()
        def closureConstructor, closureFields := createClosureConstructorAndFields(
                m.position, context.captures.peek(), closureType)
        def closureAnnotations := new Array<AnnotationType>()
        closureAnnotations.add(AnnotationType.SYNTHETIC)

        def shimmedStub:MethodStub
        if returnType.isPrimitive {
            def shimParameters := new Array<ASTExpression>()
            for p in formalParameters
                shimParameters.add(new ASTIdentifier(m.position, p.name))
            def call := new ASTCallExpression(new ASTIdentifier(m.position,
                    RAW_NAME), shimParameters)
            def statements := new Array<ASTStatement>()
            statements.add(new ASTReturn(m.position, call))
            def shimBody := new ASTBlock(m.position, statements)
            shimmedStub := new MethodStub(m.position, SHIMMED_NAME, 
                    new Annotations(m.position), m.methodType, formalParameters, 
                    ClassType.OBJECT, shimBody, closureType)
        }
        else {
            shimmedStub := new MethodStub(m.position, "shimmed", 
                    new Annotations(m.position), m.methodType, formalParameters, 
                    returnType, m.body, closureType)

        }

        closureSymbols[rawStub.name] := new Methods(rawStub)
        closureSymbols[shimmedStub.name] := new Methods(shimmedStub)
        closureSymbols[closureConstructor.name] := 
                new Methods(closureConstructor)
        for f in closureFields
            closureSymbols[f.name] := f
        def lookupContext := context.currentClass.lookupContext
        def superclass := ClassType.METHOD
        def closureStub := new ClassStub(m.position, closureType, 
                false, new Annotations(m.position, closureAnnotations), 
                superclass, new Array<ClassType>(), closureSymbols, lookupContext,
                new Array<ASTInvariant>(), null, false, 
                context.currentClass.type)
        context.classes[closureStub.name] := closureStub
        context.popSymbolTable()
        context.localVariables.clear()
        context.localVariables.addAll(oldLocals)
        context.currentMethod := lastMethod
        def constructorParameters := new Array<Value>()
        for v in context.captures.peek
            constructorParameters.add(new VariableReference(m.position, v))
        def closureInstance := new Construct(new MethodCall(m.position, 
                new ClassLiteral(m.position, closureType), 
                closureConstructor, constructorParameters))
        context.captures.pop()
        return new Cast(m.position, closureInstance, rawStub.type(context),
                CastType.IMPLICIT)
    }

    function callsOtherSelfConstructor(owner:ClassType,
            statements:ListView<Statement>):Bit {
        if statements.length > 0 {
            if statements[0]-?>(ValueStatement) {
                var value := statements[0]->(ValueStatement).value
                if value-?>(MethodCall) {
                    var call := value->(MethodCall)
                    if call.methodStub.methodType = MethodNodeType.CONSTRUCTOR
                        return call.methodStub.owner = owner
                }
            }
        }
        return false
    }
    
    function callsSuperConstructor(owner:ClassType,
            statements:ListView<Statement>):Bit {
        if statements.length > 0 {
            if statements[0]-?>(ValueStatement) {
                var value := statements[0]->(ValueStatement).value
                if value-?>(MethodCall) {
                    var call := value->(MethodCall)
                    if call.methodStub.methodType = MethodNodeType.CONSTRUCTOR
                        return call.target.type != owner
                }
            }
        }
        return false
    }   

    method convertMethod(m:MethodStub):MethodNode {
        context.localVariables.clear()
        context.currentMethod := m
        context.pushSymbolTable()
        def parameters := new Array<Parameter>()
        for formal in m.parameters {
            def p := new Parameter(formal.position, formal.name, formal.type, 
                    formal.isVar, formal.isConvert, formal.isVarArg,
                    context.currentMethod)
            parameters.add(p)
            context.symbolTable[p.name] := p
        }
        if !m.annotations.isClass {
            def selfType:Type
            if m.annotations.isWrapperMethod
                selfType := m.owner->>(PrimitiveType)
            else
                selfType := m.owner
            def selfParam := new Parameter(m.position, Parameter.SELF_NAME,
                    selfType, false, false, false, context.currentMethod)
            context.symbolTable[selfParam.name] := selfParam
        }
        var body := convertBlock(m.body->(ASTBlock))
        if m.methodType = MethodNodeType.CONSTRUCTOR {
            def callsOther := callsOtherSelfConstructor(m.owner, body.statements)
            def callsSuper := callsSuperConstructor(m.owner, body.statements)
            if !callsOther {
                def statements := new Array<Statement>()
                for f in context.currentClass.fields {
                    if !f.annotations.isClass & !f.annotations.isThread {
                        if f.initialValue != null {
                            def initialValue := resolve(
                                    f.initialValue->(ASTExpression))
                            if initialValue != null {
                                statements.add(new FieldAssignment(f.position,
                                        context.getSelf(f.position), f,
                                        initialValue.implicitCast(context, f.type)))
                            }
                        }
                    }
                }
                statements.addAll(body.statements)
                body := new Block(body.position, statements)
            }
            if !callsOther & !callsSuper & m.owner != ClassType.OBJECT {
                def statements := new Array<Statement>()
                def superCall := context.call(m.position, new Super(m.position, m.owner),
                        MethodNode.CONSTRUCTOR_NAME, new Array<Value>())
                if superCall != null
                    statements.add(new ValueStatement(superCall))
                statements.addAll(body.statements)
                body := new Block(body.position, statements)
            }
        }
        def result := new MethodNode(m, body, parameters, 
                context.localVariables)
        context.popSymbolTable()
        return result
    }

    method pushSymbols(cl:ClassStub) {
        context.currentClass := cl
        context.pushSymbolTable()
        context.symbolTable.addAll(context.getSymbolTable(cl))
    }

    method convertClass(cl:ClassStub):ClassNode {
        context.methods.clear()
        pushSymbols(cl)
        for f in cl.fields
            inferFieldType(f)
        for m in cl.methods.filter(m => m.body != null) {
            if cl.annotations.isUnspecified & !m.annotations.isClass
                continue
            context.methods.add(convertMethod(m))
        }
        context.popSymbolTable()
        return new ClassNode(cl, context.methods)
    }

    method inferFieldType(f:FieldNode) {
        if f.type-!>(UnresolvedType)
            return
        if f.initialValue = null {
            context.errors.error("field '\{f.name}' has neither an explicit " +
                    "type nor an initial value", f.position)
            f.type := VoidType.VOID
            return
        }
        if currentlyInferring.contains(f) {
            def msg := new MutableString("unable to resolve field types due " +
                    "to a circular dependency involving:")
            for msgField in currentlyInferring
                msg.append("\n    '\{msgField.name}': \{msgField.position}")
            context.errors.error(msg->>(String), f.position)
            f.type := VoidType.VOID
            return
        }
        currentlyInferring.add(f)
        def old := context.currentClass
        pushSymbols(context.getStub(f.owner))
        if !f.annotations.isClass & !f.annotations.isThread {
            def selfParam := new Parameter(f.position, Parameter.SELF_NAME,
                    f.owner, false, false, false, context.currentMethod)
            context.symbolTable[selfParam.name] := selfParam
        }        
        def expr := resolve(f.initialValue->(ASTExpression))
        context.popSymbolTable()
        context.currentClass := old
        if expr != null {
            if expr.checkValid(context)
                f.type := expr.preferredVariableType(context)
        }
        else
            f.type := VoidType.VOID
        currentlyInferring.remove(f)
    }

    method createStub(t:Type) {
        if !t.isPrimitive & t != VoidType.VOID & 
                t != NativePointerType.NATIVE_POINTER
        context.getStub(t->>(ClassType))
    }

    @private
    method createAllStubs() {
        for (_, cl) in context.stubGenerator.types {
            if cl-?>(ClassType) & cl-!>(GenericParameterType) {
                def astClass := context.stubGenerator.astClasses[cl.name]
                if astClass != null {
                    if !astClass[0].isExternal
                        createStub(cl->(ClassType))  
                } 
                else {
                    def astEnum := context.stubGenerator.astEnums[cl.name]
                    if astEnum != null & !astEnum[0].isExternal
                        createStub(cl->(ClassType))  
                }
            }
        }
        createStub(ClassType.CLASS)
        createStub(ClassType.METHOD)
        var progress:Bit
        def checked := new HashSet<ClassStub>()
        do {
            progress := false
            for (_, cl) in context.classes {
                if checked.contains(cl)
                    continue
                checked.add(cl)
                progress := true
                if cl.annotations.isUnspecified | cl.annotations.isExternal
                    continue
                for f in cl.fields {
                    inferFieldType(f)
                    createStub(f.type)
                }
                for m in cl.methods {
                    for p in m.parameters
                        createStub(p.type)
                    createStub(m.returnType)
                }
                def sc := cl.superclass
                if sc != null
                    createStub(sc)
                for intf in cl.interfaces
                    createStub(intf)
            }
        }
        while progress
    }

    method addClass(cl:ClassStub, root:MutablePackage) {
        var currentPackage := root
        def components := cl.name.split(".")
        def currentName := new MutableString()
        for i, c in components {
            if i > 0
                currentName.append(".")
            currentName.append(c)
            if i < components.length - 1 {
                var next := currentPackage[c]
                if next = null {
                    next := new MutablePackage(currentName->>(String))
                    currentPackage[c] := next
                }
                else if next-!>(MutablePackage)
                    unreachable
                currentPackage := next->(MutablePackage)
            }
            else {
                if currentPackage[c] = null
                    currentPackage[c] := new TypeSymbol(cl.type)
            }
        }
    }

    @pre(f.varType = VariableType.PROPERTY)
    @pre(f.name.endsWith("$PROPERTY"))
    function needsGetter(f:FieldNode, cl:ClassStub):Bit {
        def name := f.name[0 .. f.name.length - "$PROPERTY".length]
        for m in cl.methods {
            if m.name = name & m.methodType = MethodNodeType.FUNCTION &
                    m.parameters.length = 0
                return false
        }
        return true
    }

    @pre(f.varType = VariableType.PROPERTY)
    @pre(f.name.endsWith("$PROPERTY"))
    function needsSetter(f:FieldNode, cl:ClassStub):Bit {
        if f.annotations.isReadOnly
            return false
        def name := f.name[0 .. f.name.length - "$PROPERTY".length] + ":="
        for m in cl.methods {
            if m.name = name & m.methodType = MethodNodeType.METHOD &
                    m.parameters.length = 1
                return false
        }
        return true
    }

    method createProperties(cl:ClassStub) {
        for f in cl.fields {
            if f.varType = VariableType.PROPERTY {
                inferFieldType(f)
                context.symbolTables.remove(cl)
                cl.symbols.remove(f.name)
                def name := f.name[0 .. f.name.length - "$PROPERTY".length]
                def field := new FieldNode(f.position, cl.type, "_" + 
                        name, f.annotations, VariableType.VAR, f.type, 
                        f.initialValue, f.tuplePosition)
                StubGenerator.addSymbol(field, field.position, cl.symbols, 
                        context.errors)

                if needsGetter(f, cl) {
                    def getterStatements := new Array<ASTStatement>()
                    getterStatements.add(new ASTReturn(f.position, 
                            new ASTIdentifier(f.position, field.name)))
                    def getterBody := new ASTBlock(f.position, 
                            getterStatements)
                    def getter := new MethodStub(f.position, name, 
                            new Annotations(f.position), 
                            MethodNodeType.FUNCTION, 
                            new Array<FormalParameter>(), f.type, 
                            getterBody, cl.type)
                    StubGenerator.addSymbol(getter, cl.symbols, 
                            context.errors)
                }

                if needsSetter(f, cl) {
                    def setterStatements := new Array<ASTStatement>()
                    def parameters := new Array<FormalParameter>()
                    def parameter := new FormalParameter(f.position, 
                            "value", f.type, false, false, false)
                    parameters.add(parameter)
                    def lvalues := new Array<ASTExpression>()
                    lvalues.add(new ASTIdentifier(f.position, field.name))
                    setterStatements.add(new ASTAssignment(lvalues, null, 
                            new ASTIdentifier(f.position, parameter.name)))
                    def setterBody := new ASTBlock(f.position, 
                            setterStatements)
                    def annotationTypes := new Array<AnnotationType>()
                    annotationTypes.add(AnnotationType.SELF)
                    def setterAnnotations := new Annotations(f.position, 
                            annotationTypes)
                    def setter := new MethodStub(f.position, 
                            name + ":=", setterAnnotations, 
                            MethodNodeType.METHOD, parameters, 
                            VoidType.VOID, setterBody, cl.type)
                    StubGenerator.addSymbol(setter, cl.symbols, 
                            context.errors)
                }
            }
        }
    }

    method createProperties() {
        for cl in context.classes.values
            createProperties(cl)
    }

    @class
    function getThreadLocalInitializerName(f:FieldNode):String {
        return "$init\{f.name}"
    }

    method createThreadLocalInitializers() {
        for cl in context.classes.values {
            for f in cl.fields.filter(f => f.annotations.isThread) {
                inferFieldType(f)
                def name := getThreadLocalInitializerName(f)
                if cl.symbols[name] != null
                    continue
                context.symbolTables.remove(cl)
                def body := new Array<ASTStatement>()
                body.add(new ASTReturn(f.position, f.initialValue))
                def annotations := new Array<AnnotationType>()
                annotations.add(AnnotationType.CLASS)
                annotations.add(AnnotationType.SYNTHETIC)
                def m := new MethodStub(f.position, 
                        name, new Annotations(f.position, annotations),
                        MethodNodeType.METHOD, new Array<FormalParameter>(), 
                        f.type, new ASTBlock(f.position, body), f.owner)
                StubGenerator.addSymbol(m, cl.symbols, context.errors)
            }
        }
    }

    method generateProgram():Program {
        for symbol in context.root {
            def simpleName := symbol.name[0 .. symbol.name.indexOf(".")]
            context.symbolTable[simpleName] := symbol
        }
        def classes := new HashMap<String, ClassNode>()
        var madeProgress:Bit
        do {
            madeProgress := false
            createAllStubs()
            createProperties()
            createThreadLocalInitializers()
            def filtered := context.classes.values.filter(cl => !cl.isExternal & 
                    !classes.contains(cl.name))
            for cl in filtered {
                classes[cl.name] := convertClass(cl)
                madeProgress := true
            }
        }
        while madeProgress
        def root := new MutablePackage("")
        for cl in context.classes.values
            addClass(cl, root)
        return new Program(root->>(Package), context.classes, classes, 
                context.stubGenerator)
    }
}