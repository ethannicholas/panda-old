package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.stubs.TypedFieldStub
uses org.pandalanguage.pandac.stubs.TypedFormalParameter
uses org.pandalanguage.pandac.stubs.TypedMethodStub
uses org.pandalanguage.pandac.stubs.TypedCompilationUnitStub
uses org.pandalanguage.pandac.stubs.UntypedClassStub
uses org.pandalanguage.pandac.stubs.UntypedFieldStub
uses org.pandalanguage.pandac.stubs.UntypedMethodStub
uses org.pandalanguage.pandac.stubs.UnTypedFormaParameter
uses org.pandalanguage.pandac.stubs.UntypedCompilationUnitStub
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.SpecialType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.GenericParameterType

================================================================================
Converts the various untyped stubs into their typed equivalents.
================================================================================
class TypeResolver (MessageProcessor) {
    @private
    def typeMap:TypeMap

    @private
    var packageUses:CollectionView<String>

    @private
    var classAliases:Map<String, String>

    constructor(typeMap:TypeMap) {
        self.typeMap := typeMap
        self.packageUses := new Array<String>()
        self.classAliases := new HashMap<String, String>()
    }

    @private
    @self
    method ANY_TYPE():Type {
        def name := new PandaParser().parseType("panda.core.Object?",
                Position.INTERNAL)
        def result, messages := resolveType(name)
        assert messages = null : messages->>(String)
        assert result != null
        return result
    }

    @private
    @self
    method resolveType(type:ParseNode?):(Type?, ListView<Message>?) {
        if type != null {
            return typeMap.getType(type, new LookupContext(packageUses, 
                    classAliases))
        }
        else
            return (null, null)
    }

    @private
    @self
    method resolveTypes(m:UntypedMethodStub):
            (TypedMethodStub, ListView<Message>?) {
        def parameters := new Array<TypedFormalParameter>()
        var messages:ListView<Message>? := null
        for p in m.parameters {
            def resolved, submessages := resolveType(p.type)
            if resolved != null
                parameters.add(new TypedFormalParameter(p.position, p.name, 
                        resolved, p.isFinal, p.isConvert, p.isVarArg))
            messages := addMessages(messages, submessages)
        }
        def returnType:Type?
        if m.returnType != null {
            def submessages:ListView<Message>?
            returnType, submessages := resolveType(m.returnType->(ParseNode))
            messages := addMessages(messages, submessages)
        }
        else
            returnType := null
        return (new TypedMethodStub(m.position, m.name, m.annotations,
            m.methodType, parameters, returnType, m.block), messages)
    }

    @private
    @self
    method resolveTypes(f:UntypedFieldStub):
            (TypedFieldStub, ListView<Message>?) {
        def resolved, messages := resolveType(f.type)
        return (new TypedFieldStub(f.position, f.name, f.annotations,
            f.fieldType, resolved, f.initialValue, f.tuplePosition), 
            messages)
    }

    @private
    @self
    method resolveTypes(cl:UntypedClassStub):
            (TypedClassStub, ListView<Message>?) {
        self.packageUses := cl.lookupContext.packageUses
        self.classAliases := new HashMap<String, String>(
                cl.lookupContext.classAliases)
        var messages:ListView<Message>? := null
        def genericParameters := new Array<GenericParameterType>()
        for param in cl.genericParameters {
            def name := "\{cl.name}.\{param.name}"
            var bound, parameterMessages := resolveType(param.bound)
            messages := addMessages(messages, parameterMessages)
            if bound = null
                bound := ANY_TYPE()
            def parameter := new GenericParameterType(name, bound)
            self.classAliases[param.name] := name
            typeMap.putType(parameter)
            genericParameters.add(parameter)
        }
        def methods := new Array<TypedMethodStub>()
        for m in cl.methods {
            def resolved, submessages := resolveTypes(m)
            methods.add(resolved)
            messages := addMessages(messages, submessages)
        }
        def fields := new Array<TypedFieldStub>()
        for f in cl.fields {
            def resolved, submessages := resolveTypes(f)
            fields.add(resolved)
            messages := addMessages(messages, submessages)
        }
        def interfaces := new Array<ClassType>()
        for intf in cl.interfaces {
            def resolved, submessages := resolveType(intf)
            if resolved != null {
                if resolved-?>(ClassType)
                    interfaces.add(resolved->(ClassType))
                else {
                    messages := addMessage(messages, 
                            "'\{intf}' is not an interface", intf.position)
                }
            }
            messages := addMessages(messages, submessages)
        }
        def rawSuperclass, submessages := resolveType(cl.superclass)
        messages := addMessages(messages, submessages)
        def superclass:ClassType?
        if rawSuperclass-?>(ClassType)
            superclass := rawSuperclass->(ClassType)
        else {
            if rawSuperclass != null {
                def sc := cl.superclass
                assert sc != null
                messages := addMessage(messages, 
                        "'\{sc}' may not be subclassed", sc.position)
            }
            superclass := null
        }
        return (new TypedClassStub(cl.position, cl.name, cl.isInterface, 
                cl.annotations, new LookupContext(cl.lookupContext.packageUses, 
                        self.classAliases), superclass, interfaces, methods, 
                        fields, cl.invariants, genericParameters),
                messages)
    }

    @class
    method resolveTypes(cu:UntypedCompilationUnitStub, queue:MessageQueue, 
            typeMap:TypeMap):
            (TypedCompilationUnitStub, ListView<Message>?) {
        def list := new Array<UntypedCompilationUnitStub>()
        list.add(cu)
        def t := new TypeResolver(typeMap)
        def classes := new Array<TypedClassStub>()
        var messages:ListView<Message>? := null
        def replyTo := Thread.currentThread.queue
        for cl in cu.classes {
            queue.post((cl, replyTo))
            def resolved, submessages := replyTo.getMessage()->
                    ((TypedClassStub, ImmutableArray<Message>?))
            classes.add(resolved)
            messages := addMessages(messages, submessages)
        }
        def methods := new Array<TypedMethodStub>()
        for m in cu.methods {
            def resolved, submessages := t.resolveTypes(m)
            methods.add(resolved)
            messages := addMessages(messages, submessages)
        }
        return (new TypedCompilationUnitStub(cu.name, classes, methods, 
                cu.statements),
                messages)
    }

    @class
    method resolveTypes(compilationUnits:CollectionView<UntypedCompilationUnitStub>):
            (CollectionView<TypedCompilationUnitStub>, 
                TypeMap, ListView<Message>?) {
        def result := new Array<TypedCompilationUnitStub>()
        def classes := new Array<UntypedClassStub>()
        for cu in compilationUnits
            classes.addAll(cu.classes)
        def newTypeMap := new TypeMap(classes)
        var messages:ListView<Message>? := null
        def threads := Thread.preferredThreadCount()
        def queue := new MessageQueue()
        for i in 0 .. threads {
            Thread.start(method() {
                def t := new TypeResolver(newTypeMap)
                loop {
                    def message := queue.getMessage()->((UntypedClassStub, 
                            MessageQueue)?)
                    if message = null
                        break
                    def cl, replyTo := message
                    def result, messages := t.resolveTypes(cl)
                    def wrapped:ImmutableArray<Message>?
                    if messages != null
                        wrapped := new ImmutableArray<Message>(messages)
                    else
                        wrapped := null
                    replyTo.post((result, wrapped))
                }
            })
        }
        for cu in compilationUnits {
            def resolved, submessages := resolveTypes(cu, queue, newTypeMap)
            result.add(resolved)
            messages := addMessages(messages, submessages)
        }
        for i in 0 .. threads
            queue.post(null)
        return (result, newTypeMap, messages)
    }
}