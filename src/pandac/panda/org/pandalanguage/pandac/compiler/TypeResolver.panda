package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.stubs.TypedFormalParameter
uses org.pandalanguage.pandac.stubs.TypedMethodStub
uses org.pandalanguage.pandac.stubs.TypedCompilationUnitStub
uses org.pandalanguage.pandac.stubs.UntypedClassStub
uses org.pandalanguage.pandac.stubs.UntypedFieldNode
uses org.pandalanguage.pandac.stubs.UntypedGenericParameter
uses org.pandalanguage.pandac.stubs.UntypedMethodStub
uses org.pandalanguage.pandac.stubs.UntypedCompilationUnitStub
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.SpecialType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType

================================================================================
Converts the various untyped stubs into their typed equivalents.
================================================================================
class TypeResolver (MessageProcessor) {
    @private
    def typeMap:TypeMap

    @private
    var currentClass:TypedClassStub?

    @private
    def stubs:Map<String, TypedClassStub>

    @private
    var packageUses:CollectionView<String>

    @private
    var classAliases:Map<String, String>

    constructor(typeMap:TypeMap) {
        self.typeMap := typeMap
        self.packageUses := new Array<String>()
        self.classAliases := new HashMap<String, String>()
        self.stubs := new HashMap<String, TypedClassStub>()
    }

    @private
    @self
    method ANY_TYPE():Type {
        def name := new PandaParser().parseType("panda.core.Object?",
                Position.INTERNAL)
        def result, messages := resolveType(name)
        assert messages = null : messages->>(String)
        assert result != null
        return result
    }

    @private
    @self
    method resolveType(type:ParseNode?):(Type?, ListView<Message>?) {
        if type != null {
            return typeMap.getType(type, new LookupContext(packageUses, 
                    classAliases))
        }
        else
            return (null, null)
    }

    @private
    @self
    method resolveTypes(cl:ClassType, m:UntypedMethodStub):
            (TypedMethodStub, ListView<Message>?) {
        def parameters := new Array<TypedFormalParameter>()
        var messages:ListView<Message>? := null
        for p in m.parameters {
            def resolved, submessages := resolveType(p.type)
            if resolved != null
                parameters.add(new TypedFormalParameter(p.position, p.name, 
                        resolved, p.isFinal, p.isConvert, p.isVarArg))
            messages := addMessages(messages, submessages)
        }
        var returnType:Type?
        if m.returnType != null {
            def submessages:ListView<Message>?
            returnType, submessages := resolveType(m.returnType->(ParseNode))
            messages := addMessages(messages, submessages)
        }
        else
            returnType := VoidType.VOID
        if returnType = null
            returnType := ANY_TYPE()
        return (new TypedMethodStub(m.position, m.name, m.annotations,
            m.methodType, parameters, returnType, m.block, cl), messages)
    }

    @private
    @self
    method resolveTypes(f:UntypedFieldNode):
            (FieldNode, ListView<Message>?) {
        var resolved, messages := resolveType(f.type)
        if resolved = null
            resolved := new UnresolvedType(f->>(String), f.position)
        return (new FieldNode(f.position, f.name, f.annotations,
            f.fieldType, resolved, f.initialValue, f.tuplePosition), 
            messages)
    }

    @private
    @self
    method resolveTypes(cl:UntypedClassStub):
            (TypedClassStub, ListView<Message>?) {
        self.packageUses := cl.lookupContext.packageUses
        self.classAliases := new HashMap<String, String>(
                cl.lookupContext.classAliases)
        var messages:ListView<Message>? := null
        def classType, _ := typeMap.getType(
                new PandaParser().parseType(cl.name, cl.position), 
                cl.lookupContext)
        assert classType != null
        def genericParameters:List<GenericParameterType>?
        if cl.genericParameters != null {
            genericParameters := new Array<GenericParameterType>()
            for param in cl.genericParameters->(ListView<UntypedGenericParameter>) {
                def name := "\{cl.name}.\{param.name}"
                var bound, parameterMessages := resolveType(param.bound)
                messages := addMessages(messages, parameterMessages)
                if bound = null
                    bound := ANY_TYPE()
                def parameter := new GenericParameterType(name, bound)
                self.classAliases[param.name] := name
                typeMap.putType(parameter)
                genericParameters.add(parameter)
            }
        }
        else
            genericParameters := null
        def methods := new Array<TypedMethodStub>()
        for m in cl.methods {
            def resolved, submessages := resolveTypes(classType->(ClassType), m)
            methods.add(resolved)
            messages := addMessages(messages, submessages)
        }
        def fields := new Array<FieldNode>()
        for f in cl.fields {
            def resolved, submessages := resolveTypes(f)
            fields.add(resolved)
            messages := addMessages(messages, submessages)
        }
        def interfaces := new Array<ClassType>()
        for intf in cl.interfaces {
            def resolved, submessages := resolveType(intf)
            if resolved != null {
                if resolved-?>(ClassType)
                    interfaces.add(resolved->(ClassType))
                else {
                    messages := addMessage(messages, 
                            "'\{intf}' is not an interface", intf.position)
                }
            }
            messages := addMessages(messages, submessages)
        }
        def rawSuperclass, submessages := resolveType(cl.superclass)
        messages := addMessages(messages, submessages)
        def superclass:ClassType?
        if rawSuperclass-?>(ClassType)
            superclass := rawSuperclass->(ClassType)
        else {
            if rawSuperclass != null {
                def sc := cl.superclass
                assert sc != null
                messages := addMessage(messages, 
                        "'\{sc}' may not be subclassed", sc.position)
            }
            superclass := null
        }
        def stub := new TypedClassStub(cl.position, cl.name, cl.isInterface, 
                cl.annotations, new LookupContext(cl.lookupContext.packageUses, 
                        self.classAliases), superclass, interfaces, methods, 
                        fields, cl.invariants, genericParameters, 
                        cl.isExternal)
        stubs[stub.name] := stub
        return (stub, messages)
    }

    method resolveTypes(cu:UntypedCompilationUnitStub, typeMap:TypeMap):
            (TypedCompilationUnitStub, ListView<Message>?) {
        def list := new Array<UntypedCompilationUnitStub>()
        list.add(cu)
        def t := new TypeResolver(typeMap)
        def classes := new Array<TypedClassStub>()
        var messages:ListView<Message>? := null
        def replyTo := Thread.currentThread.queue
        for cl in cu.classes {
            def resolved, submessages := resolveTypes(cl)
            classes.add(resolved)
            messages := addMessages(messages, submessages)
        }
        def methods := new Array<TypedMethodStub>()
-*        for m in cu.methods {
            def resolved, submessages := t.resolveTypes(m)
            methods.add(resolved)
            messages := addMessages(messages, submessages)
        }*-
        return (new TypedCompilationUnitStub(cu.name, classes, cu.statements),
                messages)
    }

    method inferFieldTypes(cl:TypedClassStub):
            (TypedClassStub, Bit, Bit, ListView<Message>?) {
        currentClass := cl
        var updated := false
        var remaining := false
        def fields := new Array<FieldNode>()
        for f in cl.fields {
            if f.type-?>(UnresolvedType) {
                def initialValue := f.initialValue
                assert initialValue != null
                def context := new Context(currentClass, null, 
                        currentClass.lookupContext, typeMap, 
                        new ImmutableHashMap<String, TypedClassStub>(stubs),
                        new ImmutableArray<LocalVariable>(),
                        new ImmutableHashMap<String, Variable>())
                def expr, messages := new ASTGenerator().convertExpression(
                        context, initialValue)
                if expr != null {
                    fields.add(new FieldNode(f.position, f.name, 
                            f.annotations, f.varType, 
                            expr.type.preferredVariableType, 
                            f.initialValue, f.tuplePosition))
                    updated := true
                }
                else {
                    fields.add(f)
                    remaining := true
                }
            }
            else
                fields.add(f)
        }
        if updated {
            return (new TypedClassStub(cl.position, cl.name, cl.isInterface, 
                cl.annotations, cl.lookupContext, cl.superclass, cl.interfaces,
                        cl.methods, fields, cl.invariants, cl.genericParameters, 
                        cl.isExternal), true, remaining, null)
        }
        return (cl, false, remaining, null)
    }

    method inferFieldTypes(cu:TypedCompilationUnitStub):
            (TypedCompilationUnitStub, Bit, Bit, ListView<Message>?) {
        var updated := false
        var remaining := false
        def classes := new Array<TypedClassStub>()
        for cl in cu.classes {
            if cl.genericParameters != null
                classes.add(cl)
            else {
                def newCl, newUpdated, newRemaining, messages := 
                        inferFieldTypes(cl)
                classes.add(newCl)
                updated |= newUpdated
                remaining |= newRemaining
            }
        }
        return (new TypedCompilationUnitStub(cu.name, classes, cu.statements), 
                updated, remaining, null)
    }

    method inferFieldTypes(var compilationUnits:CollectionView<TypedCompilationUnitStub>):
            (CollectionView<TypedCompilationUnitStub>, ListView<Message>?) {
        loop {
            var updated := false
            var remaining := false
            def newCompilationUnits := new Array<TypedCompilationUnitStub>()
            for cu in compilationUnits {
                def newCompilationUnit, newUpdated, newRemaining, messages :=
                        inferFieldTypes(cu)
                newCompilationUnits.add(newCompilationUnit)
                updated |= newUpdated
                remaining |= newRemaining
            }
            compilationUnits := newCompilationUnits
            if !updated {
                if remaining
                    Console.writeLine("cound not infer field types")
                return (compilationUnits, null)
            }
        }
    }

    @class
    method resolveTypes(compilationUnits:CollectionView<UntypedCompilationUnitStub>):
            (CollectionView<TypedCompilationUnitStub>, 
                TypeMap, ListView<Message>?) {
        def result := new Array<TypedCompilationUnitStub>()
        def classes := new Array<UntypedClassStub>()
        for cu in compilationUnits
            classes.addAll(cu.classes)
        def newTypeMap := new TypeMap(classes)
        def t := new TypeResolver(newTypeMap)
        var messages:ListView<Message>? := null
        for cu in compilationUnits {
            def resolved, submessages := t.resolveTypes(cu, newTypeMap)
            result.add(resolved)
            messages := addMessages(messages, submessages)
        }
        def finished, submessages := t.inferFieldTypes(result)
        messages := addMessages(messages, submessages)
        return (finished, t.typeMap, messages)
    }
}