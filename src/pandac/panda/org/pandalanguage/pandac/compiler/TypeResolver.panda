package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.stubs.TypedFormalParameter
uses org.pandalanguage.pandac.stubs.TypedMethodStub
uses org.pandalanguage.pandac.stubs.UntypedClassStub
uses org.pandalanguage.pandac.stubs.UntypedFieldNode
uses org.pandalanguage.pandac.stubs.UntypedGenericParameter
uses org.pandalanguage.pandac.stubs.UntypedMethodStub
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.SpecialType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType

================================================================================
Converts the various untyped stubs into their typed equivalents. This class is
also responsible for creating a bit of the synthetic code (default constructors
and classInit methods).
================================================================================
class TypeResolver (MessageProcessor) {
    constant EMPTY_CONTEXT := new LookupContext(new Array<String>(), 
            new HashMap<String, String>())

    @private
    def typeMap:TypeMap

    @private
    var currentClassName := "<error>"

    @private
    def stubs:StubMap

    @private
    var packageUses:CollectionView<String>

    @private
    var classAliases:Map<String, String>

    constructor(typeMap:TypeMap, stubs:StubMap) {
        self.typeMap := typeMap
        self.packageUses := new Array<String>()
        self.classAliases := new HashMap<String, String>()
        self.stubs := stubs
    }

    @private
    @self
    method ANY_TYPE():Type {
        def name := new PandaParser().parseType("panda.core.Object?",
                Position.INTERNAL)
        def result, messages := resolveType(name)
        assert messages = null : messages->>(String)
        assert result != null
        return result
    }

    @private
    @self
    method resolveType(type:ParseNode?):(Type?, ListView<Message>?) {
        if type != null {
            return typeMap.getType(type, new LookupContext(packageUses, 
                    classAliases))
        }
        else
            return (null, null)
    }

    @private
    @self
    method resolveTypes(cl:ClassType, m:UntypedMethodStub):
            (TypedMethodStub, ListView<Message>?) {
        def parameters := new Array<TypedFormalParameter>()
        var messages:ListView<Message>? := null
        for p in m.parameters {
            def finalType:ParseNode
            if p.isVarArg {
                finalType := new PandaParser().parseType(
                        "panda.collections.PrimitiveArray<\{p.type}>",
                        p.type.position)
            }
            else
                finalType := p.type
            def resolved, submessages := resolveType(finalType)
            if resolved != null
                parameters.add(new TypedFormalParameter(p.position, p.name, 
                        resolved, p.isFinal, p.isConvert, p.isVarArg))
            messages := addMessages(messages, submessages)
        }
        var returnType:Type?
        if m.returnType != null {
            def submessages:ListView<Message>?
            returnType, submessages := resolveType(m.returnType->(ParseNode))
            messages := addMessages(messages, submessages)
        }
        else
            returnType := VoidType.VOID
        if returnType = null
            returnType := ANY_TYPE()
        return (new TypedMethodStub(m.position, m.name, m.annotations,
            m.methodType, parameters, returnType, m.block, cl), messages)
    }

    @private
    @self
    method resolveTypes(f:UntypedFieldNode):
            (FieldNode, ListView<Message>?) {
        var resolved, messages := resolveType(f.type)
        if resolved = null
            resolved := new UnresolvedType(f.name, f.position)
        def owner, submessages := typeMap.getType(
                new PandaParser().parseType(currentClassName, 
                    Position.INTERNAL), 
                EMPTY_CONTEXT)
        messages := addMessages(messages, submessages)
        assert owner != null : messages->>(String)
        if messages != null
            Console.writeLine("FAILURE: " + messages)
        return (new FieldNode(f.position, owner->(ClassType), f.name, 
                f.annotations, f.fieldType, resolved, f.initialValue, 
                f.tuplePosition), messages)
    }

    method createClassInit(position:Position, owner:ClassType,
            fields:ListView<FieldNode>):(FieldNode, TypedMethodStub)? {
        var createInit := false
        def body := new MutableString()
        for f in fields {
            if f.annotations.isClass | 
                    f.annotations.isThread {
                -- for isThread, we just ensure that the class init method
                -- exists (it doesn't have to contain anything). This is so
                -- code generators can easily do required thread local 
                -- setup.
                createInit := true
                if f.annotations.isClass {
                    def value := f.initialValue
                    if value != null
                        body.append("\{f.name} := \{value}\n")
                }
            }
        }
        if createInit {
            -- FIXME need to use array syntax when it's wired up
            def classAnnotations := new Array<AnnotationType>()
            classAnnotations.add(AnnotationType.CLASS)
            def classInited := new FieldNode(position, owner->(ClassType), 
                    FieldNode.CLASS_INITED_NAME, new Annotations(position, 
                        classAnnotations), 
                    VariableType.VAR, BitType.BIT, null, null)

            def methodBody := new PandaParser().parseBlock(
                    "{ if \{owner.name}.\{classInited.name} return " +
                    "\{owner.name}.\{classInited.name} := true \{body} }",
                    position)

            def classInit := new TypedMethodStub(position, 
                    MethodNode.CLASS_INIT_NAME, new Annotations(position, 
                        classAnnotations),
                    MethodNodeType.METHOD, new Array<TypedFormalParameter>(), 
                    VoidType.VOID, methodBody, owner->(ClassType))

            return (classInited, classInit)
        }
        return null
    }

    method createDefaultConstructor(position:Position, owner:ClassType):
            TypedMethodStub {
        def methodBody := new PandaParser().parseBlock("{}", position)
        def params := new Array<TypedFormalParameter>()
        params.add(new TypedFormalParameter(position, Parameter.SELF_NAME, 
                owner, true, false, false))
        return new TypedMethodStub(position, 
                MethodNode.CONSTRUCTOR_NAME, new Annotations(position, 
                    new Array<AnnotationType>()),
                MethodNodeType.CONSTRUCTOR, params, VoidType.VOID, methodBody, 
                owner->(ClassType))
    }

    @private
    @self
    method resolveTypes(cl:UntypedClassStub):
            (TypedClassStub, ListView<Message>?) {
        currentClassName := cl.name
        self.packageUses := cl.lookupContext.packageUses
        self.classAliases := new HashMap<String, String>(
                cl.lookupContext.classAliases)
        var messages:ListView<Message>? := null
        def rawClassType, _ := typeMap.getType(
                new PandaParser().parseType(cl.name, cl.position), 
                cl.lookupContext)
        def classType := rawClassType->(ClassType)
        def genericParameters:List<GenericParameterType>?
        if cl.genericParameters != null {
            genericParameters := new Array<GenericParameterType>()
            for param in cl.genericParameters->(ListView<UntypedGenericParameter>) {
                def name := "\{cl.name}.\{param.name}"
                var bound, parameterMessages := resolveType(param.bound)
                messages := addMessages(messages, parameterMessages)
                if bound = null
                    bound := ANY_TYPE()
                def parameter := new GenericParameterType(name, bound)
                self.classAliases[param.name] := name
                typeMap.putType(parameter)
                genericParameters.add(parameter)
            }
        }
        else
            genericParameters := null
        def methods := new Array<TypedMethodStub>()
        for m in cl.methods {
            def resolved, submessages := resolveTypes(classType, m)
            methods.add(resolved)
            messages := addMessages(messages, submessages)
        }
        def fields := new Array<FieldNode>()
        for f in cl.fields {
            def resolved, submessages := resolveTypes(f)
            fields.add(resolved)
            messages := addMessages(messages, submessages)
        }
        if !cl.isExternal {
            def classInit := createClassInit(cl.position, classType, fields)
            if classInit != null {
                fields.add(classInit[0])
                methods.add(classInit[1])
            }
            if methods.filter(m => m.methodType = 
                    MethodNodeType.CONSTRUCTOR).length = 0 {
                -- no default constructor
                methods.add(createDefaultConstructor(cl.position, classType))
            }
        }
        def interfaces := new Array<ClassType>()
        for intf in cl.interfaces {
            def resolved, submessages := resolveType(intf)
            if resolved != null {
                if resolved-?>(ClassType)
                    interfaces.add(resolved->(ClassType))
                else {
                    messages := addMessage(messages, 
                            "'\{intf}' is not an interface", intf.position)
                }
            }
            messages := addMessages(messages, submessages)
        }
        def rawSuperclass, submessages := resolveType(cl.superclass)
        messages := addMessages(messages, submessages)
        def superclass:ClassType?
        if rawSuperclass-?>(ClassType)
            superclass := rawSuperclass->(ClassType)
        else {
            if rawSuperclass != null {
                def sc := cl.superclass
                assert sc != null
                messages := addMessage(messages, 
                        "'\{sc}' may not be subclassed", sc.position)
            }
            if cl.name = class(Object).name
                superclass := null
            else
                superclass := ClassType.OBJECT
        }
        def stub := new TypedClassStub(cl.position, cl.name, cl.isInterface, 
                cl.annotations, new LookupContext(cl.lookupContext.packageUses, 
                        self.classAliases), superclass, interfaces, methods, 
                        fields, cl.invariants, genericParameters, 
                        cl.isExternal)
        stubs.putStub(stub)
        return (stub, messages)
    }

    -- returns a new stub with resolved types, whether any fields were resolved,
    -- whether there are remaining unresolved fields, and errors
    method inferFieldTypes(cl:TypedClassStub):
            (TypedClassStub, Bit, Bit, ListView<Message>?) {
        var updated := false
        var remaining := false
        def fields := new Array<FieldNode>()
        for f in cl.fields {
            if f.type-?>(UnresolvedType) {
                def initialValue := f.initialValue
                assert initialValue != null
                def context := new Context(cl, null, 
                        cl.lookupContext, typeMap, stubs,
                        new ImmutableArray<LocalVariable>(),
                        new ImmutableHashMap<String, Variable>())
                var expr, messages := new ASTGenerator().convertExpression(
                        context, initialValue)
                if expr != null {
                    def owner, submessages := typeMap.getType(
                            new PandaParser().parseType(cl.name,
                                    Position.INTERNAL), EMPTY_CONTEXT)
                    messages := addMessages(messages, submessages)
                    assert owner != null : messages->>(String)
                    fields.add(new FieldNode(f.position, owner->(ClassType), 
                            f.name, f.annotations, f.varType, 
                            expr.type.preferredVariableType, 
                            f.initialValue, f.tuplePosition))
                    updated := true
                }
                else {
                    fields.add(f)
                    remaining := true
                }
            }
            else
                fields.add(f)
        }
        if updated {
            return (new TypedClassStub(cl.position, cl.name, cl.isInterface, 
                cl.annotations, cl.lookupContext, cl.superclass, cl.interfaces,
                        cl.methods, fields, cl.invariants, cl.genericParameters, 
                        cl.isExternal), true, remaining, null)
        }
        return (cl, false, remaining, null)
    }

    method inferFieldTypes(var classes:CollectionView<TypedClassStub>):
            (CollectionView<TypedClassStub>, ListView<Message>?) {
        loop {
            var updated := false
            var remaining := false
            def newClasses := new Array<TypedClassStub>()
            for cl in classes {
                def newClass, newUpdated, newRemaining, messages :=
                        inferFieldTypes(cl)
                newClasses.add(newClass)
                updated |= newUpdated
                remaining |= newRemaining
            }
            classes := newClasses
            if !updated {
                if remaining
                    Console.writeLine("could not infer field types")
                return (classes, null)
            }
        }
    }

    @class
    method resolveTypes(classes:CollectionView<UntypedClassStub>):
            (CollectionView<TypedClassStub>, 
                TypeMap, StubMap, ListView<Message>?) {
        def result := new Array<TypedClassStub>()
        def newTypeMap := new TypeMap(classes)
        def stubs := new StubMap(newTypeMap)
        def t := new TypeResolver(newTypeMap, stubs)
        var messages:ListView<Message>? := null
        for cl in classes {
            def resolved, submessages := t.resolveTypes(cl)
            messages := addMessages(messages, submessages)
            result.add(resolved)
        }
        def finished, submessages := t.inferFieldTypes(result)
        messages := addMessages(messages, submessages)
        return (finished, t.typeMap, stubs, messages)
    }
}