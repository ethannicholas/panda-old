package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.stubs.UntypedClassStub
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.Type

class TypeMap : Immutable {
    @private
    constant DUMMY_CONTEXT := new LookupContext(new Array<String>(), 
            new HashMap<String, String>())

    @private
    constant CLASS_NAME := new PandaParser().parseType(class(Class).name, 
            Position.INTERNAL)

    @private
    def queue := new MessageQueue()

    constructor(stubs:CollectionView<UntypedClassStub>) {
        def immutableStubs := new ImmutableArray<UntypedClassStub>(stubs)
        Thread.start(method() {
            def typeMap := new MutableTypeMap(immutableStubs)
            loop {
                def message := queue.getMessage()
                if message-?>(Type) {
                    typeMap.putType(message->(Type))
                }
                else if message-?>((String, MessageQueue)) {
                    def command, replyTo := message->((String, MessageQueue))
                    assert command = "allTypes"
                    replyTo.post(typeMap.allTypes)
                }
                else {
                    def node, context, replyTo := 
                            message->((ParseNode, LookupContext, 
                                MessageQueue))
                    def type, messages := typeMap.getType(node, context)
                    def wrappedMessages:ImmutableArray<Message>?
                    if messages != null
                        wrappedMessages := new ImmutableArray<Message>(messages)
                    else
                        wrappedMessages := null
                    replyTo.post((type, wrappedMessages))
                }
            }
        }, false)
    }

    @self
    method getType(node:ParseNode, lookupContext:LookupContext):(Type?, ListView<Message>?) {
        def replyTo := Thread.currentThread().queue
        queue.post((node, lookupContext, replyTo))
        def type, messages := replyTo.getMessage()->((Type?, ImmutableArray<Message>?))
        return (type, messages)
    }

    method allTypes():ImmutableHashMap<String, Type> {
        def replyTo := Thread.currentThread().queue
        queue.post(("allTypes", replyTo))
        return replyTo.getMessage()->(ImmutableHashMap<String, Type>)
    }

    @self
    method CLASS():ClassType {
        def result, messages := getType(CLASS_NAME, DUMMY_CONTEXT)
        assert result != null & messages = null
        return result->(ClassType)
    }

    @self
    method putType(type:Type) {
        queue.post(type)
    }
 }
