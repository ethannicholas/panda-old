package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.compiler.IRGenerator
uses org.pandalanguage.pandac.compiler.CompilerSettings
uses org.pandalanguage.pandac.compiler.Dummy
uses org.pandalanguage.pandac.compiler.StubGenerator
uses org.pandalanguage.pandac.stubs.ClassStub 
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.MethodStub 
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Closure
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodReference
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.SkippedValue
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class CCodeGenerator (CodeGenerator) {
    constant POINTER_SIZE := 8

    @private
    constant SHARED_LINKAGE := "weak_odr"
    
    @private 
    constant CLASS_POINTER_INDEX := 0
    
    @private 
    constant ARRAY_CONTENTS_INDEX := 2

    -- index of the vtable within the class structure. Note that Class is 
    -- special and this information is spread between more locations than I
    -- would like; the vtable (and itable) are "special" fields programmatically
    -- added to the Class class here. The information shows up in a couple spots
    -- here in the LLVM output, and *also* shows up in the panda$core$Class.h 
    -- file generated by HeaderCodeGenerator (where the same extra fields are 
    -- added). All of these sources must agree with each other or nothing will 
    -- work.
    @private 
    constant VTABLE_INDEX := 6

    @private
    constant ITABLE_INDEX := 5

    @private
    constant METHOD_INDEX := 4

    @private
    constant MAX_C_VARARG_COUNT := 127

    @private
    constant FAIL_ASSERT_NAME := "panda$core$Panda$failAssert_class_panda$core$String$Z"

    def program:Program

    def debug := false

    var tempVariable := 0

    def variableNames := HashMap<Variable, String>()

    var currentBlockLabel:String := "0"

    def classes:MapView<String, ClassNode>

    def classConstants := HashMap<String, ClassConstant>()

    var nameCount:Int
    
    var charArrayCount := 0

    def stringConstants := HashMap<String, String>()

    def references := HashMap<Value, String>()

    def methodReferences := HashMap<MethodStub, String>()

    def loops := Stack<AbstractLoop>()

    def nextLabels := HashMap<AbstractLoop, String>()

    def endLabels := HashMap<AbstractLoop, String>()

    def declsBuffer := MemoryOutputStream()

    def decls := IndentedOutputStream(declsBuffer)

    def methodsBuffer := MemoryOutputStream()

    def methods := IndentedOutputStream(methodsBuffer)

    def stringsBuffer := MemoryOutputStream()

    def strings := IndentedOutputStream(stringsBuffer)

    def structsBuffer := MemoryOutputStream()

    def structs := IndentedOutputStream(structsBuffer)

    def shimsBuffer := MemoryOutputStream()

    def shims := IndentedOutputStream(shimsBuffer)

    def bodyBuffer := MemoryOutputStream()

    def body := IndentedOutputStream(bodyBuffer)

    def extraLocals := MemoryOutputStream()

    def methodNamer:MethodNamer

    var currentMethod:MethodNode?

    var context:Context

    def writtenStubs := HashSet<String>()

    def writtenTypes := HashSet<String>()

    def writtenMethods := HashSet<MethodStub>()

    def shimMap := HashMap<MethodStub, String>()

    def headerCodeGenerator:HeaderCodeGenerator

    init(p:Program, compilerSettings:CompilerSettings) {
        self.program := p
        def errors := FatalErrorReporter()
        self.context := IRGenerator(p.root, p.stubs, p.stubGenerator, 
                compilerSettings, errors).context
        self.classes := p.classes
        self.methodNamer := MethodNamer(context, 
                CMethodNamingStrategy())
        self.headerCodeGenerator := HeaderCodeGenerator(p, compilerSettings)
    }

    @protected
    method writeBody(text:String, comment:String) {
        body.write(text)
        if debug {
            body.write("; ")
            body.write(comment)
        }
        body.writeLine()
    }
    
    @override
    function defaultExtension():String? {
        return ".c"
    }

    @private
    method determineSize(t:Type):Int {
        if t.isPrimitive {
            return t.convert()->PrimitiveType.size
        }
        def stub := getStub(t.convert()->ClassType)
        var total := 0
        def sc := stub.superclass
        if sc != null {
            total += size(sc)
        }
        for field in stub.fields.filter(f => !f.annotations.isClass &
                !f.annotations.isThread & f.kind != Variable.Kind.PROPERTY) {
            def fieldSize:Int
            if field.type.isPrimitive {
                fieldSize := size(field.type)
            }
            else {
                fieldSize := POINTER_SIZE
            }
            def align := total % fieldSize
            if align != 0 {
                total += fieldSize - align
            }
            assert total % fieldSize = 0
            total += fieldSize
        }
        return total
    }

    @private
    def sizes := HashMap<Type, Int>()
    @private
    method size(t:Type):Int {
        var result := sizes[t]
        if result = null {
            result := determineSize(t)
            sizes[t] := result
        }
        return result
    }
    
    method getName(t:Type):String {
        return headerCodeGenerator.getName(t.unwrapGenerics)
    }

    method getCType(t:Type):String {
        return headerCodeGenerator.getCType(t.unwrapGenerics)
    }

    method getCMethodType(m:MethodStub):String {
        if m.base != null {
            return getCMethodType(m.base)
        }
        def result := MutableString()
        def returnType := m.returnType
        result.append(getCType(returnType))
        result.append(" (*)(")
        def parameters := m.parameters
        var first := true
        if !m.annotations.isClass {
            first := false
            result.append(getSelfType(m))
        }
        for (i, p) in parameters.enumeration {
            if first {
                first := false
            }
            else {
                result.append(", ")
            }
            result.append(getCType(p.type))
        }
        result.append(")")
        return result.convert()
    }

    method getCMethodType(t:MethodType):String {
        def result := MutableString()
        def returnType := t.returnType
        result.append(getCType(returnType))
        result.append(" (*)(")
        def parameters := t.methodParameters
        for (i, p) in parameters.enumeration {
            if i > 0 {
                result.append(", ")
            }
            result.append(getCType(p))
        }
        result.append(")")
        return result.convert()
    }

    method getSelfType(m:MethodStub):String {
        if m.annotations.isWrapperMethod {
            return getCType(m.owner.convert()->PrimitiveType)
        }
        return getCType(m.owner)
    }

    @protected
    method getTempVariable():String {
        def result := "%" + tempVariable
        tempVariable += 1
        return result
    }

    @private
    def nameCache := HashMap<ClassStub, String>()
    @private
    function getName(cl:ClassStub):String {
        var result := nameCache[cl]
        if result = null {
            result := MethodNamer.escapeTypeName(cl.name)
            nameCache[cl] := result
        }
        return result
    }

    @private
    function getName(f:FieldNode):String {
        return headerCodeGenerator.getName(f)
    }

    @private
    method getName(m:MethodNode):String {
        return getName(m.stub)
    }

    @private
    method getName(m:MethodStub):String {
        if m.base != null {
            return getName(m.base)
        }
        return methodNamer.getName(m)
    }

    @private
    method getName(v:Variable):String {
        var result := variableNames[v]
        if result = null {
            if v-?>FieldNode {
                def field := v->FieldNode
                def name := getName(getStub(field.owner)) + "$" + v.name
                if field.annotations.isClass {
                    result := "class_" + name
                }
                else {
                    result := name
                }
            }
            else {
                result := "$" + v.name
            }
            if v-?>LocalVariable {
                result += variableNames.count
            }
            variableNames[v] := result
        }
        return result
    }

    @private
    function getClass(cl:ClassType):ClassNode {
        return classes[cl.name]->ClassNode
    }

    @private
    method getStub(cl:ClassType):ClassStub {
        def stub := context.getStub(cl.name)
        if !writtenStubs.contains(stub.name) {
            if program.classes[stub.name] != null & 
                    !stub.annotations.isUnspecified {
                generateClassCode(stub)
            }
        }
        return stub
    }

    @protected
    method createBlock(label:String, comment:String) {
        currentBlockLabel := label
        if debug {
            body.writeLine("; block: " + comment.replace("\n", "\n; (block cont) "))
        }
        body.writeLine(label + ":")
    }

    @protected
    function endsInBranch(s:Statement):Bit {
        if s-?>Return | s-?>Break | s-?>Continue {
            return true
        }
        if s-?>Block {
            return s->Block.endsInBranch()
        }
        return false
    }
    
    @protected
    method createLabel():String {
        nameCount += 1
        return "$label" + nameCount
    }

    @private
    constant DIGITS := /\d+/
    @private
    function isConstant(expr:String):Bit {
        return expr.startsWith("%") | expr.matches(DIGITS)
    }

    @protected
    method createCommandReference(codeString:String, comment:String):String {
        if isConstant(codeString) {
            return codeString
        }
        def result := getTempVariable()
        writeBody(result + " = " + codeString, comment)
        return result
    }

    @private
    function unwrapUnspecified(m:MethodStub):MethodStub {
        def stub := getStub(m.owner)
        if stub.annotations.isUnspecified {
            def base := m.owner->GenericType.base
            def args := Array<Type>()
            for (_, type) in getStub(base).genericParameters {
                if type != null {
                    args.add(type)
                }
                else {
                    args.add(NullableType.ANY)
                }
            }
            def specified := GenericType(base, args)
            return getStub(specified).methods[stub.methods.indexOf(m)]
        }
        return m
    }

    @protected
    method writeConstruct(construct:Construct) {
        def m := construct.initCall.methodStub
        body.write("new_\{getName(unwrapUnspecified(m))}(")
        for (i, p) in construct.initCall.parameters.enumeration {
            if i != 0 {
                body.write(", ")
            }
            writeValue(p)
        }
        body.write(")")
    }


    @protected
    function getMethodIndex(var m:MethodStub):Int {
        m := m.unwrapped
        for (i, m2) in m.owner.virtualMethods(context).enumeration {
            if m = m2.unwrapped {
                return i
            }
        }
        unreachable : "\{m} not found in class \{m.owner.name} (\{m.owner.virtualMethods(context)})"
    }

    ============================================================================
    Workaround for a difficulty calling virutal methods in C. Suppose we compile 
    the Panda code `getFoo().bar()`. We have to call `getFoo()`, then look up a
    virtual method in the return value, and then call that virtual method with
    the return value as a parameter. Using the return value twice in the space 
    of a single expression is problematic in C because the evaluation order is
    undefined, so we can't rely on being able to stick the value in a temporary
    value (as we do with ReusedValues) because the variable might be used before
    the expression that assigns it is evaluated.

    The best workaround I have been able to come up with so far is to shim the
    methods, so that I can call the shim and the shim can then use the value
    twice. This is obviously less than ideal, but should be acceptable as C 
    output is used only for bootstrapping.
    ============================================================================
    @protected
    method getVirtualShim(m:MethodStub):String {
        var result := shimMap[m]
        if result = null {
            result := "$vshim" + nameCount
            nameCount += 1
            shimMap[m] := result
            shims.write("/* \{m} */")
            shims.write("\{getCType(m.returnType)} \{result}(")
            shims.write("\{getCType(m.owner)} $self")
            for (i, p) in m.parameters.enumeration {
                shims.write(", \{getCType(p.type)} param\{i}")
            }
            shims.writeLine(") {")
            shims.write("    ")
            if m.returnType != VoidType.VOID {
                shims.write("return ")
            }
            def index := getMethodIndex(m)
            shims.write("((\{getCMethodType(m)}) $self->cl->vtable[\{index}])($self")
            for i in 0 .. m.parameters.count {
                shims.write(", param\{i}")
            }
            shims.writeLine(");")
            shims.writeLine("}")
        }
        return result
    }

    ============================================================================
    See getVirtualShim for an explanation.
    ============================================================================
    @protected
    method getInterfaceShim(var m:MethodStub):String {
        m := m.unwrapped
        var result := shimMap[m]
        if result = null {
            result := "$ishim" + nameCount
            nameCount += 1
            shimMap[m] := result
            shims.write("/* \{m} */")
            shims.write("\{getCType(m.returnType)} \{result}(")
            shims.write("\{getCType(m.owner)} $self")
            for (i, p) in m.parameters.enumeration {
                shims.write(", \{getCType(p.type)} param\{i}")
            }
            shims.writeLine(") {")
            shims.write("    ")
            if m.returnType != VoidType.VOID {
                shims.write("return ")
            }
            def index := getMethodIndex(m)
            shims.write("((\{getCMethodType(m)}) pandaGetInterfaceMethod(" +
                    "(\{getCType(ClassType.OBJECT)}) $self, " +
                    "(\{getCType(ClassType.CLASS)}) &\{getClassConstantName(getStub(m.owner.unwrapGenerics->ClassType))}, " +
                    "\{index}))($self")
            for i in 0 .. m.parameters.count {
                shims.write(", param\{i}")
            }
            shims.writeLine(");")
            shims.writeLine("}")
        }
        return result
    }

    @protected
    method writeMethodCall(mc:MethodCall) {
        def m := mc.methodStub
        if program.isEffectivelyVirtual(m) & 
                IRGenerator.unwrapCast(mc.target)-!>Super {
            assert !m.annotations.isClass : "expected method not to be @class"
            def classStub := getStub(mc.target.type.convert()->ClassType)
            if classStub.kind = ClassStub.Kind.INTERFACE {
                body.write(getInterfaceShim(m))
            }
            else {
                body.write(getVirtualShim(m))
            }
        }
        else {
            body.write(getName(m))
        }

        body.write("(")
        def parameters := mc.parameters
        if !m.annotations.isClass {
            writeValue(mc.target)
            if parameters.count > 0 {
                body.write(", ")
            }
        }
        for (i, p) in parameters.enumeration {
            if i > 0 {
                body.write(", ")
            }
            writeValue(p)
        }
        body.writeLine(")")
    }

    @protected
    method writeVariableAssignment(va:VariableAssignment) {
        var variable := va.variable
        body.write("(")
        body.write(getName(va.variable))
        body.write(" = ")
        writeValue(va.value)
        body.write(")")
    }
    
    @protected
    method getClassConstant(cl:ClassStub):ClassConstant {
        return ClassConstant("<classConstant:\{cl.name}>", "<classConstant:\{cl.name}>", [])
    }

    @private
    method writeStringConstant(s:String) {
        body.write("pandaNewString(\{s.format("panda")}, \{s.length})")
    }

    @private
    method writeBinaryOperation(b:BinaryOperation, op:String) {
        body.write("(")
        writeValue(b.left)
        body.write(op)
        writeValue(b.right)
        body.write(")")
    }
    
    method writePrimitiveArrayIndexValue(iv:PrimitiveArrayIndexValue) {
        writeValue(iv.array)
        body.write("->contents[")
        writeValue(iv.index)
        body.write("]")
    }

    method writeUnaryOperation(u:UnaryOperation) {
        switch u.kind {
            case UnaryOperation.Kind.MINUS: {
                body.write("-")
                writeValue(u.operand)
            }
            case UnaryOperation.Kind.NOT: {
                body.write("!")
                writeValue(u.operand)
            }
            case UnaryOperation.Kind.BITWISE_NOT: {
                body.write("~")
                writeValue(u.operand)
            }
            default: unreachable
        }
    }

    method writeNewPrimitiveArrayWithLength(na:NewPrimitiveArrayWithLength) {
        def arrayType := na.type->PrimitiveArrayType
        def arrayClass := getStub(arrayType)
        def cc := getClassConstantName(arrayClass)
        body.write("(\{getCType(na.type)}) pandaNewPrimitiveArrayWithLength(" +
                "(\{getCType(ClassType.CLASS)}) &\{cc}, ")
        writeValue(na.arrayLength)
        body.write(", \{size(arrayType.elementType)}, true)")
    }
    
    method writePrimitiveArrayCopy(na:PrimitiveArrayCopy) {
        def arrayType := na.type->PrimitiveArrayType
        def arrayClass := getStub(arrayType)
        def cc := getClassConstantName(arrayClass)
        body.write("(\{getCType(na.type)}) pandaNewPrimitiveArrayCopy(" +
                "(\{getCType(ClassType.CLASS)}) &\{cc}, ")
        body.write("(PrimitiveArray*) ")
        writeValue(na.array)
        body.write(", \{size(arrayType.elementType)}, true)")
    }
    
    function getClassConstantName(cl:ClassStub):String {
        return getName(cl) + "_class"
    }

    function getClassConstantName(cl:ClassType):String {
        return getName(cl) + "_class"
    }

    method writeNewPrimitiveArrayWithValues(na:NewPrimitiveArrayWithValues) {
        if na.values.count > MAX_C_VARARG_COUNT {
            -- too many values to call pandaNewPrimitiveArrayWithValues directly
            def temp := "$temp\{nameCount}"
            extraLocals.writeLine("\{getCType(na.type)} \{temp};")
            nameCount += 1
            def arrayType := na.type->PrimitiveArrayType
            def arrayClass := getStub(arrayType)
            def cc := getClassConstantName(arrayClass)
            body.write("(\{temp} = (\{getCType(na.type)}) " +
                "pandaNewPrimitiveArrayWithLength(" +
                "(\{getCType(ClassType.CLASS)}) &\{cc}, \{na.values.count}, " +
                "\{size(arrayType.elementType)}, true)")
            for (i, v) in na.values.enumeration {
                body.write(", \{temp}->contents[\{i}] = ")
                writeValue(v)
            }
            body.write(", \{temp})")
            return
        }
        def elementType := na.type->PrimitiveArrayType.elementType
        def arrayClass := getStub(na.type->PrimitiveArrayType)
        def cc := getClassConstantName(arrayClass)
        def type:Int
        constant ARRAY_INT8   := 0
        constant ARRAY_INT16  := 1
        constant ARRAY_INT32  := 2
        constant ARRAY_INT64  := 3
        constant ARRAY_REAL32 := 4
        constant ARRAY_REAL64 := 5
        constant ARRAY_PTR    := 6
        switch elementType {
            case IntType.INT8, IntType.UINT8, BitType.BIT: 
                type := ARRAY_INT8

            case IntType.INT16, IntType.UINT16, CharType.CHAR: 
                type := ARRAY_INT16

            case IntType.INT32, IntType.UINT32: 
                type := ARRAY_INT32

            case IntType.INT64, IntType.UINT64: 
                type := ARRAY_INT64

            case RealType.REAL32: 
                type := ARRAY_REAL32

            case RealType.REAL64: 
                type := ARRAY_REAL64

            default:
                type := ARRAY_PTR
        }
        body.write("(\{getCType(na.type)}) pandaNewPrimitiveArrayWithValues(" +
                "(\{getCType(ClassType.CLASS)}) &\{cc}, \{na.values.count}, " +
                type)
        for v in na.values {
            body.write(", ")
            writeValue(v)
        }
        body.write(")")
    }

    @protected
    method writeBinaryOperation(b:BinaryOperation) {
        switch b.kind {
            case BinaryOperation.Kind.ADD: 
                writeBinaryOperation(b, "+")
            case BinaryOperation.Kind.SUBTRACT:
                writeBinaryOperation(b, "-")
            case BinaryOperation.Kind.MULTIPLY: 
                writeBinaryOperation(b, "*")
            case BinaryOperation.Kind.DIVIDE: 
                writeBinaryOperation(b, "/")
            case BinaryOperation.Kind.INT_DIVIDE:
                writeBinaryOperation(b, "/")
            case BinaryOperation.Kind.REMAINDER: 
                writeBinaryOperation(b, "%")
            case BinaryOperation.Kind.SHIFT_LEFT: 
                writeBinaryOperation(b, "<<")
            case BinaryOperation.Kind.SHIFT_RIGHT:
                writeBinaryOperation(b, ">>")
            case BinaryOperation.Kind.AND: 
                writeBinaryOperation(b, "&&")
            case BinaryOperation.Kind.OR:
                writeBinaryOperation(b, "||")
            case BinaryOperation.Kind.XOR: 
                writeBinaryOperation(b, "^")
            case BinaryOperation.Kind.BITWISE_AND: 
                writeBinaryOperation(b, "&")
            case BinaryOperation.Kind.BITWISE_OR: 
                writeBinaryOperation(b, "|")
            case BinaryOperation.Kind.BITWISE_XOR: 
                writeBinaryOperation(b, "^")
            case BinaryOperation.Kind.EQUAL: 
                writeBinaryOperation(b, "==")
            case BinaryOperation.Kind.IDENTITY: 
                writeBinaryOperation(b, "==")
            case BinaryOperation.Kind.LESS_THAN:
                writeBinaryOperation(b, "<")
            case BinaryOperation.Kind.GREATER_THAN:
                writeBinaryOperation(b, ">")
            case BinaryOperation.Kind.LESS_THAN_OR_EQUAL:
                writeBinaryOperation(b, "<=")
            case BinaryOperation.Kind.GREATER_THAN_OR_EQUAL:
                writeBinaryOperation(b, ">=")
            case BinaryOperation.Kind.NOT_EQUAL:
                writeBinaryOperation(b, "!=")
            case BinaryOperation.Kind.NOT_IDENTITY:
                writeBinaryOperation(b, "!=")
            default:
                Console.writeLine("no support for binary operation \{b.kind}")
                unreachable
        }
    }

    @private
    method callClassInit(cl:ClassStub) {
        if currentMethod->MethodNode.stub.name = MethodNode.CLASS_INIT_NAME &
                currentMethod->MethodNode.stub.owner = cl.type {
            return
        }
        def classInit := cl.methods.filter(
                m => m.name = MethodNode.CLASS_INIT_NAME)
        assert classInit.count = 1 : "expected exactly one method named " +
                "'\{MethodNode.CLASS_INIT_NAME} in \{cl}, found " +
                classInit.count
        def stub := classInit.iterator.next()
        extraLocals.writeLine("\{getName(stub)}();")
        -- FIXME deal with duplicates
        writeMethodDeclaration(stub, methods)
        methods.writeLine(";")
        program.liveMethods.add(stub)
    }

    @protected
    method writeFieldReference(fr:FieldReference) {
        if fr.field.annotations.isThread {
            def owner := fr.field.owner
            callClassInit(getStub(owner))
            var type := fr.type
            def suffix:String
            if type.isPrimitive {
                suffix := fr.type.name["panda.core.".length..]
            }
            else {
                suffix := "Object"
                type := ClassType.OBJECT
            }

            def symbolTable := context.getSymbolTable(owner)
            def indexField := symbolTable[fr.field.name + 
                    StubGenerator.INDEX_SUFFIX]->FieldNode
            def stub := getStub(ClassType.PANDA).symbols["getThreadLocal" + 
                    suffix]->Methods.entries[0]
            body.write("((\{getCType(fr.type)}) \{getName(stub)}(")
            body.write("class_\{getName(fr.field.owner)}$\{getName(indexField)}")
            program.liveMethods.add(stub)
            def initializer := symbolTable[
                        IRGenerator.getThreadLocalInitializerName(fr.field)
                    ]->Methods?
            if initializer != null {
                body.write(", \{getName(initializer.entries[0])}")
                program.liveMethods.add(initializer.entries[0])
            }
            else {
                body.write(", null") -- no initializer function
            }
            body.write("))")
            return
        }
        if fr.field.annotations.isClass {
            if fr.field.name != FieldNode.CLASS_INITED_NAME {
                callClassInit(getStub(fr.field.owner))
            }
            body.write("class_\{getName(fr.field.owner)}$\{getName(fr.field)}")
        }
        else {
            writeValue(fr.object)
            body.write("->\{getName(fr.field)}")
        }
    }

    @protected
    method writeCast(c:Cast) {
        body.write("((\{getCType(c.type)}) ")
        writeValue(c.value)
        body.write(")")
    }
    
    @protected
    method writeVariableReference(vr:VariableReference) {
        body.write(getName(vr.variable))
    }
        
    @protected
    method writeSuperReference(s:Super) {
        body.write("$self")
    }

    @protected
    method writeReusedValueDefinition(rvd:ReusedValueDefinition) {
        def name := "$reused" + nameCount
        nameCount += 1
        references[rvd] := name
        body.write("(\{name} = ")
        writeValue(rvd.value)
        body.write(")")
        extraLocals.writeLine("\{getCType(rvd.type)} \{name};")
    }

    @protected
    method writeReusedValue(rv:ReusedValue) {
        def result := references[rv.owner]
        assert result != null : "null reference for ReusedValue owner " + rv
        body.write(result)
    }
    
    @protected
    method createMethodReference(m:MethodReference):String? {
        def stub := m.methodStub
        var methodValue := methodReferences[stub]
        if methodValue = null {
            methodValue := "@" + getName(stub) + "_value"
            def methodClass := m.type.convert()->ClassType
            def cc := getClassConstant(getStub(methodClass))
            shims.writeLine("\{methodValue} = private unnamed_addr " +
                    "constant %\{getName(getStub(methodClass))} { " + 
                    "\{getCType(ClassType.CLASS)} bitcast6(\{cc.type}" + 
                    "* @\{cc.name} to \{getCType(ClassType.CLASS)}" + 
                    "), i8* bitcast7(\{getCMethodType(stub)} @" + 
                    "\{getName(stub)} to i8*) }, " +
                    "align \{POINTER_SIZE}")
            methodReferences[stub] := methodValue
        }
        return methodValue
    }

    @protected
    method writeDynamicCall(d:DynamicCall) {
        -- the "real" type of the method includes a reference to the method 
        -- object before the formal parameters
        def baseType := d.methodValue.type.convert()->MethodType
        def realParameters := Array<Type>()
        realParameters.add(baseType)
        realParameters.addAll(baseType.methodParameters)
        def realType := MethodType(realParameters, baseType.returnType, 
                baseType.isMethod, baseType.immutableMethod)
        body.write("((\{getCMethodType(realType)}) " +
                "((\{getCType(ClassType.OBJECT)})")
        writeValue(d.methodValue)
        body.write(")->cl->vtable[\{METHOD_INDEX}])(")
        Console.writeLine("HACK, NEED SHIM OF SOME KIND")
        writeValue(d.methodValue)
        for p in d.parameters {
            body.write(", ")
            writeValue(p)
        }
        body.write(")")
    }

    @protected
    method writeClassLiteral(cl:ClassLiteral) {
        def cc := getClassConstantName(getStub(cl.value.unwrapGenerics->ClassType))
        def classType := getCType(ClassType.CLASS)
        body.write("((\{classType}) &\{cc})")
    }

    @protected
    method writeClosureReference(c:Closure) {
        def cast := Cast(c.position, c.instance, c.type, Cast.Kind.IMPLICIT)
        cast.safe := true
        writeCast(cast)
    }

    @protected
    method writeSkippedValue(s:SkippedValue) {
        body.write("(")
        writeValue(s.discardedValue)
        body.write(", ")
        writeValue(s.actualValue)
        body.write(")")
    }

    @protected
    method getReference(v:Value):String? {
        return "<broken:\{v.class.name}>"
    }

    @protected
    method writeValue(v:Value) {
        switch v.class {
            case VariableAssignment: writeVariableAssignment(v->VariableAssignment)
            case UnaryOperation: writeUnaryOperation(v->UnaryOperation)
            case BinaryOperation: writeBinaryOperation(v->BinaryOperation)
            case Construct: writeConstruct(v->Construct)
            case MethodCall: writeMethodCall(v->MethodCall)
            case StringLiteral: writeStringConstant(v->StringLiteral.value)
            case IntegerLiteral: body.write(v->IntegerLiteral.value.convert()->String)
            case RealLiteral: body.write(v->RealLiteral.value.convert()->String)
            case VariableReference: writeVariableReference(v->VariableReference)
            case FieldReference: writeFieldReference(v->FieldReference)
            case Cast: writeCast(v->Cast)
            case BitLiteral: body.write(v->BitLiteral.value.convert()->String)
            case NewPrimitiveArrayWithLength: writeNewPrimitiveArrayWithLength(v->NewPrimitiveArrayWithLength)
            case PrimitiveArrayCopy: writePrimitiveArrayCopy(v->PrimitiveArrayCopy)
            case NewPrimitiveArrayWithValues: writeNewPrimitiveArrayWithValues(v->NewPrimitiveArrayWithValues)
            case PrimitiveArrayIndexValue: writePrimitiveArrayIndexValue(v->PrimitiveArrayIndexValue)
            case NullLiteral: body.write("NULL")
            case ClassLiteral: writeClassLiteral(v->ClassLiteral)
            case Unwrap: writeValue(v->Unwrap.value)
            case MethodReference: body.write("<method>")
            case DynamicCall: writeDynamicCall(v->DynamicCall)
            case ReusedValueDefinition: writeReusedValueDefinition(v->ReusedValueDefinition)
            case ReusedValue: writeReusedValue(v->ReusedValue) 
            case Super: writeSuperReference(v->Super)
            case Closure: writeClosureReference(v->Closure)
            case SkippedValue: writeSkippedValue(v->SkippedValue)
            default:
                throw CompilerException("unsupported value class: " + 
                        "\{v.class.name}: \{v}", v.position)
        }
    }

    @protected
    method generateValueStatementCode(v:ValueStatement) {
        writeValue(v.value)
        body.writeLine(";")
    }

    @protected
    method generatePrimitiveArrayIndexAssignmentCode(ia:PrimitiveArrayIndexAssignment) {
        writeValue(ia.array)
        body.write("->contents[")
        writeValue(ia.index)
        body.write("] = ")
        writeValue(ia.value)
        body.writeLine(";")
    }
    
    @protected
    method generateFieldAssignmentCode(fa:FieldAssignment) {
        if !fa.fieldNode.annotations.isThread {
            if fa.fieldNode.annotations.isClass {
                if fa.fieldNode.name != FieldNode.CLASS_INITED_NAME {
                    callClassInit(getStub(fa.fieldNode.owner))
                }
                body.write("class_\{getName(fa.fieldNode.owner)}$\{getName(fa.fieldNode)}")
            }
            else {
                writeValue(fa.object)
                body.write("->\{getName(fa.fieldNode)}")
            }
            body.write(" = ")
            writeValue(fa.value)
            body.writeLine(";")
        }
        else {
            def owner := getStub(fa.fieldNode.owner)
            callClassInit(owner)
            def indexField := owner.symbols[fa.fieldNode.name + 
                    StubGenerator.INDEX_SUFFIX]->Variable
            var suffix:String
            if fa.value.type.isPrimitive {
                suffix := fa.value.type.name["panda.core.".length..]
            }
            else {
                suffix := "Object"
            }
            def stub := getStub(ClassType.PANDA).symbols["setThreadLocal" + 
                    suffix]->Methods.entries[0]
            body.write("\{getName(stub)}(\{getName(indexField)}, ")
            writeValue(fa.value)
            body.writeLine(");")
            return
        }
    }

    @protected
    method generateIfCode(i:If) {
        body.write("if (")
        writeValue(i.test)
        body.write(") ")
        generateStatementCode(i.thenStatement)
        if i.elseStatement != null {
            body.write(" else ")
            generateStatementCode(i.elseStatement)
        }
    }

    @protected
    method generateReturnCode(ret:Return) {
        body.write("return")
        if ret.value != null {
            body.write(" ")
            writeValue(ret.value)
        }
        body.writeLine(";")
    }
    
    @protected
    method generateWhileCode(w:While) {
        if w.label != null {
            body.write(w.label + ": ")
        }
        body.write("while (")
        writeValue(w.test)
        body.write(") ")
        generateStatementCode(w.statement)
        if w.label != null {
            body.write(w.label + "$end:;")
        }
    }

    @protected
    method generateDoCode(d:Do) {
        if d.label != null {
            body.write(d.label + ": ")
        }
        body.write("do ")
        generateStatementCode(d.statement)
        body.write("while (")
        writeValue(d.test)
        body.writeLine(");")
        if d.label != null {
            body.write(d.label + "$end:;")
        }
    }

    @protected
    method generateLoopCode(l:Loop) {
        if l.label != null {
            body.write(l.label + ": ")
        }
        body.write("for (;;) ")
        generateStatementCode(l.statement)
        if l.label != null {
            body.write(l.label + "$end:;")
        }
    }

    @protected
    method generateLoopWithContinueBlockCode(l:LoopWithContinueBlock) {
        def startLabel := createLabel()
        body.writeLine("{")
        body.write("goto \{startLabel};")
        if l.label != null {
            body.write(l.label + ": ")
        }
        body.write("for (;;) {")
        generateStatementCode(l.continueBlock)
        body.write("\{startLabel}:")
        generateStatementCode(l.statement)
        body.write("}")
        if l.label != null {
            body.write(l.label + "$end:;")
        }
        body.writeLine("}")
    }

    @protected
    method generateBreakCode(br:Break) {
        if br.label != null {
            body.writeLine("goto \{br.label}$end;")
        }
        else {
            body.writeLine("break;")
        }
    }

    @protected
    method generateContinueCode(c:Continue) {
        if c.label != null {
            body.writeLine("goto \{c.label};")
        }
        else {
            body.writeLine("continue;")
        }
    }

    @protected
    method generateAssertCode(a:Assert) {
        body.writeLine("if (!")
        writeValue(a.test)
        body.writeLine(") {")
        var error := a.error
        if error != null {
            if error.type = ClassType.STRING {
                body.write("\{FAIL_ASSERT_NAME}(")
                writeValue(error)
                body.writeLine(");")
                body.writeLine("abort();")
            }
            else {
                assert error.type = ClassType.ERROR : 
                        "expected msg.type = ERROR but found \{error.type}"
                body.write("pandaThrow(")
                writeValue(error)
                body.writeLine(");")
                body.writeLine("abort();")
            }
        }
        else {
            body.writeLine("\{FAIL_ASSERT_NAME}(NULL);")
            body.writeLine("abort();")
        }
        body.writeLine("}")
    }
    
    @protected
    method generateUnreachableCode(u:Unreachable) {
        generateAssertCode(Assert(u.position, BitLiteral(u.position, false),
                u.error))
    }

    @protected
    method generateTryCode(t:Try) {
        generateStatementCode(t.statement)
    }

    @protected
    method generateThrowCode(t:Throw) {
        body.writeLine("{")
        body.write("pandaThrow(")
        writeValue(t.error)
        body.writeLine(");")
        body.writeLine("abort();")
        body.writeLine("}")
    }

    @protected
    method generateStatementCode(s:Statement) {
        if debug {
            body.writeLine("; statement:" + s.convert().replace("\n", "\n; (statement cont) "))
        }
        switch s.class {
            case PrimitiveArrayIndexAssignment: 
                    generatePrimitiveArrayIndexAssignmentCode(s->PrimitiveArrayIndexAssignment)
            case FieldAssignment: 
                    generateFieldAssignmentCode(s->FieldAssignment)
            case ValueStatement:
                    generateValueStatementCode(s->ValueStatement)
            case If: generateIfCode(s->If)
            case While: generateWhileCode(s->While)
            case Do: generateDoCode(s->Do)
            case Loop: generateLoopCode(s->Loop)
            case LoopWithContinueBlock: 
                    generateLoopWithContinueBlockCode(
                        s->LoopWithContinueBlock)
            case Block: generateBlockCode(s->Block)
            case Return: generateReturnCode(s->Return)
            case Break: generateBreakCode(s->Break)
            case Continue: generateContinueCode(s->Continue)
            case Assert: generateAssertCode(s->Assert)
            case Throw: generateThrowCode(s->Throw)
            case Try: generateTryCode(s->Try)
            case Unreachable: generateUnreachableCode(s->Unreachable)
            default: 
                throw InternalCompilerException("unsupported statement: " + 
                        s, s.position)
        }
    }

    @protected
    method generateBlockCode(b:Block) {
        body.writeLine("{")
        for s in b.statements {
            generateStatementCode(s)
        }
        body.writeLine("}")
    }

    @protected
    method getDefaultValue(f:FieldNode):String {
        def type := f.type
        if type.isInteger | type = CharType.CHAR {
            return "0"
        }
        else if type.isReal {
            return "0.0"
        }
        else if type = BitType.BIT {
            return "false"
        }
        else {
            return "NULL"
        }
    }

    @protected
    method writeClassInitializers() {
-*        for (_, cl) in context.classes {
            def classInit := cl.methods.filter(
                    m => m.stub.name = MethodNode.CLASS_INIT_NAME)
            if classInit.count = 0
                continue
            def stub := classInit.iterator.next()
            program.liveMethods.add(stub)
            call("fastcc void @\{getName(stub)}()")
        }*-
    }

    method writeMethodDeclaration(m:MethodStub, parameterNames:Array<String>,
            out:OutputStream) {
        out.write(getCType(m.returnType) + " \{getName(m)}(")
        var first := true
        if !m.annotations.isClass {
            out.write("\{getSelfType(m)} $self")
            first := false
        }
        for (i, p) in m.parameters.enumeration {
            if first {
                first := false
            }
            else {
                out.write(", ")
            }
            out.write(getCType(p.type))
            out.write(" ") 
            out.write(parameterNames[i])
        }
        out.write(")")
    }

    method writeMethodDeclaration(m:MethodStub, out:OutputStream) {
        def names := Array<String>()
        for p in m.parameters {
            names.add("$" + p.name)
        }
        writeMethodDeclaration(m, names, out)
    }

    method writeMethodDeclaration(m:MethodNode, out:OutputStream) {
        def names := Array<String>()
        for p in m.parameters {
            names.add(getName(p))
        }
        writeMethodDeclaration(m.stub, names, out)
    }

    @protected
    method generateMethodCode(m:MethodNode) {
        assert currentMethod = null
        if writtenMethods.contains(m.stub) {
            return
        }
        writtenMethods.add(m.stub)
        if m.stub.annotations.isAbstract {
            return
        }
        currentMethod := m
        body.writeLine()
        writeMethodDeclaration(m.stub, body)
        body.writeLine(" {")
        body.level += 1
        if m.stub.name = MethodNode.MAIN_NAME {
            writeClassInitializers()
        }
        for v in m.localVariables {
            body.writeLine("\{getCType(v.type)} \{getName(v)};")
        }

        def block := m.body
        def oldBody := body
        def newBuffer := MemoryOutputStream()
        body := IndentedOutputStream(newBuffer)
        generateBlockCode(block)
        oldBody.write(extraLocals)
        extraLocals.reset()
        oldBody.write(newBuffer)
        body := oldBody
        body.level -= 1
        body.writeLine("}")
        currentMethod := null
        if m.stub.kind = MethodStub.Kind.INIT {
            methods.write(getCType(m.stub.owner) + " new_\{getName(m)}(")
            for (i, p) in m.parameters.enumeration {
                if i > 0 {
                    methods.write(", ")
                }
                methods.write("\{getCType(p.type)} $param\{i}") 
            }
            methods.writeLine(");")
            body.write(getCType(m.stub.owner) + " new_\{getName(m)}(")
            for (i, p) in m.parameters.enumeration {
                if i > 0 {
                    body.write(", ")
                }
                body.write("\{getCType(p.type)} $param\{i}") 
            }
            body.writeLine(") {")
            body.writeLine("\{getCType(m.stub.owner)} result = pandaNew(\{getName(m.stub.owner)});")
            body.write("\{getName(m.stub)}(result")
            for (i, p) in m.parameters.enumeration {
                body.write(", $param\{i}")
            }
            body.writeLine(");")
            body.writeLine("return result;")
            body.writeLine("}")
        }
    }

    method getStringStruct(s:String):String {
        def chars := "$chars" + nameCount
        nameCount += 1
        strings.write("Char \{chars}[] = {")
        var separator := ""
        for c in s.chars {
            strings.write(separator + c.convert()->Int)
            separator := ", "
        }
        strings.writeLine("};")
        def ca := "$ca" + nameCount
        nameCount += 1
        def arrayClass := getStub(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
        strings.writeLine("\{getName(arrayClass)} \{ca} = { .cl = &\{getClassConstantName(arrayClass)}, " +
                ".$length = \{s.length}, " +
                ".contents = \{chars} };")
        def s := "$s" + nameCount
        nameCount += 1
        def stringClass := getStub(ClassType.STRING)
        strings.writeLine("\{getName(stringClass)} \{s} = { .cl = &\{getClassConstantName(stringClass)}, " +
                ".chars = &\{ca} };")
        return "&" + s
    }

    method generateClassCode(cl:ClassStub) {
        writtenStubs.add(cl.name)
        getStub(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
        getStub(ClassType.STRING)
        if cl.superclass != null {
            getStub(cl.superclass)
        }
        assert !cl.annotations.isUnspecified
        def name := getName(cl)
        def classStub := getStub(ClassType.CLASS)
        decls.writeLine("typedef struct \{name} \{name};")
        for intf in cl.type.allInterfaces(context) {
            getStub(intf)
        }
--        structs.writeLine("#ifndef CLASS_\{getName(cl)}")
        headerCodeGenerator.generateClass(cl, false, structs)
        var itable := "NULL"
        for intf in cl.type.allInterfaces(context) {
            if intf.name = cl.name {
                continue
            }
            def intfStub := getStub(intf)
            def next := "$itable" + nameCount
            nameCount += 1
            structs.writeLine("itable \{next} = {")
            structs.writeLine("    .cl = (Class*) &\{getClassConstantName(intfStub)},")
            structs.writeLine("    .next = \{itable},")
            structs.writeLine("    .methods = {")
            var separator := ""
            for m in cl.type.interfaceMethods(intf, context) {
                structs.write(separator)
                separator := ", "
                if m.annotations.isAbstract {
                    structs.writeLine("NULL")
                }
                else {
                    structs.writeLine("&" + getName(m))
                    writeMethodDeclaration(m, methods)
                    methods.writeLine(";")
                }
            }
            structs.writeLine("    }")
            structs.writeLine("};")
            itable := "&" + next
        }
-*        structs.writeLine("struct {")
        structs.writeLine("    \{getCType(ClassType.CLASS)} cl;")
        structs.writeLine("    \{getCType(ClassType.STRING)} name;")
        structs.writeLine("    \{getCType(ClassType.CLASS)} superclass;")
        structs.writeLine("    \{getCType(BitType.BIT)} containsPointers;")
        structs.writeLine("    \{getCType(BitType.BIT)} overridesFinalize;")
        structs.writeLine("    struct itable* itables;")
        structs.writeLine("    void* vtable[];")
        structs.writeLine("} \{name}_class = {")*-
        structs.writeLine("panda$core$Class \{name}_class = {")
        structs.writeLine("    .cl = &\{getClassConstantName(classStub)},")
        structs.writeLine("    .name = \{getStringStruct(cl.name)}, ")
        structs.write("    .superclass = ")
        if (cl.superclass != null) {
            structs.writeLine("(Class*) &\{getClassConstantName(cl.superclass)},")
        }
        else {
            structs.writeLine("NULL,")
        }
        structs.writeLine(".containsPointers = true,")
        var overridesFinalize := false
        for m in cl.methods {
            if m.name = MethodNode.FINALIZE_NAME & 
                    !m.annotations.isClass & 
                    m.parameters.count = 1 {
                overridesFinalize := true
            }
        }
        structs.writeLine(".overridesFinalize = \{overridesFinalize},")
        structs.writeLine(".itables = \{itable},")
        structs.writeLine(".vtable = {")
        var separator := ""
        for m in cl.type.virtualMethods(context) {
            structs.write(separator)
            separator := ", "
            if m.annotations.isAbstract {
                structs.writeLine("NULL")
            }
            else {
                structs.writeLine("(void*) &" + getName(m))
                writeMethodDeclaration(m, methods)
                methods.writeLine(";")
            }
        }
        structs.writeLine("}")        
        structs.writeLine("};")
--        structs.writeLine("#endif")
    }

    method writeMethods() {
        var progress:Bit
        do {
            progress := false
            for (_, cl) in classes {
                for m in cl.methods {
                    if (context.compilerSettings.isLibrary | 
                            program.liveMethods.contains(m.stub)) & 
                            !writtenMethods.contains(m.stub) {
                        generateMethodCode(m)
                        progress := true
                    }
                }
            }
        }
        while progress
    }

    @override
    method generateCode(target:File) {
        for (_, cl) in classes {
            if !cl.stub.annotations.isUnspecified {
                if !writtenStubs.contains(cl.stub.name) {
                    generateClassCode(cl.stub)
                }
            }
        }
        writeMethods()

        def parent := target.parent()
        if parent = null {
            throw CompilerException("could not determine parent " +
                    "directory of " + target.path)
        }
        def out := BufferedOutputStream(target.openOutputStream())
        out.writeLine("#include \"pandalib.h\"")
        declsBuffer.sendTo(out)
        methodsBuffer.sendTo(out)
        stringsBuffer.sendTo(out)
        structsBuffer.sendTo(out)
        shimsBuffer.sendTo(out)
        bodyBuffer.sendTo(out)
        out.close()
    }
}