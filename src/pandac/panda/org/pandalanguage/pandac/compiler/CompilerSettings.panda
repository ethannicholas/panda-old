package org.pandalanguage.pandac.compiler

class CompilerSettings {
    @private
    constant QUEUE := new MessageQueue()

    @private
    constant SETTINGS_KEY := "CompilerSettings"

    @private
    constant OPTIMIZATION_KEY := "CompilerSettings.opimization"

    @private
    constant ASSERTIONS_KEY := "CompilerSettings.assertions"

    @private
    constant PRECONDITIONS_KEY := "CompilerSettings.preconditions"

    @private
    constant POSTCONDITIONS_KEY := "CompilerSettings.postconditions"

    @private
    constant INVARIANTS_KEY := "CompilerSettings.invariants"

    @private
    constant OVERFLOW_CHECKING_KEY := "CompilerSettings.overflowChecking"

    @private
    constant BOUNDS_CHECKING_KEY := "CompilerSettings.boundsChecking"

    @private
    constant CHECK_CASTS_KEY := "CompilerSettings.checkCasts"

    @private
    constant SEALED_KEY := "CompilerSettings.sealed"

    @private
    constant PRESERVE_TEMP_ARTIFACTS_KEY := "CompilerSettings.preserveTempArtifacts"

    @private
    constant LOAD_CORE_LIB_KEY := "CompilerSettings.loadCoreLib"

    @private
    constant NEW_BUILD_KEY := "CompilerSettings.newBuild"

    @private
    constant CODE_GENERATOR_KEY := "CompilerSettings.codeGenerator"

    @private
    constant SOURCES_KEY := "CompilerSettings.sources"

    @private
    constant LIBRARY_SEARCH_PATHS_KEY := "CompilerSettings.librarySearchPaths"

    @private
    constant LIBRARIES_KEY := "CompilerSettings.libraries"

    @private
    constant OBJECT_FILES_KEY := "CompilerSettings.objectFiles"

    @private
    constant MODULES_KEY := "CompilerSettings.modules"

    @private
    constant OUTPUT_KEY := "CompilerSettings.output"

    @private
    constant JAVAC_KEY := "CompilerSettings.javac"

    @private
    constant JAR_KEY := "CompilerSettings.java"

    @private
    @class
    function get(key:String):Immutable? {
        def map := Thread.context[SETTINGS_KEY]->(SharedMap)
        return map[key]->(Immutable?)
    }

    @private
    @class
    method set(key:String, value:Immutable?) {
        def map := Thread.context[SETTINGS_KEY]->(SharedMap)
        map[key] := value
    }

    @class
    function optimization():Bit {
        return get(OPTIMIZATION_KEY)->(Bit)
    }

    @class
    method setOptimization(optimization:Bit) {
        set(OPTIMIZATION_KEY, optimization)
    }
    
    @class
    function assertions():Bit {
        return get(ASSERTIONS_KEY)->(Bit)
    }
    
    @class
    method setAssertions(assertions:Bit) {
        set(ASSERTIONS_KEY, assertions)
    }
        
    @class
    function preconditions():Bit {
        return get(PRECONDITIONS_KEY)->(Bit)
    }
    
    @class
    method setPreconditions(preconditions:Bit) {
        set(PRECONDITIONS_KEY, preconditions)
    }

    @class
    function postconditions():Bit {
        return get(POSTCONDITIONS_KEY)->(Bit)
    }
    
    @class
    method setPostconditions(postconditions:Bit) {
        set(POSTCONDITIONS_KEY, postconditions)
    }
    
    @class
    function invariants():Bit {
        return get(INVARIANTS_KEY)->(Bit)
    }
    
    @class
    method setInvariants(invariants:Bit) {
        set(INVARIANTS_KEY, invariants)
    }

    @class
    function overflowChecking():Bit {
        return get(OVERFLOW_CHECKING_KEY)->(Bit)
    }
    
    @class
    method setOverflowChecking(overflowChecking:Bit) {
        set(OVERFLOW_CHECKING_KEY, overflowChecking)
    }

    @class
    function boundsChecking():Bit {
        return get(BOUNDS_CHECKING_KEY)->(Bit)
    }
    
    @class
    method setBoundsChecking(boundsChecking:Bit) {
        set(BOUNDS_CHECKING_KEY, boundsChecking)
    }

    @class
    function checkCasts():Bit {
        return get(CHECK_CASTS_KEY)->(Bit)
    }
    
    @class
    method setCheckCasts(checkCasts:Bit) {
        set(CHECK_CASTS_KEY, checkCasts)
    }
    
    @class
    function sealed():Bit {
        return get(SEALED_KEY)->(Bit)
    }
    
    @class
    method setSealed(sealed:Bit) {
        set(SEALED_KEY, sealed)
    }

    @class
    function loadCoreLib():Bit {
        return get(LOAD_CORE_LIB_KEY)->(Bit)
    }
    
    @class
    method setLoadCoreLib(loadCoreLib:Bit) {
        set(LOAD_CORE_LIB_KEY, loadCoreLib)
    }

    @class
    function preserveTempArtifacts():Bit {
        return get(PRESERVE_TEMP_ARTIFACTS_KEY)->(Bit)
    }
    
    @class
    method setPreserveTempArtifacts(newBuild:Bit) {
        set(PRESERVE_TEMP_ARTIFACTS_KEY, newBuild)
    }
    
    @class
    function newBuild():Bit {
        return get(NEW_BUILD_KEY)->(Bit)
    }
    
    @class
    method setNewBuild(newBuild:Bit) {
        set(NEW_BUILD_KEY, newBuild)
    }
    
    @class
    function codeGenerator():String {
        return get(CODE_GENERATOR_KEY)->(String)
    }
    
    @class
    method setCodeGenerator(codeGenerator:String) {
        set(CODE_GENERATOR_KEY, codeGenerator)
    }
    
    @class
    function sources():ImmutablePrimitiveArray<File> {
        return get(SOURCES_KEY)->(ImmutablePrimitiveArray<File>)
    }
    
    @class
    method setSources(sources->>ImmutablePrimitiveArray<File>) {
        set(SOURCES_KEY, sources)
    }
    
    @class
    function librarySearchPaths():ImmutablePrimitiveArray<File> {
        return get(LIBRARY_SEARCH_PATHS_KEY)->(ImmutablePrimitiveArray<File>)
    }
    
    @class
    method setLibrarySearchPaths(librarySearchPaths->>ImmutablePrimitiveArray<File>) {
        set(LIBRARY_SEARCH_PATHS_KEY, librarySearchPaths)
    }

    @class
    function libraries():ImmutablePrimitiveArray<String> {
        return get(LIBRARIES_KEY)->(ImmutablePrimitiveArray<String>)
    }
    
    @class
    method setLibraries(libraries:ImmutablePrimitiveArray<String>) {
        set(LIBRARIES_KEY, libraries)
    }

    @class
    function objectFiles():ImmutablePrimitiveArray<File> {
        return get(OBJECT_FILES_KEY)->(ImmutablePrimitiveArray<File>)
    }
    
    @class
    method setObjectFiles(objectFiles:ImmutablePrimitiveArray<File>) {
        set(OBJECT_FILES_KEY, objectFiles)
    }

    @class
    function modules():ImmutablePrimitiveArray<Module> {
        return get(MODULES_KEY)->(ImmutablePrimitiveArray<Module>)
    }
    
    @class
    method addModule(module:Module) {
        QUEUE.post(module)
    }

    @class
    function output():File? {
        return get(OUTPUT_KEY)->(File?)
    }
    
    @class
    method setOutput(output:File?) {
        set(OUTPUT_KEY, output)
    }

    @class
    function javac():File {
        return get(JAVAC_KEY)->(File)
    }
    
    @class
    method setJavac(javac:File) {
        set(JAVAC_KEY, javac)
    }

    @class
    function jar():File {
        return get(JAR_KEY)->(File)
    }
    
    @class
    method setJar(jar:File) {
        set(JAR_KEY, jar)
    }

    @class
    method setDefaults() {
        Thread.context[SETTINGS_KEY] := new SharedMap()
        setOptimization(true)
        setAssertions(true)
        setPreconditions(true)
        setPostconditions(true)
        setInvariants(true)
        setOverflowChecking(true)
        setBoundsChecking(true)
        setCheckCasts(true)
        setSealed(true)
        setLoadCoreLib(true)
        setPreserveTempArtifacts(false)
        setNewBuild(false)
        setCodeGenerator("exec")
        setSources([])
        setLibrarySearchPaths([])
        setLibraries([])
        setObjectFiles([])
        set(MODULES_KEY, new ImmutablePrimitiveArray<Module>())
        setJavac(new File("/usr/bin/javac"))
        setJar(new File("/usr/bin/jar"))

        Thread.start(method() {
            outer: loop {
                -- FIXME awkwardness here due to lack of PDS list
                def module := QUEUE.getMessage()->(Module)
                def modules := modules->>(PrimitiveArray<Module>)
                for m in modules {
                    if m = module
                        continue outer
                }
                modules.append(module)
                set(MODULES_KEY, modules->>(ImmutablePrimitiveArray<Module>))
            }
        }, false)
    }
}