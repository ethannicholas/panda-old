package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.And
uses org.pandalanguage.pandac.tree.AndLeft
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.BitwiseAnd
uses org.pandalanguage.pandac.tree.BitwiseNot
uses org.pandalanguage.pandac.tree.BitwiseOr
uses org.pandalanguage.pandac.tree.BitwiseXor
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Divide
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.Equal
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewArrayWithLength
uses org.pandalanguage.pandac.tree.NewArrayWithRange
uses org.pandalanguage.pandac.tree.NewArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryMinus
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedType
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class JavaScriptCodeGenerator (CodeGenerator) {
    constant NAME := "JavaScriptCodeGenerator.name"
    constant PANDAMAIN_NAME := "$pandaMain"
    constant NEWSTRING := "panda$core$PandaCore$newString"
    constant METHOD_INDEX := "methodIndex"
    constant INTERFACE_METHOD_INDEX := "interfaceMethodIndex"

    var rootPath:File?
    var out := new IndentedOutputStream(Console.outputStream)
    var variableIndex := 0
    var currentMethod:MethodNode?

    @override
    function defaultExtension():String? {
        return null
    }
    
    @class
    method getName(c:ClassNode):String {
        return getName(c.type())
    }

    @class
    function getName(t:Type):String {
        if t.isNullable
            return getName(t.unwrapNullable)
        if t.isArray {
            var prefix:String
            if t.isImmutable
                prefix := "panda$collections$ImmutableArray$"
            else
                prefix := "panda$collections$Array$"
            var elementType := t.elementType
            return prefix + MethodNamer.escapeTypeName(getName(elementType))
        }    
        return MethodNamer.escapeTypeName(t.name)
    }

    function getName(m:MethodNode):String {
        return m.getProperty(MethodNamer.NAME)->(String)
    }

    function getName(f:FieldNode):String {
        -- prepending a "$" prevents conflicts with Java keywords, and also
        -- handles weird cases where a field has the same name as a package
        -- (consider trying to refer to "panda.core.String" when we have
        -- defined a field named "panda")
        return "$" + f.name
    }
    
    @pre(currentMethod != null)
    method getName(v:Variable):String {
        var result := v.getProperty(NAME)->(String?)
        if result = null {
           if v-?>(Parameter) & v.name = Parameter.SELF_NAME
                result := "$this"
            else {
                result := v.name + variableIndex
                v.setProperty(NAME, result)
                variableIndex += 1
            }
        }
        return result
    }

    method generateMethodCallCode(mc:MethodCall) {
        var m := mc.methodNode
        if m.isDeclaredVirtual & !m.annotations.isWrapperMethod {
            if m.owner.isInterface {
                out.write("callInterfaceMethod(")
                def index := m.getProperty(INTERFACE_METHOD_INDEX)
                assert index != null: "\{m.owner.name}::\{m.name} did not " +
                        "have an INTERFACE_METHOD_INDEX"
                out.write("\{getName(m.owner)}, \{index}, ")
            }
            else {
                if mc.isVirtual {
                    generateValueCode(mc.parameters[0])
                    out.write(".$cl.vtable[")
                }
                else {
                    var cm := currentMethod
                    assert cm != null
                    var superclass := cm.owner.superclass
                    assert superclass != null
                    out.write(getName(superclass) + ".vtable[")
                }
                var mi := m.getProperty(METHOD_INDEX)
                assert mi != null
                out.write(mi + "](")
            }
        }
        else {
            out.write(getName(m.owner))
            out.write(".")
            out.write(getName(m))
            out.write("(")
        }
        for i, p in mc.parameters {
            if i > 0
                out.write(", ")
            generateValueCode(mc.parameters[i])
        }
        out.write(")")
    }
    
    method generateUnaryMinusCode(u:UnaryMinus) {
        if u.value-?>(IntegerLiteral) {
            var v := u.value->(IntegerLiteral).value
            if v = Int32.MAX->(UInt64) + 1 {
                out.write(Int32.MIN)
                return
            }
        }
        out.write("-(")
        generateValueCode(u.value)
        out.write(")")
    }
    
    method generateBinaryCode(b:BinaryOperation, op:String) {
        if b.left.type = IntType.INT64 {
            generateValueCode(b.left)
            out.write(".")
            switch op {
                case "+":   out.write("add")
                case "-":   out.write("sub")
                case "*":   out.write("mul")
                case "/":   out.write("div")
                case "%":   out.write("rem")
                case ">>":  out.write("ashr")
                case ">>>": out.write("lshr")
                case "<<":  out.write("shl")
                case "&":   out.write("and")
                case "|":   out.write("or")
                case "^":   out.write("xor")
                case "==":  out.write("eq")
                case "!=":  out.write("ne")
                case ">":   out.write("gt")
                case "<":   out.write("lt")
                case ">=":  out.write("gte")
                case "<=":  out.write("lte")
                default:    throw new AssertionError("unsupported: " + op)
            }
            out.write("(")
            generateValueCode(b.right)
            out.write(")")
        }
        else {
            out.write("(")
            generateValueCode(b.left)
            out.write(" ")
            out.write(op)
            out.write(" ")
            generateValueCode(b.right)
            out.write(")")
        }
    }
    
    method generateIndexValueCode(i:IndexValue) {
        generateValueCode(i.array)
        out.write(".contents[")
        generateValueCode(i.index)
        out.write("]")
    }
    
    method generateFieldReferenceCode(f:FieldReference) {
        if f.object-?>(ClassLiteral)
            out.write(getName(f.object->(ClassLiteral).value))
        else
            generateValueCode(f.object)
        out.write(".")
        out.write(getName(f.field))
    }
    
    method generateConstructCode(c:Construct) {
        var m := c.methodNode
        out.write(getName(m.owner))
        out.write(".create")
        out.write(getName(m))
        out.write("(")
        for i in 0 ... c.parameters.length - 1 {
            if i > 0
                out.write(", ")
            generateValueCode(c.parameters[i])
        }
        out.write(")")
    }
    
    method generateNewArrayWithLengthCode(n:NewArrayWithLength) {
        out.write("panda$core$PandaCore$newArrayWithLength(")
        out.write(getName(n.type))
        out.write(", ")
        generateValueCode(n.arrayLength)
        out.write(")")
    }
    
    method generateNewArrayWithValuesCode(n:NewArrayWithValues) {
        out.write("panda$core$PandaCore$newArrayWithValues(")
        out.write(getName(n.type))
        for i in 0 ... n.values.length - 1 {
            out.write(", ")
            generateValueCode(n.values[i])
        }
        out.write(")")
    }
    
    method generateNewArrayWithRangeCode(n:NewArrayWithRange) {
        out.write("panda$core$PandaCore$newArrayWithRange(")
        out.write(getName(n.type))
        out.write(", ")
        generateValueCode(n.source)
        out.write(", ")
        generateValueCode(n.offset)
        out.write(", ")
        generateValueCode(n.arrayLength)
        out.write(")")
    }
    
    method generateIntegerLiteralCode(i:IntegerLiteral) {
        constant MASK := 0b11111111111111111111111111111111->(UInt64)
        if i.type = IntType.INT64 {
            out.write("new Int64(" + i.value >> 32 && MASK + ", " + 
                    i.value && MASK + ")")
        }
        else
            out.write(i.value)
    }
    
    method generateTernaryCode(t:Ternary) {
        out.write("(")
        generateValueCode(t.test)
        out.write(" ? ")
        generateValueCode(t.left)
        out.write(" : ")
        generateValueCode(t.right)
        out.write(")")
    }
    
    method generateReusedValueDefinitionCode(rvd:ReusedValueDefinition) {
        def name := rvd.getProperty(NAME)
        assert name != null: "ReusedValueDefinition at \{rvd.position} has " +
                "not been named"
        if rvd.parent-!>(ValueStatement)
            out.write("(")
        out.write(name + " = ")
        generateValueCode(rvd.value)
        if rvd.parent-!>(ValueStatement)
            out.write(")")
    }

    method generateReusedValueCode(rv:ReusedValue) {
        def name := rv.owner.getProperty(NAME)
        assert name != null: "ReusedValue at \{rv.position} has not been named"
        out.write(name)
    }

    method generateDynamicCallCode(dc:DynamicCall) {
        generateValueCode(dc.methodValue)
        out.write(".$rawPtr(")
        for i, p in dc.parameters {
            if i != 0
                out.write(", ")
            generateValueCode(p)
        }
        out.write(")")
    }

    method generateMethodValueCode(mv:MethodValue) {
        out.write("panda$core$Method.createnew$constructor(" + 
                getName(mv.rawMethodNode.owner) + "." + 
                    getName(mv.rawMethodNode) + ", null)")
    }

    method generateValueCode(v:Value) {
        if v-?>(VariableAssignment)
            generateVariableAssignmentCode(v->(VariableAssignment))
        else if v-?>(MethodCall)
            generateMethodCallCode(v->(MethodCall))
        else if v-?>(Equal)
            generateBinaryCode(v->(Equal), "==")
        else if v-?>(NotEqual)
            generateBinaryCode(v->(NotEqual), "!=")
        else if v-?>(Identity)
            generateBinaryCode(v->(Identity), "==")
        else if v-?>(NotIdentity)
            generateBinaryCode(v->(NotIdentity), "!=")
        else if v-?>(LessThan)
            generateBinaryCode(v->(LessThan), "<")
        else if v-?>(LessThanOrEqual)
            generateBinaryCode(v->(LessThanOrEqual), "<=")
        else if v-?>(GreaterThan)
            generateBinaryCode(v->(GreaterThan), ">")
        else if v-?>(GreaterThanOrEqual)
            generateBinaryCode(v->(GreaterThanOrEqual), ">=")
        else if v-?>(Add)
            generateBinaryCode(v->(Add), "+")
        else if v-?>(Subtract)
            generateBinaryCode(v->(Subtract), "-")
        else if v-?>(UnaryMinus)
            generateUnaryMinusCode(v->(UnaryMinus))
        else if v-?>(Multiply)
            generateBinaryCode(v->(Multiply), "*")
        else if v-?>(Divide)
            generateBinaryCode(v->(Divide), "/")
        else if v-?>(IntDivide) {
            if v.type != IntType.INT64 {
                out.write("(")
                generateBinaryCode(v->(IntDivide), "/")
                out.write(" | 0)")
            }
            else
                generateBinaryCode(v->(IntDivide), "/")
        }
        else if v-?>(Remainder)
            generateBinaryCode(v->(Remainder), "%")
        else if v-?>(BitwiseNot) {
            out.write("(~")
            generateValueCode(v->(BitwiseNot).value)
            out.write(")")
        }
        else if v-?>(BitwiseAnd)
            generateBinaryCode(v->(BitwiseAnd), "&")
        else if v-?>(BitwiseOr)
            generateBinaryCode(v->(BitwiseOr), "|")
        else if v-?>(BitwiseXor)
            generateBinaryCode(v->(BitwiseXor), "^")
        else if v-?>(And)
            generateBinaryCode(v->(And), "&&")
        else if v-?>(Or)
            generateBinaryCode(v->(Or), "||")
        else if v-?>(Xor)
            generateBinaryCode(v->(Xor), "^")
        else if v-?>(ShiftLeft)
            generateBinaryCode(v->(ShiftLeft), "<<")
        else if v-?>(ShiftRight) {
            if v.type->(IntType).signed
                generateBinaryCode(v->(ShiftRight), ">>")
            else
                generateBinaryCode(v->(ShiftRight), ">>>")
        }
        else if v-?>(Not) {
            out.write("(!")
            generateValueCode(v->(Not).value)
            out.write(")")
        }
        else if v-?>(AndLeft) 
            generateValueCode(v->(AndLeft).value)
        else if v-?>(OrLeft) 
            generateValueCode(v->(OrLeft).value)
        else if v-?>(Ternary)
            generateTernaryCode(v->(Ternary))
        else if v-?>(IndexValue)
            generateIndexValueCode(v->(IndexValue))
        else if v-?>(IntegerLiteral)
            generateIntegerLiteralCode(v->(IntegerLiteral))
        else if v-?>(RealLiteral)
            out.write(v->(RealLiteral).value)
        else if v-?>(StringLiteral)
            out.write(NEWSTRING + "(" + v + ")")
        else if v-?>(BitLiteral)
            out.write(v->(BitLiteral).value)
        else if v-?>(ClassLiteral)
            out.write(getName(v->(ClassLiteral).value))
        else if v-?>(ClassObjectLiteral)
            out.write(getName(v->(ClassObjectLiteral).value))
        else if v-?>(VariableReference) 
            out.write(getName(v->(VariableReference).variable))
        else if v-?>(FieldReference)
            generateFieldReferenceCode(v->(FieldReference))
        else if v-?>(NullLiteral)
            out.write("null")
        else if v-?>(Cast) {
            if v.type = IntType.INT64 & 
                    (v->(Cast).value.type->(PrimitiveType)).size < 8 {
                out.write("Int64.fromDouble(")
                generateValueCode(v->(Cast).value)
                out.write(")")
            }
            else if v->(Cast).value.type = IntType.INT64 {
                generateValueCode(v->(Cast).value)
                out.write(".toDouble()")
            }
            else
                generateValueCode(v->(Cast).value)
        }
        else if v-?>(Construct)
            generateConstructCode(v->(Construct))
        else if v-?>(NewArrayWithLength)
            generateNewArrayWithLengthCode(v->(NewArrayWithLength))
        else if v-?>(NewArrayWithValues)
            generateNewArrayWithValuesCode(v->(NewArrayWithValues))
        else if v-?>(NewArrayWithRange)
            generateNewArrayWithRangeCode(v->(NewArrayWithRange))
        else if v-?>(Unwrap)
            generateValueCode(v->(Unwrap).value)
        else if v-?>(ReusedValueDefinition)
            generateReusedValueDefinitionCode(v->(ReusedValueDefinition))
        else if v-?>(ReusedValue)
            generateReusedValueCode(v->(ReusedValue))
        else if v-?>(DynamicCall)
            generateDynamicCallCode(v->(DynamicCall))
        else if v-?>(MethodValue)
            generateMethodValueCode(v->(MethodValue))
        else
            throw new AssertionError("unsupported value type: " + v.class.name)
    }
    
    method generateIfCode(i:If) {
        out.write("if (")
        generateValueCode(i.test)
        out.write(") " )
        generateBlockCode(i.ifBlock)
        var elseBlock := i.elseBlock
        if elseBlock != null {
            out.write("else ")
            generateBlockCode(elseBlock)
        }
    }
    
    method generateLoopCode(l:Loop) {
        var label := l.label
        if label != null
            out.write(label + ": ")
        out.write("for (;;) ")
        generateBlockCode(l.block)
    }
    
    method generateLoopWithContinueBlockCode(l:LoopWithContinueBlock) {
        var label := l.label
        if label != null
            out.write(label + ": ")
        out.writeLine("for (;;) {")
        out.level += 1
        generateBlockCode(l.block)
        if !l.block.endsInBranch
            generateBlockCode(l.continueBlock)
        out.level -= 1
        out.writeLine("}")
    }
    
    method generateWhileCode(w:While) {
        var label := w.label
        if label != null
            out.write(label + ": ")
        out.write("while (")
        generateValueCode(w.test)
        out.write(") ")
        generateBlockCode(w.block)
    }
    
    method generateDoCode(d:Do) {
        var label := d.label
        if label != null
            out.write(label + ": ")
        out.write("do ")
        generateBlockCode(d.block)
        out.write(" while (")
        generateValueCode(d.test)
        out.write(");")
    }

    method generateVariableAssignmentCode(va:VariableAssignment) {
        if !va.parent-?>(ValueStatement)
            out.write("(")
        out.write(getName(va.variable) + " = ")
        generateValueCode(va.value)
        if !va.parent-?>(ValueStatement)
            out.write(")")
    }
    
    method generateFieldAssignmentCode(fa:FieldAssignment) {
        generateValueCode(fa.object)
        out.write(".")
        out.write(getName(fa.fieldNode))
        out.write(" = ")
        generateValueCode(fa.value)
        out.writeLine(";")
    }
    
    method generateIndexedAssignmentCode(ia:IndexedAssignment) {
        generateValueCode(ia.array)
        out.write(".contents[")
        generateValueCode(ia.index)
        out.write("] = ")
        generateValueCode(ia.value)
        out.writeLine(";")
    }
    
    method generateAssertCode(a:Assert) {
        -*
        out.write("assert ")
        generateValueCode(a.test)
        out.writeLine(";")
        *-
    }
    
    method generateUnreachableCode(u:Unreachable) {
    }
    
    method generateThrowCode(t:Throw) {
        out.write("throw new PandaException(")
        generateValueCode(t.error)
        out.writeLine(");")
    }
    
    method generateTryCode(t:Try) {
        out.write("try ")
        generateBlockCode(t.block)
        var rawName := "$e" + variableIndex
        variableIndex += 1
        out.writeLine("catch (" + rawName + ") {")
        out.level += 1
        var eName := "$e" + variableIndex
        variableIndex += 1
        out.writeLine("var " + eName + " = " + rawName + 
                ".getPandaError();")
        for i in 1 ... t.length - 1 {
            var c := t[i]->(Catch)
            if i > 1
                out.write("else ")
            out.write("if (" + eName + " instanceof " + 
                    getName(c.exception.type) + ") ")
            generateBlockCode(c)
        }
        if t.length > 1
            out.write("else ")
        out.writeLine("throw new RuntimeException(" + rawName + ");")
        out.level -= 1
        out.writeLine("}")
    }
    
    method generateReturnCode(r:Return) {
        out.write("return")
        var value := r.value
        if value != null {
            out.write(" ")
            generateValueCode(value)
        }
        out.writeLine(";")
    }
    
    method generateBreakCode(b:Break) {
        out.write("break")
        var label := b.label
        if label != null
            out.write(" " + label)
        out.writeLine(";")
    }
    
    method generateContinueCode(c:Continue) {
        def target := LLVMCodeGenerator.findLoop(c, c.label)
        if target-?>(LoopWithContinueBlock)
            generateBlockCode(target->(LoopWithContinueBlock).continueBlock)
        out.write("continue")
        var label := c.label
        if label != null
            out.write(" " + label)
        out.writeLine(";")
    }
    
    method createReusedValues(n:Node) {
        for child in n.children {
            if child-!>(Statement)
                createReusedValues(child)
        }
        if n-?>(ReusedValueDefinition) {
            def rvd := n->(ReusedValueDefinition)
            def name := "$reused" + variableIndex
            variableIndex += 1
            rvd.setProperty(NAME, name)
            out.write("var " + name + ";")
        }
    }

    method generateStatementCode(s:Statement) {
        out.writeLine("// " + s.class.name + ": " + s)
        createReusedValues(s)
        switch s.class {
            case class(ValueStatement): {
                var v := s->(ValueStatement).value
                generateValueCode(s->(ValueStatement).value)
                out.writeLine(";")
            }
            case class(FieldAssignment): generateFieldAssignmentCode(
                    s->(FieldAssignment))
            case class(IndexedAssignment): generateIndexedAssignmentCode(
                    s->(IndexedAssignment))
            case class(If): generateIfCode(s->(If))
            case class(Loop): generateLoopCode(s->(Loop))
            case class(LoopWithContinueBlock): generateLoopWithContinueBlockCode(
                    s->(LoopWithContinueBlock))
            case class(While): generateWhileCode(s->(While))
            case class(Do): generateDoCode(s->(Do))
            case class(Block): generateBlockCode(s->(Block))
            case class(Assert): generateAssertCode(s->(Assert))
            case class(Unreachable): generateUnreachableCode(s->(Unreachable))
            case class(Return): generateReturnCode(s->(Return))
            case class(Break): generateBreakCode(s->(Break))
            case class(Continue): generateContinueCode(s->(Continue))
            case class(Throw): generateThrowCode(s->(Throw))
            case class(Try): generateTryCode(s->(Try))
            case class(CatchExit): { }
            default: {
                throw new AssertionError("unsupported statement type: " + 
                        s.class.name)
            }
        }
    }
    
    method generateBlockCode(b:Block) {
        out.writeLine("{")
        out.level += 1
        for s in b.children
            generateStatementCode(s->(Statement))
        out.level -= 1
        out.writeLine("}")
    }
 

    method generateMainBlockCode(m:MethodNode) {
        out.writeLine("{")
        out.level += 1
        for v in m.localVariables {
            out.writeLine("var " + 
                    getName(v) + ";")
        }
        var insertPoint:Int? := null
        if m.methodType = MethodNodeType.CONSTRUCTOR & 
                !ASTGenerator.callsOtherSelfConstructor(m) &
                m.owner.name != class(Object).name {
            if ASTGenerator.callsSuperConstructor(m)
                insertPoint := 1
            else
                insertPoint := 0
        }
        var b := m.block
        for i, s in b.children {
            if i = insertPoint {
                -- insert field initializers
                var cl := m.owner
                var selfParam := b.parent->(MethodNode).parameters[0]
                for child in cl.children {
                    if child-?>(FieldNode) {
                        var f := child->(FieldNode)
                        if f.annotations.isClass | 
                                f.annotations.isThread
                            continue
                        -- it's an instance field with an initializer
                        var value := f.initialValue
                        if value = null {
                            if f.type.isInteger | f.type = CharType.CHAR
                                value := new IntegerLiteral(0, f.type)
                            else if f.type.isReal
                                value := new RealLiteral(0, f.type)
                            else if f.type = BitType.BIT
                                value := new BitLiteral(false)
                            else
                                value := new NullLiteral(f.type)
                        }
                        else
                            value.removeFromParent()
                        ASTGenerator.replaceSelf(value, selfParam)
                        var assignment := new FieldAssignment(f.position,
                                new VariableReference(selfParam), f, value)
                        generateStatementCode(assignment)
                        value.removeFromParent()
                        f.initialValue := value
                    }
                }
            }
            generateStatementCode(s->(Statement))
        }
        if m.name = MethodNode.CLASS_INIT_NAME {
            var cm := currentMethod
            assert cm != null
            var cl := cm.owner
            for child in cl.children {
                if child-?>(FieldNode) {
                    var f := child->(FieldNode)
                    if f.annotations.isThread
                        generateFieldCode(f)
                }
            }
        }
        out.level -= 1
        out.write("}")
    }

    method generateFieldCode(f:FieldNode) {
        if f.annotations.isThread {
            out.writeLine(getName(f.owner) + "." + getName(f) + " = ")
            var initializer := f.parent->(ClassNode).symbolTable.getMethod(
                    f.position,
                    ASTGenerator.getThreadLocalInitializerName(f),
                    new Array<Value>(), true)
            if initializer != null
                out.write(getName(f.owner) + "." + getName(initializer) + "();")
            else
                out.write("0")
            out.writeLine(";")
        }
    }

    method generateMethodCode(m:MethodNode) {
        if m.annotations.isAbstract {
            out.write("null")
            return
        }
        currentMethod := m
        if m.isDeclaredVirtual
            out.write("/* \{getName(m.owner)}::\{getName(m)} */ function(")
        else
            out.write("\{getName(m.owner)}.\{getName(m)} = function(")
        for i, p in m.parameters {
            if i > 0
                out.write(", ")
            out.write(getName(p))
        }
        if m.parameters.length = 0 & getName(m) = PANDAMAIN_NAME
            out.write("$arg")
        out.write(") ")
        if m.annotations.isExternal {
            out.writeLine("{")
            out.level += 1
        }
        if m.annotations.isExternal {
            if m.returnType != VoidType.VOID
                out.write("return ")
            out.write("$external.")
            out.write(getName(m.owner) + "$")
            out.write(getName(m) + "(")
            for i, p in m.parameters {
                if i > 0
                    out.write(", ")
                out.write(getName(p))
            }
            out.writeLine(");")
        }
        else {
            generateMainBlockCode(m)
            if !m.isDeclaredVirtual
                out.writeLine()
        }
        if m.annotations.isExternal {
            out.level -= 1
            out.writeLine("}")
        }

        if m.methodType = MethodNodeType.CONSTRUCTOR {
            out.write(getName(m.owner) + ".create" + getName(m) + 
                    " = function(")
            for i in 1 .. m.parameters.length {
                if i > 1
                    out.write(", ")
                var p := m.parameters[i]
                out.write(getName(p))
            }
            out.writeLine(") {")
            out.level += 1
            out.writeLine("var $this = { };")
            out.writeLine("$this.$cl = \{getName(m.owner)};")
            out.write("\{getName(m.owner)}.\{getName(m)}(")
            for i, p in m.parameters {
                if i > 0
                    out.write(", ")
                out.write(getName(p))
            }
            out.writeLine(");")
            out.writeLine("return $this;")
            out.level -= 1
            out.writeLine("}")
        }

        currentMethod := null
    }
    
    method getFileName(cl:ClassNode):String {
        return getName(cl).replace(".", "/") + ".js"    
    }

    method writeVTable(cl:ClassNode) {
        def vtable := cl.virtualMethods
        for i, m in vtable {
            out.write(getName(cl) + ".vtable.push(")
            if m.owner = cl
                generateMethodCode(m)
            else
                out.write("\{getName(m.owner)}.vtable[\{i}]")
            out.writeLine(")")
            if m.annotations.isWrapperMethod() {
                out.writeLine("\{getName(m.owner)}.\{getName(m)} = " + 
                        "\{getName(cl)}.vtable[\{i}];")
            }
        }
    }

    method writeITables(cl:ClassNode) {
        out.writeLine(getName(cl) + ".itable = { }")
        for intf in cl.allInterfaces() {
            out.write("\{getName(cl)}.itable[\{getName(intf)}] = [")
            def itable := cl.interfaceMethods(intf)
            for i, m in itable {
                if i != 0
                    out.writeLine(",")
                def index := m.getProperty(METHOD_INDEX)
                assert index != null
                out.write("\{getName(m.owner)}.vtable[\{index}]")
            }
            out.writeLine("]")
        }
    }

    method generateClassCode(cl:ClassNode) {
        if cl.state != ClassNodeState.DEFINED & !cl.type().isArray
            return
        var rootPath := self.rootPath
        assert rootPath != null
        var dest := rootPath.resolve(getFileName(cl))
        var parent := dest.parent()
        if parent = null {
            throw new CompilerException("could not determine parent " +
                    "directory of '" + dest + "'")
        }
        parent.createDirectories()
        out := new IndentedOutputStream(new BufferedOutputStream(
                dest.openOutputStream()))
        out.writeLine(getName(cl) + ".$cl = panda$core$Class")
        var superclass := cl.superclass
        if superclass != null
            out.writeLine(getName(cl) + ".superclass = " + getName(superclass))
        out.writeLine(getName(cl) + ".$name = panda$core$PandaCore$newString('" + 
                getName(cl) + "');")
        writeVTable(cl)
        writeITables(cl)
        for child in cl.children {
            if child-?>(MethodNode) & !child->(MethodNode).isDeclaredVirtual
                generateMethodCode(child->(MethodNode))
        }
        out.close()
    }

    method prepTables() {
        var classes := SymbolTable.master.classes
        for cl in classes {
            var vtable := cl.virtualMethods
            for i, m in vtable {
                m.setProperty(METHOD_INDEX, i)
                if cl.isInterface
                    m.setProperty(INTERFACE_METHOD_INDEX, i)
            }
        }
    }

    method getMainClass():String? {
        var classes := SymbolTable.master.classes
        for cl in classes {
            for n in cl.children {
                if n-?>(MethodNode) & n->(MethodNode).name = MethodNode.MAIN_NAME
                    return getName(cl)
            }
        }
        return null
    }

    -- FIXME use a Set
    method writeScript(out:IndentedOutputStream,
            cl:ClassNode, visited:Array<ClassNode>) {
        for i in 0 ... visited.length - 1 {
            if visited[i] == cl
                return
        }
        var superclass := cl.superclass
        if superclass != null
            writeScript(out, superclass, visited)
        visited.append(cl)
        out.writeLine("<script src=\"" + getFileName(cl) + "\"></script>")
    }

    method generateHTML(html:File) {
        var out := new IndentedOutputStream(new BufferedOutputStream(
                html.openOutputStream()))
        out.writeLine("<html>")
        out.level += 1
        out.writeLine("<head>")
        out.level += 1
        var classes := SymbolTable.master.classes
        out.writeLine("<script>")
        for i in 0 ... classes.length - 1 {
            out.writeLine(getName(classes[i]) + " = { vtable: [] };")
        }
        -- force these arrays to be defined, even if they weren't present in the
        -- code, so that PandaCore works. It's ok (though not ideal) if they 
        -- were already defined.
        out.writeLine("panda$collections$Array$Int16  = { vtable: [] };")
        out.writeLine("panda$collections$Array$Int32  = { vtable: [] };")
        out.writeLine("panda$collections$Array$Int64  = { vtable: [] };")
        out.writeLine("panda$collections$Array$Bit    = { vtable: [] };")
        out.writeLine("panda$collections$Array$Real32 = { vtable: [] };")
        out.writeLine("panda$collections$Array$Real64 = { vtable: [] };")
        out.writeLine("</script>")
        out.writeLine("<script src=\"term.js\"></script>")
        out.writeLine("<script src=\"panda$core$PandaCore.js\"></script>")
        var visited := new Array<ClassNode>()
        for i in 0 ... classes.length - 1
            writeScript(out, classes[i], visited)
        out.writeLine("<script>")
        out.level += 1
        for i in 0 ... classes.length - 1 {
            var cl := classes[i]
            for j in 0 ... cl.length - 1 {
                if cl[j]-?>(MethodNode) & 
                        cl[j]->(MethodNode).name = MethodNode.CLASS_INIT_NAME {
                    out.writeLine(getName(classes[i]) + "." + 
                            MethodNode.CLASS_INIT_NAME + "()")
                    break
                }
            }
        }
        out.level -= 1
        out.writeLine("</script>")
        out.level -= 1
        out.writeLine("</head>")
        out.write("<body ")
        var main := getMainClass()
        if main != null
            out.write("onload=\"" + main + ".$pandaMain()\"")
        out.writeLine(">")
        out.writeLine("</body>")
        out.level -= 1
        out.writeLine("</html>")
        out.close()
    }

    @override
    method generateCode(target:File) {
        if !target.isDirectory()
            throw new CompilerException(
                    "JavaScript output must be to a directory")
        MethodNamer.nameMethods(new JSMethodNamingStrategy())
        rootPath := target
        prepTables()
        def classes := SymbolTable.master.classes
        for cl in classes
            generateClassCode(cl)
        generateHTML(target.resolve("main.html"))
    }
}