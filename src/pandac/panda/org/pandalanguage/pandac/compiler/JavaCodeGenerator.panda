package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.And
uses org.pandalanguage.pandac.tree.AndLeft
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.ArrayLiteral
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.BitwiseAnd
uses org.pandalanguage.pandac.tree.BitwiseNot
uses org.pandalanguage.pandac.tree.BitwiseOr
uses org.pandalanguage.pandac.tree.BitwiseXor
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.LogicalShiftRight
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedType
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType 
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class JavaCodeGenerator (CodeGenerator) {
    constant UNNAMED := "$unnamed"
    constant NAME := "JavaCodeGenerator.name"
    constant PANDACORE := "panda.core.PandaCore"
    constant STRING_CONSTANT_PREFIX := "$STRING_CONSTANT_"
    constant MAX_LENGTH := 128
    
    def context:Context
    def program:Program
    def methodNamer:MethodNamer
    def names := new HashMap<Node, String>()
    var rootPath:File?
    var out := new IndentedOutputStream(Console.outputStream)
    var reusedValueDefinitions := new MutableString()
    var variableIndex := 0
    var currentMethod:MethodNode?
    var currentClass:ClassNode?
    var stringConstants := new PrimitiveArray<String>()
    var hasClassInit := false
    -- method types we have run into which need interfaces defined for them
    var methodTypes := new HashSet<MethodType>()
    def loops := new Stack<AbstractLoop>()

    constructor(p:Program, compilerSettings:CompilerSettings) {
        self.program := p
        def errors := new FatalErrorReporter()
        self.context := new Context(p.typeResolver, p.stubs, errors, 
                compilerSettings)
        self.methodNamer := new MethodNamer(context, 
                new JavaMethodNamingStrategy())
    }

    @override
    function defaultExtension():String? {
        return null
    }

    method getName(cl:ClassStub):String {
        return getJavaType(cl.type)
    }

    function hash(fullName:String, className:String):String {
        if fullName.endsWith("?")
            return hash(fullName[0 .. fullName.length - 1], className)
        return "panda.hashed." + className + fullName.hash->>(UInt32)->>(String)
    }

    method getDisplayName(cl:ClassStub):String {
        var result := cl.name
        if result.startsWith("panda.core.") & result.endsWith("Wrapper")
            result := result[..result.length - "Wrapper".length]
        return result
    }

    @class
    function needsDisambiguation(m:MethodStub):Bit {
        -- FIXME implement this
        return true
    }

    method getStub(cl:ClassType):ClassStub {
        return context.getStub(cl)
    }

    method getName(m:MethodStub):String {
        return methodNamer.getName(m)
    }
    
    function getName(f:FieldNode):String {
        -- prepending a "$" prevents conflicts with Java keywords, and also
        -- handles edge cases where a field has the same name as a package
        -- (consider trying to refer to "panda.core.String" when we have
        -- defined a field named "panda")
        return "$" + f.name
    }
    
    method getName(v:Variable):String {
        if v-?>(Parameter) & v.name = Parameter.SELF_NAME {
            def currentMethod := self.currentMethod->(MethodNode)
            if (currentMethod.stub.methodType = MethodNodeType.CONSTRUCTOR |
                    currentMethod.stub.annotations.isWrapperMethod)
                return "$this"
            else
                return "this"
        }
        var result := names[v]->(String?)
        if result = null {
            result := v.name + variableIndex
            names[v] := result
            variableIndex += 1
        }
        return result
    }
    
    function isClass(m:MethodStub):Bit {
        return m.annotations.isClass | 
                m.methodType = MethodNodeType.CONSTRUCTOR |
                m.annotations.isWrapperMethod
    }

    method getJavaReferenceType(t:Type):String {
        switch t {
            case IntType.INT8, IntType.UINT8:   return "Byte"
            case IntType.INT16, IntType.UINT16: return "Short"
            case IntType.INT32, IntType.UINT32: return "Integer"
            case IntType.INT64, IntType.UINT64: return "Long"
            case CharType.CHAR:   return "Character"
            case BitType.BIT:     return "Boolean"
            case RealType.REAL32: return "Float"
            case RealType.REAL64: return "Double"
            case VoidType.VOID:   return "void"
        }
        return getJavaType(t)
    }

    @class
    function isJavaKeyword(token:String):Bit {
        switch token {
            case "abstract", "continue", "for", "new", "switch", "assert",
                    "default", "goto", "package", "synchronized", "boolean",
                    "do", "if", "private", "this", "break", "double", 
                    "implements", "protected", "throw", "byte", "else", 
                    "import", "public", "throws", "case", "enum", "instanceof",
                    "return", "transient", "catch", "extends", "int", "short",
                    "try", "char", "final", "interface", "static", "void",
                    "class", "finally", "long", "strictfp", "volatile", "const",
                    "float", "native", "super", "while": return true
            default: return false
        }
    }

    @class
    function filterNameToken(token:String):String {
        if isJavaKeyword(token)
            return "$" + token
        return token
    }

    @private
    method escape(s:String):String {
        if s.endsWith("?")
            return escape(s[0 .. s.length - 1])
        return s.replace("<", "$LT").replace(">", "$GT")
                .replace(",", "$C").replace("(", "$LP").replace(")", "$RP")
                .replace("=", "$EQ").replace("?", "$Z").replace(" ", "")
    }

    method getJavaType(t:Type):String {
        switch t {
            case IntType.INT8, IntType.UINT8:   return "byte"
            case IntType.INT16, IntType.UINT16: return "short"
            case IntType.INT32, IntType.UINT32: return "int"
            case IntType.INT64, IntType.UINT64: return "long"
            case CharType.CHAR:   return "char"
            case BitType.BIT:     return "boolean"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case VoidType.VOID:   return "void"
            case NativePointerType.NATIVE_POINTER: return "java.lang.Object"
        }
        if t-?>(GenericParameterType)
            return getJavaType(t->(GenericParameterType).bound)
        var result:String
        if t.isPrimitiveArray {
            var eType := t.unwrapNullable->(PrimitiveArrayType).elementType
            var eName:String
            if eType.isPrimitive {
                assert eType.name.startsWith("panda.core.")
                eName := eType.name["panda.core.".length..]
            }
            else
                eName := getJavaType(eType)
            if eType.isNullable
                eName += "$Z"
            if t.isImmutable(context)
                result := class(ImmutablePrimitiveArray).name + "<" + eName + ">"
            else
                result := class(PrimitiveArray).name + "<" + eName + ">"
        } 
        else if t.unwrapNullable-?>(MethodType) {
            if t.isImmutable(context)
                return getJavaType(ClassType.METHOD)
            else
                return getJavaType(ClassType.MUTABLE_METHOD)
        }
        else
            result := t.name.replace(#/\w+/#, token => filterNameToken(token))
        def lt := result.indexOf("<")
        if lt != null
            result := result[..lt] + result[lt..].replace(".", "$")
        -- we can't use unnamed packages in Java, because classes in named
        -- packages are not allowed to refer to classes in unnamed packages
        if !result.contains(".")
            result := UNNAMED + "." + result
        if result.length > MAX_LENGTH
            return hash(result, "Class")
        return escape(result)
    }

    method getJavaMethodType(m:MethodType):String {
        def buffer := new MutableString()
        for i, p in m.methodParameters {
            if i > 0
                buffer.append("$C")
            buffer.append(p.displayName)
        }
        if buffer.length = 0
            buffer.append("$nullary")
        var result := "panda.methods." + buffer->>(String).replace(".", "$")
        var found := false
        for existing in methodTypes {
            if existing = m {
                found := true
                break
            }
        }
        if !found
            methodTypes.add(m)
        def lt := result.indexOf("<"->(Char))
        if lt != null
            result := result[..lt] + result[lt..].replace(".", "$")
        if result.length > MAX_LENGTH
            return hash(result, "Method")
        return escape(result)
    }

    method getSimpleName(cl:ClassStub):String {
        var result := getJavaType(cl.type)
        var lt := result.indexOf("$LT")
        if lt = null
            lt := result.length - 1
        var dot := result.lastIndexOf(".", lt)
        if dot != null
            result := result[dot + 1..]
        return result
    }
    
    method generateMethodCallCode(mc:MethodCall) {
        def m := mc.methodStub
        def start:Int
        if mc.isSuper {
            if m.methodType = MethodNodeType.CONSTRUCTOR {
                def stub := context.getStub(m.owner->>(ClassType))
                out.write(getName(stub))
                start := 0
            }
            else {
                out.write("super")
                start := 1
            }
        }
        else if isClass(m) {
            out.write(getName(context.getStub(m.owner->>(ClassType))))
            start := 0
        }
        else {
            generateValueCode(mc.parameters[0])
            start := 1
        }
        out.write(".")
        out.write(getName(m))
        out.write("(")
        for i in start ... mc.parameters.length - 1 {
            if i > start
                out.write(", ")
            generateValueCode(mc.parameters[i])
        }
        out.write(")")
    }
    
    method generateUnaryOperationCode(u:UnaryOperation) {
        if u.operand-?>(IntegerLiteral) {
            def v := u.operand->(IntegerLiteral).value
            if v = Int32.MAX->(UInt64) + 1 {
                out.write(Int32.MIN)
                return
            }
        }
        def op:String
        switch u.operation {
            case UnaryOperationType.MINUS:       op := "-"
            case UnaryOperationType.NOT:         op := "!"
            case UnaryOperationType.BITWISE_NOT: op := "~"
            default: unreachable
        }
        out.write("((\{getJavaType(u.type)}) \{op}")
        if u.operand-!>(IntegerLiteral)
            out.write("(")
        generateValueCode(u.operand)
        if u.operand-!>(IntegerLiteral)
            out.write(")")
        out.write(")")
    }
    
    @pre(b.left.type = IntType.UINT64)
    method generateUInt64BinaryCode(b:BinaryOperation, op:String) {
        -- not the most efficient way to implement these, but I've got bigger 
        -- fish to fry right now
        switch b.operation {
            case BinaryOperationType.INT_DIVIDE: {
                out.write("panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").divide(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")).longValue()")
            }
            case BinaryOperationType.REMAINDER: {
                out.write("panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").remainder(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")).longValue()")
            }
            case BinaryOperationType.LESS_THAN, 
                    BinaryOperationType.LESS_THAN_OR_EQUAL,
                    BinaryOperationType.GREATER_THAN, 
                    BinaryOperationType.GREATER_THAN_OR_EQUAL: {
                out.write("(panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").compareTo(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")) " + op + " 0)")
            }
            default: {
                out.write("(")
                generateValueCode(b.left)
                out.write(" ")
                out.write(op)
                out.write(" ")
                generateValueCode(b.right)
                out.write(")")
            }
        }
    }

    method generateBinaryCode(b:BinaryOperation, op:String) {
        var operandType := b.left.type
        if operandType = IntType.UINT64 {
            generateUInt64BinaryCode(b, op)
            return
        }
        if b.type = IntType.UINT32
            out.write("(int) (")
        else if b.type.isInteger & b.type->>(PrimitiveType).size < 4 | 
                b.type = CharType.CHAR
            out.write("(\{getJavaType(b.type)}) ")
        out.write("(")
        if operandType = IntType.UINT32 {
            out.write("(((long) ")
            generateValueCode(b.left)
            out.write(") & 0xFFFFFFFF)")
        }
        else
            generateValueCode(b.left)
        out.write(" ")
        out.write(op)
        out.write(" ")
        if operandType = IntType.UINT32 {
            out.write("(((long) ")
            generateValueCode(b.right)
            out.write(") & 0xFFFFFFFF)")
        }
        else
            generateValueCode(b.right)
        out.write(")")
        if b.type = IntType.UINT32
            out.write(" & 0xFFFFFFFF)")
    }

    method generateBinaryCode(b:BinaryOperation) {
        def op:String
        switch b.operation {
            case BinaryOperationType.EQUAL: op := "=="
            case BinaryOperationType.INT_DIVIDE: op := "/"
            case BinaryOperationType.AND: op := "&&"
            case BinaryOperationType.OR:  op := "||"
            case BinaryOperationType.XOR: op := "^^"
            case BinaryOperationType.BITWISE_AND: op := "&"
            case BinaryOperationType.BITWISE_OR:  op := "|"
            case BinaryOperationType.BITWISE_XOR: op := "^"
            default: op := BinaryOperation.operatorSymbol(b.operation)
        }
        generateBinaryCode(b, op)
    }

    method generateIndexValueCode(i:PrimitiveArrayIndexValue) {
        out.write("((" + getJavaType(i.type) + ") ")
        generateValueCode(i.array)
        out.write(".get(")
        generateValueCode(i.index)
        out.write("))")
    }
    
    method generateFieldReferenceCode(f:FieldReference) {
        generateValueCode(f.object)
        out.write(".")
        out.write(getName(f.field))
        if f.field.annotations.isThread
            out.write(".get()")
    }
    
    method generateConstructCode(c:Construct) {
        def m := c.constructorCall.methodStub
        out.write(getJavaType(c.type))
        out.write(".create")
        out.write(getName(m))
        out.write("(")
        for i in 1 ... c.constructorCall.parameters.length - 1 {
            if i > 1
                out.write(", ")
            generateValueCode(c.constructorCall.parameters[i])
        }
        out.write(")")
    }
    
    method generateNewPrimitiveArrayWithLengthCode(n:NewPrimitiveArrayWithLength) {
        out.write("(" + getJavaType(n.type) + ".newWithLength(")
        generateValueCode(n.arrayLength)
        out.write("))")
    }
    
    method generateNewPrimitiveArrayWithValuesCode(n:NewPrimitiveArrayWithValues) {
        out.write("(" + getJavaType(n.type) + ".newWithValues(")
        for i, v in n.values {
            if i > 0
                out.write(", ")
            generateValueCode(v)
        }
        out.write("))")
    }
    
    method generateArrayLiteralCode(a:ArrayLiteral) {
        out.write("new " + getJavaType(a.type) + "(")
        if a.values.length > 0 {
            for i, v in a.values {
                if i > 0
                    out.write(", ")
                generateValueCode(v)
            }
        }
        else {
            def elementType := a.type->(GenericType).parameters[0]
            out.write("new \{getJavaType(elementType)}[0]")
        }
        out.write(")")
    }
    
    method generatePrimitiveArrayCopy(c:PrimitiveArrayCopy) {
        out.write("(" + getJavaType(c.type) + ".newWithValues(")
        generateValueCode(c.array)
        out.write(".contents))")
    }

    method generateIntegerLiteralCode(i:IntegerLiteral) {
        if i.type = IntType.INT32
            out.write(i.value)
        else if i.type = IntType.INT64
            out.write(i.value + "L")
        else if i.type = IntType.UINT32
            out.write(i.value->>(Int32))
        else if i.type = IntType.UINT64
            out.write(i.value->>(Int64) + "L")
        else
            out.write("((" + getJavaType(i.type) + ") " + i.value + ")")
    }
    
    method generateCastCode(c:Cast) {
        var srcType := c.value.type
        var destType := c.type
        var mask := srcType.isInteger & srcType->>(PrimitiveType).size < 8 & 
                !srcType->(IntType).signed & destType.isInteger
        out.write("((" + getJavaType(destType) + ") ")
        if mask {
            out.write("(")
            generateValueCode(c.value)
            out.write(" & 0x" + srcType->>(PrimitiveType).size * 2 * "F")
            if destType->>(PrimitiveType).size = 8
                out.write("L")
            out.write(")")
        }
        else {
            def check := !c.safe & !srcType.isPrimitive
            if check {
                if destType.isNullable
                    out.write("panda.core.PandaCore.checkCastNullable(")
                else
                    out.write("panda.core.PandaCore.checkCast(")
            }
            generateValueCode(c.value)
            if check {
                out.write(", ")
                out.write(getJavaType(destType))
                out.write(".class)")
            }
        }
        out.write(")")
    }
-*
    method generateMethodValueCode(mv:MethodValue) {
        out.write(getJavaType(mv.type) + ".createnew$constructor(new " + 
                getJavaMethodType(mv.type.unwrapNullable->(MethodType)) + "() { ")
        var m := mv.rawMethodNode
        out.write("public java.lang.Object method(")
        for i, p in m.parameters {
            if i > 0
                out.write(", ")
            out.write(getJavaType(p.type) + " param" + i)
        }
        out.write(") { ") 
        if m.returnType != VoidType.VOID {
            out.write("return ")
            if m.returnType.isPrimitive {
                out.write(m.returnType->(PrimitiveType).wrapperVersion().name + 
                        ".createnew$constructor(")
            }
        }
        var start:Int
        if m.annotations.isClass | m.annotations.isWrapperMethod {
            out.write(getName(m.owner))
            start := 0
        }
        else {
            out.write("param0")
            start := 1
        }
        out.write("." + getName(m) + "(")
        for i, p in m.parameters {
            if i < start
                continue
            if i > start
                out.write(", ")
            out.write("param" + i)
        }
        out.write(")")
        if m.returnType = VoidType.VOID
            out.write("; return null")
        else {
            if m.returnType.isPrimitive {
                out.write(")")
            }
        }
        out.write("; } }, null)")
    }
*-
    method generateDynamicCallCode(d:DynamicCall) {
        if d.type != VoidType.VOID {
            out.write("((")
            if d.type.isPrimitive
                out.write(getJavaReferenceType(d.type))
            else
                out.write(getJavaType(d.type))
            out.write(") ")
        }
        out.write("((")
        out.write(getJavaMethodType(d.methodValue.type.unwrapNullable->(MethodType)))
        out.write(") ")
        generateValueCode(d.methodValue)
        out.write(").raw(")
        for i, p in d.parameters {
            if i > 0
                out.write(", ")
            generateValueCode(p)
            if p.type.isWrapper
                out.write(".$value")
        }
        out.write(")")
        if d.type != VoidType.VOID
            out.write(")")
    }

    method generateReusedValueDefinitionCode(rvd:ReusedValueDefinition,
            topLevel:Bit) {
        def name := "$reused" + variableIndex
        variableIndex += 1
        names[rvd] := name
        if !topLevel
            out.write("(")
        out.write(name + " = ")
        generateValueCode(rvd.value)
        if !topLevel
            out.write(")")
        reusedValueDefinitions.append(getJavaType(rvd.type) + " " +
                name + ";\n")
    }

    method generateReusedValueCode(rv:ReusedValue) {
        def name := names[rv.owner]
        assert name != null: "ReusedValue at \{rv.position} has not been named"
        out.write(name)
    }

    method generateValueCode(v:Value, topLevel:Bit) {
        if v-?>(VariableAssignment)
            generateVariableAssignmentCode(v->(VariableAssignment), topLevel)
        else if v-?>(MethodCall)
            generateMethodCallCode(v->(MethodCall))
        else if v-?>(BinaryOperation)
            generateBinaryCode(v->(BinaryOperation))
        else if v-?>(UnaryOperation)
            generateUnaryOperationCode(v->(UnaryOperation))
        else if v-?>(PrimitiveArrayIndexValue)
            generateIndexValueCode(v->(PrimitiveArrayIndexValue))
        else if v-?>(IntegerLiteral)
            generateIntegerLiteralCode(v->(IntegerLiteral))
        else if v-?>(RealLiteral) {
            out.write(v->(RealLiteral).value)
            if v.type = RealType.REAL32
                out.write("f")
        }
        else if v-?>(StringLiteral) {
            var i := stringConstants.length
            stringConstants.append(v->(StringLiteral).value)
            out.write(STRING_CONSTANT_PREFIX + i)
        }
        else if v-?>(BitLiteral)
            out.write(v->(BitLiteral).value)
        else if v-?>(ClassLiteral)
            out.write(getJavaType(v->(ClassLiteral).value))
        else if v-?>(ClassObjectLiteral) {
            out.write(PANDACORE + '.getClass("')
            out.write(getJavaType(v->(ClassObjectLiteral).value))
            out.write('", "')
            out.write(getDisplayName(context.getStub(
                    v->(ClassObjectLiteral).value)))
            out.write('")')
        }
        else if v-?>(VariableReference) 
            out.write(getName(v->(VariableReference).variable))
        else if v-?>(FieldReference)
            generateFieldReferenceCode(v->(FieldReference))
        else if v-?>(NullLiteral) {
            out.write("((")
            out.write(getJavaType(v.type))
            out.write(") null)")
        }
        else if v-?>(Cast)
            generateCastCode(v->(Cast))
        else if v-?>(Construct)
            generateConstructCode(v->(Construct))
        else if v-?>(NewPrimitiveArrayWithLength)
            generateNewPrimitiveArrayWithLengthCode(v->(NewPrimitiveArrayWithLength))
        else if v-?>(NewPrimitiveArrayWithValues)
            generateNewPrimitiveArrayWithValuesCode(v->(NewPrimitiveArrayWithValues))
        else if v-?>(ArrayLiteral)
            generateArrayLiteralCode(v->(ArrayLiteral))
        else if v-?>(PrimitiveArrayCopy)
            generatePrimitiveArrayCopy(v->(PrimitiveArrayCopy))
        else if v-?>(Unwrap)
            generateValueCode(v->(Unwrap).value)
        else if v-?>(ReusedValueDefinition) {
            generateReusedValueDefinitionCode(v->(ReusedValueDefinition),
                    topLevel)
        }
        else if v-?>(ReusedValue)
            generateReusedValueCode(v->(ReusedValue))
        else if v-?>(DynamicCall)
            generateDynamicCallCode(v->(DynamicCall))
        else {
            throw new InternalCompilerException("unsupported value type: " +
                    v.class.name, v.position)
        }
    }

    method generateValueCode(v:Value) {
        generateValueCode(v, false)
    }
    
    method generateIfCode(i:If) {
        out.write("if (")
        generateValueCode(i.test)
        out.write(") ")
        if i.thenStatement-!>(Block)
            out.writeLine("{")
        generateStatementCode(i.thenStatement)
        if i.thenStatement-!>(Block)
            out.writeLine("}")
        var elseStatement := i.elseStatement
        if elseStatement != null {
            out.write("else ")
            if i.elseStatement-!>(Block)
                out.writeLine("{")
            generateStatementCode(elseStatement)
            if i.elseStatement-!>(Block)
                out.writeLine("}")
        }
    }
    
    method generateLoopCode(l:Loop) {
        loops.push(l)
        var label := l.label
        if label != null
            out.write(label + ": ")
        out.write("for (;;) ")
        generateStatementCode(l.statement)
        assert loops.pop() = l
    }
    
    method generateLoopWithContinueBlockCode(l:LoopWithContinueBlock) {
        loops.push(l)
        var label := l.label
        if label != null
            out.write(label + ": ")
        out.writeLine("for (;;) {")
        out.level += 1
        generateStatementCode(l.statement)
        if l.statement-!>(Block) | !l.statement->(Block).endsInBranchOrThrow
            generateBlockCode(l.continueBlock)
        out.level -= 1
        out.writeLine("}")
        assert loops.pop() = l
    }
    
    method generateWhileCode(w:While) {
        loops.push(w)
        var label := w.label
        if label != null
            out.write(label + ": ")
        out.write("while (")
        generateValueCode(w.test)
        out.write(") ")
        generateStatementCode(w.statement)
        assert loops.pop() = w
    }
    
    method generateDoCode(d:Do) {
        loops.push(d)
        var label := d.label
        if label != null
            out.write(label + ": ")
        out.write("do ")
        generateStatementCode(d.statement)
        out.write(" while (")
        generateValueCode(d.test)
        out.write(");")
        assert loops.pop() = d
    }

    method generateVariableAssignmentCode(va:VariableAssignment, topLevel:Bit) {
        if !topLevel
            out.write("(")
        out.write(getName(va.variable) + " = ")
        generateValueCode(va.value)
        if !topLevel
            out.write(")")
    }
    
    method generateFieldAssignmentCode(fa:FieldAssignment) {
        generateValueCode(fa.object)
        out.write(".")
        out.write(getName(fa.fieldNode))
        if fa.fieldNode.annotations.isThread {
            out.write(".set(")
            generateValueCode(fa.value)
            out.write(")")
        }
        else {
            out.write(" = ")
            generateValueCode(fa.value)
        }
        out.writeLine(";")
    }
    
    method generateIndexedAssignmentCode(ia:PrimitiveArrayIndexAssignment) {
        generateValueCode(ia.array)
        out.write(".set(")
        generateValueCode(ia.index)
        out.write(", ")
        generateValueCode(ia.value)
        out.writeLine(");")
    }
    
    method generateAssertCode(a:Assert) {
        out.write("if (!")
        generateValueCode(a.test)
        out.writeLine(")")
        out.level += 1
        def error := a.error
        if error = null {
            out.writeLine("throw new panda.core.PandaException(" + 
                    "panda.core.AssertionError.createnew$constructor(" +
                    "panda.core.PandaCore.newString(\"" +
                    "assertion error\")));")
        }
        else if error.type = ClassType.STRING {
            out.write("throw new panda.core.PandaException(" +
                    "panda.core.AssertionError.createnew$constructor(")
            generateValueCode(error)
            out.writeLine("));")
        }
        else {
            out.write("throw new panda.core.PandaException(")
            generateValueCode(error)
            out.writeLine(");")
        }
        out.level -= 1
    }
    
    method generateThrowCode(t:Throw) {
        out.write("throw new panda.core.PandaException(")
        generateValueCode(t.error)
        out.writeLine(");")
    }
-*    
    method generateTryCode(t:Try) {
        out.write("try ")
        generateBlockCode(t.block)
        var rawName := "$e" + variableIndex
        variableIndex += 1
        out.writeLine("catch (panda.core.PandaException " + rawName + ") {")
        out.level += 1
        var eName := "$e" + variableIndex
        variableIndex += 1
        out.writeLine("panda.core.Error " + eName + " = " + rawName + 
                ".getPandaError();")
        for i in 1 ... t.length - 1 {
            var c := t[i]->(Catch)
            if i > 1
                out.write("else ")
            out.writeLine("if (" + eName + " instanceof " + 
                    getJavaType(c.exception.type) + ") {")
            out.level += 1
            out.writeLine(getName(c.exception) + " = (" + 
                    getJavaType(c.exception.type) + ") " + eName + ";")
            generateBlockCode(c)
            out.level -= 1
            out.writeLine("}")
        }
        if t.length > 1
            out.write("else ")
        out.writeLine("throw " + rawName + ";")
        out.level -= 1
        out.writeLine("}")
    }
*-
    method generateReturnCode(r:Return) {
        out.write("return")
        var value := r.value
        if value != null {
            out.write(" ")
            generateValueCode(value)
        }
        out.writeLine(";")
    }
    
    function findLoop(label:String?):AbstractLoop {
        if label = null
            return loops.peek
        for i in 0 .. loops.length {
            if loops.peek(i).label = label
                return loops.peek(i)
        }
        unreachable
    }

    method generateBreakCode(b:Break) {
        def target := findLoop(b.label)
        out.write("break")
        var label := b.label
        if label != null
            out.write(" " + label)
        out.writeLine(";")
    }
    
    method generateContinueCode(c:Continue) {
        def target := findLoop(c.label)
        if target-?>(LoopWithContinueBlock) {
            out.write("{")
            generateBlockCode(target->(LoopWithContinueBlock).continueBlock)
        }
        out.write("continue")
        var label := c.label
        if label != null
            out.write(" " + label)
        out.writeLine(";")
        if target-?>(LoopWithContinueBlock) {
            out.write("}")
        }
    }
    
    method generateStatementCode(s:Statement) {
        switch s.class {
            case class(ValueStatement): {
                def value := s->(ValueStatement).value
                generateValueCode(value, true)
                out.writeLine(";")
            }
            case class(FieldAssignment): generateFieldAssignmentCode(
                    s->(FieldAssignment))
            case class(PrimitiveArrayIndexAssignment): 
                    generateIndexedAssignmentCode(
                        s->(PrimitiveArrayIndexAssignment))
            case class(If): generateIfCode(s->(If))
            case class(Loop): generateLoopCode(s->(Loop))
            case class(LoopWithContinueBlock): 
                    generateLoopWithContinueBlockCode(s->(LoopWithContinueBlock))
            case class(While): generateWhileCode(s->(While))
            case class(Do): generateDoCode(s->(Do))
            case class(Block): generateBlockCode(s->(Block))
            case class(Assert): generateAssertCode(s->(Assert))
            case class(Return): generateReturnCode(s->(Return))
            case class(Break): generateBreakCode(s->(Break))
            case class(Continue): generateContinueCode(s->(Continue))
            case class(Throw): generateThrowCode(s->(Throw))
--            case class(Try): generateTryCode(s->(Try))
            case class(CatchExit): { }
            case class(Unreachable): out.writeLine(
                    "throw new panda.core.PandaException(" + 
                    "panda.core.AssertionError.createnew$constructor(" +
                    "panda.core.PandaCore.newString(\"" +
                    "unreachable\")));")
            default: out.writeLine("unsupported:" + s.class.name + "(" + s + 
                    ")")
        }
    }
    
    method generateBlockCode(b:Block) {
        generateBlockCode(b, false)
    }

    method generateBlockCode(b:Block, topLevel:Bit) {
        out.writeLine("{")
        if topLevel {
            -- HACK: we need to look at the CFG to determine whether the block
            -- can be exited, in order to know whether we need to add a 
            -- "return null;" at the end of it. Just a quick hack to avoid
            -- unreachable code errors until I get the CFG analysis in place.
            def m := currentMethod->(MethodNode).stub
            if isMethodClass(m.owner) & m.returnType = VoidType.VOID
                out.writeLine("if (true) { // FIXME hack!")
        }
        out.level += 1
        if topLevel {
            def m := currentMethod->(MethodNode)
            for v in m.localVariables {
                out.writeLine(getJavaType(v.type) + " " + 
                        getName(v) + ";")
            }
        }
        for s in b.statements
            generateStatementCode(s->(Statement))
        if topLevel {
            def m := currentMethod->(MethodNode).stub
            if isMethodClass(m.owner) & m.returnType = VoidType.VOID
                out.writeLine("} return null;")
        }
        out.level -= 1
        out.writeLine("}")
    }
    
    method generateFieldCode(f:FieldNode) {
        if currentClass->(ClassNode).stub.annotations.isUnspecified & 
                !f.annotations.isThread &
                !f.annotations.isClass
            return
        if f.name = FieldNode.ELEMENTS_NAME {
            var type := getJavaType(f.type)
            out.writeLine("public " + type + "[] contents = new " + type + 
                    "[0];")
        }
        else {
            if f.annotations.isThread {
-*                var type := "java.lang.ThreadLocal<" + 
                        getJavaReferenceType(f.type) + ">"
                out.writeLine("public static " + type + " " + getName(f) + 
                        " = new " + type + "()")
                var initializer := currentClass->(ClassNode).symbolTable.getMethod(
                            f.position,
                            ASTGenerator.getThreadLocalInitializerName(f),
                            new PrimitiveArray<Value>(), true)
                if initializer != null {
                    out.writeLine(" {")
                    out.level += 1
                    out.writeLine("protected " + 
                            getJavaReferenceType(f.type) + " initialValue() {")
                    out.level += 1
                    out.writeLine("return " + initializer.name +
                            "();")
                    out.level -= 1
                    out.writeLine("}")
                    out.level -= 1
                    out.write("}")
                }
                out.writeLine(";")*-
                unreachable
            }
            else {
                out.write("public ")
                if f.annotations.isClass
                    out.write("static ")
                out.write(getJavaType(f.type) + " " + getName(f))
                out.writeLine(";")
            }
        }
    }

    method generateMethodDeclaration(m:MethodStub) {
        out.write("public ")
        if isClass(m)
            out.write("static ")
        if m.annotations.isAbstract
            out.write("abstract ")
        else if context.getStub(m.owner).isInterface & !isClass(m)
            out.write("default ")
        def returnType:String
        if isMethodClass(m.owner) {
            if m.returnType = VoidType.VOID
                returnType := getJavaType(ClassType.OBJECT)
            else
                returnType := getJavaReferenceType(m.returnType)
        }
        else
            returnType := getJavaType(m.returnType)
        out.write("\{returnType} \{methodNamer.getName(m)}(")
        var start := 0
        if !isClass(m)
            start := 1
        for i in start .. m.parameters.length {
            if i > start
                out.write(", ")
            def p := m.parameters[i]
            out.write(getJavaType(p.type) + " " + p.name)
        }
        if m.parameters.length = 0 & getName(m) = 
                JavaMethodNamingStrategy.PANDAMAIN_NAME
            out.write("panda.collections.PrimitiveArray$LTpanda$core$String$GT $arg")
        out.write(");")

    }
    
    method generateMethodCode(m:MethodNode) {
        if currentClass->(ClassNode).stub.annotations.isUnspecified & 
                !m.stub.annotations.isClass
            return
        currentMethod := m
        if m.stub.name = MethodNode.CLASS_INIT_NAME
            hasClassInit := true
        out.write("public ")
        if isClass(m.stub)
            out.write("static ")
        if m.stub.annotations.isAbstract
            out.write("abstract ")
        else if context.getStub(m.stub.owner).isInterface & !isClass(m.stub)
            out.write("default ")
        def returnType:String
        if isMethodClass(m.stub.owner) {
            if m.stub.returnType = VoidType.VOID
                returnType := getJavaType(ClassType.OBJECT)
            else
                returnType := getJavaReferenceType(m.stub.returnType)
        }
        else
            returnType := getJavaType(m.stub.returnType)
        out.write("\{returnType} \{methodNamer.getName(m.stub)}(")
        var start := 0
        if !isClass(m.stub)
            start := 1
        for i in start .. m.parameters.length {
            if i > start
                out.write(", ")
            var p := m.parameters[i]
            out.write(getJavaType(p.type) + " " + getName(p))
        }
        if m.parameters.length = 0 & getName(m.stub) = 
                JavaMethodNamingStrategy.PANDAMAIN_NAME
            out.write("panda.collections.PrimitiveArray$LTpanda$core$String$GT $arg")
        out.write(")")
        if m.stub.annotations.isAbstract
            out.writeLine(";")
        else {
            if m.stub.annotations.isExternal {
                out.writeLine(" {")
                if m.stub.returnType != VoidType.VOID
                    out.write("return ")
                out.write("$external." + getName(m.stub) + "(")
                for i in 0 ... m.parameters.length - 1 {
                    if i > 0
                        out.write(", ")
                    var p := m.parameters[i]
                    out.write(getName(p))
                }
                out.writeLine(");")
                out.writeLine("}")
            }
            else {
                out.writeLine("{")
                def buffer := new MemoryOutputStream()
                def oldOut := out
                out := new IndentedOutputStream(buffer)

                -- DEBUG:temp
                out.indentSize := 0

                reusedValueDefinitions.clear()
                generateBlockCode(m.body, true)
                out := oldOut
                out.write(reusedValueDefinitions)
                out.write(buffer->>(String))
                out.writeLine("}")
            }
        }
        
        if m.stub.methodType = MethodNodeType.CONSTRUCTOR & 
                !context.getStub(m.stub.owner).annotations.isAbstract() {
            def type := getJavaType(m.stub.owner)
            out.write("public static \{type} create\{getName(m.stub)}(")
            for i in 1 ... m.parameters.length - 1 {
                if i > 1
                    out.write(", ")
                var p := m.parameters[i]
                out.write(getJavaType(p.type) + " " + getName(p))
            }
            out.writeLine(") {")
            out.level += 1
            out.writeLine("\{type} $this = new \{type}();")
            out.writeLine("$this.$cl = " + PANDACORE + '.getClass("' +
                    getName(m.stub) + '", "' +
                    getDisplayName(context.getStub(m.stub.owner)) + '");')
            out.write(getName(m.stub) + "($this")
            for i in 1 ... m.parameters.length - 1 {
                var p := m.parameters[i]
                out.write(", " + getName(p))
            }
            out.writeLine(");")
            out.writeLine("return $this;")
            out.level -= 1
            out.writeLine("}")
        }
        if methodNamer.getName(m.stub) = 
                JavaMethodNamingStrategy.PANDAMAIN_NAME {
            out.writeLine(
                    "public static void main(java.lang.String[] arg) {")
            out.level += 1
            out.write(JavaMethodNamingStrategy.PANDAMAIN_NAME + 
                    "(" + PANDACORE + ".convertArgs(arg));")
            out.level -= 1
            out.writeLine("}")
        }
        currentMethod := null
    }

    method generateStringConstants() {
        for i in 0 .. stringConstants.length {
            out.writeLine("public static final " + class(String).name + " " + 
                    STRING_CONSTANT_PREFIX + i + " = " + PANDACORE + 
                    '.newString("' + StringLiteral.escape(stringConstants[i]) + 
                    '");')
        }
    }
    
    function isMethodClass(cl:ClassType):Bit {
        def superclass := context.getStub(cl).superclass
        return superclass != null & (superclass = ClassType.METHOD | 
                    superclass.name = ClassType.MUTABLE_METHOD)
    }

    method generateClassCode(cl:ClassNode) {
        if cl.stub.isExternal
            return
        if cl.stub.annotations.isUnspecified & cl.stub.type.isPrimitiveArray()
            return
        currentClass := cl
        hasClassInit := false
        stringConstants := new PrimitiveArray<String>()
        var rootPath := self.rootPath
        assert rootPath != null
        def dest := rootPath.resolve(getName(cl.stub).replace(".", "/") + 
                ".java")
        var parent := dest.parent()
        if parent = null {
            throw new CompilerException("could not determine parent of '" + 
                    dest.path + "'")
        }
        parent.createDirectories()
        out := new IndentedOutputStream(new BufferedOutputStream(
                dest.openOutputStream()))

        -- DEBUG:temp
        out.indentSize := 0

        var packageName := getJavaType(cl.stub.type)
        var index := packageName.indexOf("<")
        if index != null
            packageName := packageName[..index]
        index := packageName.lastIndexOf(".")
        if index != null {
            packageName := packageName[..index]
            out.writeLine("package " + packageName + ";")
        }
        else
            out.writeLine("package " + UNNAMED + ";")
        out.write("public ")
        if cl.stub.annotations.isAbstract()
            out.write("abstract ")
        if cl.stub.isInterface
            out.write("interface ")
        else 
            out.write("class ")
        var simpleName := getSimpleName(cl.stub)
        out.write(simpleName)
        var superclass := cl.stub.superclass
        if cl.stub.isInterface {
            for i, intf in cl.stub.interfaces {
                if i = 0
                    out.write(" extends ")
                else
                    out.write(", ")
                out.write(getName(getStub(intf)))
            }
        }
        else {
            if superclass != null {
                out.write(" extends " + getName(getStub(superclass)))
            }
            if cl.stub.type = ClassType.OBJECT
                out.write(" implements java.lang.Cloneable")
-*            else if isMethodClass(cl.stub.type) {
                def m := cl.stub.methods.filter(
                        m => m.name = "raw").iterator.next()
                def typeName := new MutableString("(")
                for i, param in m.parameters {
                    if i = 0
                        continue
                    if i > 1
                        typeName.append(",")
                    typeName.append(param.type.name)
                }
                typeName.append(")=")
                if m.methodType = MethodNodeType.METHOD
                    typeName.append("&")
                typeName.append(">(")
                if m.returnType != VoidType.VOID
                    typeName.append(m.returnType.name)
                typeName.append(")")
                def methodType := SymbolTable.master.getType(cl.position,
                        typeName->>(String))
                out.write(" implements " + 
                        getJavaMethodType(methodType->(MethodType)))
            }*-
            else {
                for i, intf in cl.stub.interfaces {
                    if i = 0
                        out.write(" implements ")
                    else
                        out.write(", ")
                    out.write(getName(getStub(intf)))
                }
            }
        }
        out.writeLine(" {")
        out.level += 1

        -- add $external if needed
        for m in cl.stub.methods {
            if m.annotations.isExternal {
                def className := getName(cl.stub) + "_External"
                out.writeLine("    private static final " + className + 
                        " $external = new " + className + "Impl();")
                break
            }
        }

        -- add array constructor
        if cl.stub.type-?>(GenericType) {
            def g := cl.stub.type->(GenericType)
            def elementType := g.parameters[0]
            if g.base = ClassType.ARRAY | g.base = ClassType.IMMUTABLE_ARRAY {
                out.writeLine("public \{simpleName}() { }")
                out.writeLine("public \{simpleName}(\{getJavaType(elementType)}... values) {")
                out.level += 1
                out.writeLine("new$constructor(this);")
                out.writeLine("ensureCapacity(values.length);")
                out.writeLine("$_length = values.length;")
                out.writeLine("for (int i = 0; i < values.length; i++)")
                out.level += 1
                out.writeLine("$contents.set(i, values[i]);")
                out.level -= 2
                out.writeLine("}")
            }
        }

        if !cl.stub.isInterface {
            out.write("static { " + PANDACORE + ".initClass(" + PANDACORE + 
                    '.getClass("' + getName(cl.stub) + '", "' +
                    getDisplayName(cl.stub) + '"), ')
            if superclass != null {
                out.write('panda.core.PandaCore.getClass("' + 
                        getName(getStub(superclass)) + '", "' + 
                        getDisplayName(getStub(superclass)) + '")')
            }
            else
                out.write("null")
            out.writeLine("); }")
        }

        if cl.stub.type.isPrimitiveArray() {
            def elementType := getJavaType(cl.stub.type->>(PrimitiveArrayType).
                    elementType->(Type))

            -- no-arg constructor
            out.writeLine("public \{simpleName}() {")
            out.writeLine("}")
            out.writeLine("public static " + simpleName + 
                    " newWithLength(int size) {")
            out.level += 1
            out.writeLine(simpleName + " result = new " + simpleName + 
                    "();")
            out.writeLine('result.$cl = panda.core.PandaCore.getClass("' + 
                    getName(cl.stub) + '", "' + getDisplayName(cl.stub) + '");')
            out.writeLine("result.contents = new " + elementType + "[size];")
            out.writeLine("result.$$length = size;")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            -- newWithRange (mutable)
-*            var arrayName:String
            var immutablePrimitiveArrayName:String
            constant MUTABLE_PREFIX := "panda.collections.PrimitiveArray$"
            constant IMMUTABLE_PREFIX := "panda.collections.ImmutablePrimitiveArray$"
            if cl.type().isImmutable {
                immutablePrimitiveArrayName := getName(cl)
                assert immutablePrimitiveArrayName.startsWith(IMMUTABLE_PREFIX)
                arrayName := MUTABLE_PREFIX + 
                        immutablePrimitiveArrayName[IMMUTABLE_PREFIX.length..]
            }
            else {
                arrayName := getName(cl)
                assert arrayName.startsWith(MUTABLE_PREFIX)
                immutablePrimitiveArrayName := IMMUTABLE_PREFIX + 
                        arrayName[MUTABLE_PREFIX.length..]
            }*-

            out.writeLine("public static " + simpleName + " newWithRange(" +
                    elementType + "[] source, int offset, " +
                    "int arrayLength) {")
            out.level += 1
            out.writeLine(simpleName + " result = new " + simpleName + 
                    "();")
            out.writeLine('result.$cl = panda.core.PandaCore.getClass("' + 
                    getName(cl.stub) + '", "' + getDisplayName(cl.stub) + '");')
            out.writeLine("result.contents = new " + elementType + 
                    "[arrayLength];")
            out.writeLine("java.lang.System.arraycopy(source, offset, " +
                    "result.contents, 0, arrayLength);")
            out.writeLine("result.$$length = arrayLength;")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            -- newWithValues
            out.writeLine("public static " + simpleName + " newWithValues(" +
                    elementType + "... values) {")
            out.level += 1
            out.writeLine(simpleName + " result = newWithLength(values.length);")
            out.writeLine("java.lang.System.arraycopy(values, 0, result.contents, 0, values.length);")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            -- get
            out.writeLine("public " + elementType + " get(int i) {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            out.writeLine("if (i >= $$length) throw new java.lang.IndexOutOfBoundsException(String.valueOf(i));")
            out.writeLine("return contents[i];")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (java.lang.IndexOutOfBoundsException e) {")
            out.writeLine("throw new panda.core.PandaException(panda.collections.IndexOutOfBoundsError.createnew$constructor(panda.core.PandaCore.newString(\"PrimitiveArray index out of bounds: requested element \" + i + \", array length is \" + $$length)));")
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")

            -- set
            out.writeLine("public void set(int i, " + elementType + " v) {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            out.writeLine("if (i >= $$length) throw new java.lang.IndexOutOfBoundsException(String.valueOf(i));")
            out.writeLine("contents[i] = v;")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (java.lang.IndexOutOfBoundsException e) {")
            out.writeLine("throw new panda.core.PandaException(panda.collections.IndexOutOfBoundsError.createnew$constructor(panda.core.PandaCore.newString(\"PrimitiveArray index out of bounds: requested element \" + i + \", array length is \" + $$length)));")
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")
        }
        var oldOut := out
        var buffer := new MemoryOutputStream()
        out := new IndentedOutputStream(buffer)

        -- DEBUG:temp
        out.indentSize := 0

        for m in cl.methods
            generateMethodCode(m)
        for m in cl.stub.methods.filter(m => m.annotations.isAbstract)
            generateMethodDeclaration(m)
        for f in cl.stub.fields
            generateFieldCode(f)
        out.close()
        out := oldOut
        generateStringConstants()
        if hasClassInit
            out.writeLine("static { " + MethodNode.CLASS_INIT_NAME + "(); }")
        out.write(buffer->>(String))

        if cl.stub.name = class(Object).name {
            out.writeLine("public Object clone() {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            out.writeLine("return (panda.core.Object) super.clone();")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (CloneNotSupportedException e) {")
            out.level += 1
            out.writeLine("throw new RuntimeException(e);")
            out.level -= 1
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")
        }
        out.level -= 1
        out.writeLine("}")
        out.close()
    }

    method generateMethodTypeCode(mt:MethodType) {
        def rootPath := self.rootPath
        assert rootPath != null : "no rootPath"
        def name := getJavaMethodType(mt)
        def lastIndex := name.lastIndexOf(".")
        assert lastIndex != null : "expected '.' in \{name}"
        def parent := rootPath.resolve(name[0 .. lastIndex].replace(".", 
                "/"))
        parent.createDirectories()
        def dest := parent.resolve(name[lastIndex + 1..] + ".java")
        def out := dest.openOutputStream()
        out.writeLine("package " + name[0 .. lastIndex] + ";")
        out.writeLine("public interface " + name[lastIndex + 1..] + " {")
        out.write("    java.lang.Object raw(")
        for i, t in mt.methodParameters {
            if i > 0
                out.write(", ")
            if t.unwrapNullable.isWrapper
                out.write(getJavaType(t->>(PrimitiveType)) + " param" + i)
            else
                out.write(getJavaType(t) + " param" + i)
        }
        out.writeLine(");")
        out.writeLine("}")
        out.close()
    }

    @override
    method generateCode(target:File) {
        if target.exists() & !target.isDirectory()
            throw new CompilerException("Java output must be to a directory")
        rootPath := target
        var rootPath := self.rootPath
        assert rootPath != null
        rootPath.createDirectories()
        for cl in program.classes.values
            generateClassCode(cl)
        for mt in methodTypes
            generateMethodTypeCode(mt)
    }
}