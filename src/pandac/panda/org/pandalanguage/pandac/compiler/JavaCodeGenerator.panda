package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.And
uses org.pandalanguage.pandac.tree.AndLeft
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.BitwiseAnd
uses org.pandalanguage.pandac.tree.BitwiseNot
uses org.pandalanguage.pandac.tree.BitwiseOr
uses org.pandalanguage.pandac.tree.BitwiseXor
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Divide
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.Equal
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.LogicalShiftRight
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodStub
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewArrayWithLength
uses org.pandalanguage.pandac.tree.NewArrayWithRange
uses org.pandalanguage.pandac.tree.NewArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryMinus
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedType
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.ArrayType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class JavaCodeGenerator : CodeGenerator {
    constant UNNAMED := "$unnamed"
    constant NAME := "JavaCodeGenerator.name"
    constant PANDACORE := "panda.core.PandaCore"
    constant STRING_CONSTANT_PREFIX := "$STRING_CONSTANT_"
    
    var rootPath:File?
    var out := new IndentedOutputStream(Console.outputStream)
    var variableIndex := 0
    var currentMethod:MethodNode?
    var stringConstants := new Array<String>()
    var hasClassInit := false
    -- method types we have run into which need interfaces defined for them
    -- FIXME use a set
    var methodTypes := new Array<MethodType>()

    method getName(cl:ClassNode):String {
        return getJavaType(cl.type())
    }

    method getDisplayName(cl:ClassNode):String {
        var result := cl.name
        if result.startsWith("panda.core.") & result.endsWith("Wrapper")
            result := result[..result.length - "Wrapper".length]
        return result
    }

    @class
    function needsDisambiguation(m:MethodNode):Bit {
        -- FIXME implement this
        return true
    }

    function getName(m:MethodNode):String {
        return m.getProperty(MethodNamer.NAME)->(String)
    }
    
    function getName(f:FieldNode):String {
        -- prepending a "$" prevents conflicts with Java keywords, and also
        -- handles edge cases where a field has the same name as a package
        -- (consider trying to refer to "panda.core.String" when we have
        -- defined a field named "panda")
        return "$" + f.name
    }
    
    method getName(v:Variable):String {
        if v-?>(Parameter) & v.name = Parameter.SELF_NAME {
            var currentMethod := self.currentMethod
            if currentMethod != null & 
                    (currentMethod.methodType = MethodNodeType.CONSTRUCTOR |
                    currentMethod.annotations.isWrapperMethod)
                return "$this"
            else
                return "this"
        }
        var result := v.getProperty(NAME)->(String?)
        if result = null {
            result := v.name + variableIndex
            v.setProperty(NAME, result)
            variableIndex += 1
        }
        return result
    }
    
    function isClass(m:MethodNode):Bit {
        return m.annotations.isClass | 
                m.methodType = MethodNodeType.CONSTRUCTOR |
                m.annotations.isWrapperMethod
    }
    
    method getJavaReferenceType(t:Type):String {
        if t.isArray
            return getJavaType(t)
        switch t {
            case IntType.INT8, IntType.UINT8:   return "Byte"
            case IntType.INT16, IntType.UINT16: return "Short"
            case IntType.INT32, IntType.UINT32: return "Integer"
            case IntType.INT64, IntType.UINT64: return "Long"
            case CharType.CHAR:   return "Character"
            case BitType.BIT:     return "Boolean"
            case RealType.REAL32: return "Float"
            case RealType.REAL64: return "Double"
            case VoidType.VOID:   return "void"
        }
        var result := t.name
        -- we can't use unnamed packages in Java, because classes in named
        -- packages are not allowed to refer to classes in unnamed packages
        if !("." in result)
            result := UNNAMED + "." + result
        return result.replace("?", "")
    }

    @class
    function isJavaKeyword(token:String):Bit {
        switch token {
            case "abstract", "continue", "for", "new", "switch", "assert",
                    "default", "goto", "package", "synchronized", "boolean",
                    "do", "if", "private", "this", "break", "double", 
                    "implements", "protected", "throw", "byte", "else", 
                    "import", "public", "throws", "case", "enum", "instanceof",
                    "return", "transient", "catch", "extends", "int", "short",
                    "try", "char", "final", "interface", "static", "void",
                    "class", "finally", "long", "strictfp", "volatile", "const",
                    "float", "native", "super", "while": return true
            default: return false
        }
    }

    @class
    function filterNameToken(token:String):String {
        if isJavaKeyword(token)
            return "$" + token
        return token
    }

    @private
    method escape(s:String):String {
        return s.replace("?", "").replace("<", "$LT").replace(">", "$GT")
                .replace(",", "$C").replace("(", "$LP").replace(")", "$RP")
                .replace("=", "$EQ").replace(" ", "")    
    }

    method getJavaType(t:Type):String {
        switch t {
            case IntType.INT8, IntType.UINT8:   return "byte"
            case IntType.INT16, IntType.UINT16: return "short"
            case IntType.INT32, IntType.UINT32: return "int"
            case IntType.INT64, IntType.UINT64: return "long"
            case CharType.CHAR:   return "char"
            case BitType.BIT:     return "boolean"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case VoidType.VOID:   return "void"
            case NativePointerType.NATIVE_POINTER: return "java.lang.Object"
        }
        var result:String
        if t.isArray {
            var eType := t.unwrapNullable->(ArrayType).elementType
            var eName:String
            if eType.isPrimitive {
                assert eType.name.startsWith(ClassNode.CORE)
                eName := eType.name[ClassNode.CORE.length..]
            }
            else
                eName := getJavaType(eType)
            if eType.isNullable
                eName += "$Z"
            if t.isImmutable
                result := class(ImmutableArray).name + "<" + eName + ">"
            else
                result := class(Array).name + "<" + eName + ">"
        } 
        else if t.unwrapNullable-?>(MethodType) {
            if t.isImmutable
                return getJavaType(ClassType.METHOD())
            else
                return getJavaType(ClassType.MUTABLE_METHOD())
        }
        else
            result := t.name.replace(#/\w+/#, token => filterNameToken(token))
        def lt := result.indexOf("<")
        if lt != null
            result := result[..lt] + result[lt..].replace(".", "$")
        -- we can't use unnamed packages in Java, because classes in named
        -- packages are not allowed to refer to classes in unnamed packages
        if !("." in result)
            result := UNNAMED + "." + result
        return escape(result)
    }

    method getJavaMethodType(m:MethodType):String {
        def buffer := new MutableString()
        for i, p in m.methodParameters {
            if i > 0
                buffer.append("$C")
            buffer.append(p.displayName)
        }
        if buffer.length = 0
            buffer.append("$nullary")
        var result := buffer->>(String).replace(".", "$")
        if m.isFunction
            result := "panda.functions." + result
        else
            result := "panda.methods." + result
        var found := false
        for existing in methodTypes {
            if existing = m {
                found := true
                break
            }
        }
        if !found
            methodTypes.append(m)
        def lt := result.indexOf("<")
        if lt != null
            result := result[..lt] + result[lt..].replace(".", "$")
        return escape(result)
    }

    method getSimpleName(cl:ClassNode):String {
        var result := getJavaType(cl.type())
        var lt := result.indexOf("$LT")
        if lt = null
            lt := result.length - 1
        var dot := result.lastIndexOf(".", lt)
        if dot != null
            result := result[dot + 1..]
        return result
    }
    
    method generateMethodCallCode(mc:MethodCall) {
        var m := mc.methodNode
        var start := 0
        if isClass(m)
            out.write(getName(m.parent->(ClassNode)))
        else {
            if mc.isVirtual | !m.isDeclaredVirtual()
                generateValueCode(mc.parameters[0])
            else
                out.write("super")
            start := 1
        }
        out.write(".")
        out.write(getName(m))
        out.write("(")
        for i in start ... mc.parameters.length - 1 {
            if i > start
                out.write(", ")
            generateValueCode(mc.parameters[i])
        }
        out.write(")")
    }
    
    method generateUnaryMinusCode(u:UnaryMinus) {
        if u.value-?>(IntegerLiteral) {
            var v := u.value->(IntegerLiteral).value
            if v = Int32.MAX->(UInt64) + 1 {
                out.write(Int32.MIN)
                return
            }
        }
        out.write("((" + getJavaType(u.type) + ") -(")
        generateValueCode(u.value)
        out.write("))")
    }
    
    @pre(b.left.type = IntType.UINT64)
    method generateUInt64BinaryCode(b:BinaryOperation, op:String) {
        -- not the absolute most efficient way to implement these, but I've got
        -- bigger fish to fry right now
        switch b.class {
            case class(IntDivide): {
                out.write("panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").divide(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")).longValue()")
            }
            case class(Remainder): {
                out.write("panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").remainder(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")).longValue()")
            }
            case class(LessThan), class(LessThanOrEqual), class(GreaterThan), 
                    class(GreaterThanOrEqual): {
                out.write("(panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").compareTo(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")) " + op + " 0)")
            }
            default: {
                out.write("(")
                generateValueCode(b.left)
                out.write(" ")
                out.write(op)
                out.write(" ")
                generateValueCode(b.right)
                out.write(")")
            }
        }
    }

    method generateBinaryCode(b:BinaryOperation, op:String) {
        var operandType := b.left.type
        if operandType = IntType.UINT64 {
            generateUInt64BinaryCode(b, op)
            return
        }
        if b.type = IntType.UINT32
            out.write("(int) (")
        else if b.type.size < 4
            out.write("(\{getJavaType(b.type)}) ")
        out.write("(")
        if operandType = IntType.UINT32 {
            out.write("(((long) ")
            generateValueCode(b.left)
            out.write(") & 0xFFFFFFFF)")
        }
        else
            generateValueCode(b.left)
        out.write(" ")
        out.write(op)
        out.write(" ")
        if operandType = IntType.UINT32 {
            out.write("(((long) ")
            generateValueCode(b.right)
            out.write(") & 0xFFFFFFFF)")
        }
        else
            generateValueCode(b.right)
        out.write(")")
        if b.type = IntType.UINT32
            out.write(" & 0xFFFFFFFF)")
    }

    method generateIndexValueCode(i:IndexValue) {
        out.write("((" + getJavaType(i.type) + ") ")
        generateValueCode(i.array)
        out.write(".get(")
        generateValueCode(i.index)
        out.write("))")
    }
    
    method generateFieldReferenceCode(f:FieldReference) {
        generateValueCode(f.object)
        out.write(".")
        out.write(getName(f.field))
        if f.field.annotations.isThread
            out.write(".get()")
    }
    
    method generateConstructCode(c:Construct) {
        var m := c.methodNode
        out.write(getJavaType(c.type))
        out.write(".create")
        out.write(getName(m))
        out.write("(")
        for i in 0 ... c.parameters.length - 1 {
            if i > 0
                out.write(", ")
            generateValueCode(c.parameters[i])
        }
        out.write(")")
    }
    
    method generateNewArrayWithLengthCode(n:NewArrayWithLength) {
        out.write("(" + getJavaType(n.type) + ".newWithLength(")
        generateValueCode(n.arrayLength)
        out.write("))")
    }
    
    method generateNewArrayWithValuesCode(n:NewArrayWithValues) {
        out.write("(" + getJavaType(n.type) + ".newWithValues(")
        for i in 0 ... n.values.length - 1 {
            if i > 0
                out.write(", ")
            generateValueCode(n.values[i])
        }
        out.write("))")
    }
    
    method generateNewArrayWithRangeCode(n:NewArrayWithRange) {
        out.write("(" + getJavaType(n.type) + ".newWithRange(")
        generateValueCode(n.source)
        out.write(".contents, ")
        generateValueCode(n.offset)
        out.write(", ")
        generateValueCode(n.arrayLength)
        out.write("))")
    }
    
    method generateIntegerLiteralCode(i:IntegerLiteral) {
        if i.type = IntType.INT32
            out.write(i.value)
        else if i.type = IntType.INT64
            out.write(i.value + "L")
        else if i.type = IntType.UINT32
            out.write(i.value->>(Int32))
        else if i.type = IntType.UINT64
            out.write(i.value->>(Int64) + "L")
        else
            out.write("((" + getJavaType(i.type) + ") " + i.value + ")")
    }
    
    method generateTernaryCode(t:Ternary) {
        out.write("(")
        generateValueCode(t.test)
        out.write(" ? ")
        generateValueCode(t.left)
        out.write(" : ")
        generateValueCode(t.right)
        out.write(")")
    }

    method generateCastCode(c:Cast) {
        var srcType := c.value.type
        var destType := c.type
        var mask := srcType.isInteger & srcType.size < 8 & 
                !srcType->(IntType).signed & destType.isInteger
        out.write("((" + getJavaType(destType) + ") ")
        if mask {
            out.write("(")
            generateValueCode(c.value)
            out.write(" & 0x" + srcType.size * 2 * "F")
            if destType.size = 8
                out.write("L")
            out.write(")")
        }
        else {
            def check := !c.safe & CompilerSettings.checkCasts & 
                    !srcType.isPrimitive
            if check {
                if destType.isNullable
                    out.write("panda.core.PandaCore.checkCastNullable(")
                else
                    out.write("panda.core.PandaCore.checkCast(")
            }
            generateValueCode(c.value)
            if check {
                out.write(", ")
                out.write(getJavaType(destType))
                out.write(".class)")
            }
        }
        out.write(")")
    }

    method generateMethodValueCode(mv:MethodValue) {
        out.write(getJavaType(mv.type) + ".createnew$constructor(new " + 
                getJavaMethodType(mv.type.unwrapNullable->(MethodType)) + "() { ")
        var m := mv.rawMethodNode
        out.write("public java.lang.Object method(")
        for i, p in m.parameters {
            if i > 0
                out.write(", ")
            out.write(getJavaType(p.type) + " param" + i)
        }
        out.write(") { ") 
        if m.returnType != VoidType.VOID {
            out.write("return ")
            if m.returnType.isPrimitive {
                out.write(m.returnType->(PrimitiveType).wrapperVersion().name + 
                        ".createnew$constructor(")
            }
        }
        var start:Int
        if m.annotations.isClass | m.annotations.isWrapperMethod {
            out.write(getName(m.owner))
            start := 0
        }
        else {
            out.write("param0")
            start := 1
        }
        out.write("." + getName(m) + "(")
        for i, p in m.parameters {
            if i < start
                continue
            if i > start
                out.write(", ")
            out.write("param" + i)
        }
        out.write(")")
        if m.returnType = VoidType.VOID
            out.write("; return null")
        else {
            if m.returnType.isPrimitive {
                out.write(")")
            }
        }
        out.write("; } }, null)")
    }

    method generateDynamicCallCode(d:DynamicCall) {
        if d.type != VoidType.VOID {
            out.write("((")
            if d.type.isPrimitive
                out.write(getJavaType(d.type->(PrimitiveType).wrapperVersion()))
            else
                out.write(getJavaType(d.type))
            out.write(") ")
        }
        out.write("((")
        out.write(getJavaMethodType(d.methodValue.type.unwrapNullable->(MethodType)))
        out.write(") ")
        generateValueCode(d.methodValue)
        out.write(".$rawPtr).method(")
        for i, p in d.parameters {
            if i > 0
                out.write(", ")
            generateValueCode(p)
        }
        out.write(")")
        if d.type != VoidType.VOID {
            out.write(")")
            if d.type.isPrimitive()
                out.write(".$value")
        }
    }

    method generateReusedValueDefinitionCode(rvd:ReusedValueDefinition) {
        def name := rvd.getProperty(NAME)
        assert name != null: "ReusedValueDefinition at \{rvd.position} has " +
                "not been named"
        if rvd.parent-!>(ValueStatement)
            out.write("(")
        out.write(name + " = ")
        generateValueCode(rvd.value)
        if rvd.parent-!>(ValueStatement)
            out.write(")")
    }

    method generateReusedValueCode(rv:ReusedValue) {
        def name := rv.owner.getProperty(NAME)
        assert name != null: "ReusedValue at \{rv.position} has not been named"
        out.write(name)
    }

    method generateValueCode(v:Value) {
        if v-?>(VariableAssignment)
            generateVariableAssignmentCode(v->(VariableAssignment))
        else if v-?>(MethodCall)
            generateMethodCallCode(v->(MethodCall))
        else if v-?>(Equal)
            generateBinaryCode(v->(Equal), "==")
        else if v-?>(NotEqual)
            generateBinaryCode(v->(NotEqual), "!=")
        else if v-?>(Identity)
            generateBinaryCode(v->(Identity), "==")
        else if v-?>(NotIdentity)
            generateBinaryCode(v->(NotIdentity), "!=")
        else if v-?>(LessThan)
            generateBinaryCode(v->(LessThan), "<")
        else if v-?>(LessThanOrEqual)
            generateBinaryCode(v->(LessThanOrEqual), "<=")
        else if v-?>(GreaterThan)
            generateBinaryCode(v->(GreaterThan), ">")
        else if v-?>(GreaterThanOrEqual)
            generateBinaryCode(v->(GreaterThanOrEqual), ">=")
        else if v-?>(Add)
            generateBinaryCode(v->(Add), "+")
        else if v-?>(Subtract)
            generateBinaryCode(v->(Subtract), "-")
        else if v-?>(UnaryMinus)
            generateUnaryMinusCode(v->(UnaryMinus))
        else if v-?>(Multiply)
            generateBinaryCode(v->(Multiply), "*")
        else if v-?>(Divide)
            generateBinaryCode(v->(Divide), "/")
        else if v-?>(IntDivide)
            generateBinaryCode(v->(IntDivide), "/")
        else if v-?>(Remainder)
            generateBinaryCode(v->(Remainder), "%")
        else if v-?>(BitwiseAnd)
            generateBinaryCode(v->(BitwiseAnd), "&")
        else if v-?>(BitwiseOr)
            generateBinaryCode(v->(BitwiseOr), "|")
        else if v-?>(BitwiseXor)
            generateBinaryCode(v->(BitwiseXor), "^")
        else if v-?>(BitwiseNot) {
            out.write("(~")
            generateValueCode(v->(BitwiseNot).value)
            out.write(")")
        }
        else if v-?>(And)
            generateBinaryCode(v->(And), "&&")
        else if v-?>(Or)
            generateBinaryCode(v->(Or), "||")
        else if v-?>(Xor)
            generateBinaryCode(v->(Xor), "^")
        else if v-?>(ShiftLeft)
            generateBinaryCode(v->(ShiftLeft), "<<")
        else if v-?>(ShiftRight) {
            if v.type->(IntType).signed
                generateBinaryCode(v->(ShiftRight), ">>")
            else
                generateBinaryCode(v->(ShiftRight), ">>>")
        }
        else if v-?>(Not) {
            out.write("(!")
            generateValueCode(v->(Not).value)
            out.write(")")
        }
        else if v-?>(AndLeft) 
            generateValueCode(v->(AndLeft).value)
        else if v-?>(OrLeft) 
            generateValueCode(v->(OrLeft).value)
        else if v-?>(Ternary)
            generateTernaryCode(v->(Ternary))
        else if v-?>(IndexValue)
            generateIndexValueCode(v->(IndexValue))
        else if v-?>(IntegerLiteral)
            generateIntegerLiteralCode(v->(IntegerLiteral))
        else if v-?>(RealLiteral) {
            out.write(v->(RealLiteral).value)
            if v.type = RealType.REAL32
                out.write("f")
        }
        else if v-?>(StringLiteral) {
            var i := stringConstants.length
            stringConstants.append(v->(StringLiteral).value)
            out.write(STRING_CONSTANT_PREFIX + i)
        }
        else if v-?>(BitLiteral)
            out.write(v->(BitLiteral).value)
        else if v-?>(ClassLiteral)
            out.write(getJavaType(v->(ClassLiteral).value))
        else if v-?>(ClassObjectLiteral) {
            out.write(PANDACORE + '.getClass("')
            out.write(getJavaType(v->(ClassObjectLiteral).value))
            out.write('", "')
            out.write(getDisplayName(v->(ClassObjectLiteral).value.classNode()))
            out.write('")')
        }
        else if v-?>(VariableReference) 
            out.write(getName(v->(VariableReference).variable))
        else if v-?>(FieldReference)
            generateFieldReferenceCode(v->(FieldReference))
        else if v-?>(NullLiteral) {
            out.write("((")
            out.write(getJavaType(v.type))
            out.write(") null)")
        }
        else if v-?>(Cast)
            generateCastCode(v->(Cast))
        else if v-?>(Construct)
            generateConstructCode(v->(Construct))
        else if v-?>(NewArrayWithLength)
            generateNewArrayWithLengthCode(v->(NewArrayWithLength))
        else if v-?>(NewArrayWithValues)
            generateNewArrayWithValuesCode(v->(NewArrayWithValues))
        else if v-?>(NewArrayWithRange)
            generateNewArrayWithRangeCode(v->(NewArrayWithRange))
        else if v-?>(DynamicCall)
            generateDynamicCallCode(v->(DynamicCall))
        else if v-?>(MethodValue)
            generateMethodValueCode(v->(MethodValue))
        else if v-?>(Unwrap)
            generateValueCode(v->(Unwrap).value)
        else if v-?>(ReusedValueDefinition)
            generateReusedValueDefinitionCode(v->(ReusedValueDefinition))
        else if v-?>(ReusedValue)
            generateReusedValueCode(v->(ReusedValue))
        else {
            throw new InternalCompilerException("unsupported value type: " +
                    v.class.name, v.position)
        }
    }
    
    method generateIfCode(i:If) {
        out.write("if (")
        generateValueCode(i.test)
        out.write(") " )
        generateBlockCode(i.ifBlock)
        var elseBlock := i.elseBlock
        if elseBlock != null {
            out.write("else ")
            generateBlockCode(elseBlock)
        }
    }
    
    method generateLoopCode(l:Loop) {
        var label := l.label
        if label != null
            out.write(label + ": ")
        out.write("for (;;) ")
        generateBlockCode(l.block)
    }
    
    method generateLoopWithContinueBlockCode(l:LoopWithContinueBlock) {
        var label := l.label
        if label != null
            out.write(label + ": ")
        out.writeLine("for (;;) {")
        out.level += 1
        generateBlockCode(l.block)
        if !l.block.endsInBranch
            generateBlockCode(l.continueBlock)
        out.level -= 1
        out.writeLine("}")
    }
    
    method generateWhileCode(w:While) {
        var label := w.label
        if label != null
            out.write(label + ": ")
        out.write("while (")
        generateValueCode(w.test)
        out.write(") ")
        generateBlockCode(w.block)
    }
    
    method generateDoCode(d:Do) {
        var label := d.label
        if label != null
            out.write(label + ": ")
        out.write("do ")
        generateBlockCode(d.block)
        out.write(" while (")
        generateValueCode(d.test)
        out.write(");")
    }

    method generateVariableAssignmentCode(va:VariableAssignment) {
        if va.parent-!>(ValueStatement)
            out.write("(")
        out.write(getName(va.variable) + " = ")
        generateValueCode(va.value)
        if va.parent-!>(ValueStatement)
            out.write(")")
    }
    
    method generateFieldAssignmentCode(fa:FieldAssignment) {
        generateValueCode(fa.object)
        out.write(".")
        out.write(getName(fa.fieldNode))
        if fa.fieldNode.annotations.isThread {
            out.write(".set(")
            generateValueCode(fa.value)
            out.write(")")
        }
        else {
            out.write(" = ")
            generateValueCode(fa.value)
        }
        out.writeLine(";")
    }
    
    method generateIndexedAssignmentCode(ia:IndexedAssignment) {
        generateValueCode(ia.array)
        out.write(".set(")
        generateValueCode(ia.index)
        out.write(", ")
        generateValueCode(ia.value)
        out.writeLine(");")
    }
    
    method generateAssertCode(a:Assert) {
        if !CompilerSettings.assertions
            return
        out.write("if (!")
        generateValueCode(a.test)
        out.writeLine(")")
        out.level += 1
        var message := a.message
        if message = null {
            out.writeLine("throw new panda.core.PandaException(" + 
                    "panda.core.AssertionError.createnew$constructor(" +
                    "panda.core.PandaCore.newString(\"" +
                    "assertion error\")));")
        }
        else if message.type = ClassType.STRING() {
            out.write("throw new panda.core.PandaException(" +
                    "panda.core.AssertionError.createnew$constructor(")
            generateValueCode(message)
            out.writeLine("));")
        }
        else {
            out.write("throw new panda.core.PandaException(")
            generateValueCode(message)
            out.writeLine(");")
        }
        out.level -= 1
    }
    
    method generateThrowCode(t:Throw) {
        out.write("throw new panda.core.PandaException(")
        generateValueCode(t.error)
        out.writeLine(");")
    }
    
    method generateTryCode(t:Try) {
        out.write("try ")
        generateBlockCode(t.block)
        var rawName := "$e" + variableIndex
        variableIndex += 1
        out.writeLine("catch (panda.core.PandaException " + rawName + ") {")
        out.level += 1
        var eName := "$e" + variableIndex
        variableIndex += 1
        out.writeLine("panda.core.Error " + eName + " = " + rawName + 
                ".getPandaError();")
        for i in 1 ... t.length - 1 {
            var c := t[i]->(Catch)
            if i > 1
                out.write("else ")
            out.writeLine("if (" + eName + " instanceof " + 
                    getJavaType(c.exception.type) + ") {")
            out.level += 1
            out.writeLine(getName(c.exception) + " = (" + 
                    getJavaType(c.exception.type) + ") " + eName + ";")
            generateBlockCode(c)
            out.level -= 1
            out.writeLine("}")
        }
        if t.length > 1
            out.write("else ")
        out.writeLine("throw " + rawName + ";")
        out.level -= 1
        out.writeLine("}")
    }
    
    method generateReturnCode(r:Return) {
        out.write("return")
        var value := r.value
        if value != null {
            out.write(" ")
            generateValueCode(value)
        }
        out.writeLine(";")
    }
    
    method generateBreakCode(b:Break) {
        def target := LLVMCodeGenerator.findLoop(b, b.label)
        out.write("break")
        var label := b.label
        if label != null
            out.write(" " + label)
        out.writeLine(";")
    }
    
    method generateContinueCode(c:Continue) {
        def target := LLVMCodeGenerator.findLoop(c, c.label)
        if target-?>(LoopWithContinueBlock)
            generateBlockCode(target->(LoopWithContinueBlock).continueBlock)
        out.write("continue")
        var label := c.label
        if label != null
            out.write(" " + label)
        out.writeLine(";")
    }
    
    method createReusedValues(n:Node) {
        for child in n.children {
            if child-!>(Statement)
                createReusedValues(child)
        }
        if n-?>(ReusedValueDefinition) {
            def rvd := n->(ReusedValueDefinition)
            def name := "$reused" + variableIndex
            variableIndex += 1
            rvd.setProperty(NAME, name)
            out.write(getJavaType(rvd.type) + " " + name + ";")
        }
    }

    method generateStatementCode(s:Statement) {
        out.writeLine("// " + s.class.name + ": " + s)
        createReusedValues(s)
        switch s.class {
            case class(ValueStatement): {
                def value := s->(ValueStatement).value
                generateValueCode(value)
                out.writeLine(";")
            }
            case class(FieldAssignment): generateFieldAssignmentCode(
                    s->(FieldAssignment))
            case class(IndexedAssignment): generateIndexedAssignmentCode(
                    s->(IndexedAssignment))
            case class(If): generateIfCode(s->(If))
            case class(Loop): generateLoopCode(s->(Loop))
            case class(LoopWithContinueBlock): 
                    generateLoopWithContinueBlockCode(s->(LoopWithContinueBlock))
            case class(While): generateWhileCode(s->(While))
            case class(Do): generateDoCode(s->(Do))
            case class(Block): generateBlockCode(s->(Block))
            case class(Assert): generateAssertCode(s->(Assert))
            case class(Return): generateReturnCode(s->(Return))
            case class(Break): generateBreakCode(s->(Break))
            case class(Continue): generateContinueCode(s->(Continue))
            case class(Throw): generateThrowCode(s->(Throw))
            case class(Try): generateTryCode(s->(Try))
            case class(CatchExit): { }
            case class(Unreachable): out.writeLine(
                    "throw new panda.core.PandaException(" + 
                    "panda.core.AssertionError.createnew$constructor(" +
                    "panda.core.PandaCore.newString(\"" +
                    "unreachable\")));")
            default: out.writeLine("unsupported:" + s.class.name + "(" + s + 
                    ")")
        }
    }
    
    method generateBlockCode(b:Block) {
        out.writeLine("{")
        out.level += 1
        if b.parent-?>(MethodNode) {
            var m := b.parent->(MethodNode)
            for i in 0 ... m.localVariables.length - 1 {
                var v := m.localVariables[i]
                out.writeLine(getJavaType(v.type) + " " + 
                        getName(v) + ";")
            }
        }
        for i in 0 ... b.length - 1
            generateStatementCode(b[i]->(Statement))
        out.level -= 1
        out.writeLine("}")
    }
    
    method generateFieldCode(f:FieldNode) {
        if f.name = FieldNode.ELEMENTS_NAME {
            var type := getJavaType(f.type)
            out.writeLine("public " + type + "[] contents = new " + type + 
                    "[0];")
        }
        else {
            if f.annotations.isThread {
                var type := "java.lang.ThreadLocal<" + 
                        getJavaReferenceType(f.type) + ">"
                out.writeLine("public static " + type + " " + getName(f) + 
                        " = new " + type + "()")
                var initializer := f.parent->(ClassNode).symbolTable.getMethod(
                            f.position,
                            ASTGenerator.getThreadLocalInitializerName(f),
                            new Array<Value>(), true)
                if initializer != null {
                    out.writeLine(" {")
                    out.level += 1
                    out.writeLine("protected " + 
                            getJavaReferenceType(f.type) + " initialValue() {")
                    out.level += 1
                    out.writeLine("return " + initializer.name +
                            "();")
                    out.level -= 1
                    out.writeLine("}")
                    out.level -= 1
                    out.write("}")
                }
                out.writeLine(";")
            }
            else {
                def initialValue := f.initialValue
                if initialValue != null & initialValue-?>(FieldReference) {
                    def initialField := initialValue->(FieldReference)
                    if initialField.object-?>(ReusedValue) {
                        def rv := initialField.object->(ReusedValue)
                        if rv.owner.getProperty(NAME) = null {
                            generateReusedValueDefinitionCode(rv.owner)
                            out.writeLine(";")
                        }
                    }
                }
                if f.parent->(ClassNode).name != "panda.core.Object" {
-*                    if f.annotations.isProtected
                        out.write("protected ")
                    else if !f.annotations.isPrivate*-
                    -- FIXME leaving it all public for now
                        out.write("public ")
                }
                else {
                    -- FIXME HACK for right now, forcing the cl field to be
                    -- public
                    out.write("public ")
                }
                if f.annotations.isClass
                    out.write("static ")
                out.write(getJavaType(f.type) + " " + getName(f))
                if initialValue != null {
                    out.write(" = ")
                    generateValueCode(initialValue)
                }
                out.writeLine(";")
            }
        }
    }
    
    method generateMethodCode(m:MethodNode) {
        currentMethod := m
        if m.name = MethodNode.CLASS_INIT_NAME
            hasClassInit := true
        out.write("public ")
        if isClass(m)
            out.write("static ")
        if m.annotations.isAbstract
            out.write("abstract ")
        else if m.owner.isInterface
            out.write("default ")
        var returnType := m.returnType
        out.write(getJavaType(returnType) + " " + getName(m) + 
                "(")
        var start := 0
        if !isClass(m)
            start := 1
        for i in start ... m.parameters.length - 1 {
            if i > start
                out.write(", ")
            var p := m.parameters[i]
            out.write(getJavaType(p.type) + " " + getName(p))
        }
        if m.parameters.length = 0 & getName(m) = 
                JavaMethodNamingStrategy.PANDAMAIN_NAME
            out.write("panda.collections.Array$LTpanda$core$String$GT $arg")
        out.write(")")
        if m.annotations.isAbstract
            out.writeLine(";")
        else {
            if m.annotations.isExternal {
                out.writeLine(" {")
                if m.returnType != VoidType.VOID
                    out.write("return ")
                out.write("$external." + getName(m) + 
                        "(")
                for i in 0 ... m.parameters.length - 1 {
                    if i > 0
                        out.write(", ")
                    var p := m.parameters[i]
                    out.write(getName(p))
                }
                out.writeLine(");")
                out.writeLine("}")
            }
            else if m.name = "length:=" & m.owner.isArray() {
                out.writeLine(" {")
                var elementType := getJavaType(
                        m.owner.type().elementType->(Type))
                out.level += 1
                var param := getName(m.parameters[1])
                out.writeLine("if (" + param + " > $$length) {")
                out.level += 1
                out.writeLine(elementType + "[] newContents = new " + 
                        elementType + "[" + param + "];")
                out.writeLine("java.lang.System.arraycopy(contents, 0, " +
                        "newContents, 0, $$length);")
                out.writeLine("contents = newContents;")
                out.level -= 1
                out.writeLine("}")
                out.writeLine("$$length = " + getName(m.parameters[1]) + 
                        ";")
                out.level -= 1
                out.writeLine("}")
            }
            else
                generateBlockCode(m.block)
        }
        
        if m.methodType = MethodNodeType.CONSTRUCTOR & 
                !m.parent->(ClassNode).annotations.isAbstract() {
            var type := getJavaType(m.parent->(ClassNode).type())
            out.write("public static " + type + " create" + 
                    getName(m) + "(")
            for i in 1 ... m.parameters.length - 1 {
                if i > 1
                    out.write(", ")
                var p := m.parameters[i]
                out.write(getJavaType(p.type) + " " + getName(p))
            }
            out.writeLine(") {")
            out.level += 1
            out.writeLine(type + " $this = new " + type + "();")
            out.writeLine("$this.$cl = " + PANDACORE + '.getClass("' +
                    getName(m.parent->(ClassNode)) + '", "' +
                    getDisplayName(m.parent->(ClassNode)) + '");')
            out.write(getName(m) + "($this")
            for i in 1 ... m.parameters.length - 1 {
                var p := m.parameters[i]
                out.write(", " + getName(p))
            }
            out.writeLine(");")
            out.writeLine("return $this;")
            out.level -= 1
            out.writeLine("}")
        }
        if getName(m) = JavaMethodNamingStrategy.PANDAMAIN_NAME {
            out.writeLine(
                    "public static void main(java.lang.String[] arg) {")
            out.level += 1
            out.write(JavaMethodNamingStrategy.PANDAMAIN_NAME + 
                    "(" + PANDACORE + ".convertArgs(arg));")
            out.level -= 1
            out.writeLine("}")
        }
        currentMethod := null
    }

    method generateStringConstants() {
        for i in 0 ... stringConstants.length - 1 {
            out.writeLine("public static final " + class(String).name + " " + 
                    STRING_CONSTANT_PREFIX + i + " = " + PANDACORE + 
                    '.newString("' + StringLiteral.escape(stringConstants[i]) + 
                    '");')
        }
    }
    
    method generateClassCode(cl:ClassNode) {
        if cl.state != ClassNodeState.DEFINED
            return
        hasClassInit := false
        stringConstants := new Array<String>()
        var rootPath := self.rootPath
        assert rootPath != null
        var dest := rootPath.resolve(getName(cl).replace(".", "/") + ".java")
        var parent := dest.parent()
        if parent = null {
            throw new CompilerException("could not determine parent of '" + 
                    dest.path + "'")
        }
        parent.createDirectories()
        out := new IndentedOutputStream(new BufferedOutputStream(
                dest.openOutputStream()))
        var packageName := getJavaType(cl.type())
        var index := packageName.indexOf("<")
        if index != null
            packageName := packageName[..index]
        index := packageName.lastIndexOf(".")
        if index != null {
            packageName := packageName[..index]
            out.writeLine("package " + packageName + ";")
        }
        else
            out.writeLine("package " + UNNAMED + ";")
        out.write("public ")
        if cl.annotations.isAbstract()
            out.write("abstract ")
        if cl.isInterface
            out.write("interface ")
        else 
            out.write("class ")
        var simpleName := getSimpleName(cl)
        out.write(simpleName)
        var superclass := cl.superclass
        if cl.isInterface {
            for i, intf in cl.interfaces {
                if i = 0
                    out.write(" extends ")
                else
                    out.write(", ")
                out.write(getName(intf.classNode))
            }
        }
        else {
            if superclass != null {
                out.write(" extends " + getName(superclass))
            }
            if cl.name = class(Object).name
                out.write(" implements java.lang.Cloneable")
            for i, intf in cl.interfaces {
                if i = 0
                    out.write(" implements ")
                else
                    out.write(", ")
                out.write(getName(intf.classNode))
            }
        }
        out.writeLine(" {")
        out.level += 1

        -- add $external if needed
        for i in 0 ... cl.length - 1 {
            if cl[i]-?>(MethodNode) & 
                    cl[i]->(MethodNode).annotations.isExternal {
                var className := getName(cl) + "_External"
                out.writeLine("    private static final " + className + 
                        " $external = new " + className + "Impl();")
                break
            }
        }

        if !cl.isInterface {
            out.write("static { " + PANDACORE + ".initClass(" + PANDACORE + 
                    '.getClass("' + getName(cl) + '", "' +
                    getDisplayName(cl) + '"), ')
            if superclass != null {
                out.write('panda.core.PandaCore.getClass("' + 
                        getName(superclass) + '", "' + 
                        getDisplayName(superclass) + '")')
            }
            else
                out.write("null")
            out.writeLine("); }")
        }

        if cl.isArray() {
            var elementType := getJavaType(cl.type().elementType->(Type))

            -- no-arg constructor
            out.writeLine("public " + simpleName + "() {")
            out.writeLine("}")
            out.writeLine("public static " + simpleName + 
                    " newWithLength(int size) {")
            out.level += 1
            out.writeLine(simpleName + " result = new " + simpleName + 
                    "();")
            out.writeLine('result.$cl = panda.core.PandaCore.getClass("' + 
                    getName(cl) + '", "' + getDisplayName(cl) + '");')
            out.writeLine("result.contents = new " + elementType + "[size];")
            out.writeLine("result.$$length = size;")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            -- newWithRange (mutable)
-*            var arrayName:String
            var immutableArrayName:String
            constant MUTABLE_PREFIX := "panda.collections.Array$"
            constant IMMUTABLE_PREFIX := "panda.collections.ImmutableArray$"
            if cl.type().isImmutable {
                immutableArrayName := getName(cl)
                assert immutableArrayName.startsWith(IMMUTABLE_PREFIX)
                arrayName := MUTABLE_PREFIX + 
                        immutableArrayName[IMMUTABLE_PREFIX.length..]
            }
            else {
                arrayName := getName(cl)
                assert arrayName.startsWith(MUTABLE_PREFIX)
                immutableArrayName := IMMUTABLE_PREFIX + 
                        arrayName[MUTABLE_PREFIX.length..]
            }*-

            out.writeLine("public static " + simpleName + " newWithRange(" +
                    elementType + "[] source, int offset, " +
                    "int arrayLength) {")
            out.level += 1
            out.writeLine(simpleName + " result = new " + simpleName + 
                    "();")
            out.writeLine('result.$cl = panda.core.PandaCore.getClass("' + 
                    getName(cl) + '", "' + getDisplayName(cl) + '");')
            out.writeLine("result.contents = new " + elementType + 
                    "[arrayLength];")
            out.writeLine("java.lang.System.arraycopy(source, offset, " +
                    "result.contents, 0, arrayLength);")
            out.writeLine("result.$$length = arrayLength;")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            -- newWithValues
            out.writeLine("public static " + simpleName + " newWithValues(" +
                    elementType + "... values) {")
            out.level += 1
            out.writeLine(simpleName + " result = newWithLength(values.length);")
            out.writeLine("java.lang.System.arraycopy(values, 0, result.contents, 0, values.length);")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            -- get
            out.writeLine("public " + elementType + " get(int i) {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            if CompilerSettings.boundsChecking
                out.writeLine("if (i >= $$length) throw new java.lang.IndexOutOfBoundsException(String.valueOf(i));")
            out.writeLine("return contents[i];")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (java.lang.IndexOutOfBoundsException e) {")
            out.writeLine("throw new panda.core.PandaException(panda.collections.IndexOutOfBoundsError.createnew$constructor(panda.core.PandaCore.newString(\"Array index out of bounds: requested element \" + i + \", array length is \" + $$length)));")
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")

            -- set
            out.writeLine("public void set(int i, " + elementType + " v) {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            if CompilerSettings.boundsChecking
                out.writeLine("if (i >= $$length) throw new java.lang.IndexOutOfBoundsException(String.valueOf(i));")
            out.writeLine("contents[i] = v;")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (java.lang.IndexOutOfBoundsException e) {")
            out.writeLine("throw new panda.core.PandaException(panda.collections.IndexOutOfBoundsError.createnew$constructor(panda.core.PandaCore.newString(\"Array index out of bounds: requested element \" + i + \", array length is \" + $$length)));")
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")
        }
        var oldOut := out
        var buffer := new MemoryOutputStream()
        out := new IndentedOutputStream(buffer)
        for i in 0 ... cl.length - 1 {
            var n := cl[i]
            if n-?>(MethodStub)
                continue
            if n-?>(MethodNode)
                generateMethodCode(n->(MethodNode))
            else if n-?>(FieldNode)
                generateFieldCode(n->(FieldNode))
        }
        out.close()
        out := oldOut
        generateStringConstants()
        if hasClassInit
            out.writeLine("static { " + MethodNode.CLASS_INIT_NAME + "(); }")
        out.write(buffer->>(String))

        if cl.name = class(Object).name {
            out.writeLine("public Object clone() {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            out.writeLine("return (panda.core.Object) super.clone();")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (CloneNotSupportedException e) {")
            out.level += 1
            out.writeLine("throw new RuntimeException(e);")
            out.level -= 1
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")
        }
        out.level -= 1
        out.writeLine("}")
        out.close()
    }

    method getMainClass():String? {
        var classes := SymbolTable.master.classes
        for cl in classes {
            for n in cl.children {
                if n-?>(MethodNode) & n->(MethodNode).name = MethodNode.MAIN_NAME
                    return getName(cl)
            }
        }
        return null
    }

    method generateMethodTypeCode(mt:MethodType) {
        var rootPath := self.rootPath
        assert rootPath != null
        var name := getJavaMethodType(mt)
        var lastIndex := name.lastIndexOf(".")
        assert lastIndex != null
        var parent := rootPath.resolve(name[0 .. lastIndex].replace(".", 
                "/"))
        parent.createDirectories()
        var dest := parent.resolve(name[lastIndex + 1..] + ".java")
        var out := dest.openOutputStream()
        assert lastIndex != null
        out.writeLine("package " + name[0 .. lastIndex] + ";")
        out.writeLine("public interface " + name[lastIndex + 1..] + " {")
        out.write("    java.lang.Object method(")
        for i, t in mt.methodParameters {
            if i > 0
                out.write(", ")
            out.write(getJavaType(t) + " param" + i)
        }
        out.writeLine(");")
        out.writeLine("}")
        out.close()
    }

    @override
    method generateCode(target:File) {
        if target.exists() & !target.isDirectory()
            throw new CompilerException("Java output must be to a directory")
        MethodNamer.nameMethods(new JavaMethodNamingStrategy())
        rootPath := target
        var rootPath := self.rootPath
        assert rootPath != null
        rootPath.createDirectories()
        var classes := SymbolTable.master.classes
        for cl in classes
            generateClassCode(cl)
        for mt in methodTypes
            generateMethodTypeCode(mt)
    }
}