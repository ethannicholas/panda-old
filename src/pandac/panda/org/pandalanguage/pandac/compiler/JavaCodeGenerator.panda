package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTMethodType
uses org.pandalanguage.pandac.ast.ClassCategory
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.ArrayLiteral
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Closure
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.SkippedValue
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType 
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class JavaCodeGenerator (CodeGenerator) {
    constant UNNAMED := "$unnamed"
    constant NAME := "JavaCodeGenerator.name"
    constant PANDACORE := "panda.core.PandaCore"
    constant STRING_CONSTANT_PREFIX := "$STRING_CONSTANT_"
    constant MAX_LENGTH := 0
    
    def context:Context
    def program:Program
    def methodNamer:MethodNamer
    def names := HashMap<Node, String>()
    var rootPath:File?
    var out := IndentedOutputStream(Console.outputStream)
    var reusedValueDefinitions := MutableString()
    var variableIndex := 0
    var currentMethod:MethodNode?
    var currentClass:ClassNode?
    var stringConstants := Array<String>()
    var hasClassInit := false
    -- method types we have run into which need interfaces defined for them
    var methodTypes := HashSet<MethodType>()
    def loops := Stack<AbstractLoop>()

    init(p:Program, compilerSettings:CompilerSettings) {
        self.program := p
        def errors := FatalErrorReporter()
        self.context := IRGenerator(p.root, p.stubs, p.stubGenerator, 
                compilerSettings, errors).context
        self.methodNamer := MethodNamer(context, 
                JavaMethodNamingStrategy())
    }

    @override
    function defaultExtension():String? {
        return null
    }

    method getName(cl:ClassStub):String {
        return getJavaType(cl.type)
    }

    function shorten(fullName:String):String {
        if fullName.endsWith("?")
            return shorten(fullName[..fullName.length - 1])
        def result := MutableString()
        var i := 0
        while i < fullName.length {
            def c := fullName[i]
            i += 1
            switch c {
                case "(": result.append("$.$l")
                case ")": result.append("$.$r")
                case "<": result.append("$.$L")
                case ">": result.append("$R")
                case ",": result.append("$.$C")
                case "?": result.append("$Z")
                case ".": {
                    while i < result.length & result[i] = "."
                        i += 1
                    result.append(".")
                }
                default: result.append(c)
            }
        }
        var start := 0
        while result[start] = "."
            start += 1
        var end := result.count - 1
        while result[end] = "."
            end -= 1
        return escape(result[start ... end])
    }

    method getDisplayName(cl:ClassStub):String {
        var result := cl.name
        if result.startsWith("panda.core.") & result.endsWith("Wrapper")
            result := result[..result.length - "Wrapper".length]
        return result
    }

    @class
    function needsDisambiguation(m:MethodStub):Bit {
        -- FIXME implement this
        return true
    }

    method getStub(cl:ClassType):ClassStub {
        return context.getStub(cl)
    }

    method getName(m:MethodStub):String {
        if isMethodClass(m.owner) | m.name.startsWith("$init")
            return m.name
        return methodNamer.getName(m)
    }
    
    function getName(f:FieldNode):String {
        -- prepending a "$" prevents conflicts with Java keywords, and also
        -- handles edge cases where a field has the same name as a package
        -- (consider trying to refer to "panda.core.String" when we have
        -- defined a field named "panda")
        return "$" + f.name
    }
    
    method getName(v:Variable):String {
        if v-?>Parameter & v.name = Parameter.SELF_NAME {
            def currentMethod := self.currentMethod->MethodNode
            if (currentMethod.stub.methodType = MethodNodeType.INIT |
                    currentMethod.stub.annotations.isWrapperMethod)
                return "$this"
            else
                return "this"
        }
        var result := names[v]->String?
        if result = null {
            result := v.name + variableIndex
            names[v] := result
            variableIndex += 1
        }
        return result
    }
    
    function isClass(m:MethodStub):Bit {
        return m.annotations.isClass | 
                m.methodType = MethodNodeType.INIT |
                m.annotations.isWrapperMethod
    }

    method getJavaReferenceType(t:Type):String {
        switch t {
            case IntType.INT8, IntType.UINT8:   return "java.lang.Byte"
            case IntType.INT16, IntType.UINT16: return "java.lang.Short"
            case IntType.INT32, IntType.UINT32: return "java.lang.Integer"
            case IntType.INT64, IntType.UINT64: return "java.lang.Long"
            case CharType.CHAR:   return "java.lang.Character"
            case BitType.BIT:     return "java.lang.Boolean"
            case RealType.REAL32: return "java.lang.Float"
            case RealType.REAL64: return "java.lang.Double"
            case VoidType.VOID:   return "void"
        }
        return getJavaType(t)
    }

    constant KEYWORDS := HashSet<String>(["abstract", "continue", "for", "new", "switch", "assert",
                    "default", "goto", "package", "synchronized", "boolean",
                    "do", "if", "private", "this", "break", "double", 
                    "implements", "protected", "throw", "byte", "else", 
                    "import", "public", "throws", "case", "enum", "instanceof",
                    "return", "transient", "catch", "extends", "int", "short",
                    "try", "char", "final", "interface", "static", "void",
                    "class", "finally", "long", "strictfp", "volatile", "const",
                    "float", "native", "super", "while"])

    @class
    function isJavaKeyword(token:String):Bit {
        return KEYWORDS.contains(token)
    }

    @class
    function filterNameToken(token:String):String {
        if isJavaKeyword(token)
            return "$" + token
        return token
    }

    @private
    method escape(s:String):String {
        def result := MutableString()
        var i := 0
        while i < s.length {
            def c := s[i]
            switch c {
                case "<": result.append("$LT")
                case ">": result.append("$GT")
                case ",": result.append("$C")
                case "(": result.append("$LP")
                case ")": result.append("$RP")
                case "=": result.append("$EQ")
                case "?": {
                    if i < s.length - 1
                        result.append("$Z")
                }
                case "*": result.append("$MUL")
                case "&": result.append("$AND")
                case " ": { }
                default: result.append(c)
            }
            i += 1
        }
        return result.convert()
    }

    constant WORD := /\w+/

    method determineJavaType(raw:Type):String {
        def t := raw
        switch t {
            case IntType.INT8, IntType.UINT8:   return "byte"
            case IntType.INT16, IntType.UINT16: return "short"
            case IntType.INT32, IntType.UINT32: return "int"
            case IntType.INT64, IntType.UINT64: return "long"
            case CharType.CHAR:   return "char"
            case BitType.BIT:     return "boolean"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case VoidType.VOID:   return "void"
            case NativePointerType.NATIVE_POINTER: return "java.lang.Object"
        }
        if t-?>GenericParameterType
            return getJavaType(t->GenericParameterType.bound)
        var result:String
        if t.isPrimitiveArray {
            var eType := t.unwrapNullable->PrimitiveArrayType.elementType
            var eName:String
            if eType.isPrimitive {
                assert eType.name.startsWith("panda.core.")
                eName := eType.name["panda.core.".length..]
            }
            else
                eName := getJavaType(eType)
            if eType.isNullable
                eName += "$Z"
            if t.isImmutable(context)
                result := ImmutablePrimitiveArray.name + "<" + eName + ">"
            else
                result := PrimitiveArray.name + "<" + eName + ">"
        } 
        else if t.unwrapNullable-?>MethodType
            return getJavaMethodType(t.convert()->MethodType)
        else {
            def stub := context.getStub(t.convert()->ClassType)
            if stub.containingClass != null {
                result := getJavaType(stub.containingClass) + "$" + 
                        stub.simpleName
            }
            else
                result := stub.name
            result := result.replace(WORD, token => filterNameToken(token))
        }
        def lt := result.indexOf("<")
        if lt != null
            result := result[..lt] + result[lt..].replace(".", "$")
        -- we can't use unnamed packages in Java, because classes in named
        -- packages are not allowed to refer to classes in unnamed packages
        if !result.contains(".")
            result := UNNAMED + "." + result
        if result.length > MAX_LENGTH
            return shorten(result)
        return escape(result)
    }

    def javaTypes := HashMap<Type, String>()
    method getJavaType(t:Type):String {
        var result := javaTypes[t]
        if result = null {
            result := determineJavaType(t)
            javaTypes[t] := result
        }
        return result
    }

    method getJavaMethodType(m:MethodType):String {
        def buffer := MutableString()
        for (i, p) in m.methodParameters.enumeration {
            if i > 0
                buffer.append("$C")
            buffer.append(p.displayName)
        }
        if buffer.count = 0
            buffer.append("$nullary")
        var result := "panda.methods." + buffer.convert()->String.replace(".", 
                "$")
        var found := false
        for existing in methodTypes {
            if existing = m {
                found := true
                break
            }
        }
        if !found
            methodTypes.add(m)
        def lt := result.indexOf("<"->Char)
        if lt != null
            result := result[..lt] + result[lt..].replace(".", "$")
        if result.length > MAX_LENGTH
            return shorten(result)
        return escape(result)
    }

    method getSimpleName(cl:ClassStub):String {
        var result := getJavaType(cl.type)
        var lt := result.indexOf("$LT")
        if lt = null
            lt := result.length - 1
        var dot := result.lastIndexOf(".", lt)
        if dot != null
            result := result[dot + 1..]
        return result
    }
    
    method generateMethodCallCode(mc:MethodCall) {
        def m := mc.methodStub
        if IRGenerator.unwrapCast(mc.target)-?>Super {
            if m.methodType = MethodNodeType.INIT {
                def stub := context.getStub(m.owner.convert()->ClassType)
                out.write(getName(stub))
            }
            else
                out.write("super")
        }
        else if isClass(m)
            out.write(getName(context.getStub(m.owner.convert()->ClassType)))
        else
            generateValueCode(mc.target->Value)
        out.write(".")
        out.write(getName(m))
        out.write("(")
        if m.methodType = MethodNodeType.INIT {
            out.write("$this")
            if mc.parameters.count > 0
                out.write(", ")
        }
        if m.annotations.isWrapperMethod {
            generateValueCode(mc.target->Value.implicitCast(context,
                    m.owner.convert()->PrimitiveType))
            if mc.parameters.count > 0
                out.write(", ")
        }
        for (i, v) in mc.parameters.enumeration {
            if i > 0
                out.write(", ")
            generateValueCode(v)
        }
        out.write(")")
    }
    
    method generateUnaryOperationCode(u:UnaryOperation) {
        if u.operand-?>IntegerLiteral {
            def v := u.operand->IntegerLiteral.value
            if v = Int32.MAX->UInt64 + 1 {
                out.write(Int32.MIN)
                return
            }
        }
        def op:String
        switch u.kind {
            case UnaryOperation.Kind.MINUS:       op := "-"
            case UnaryOperation.Kind.NOT:         op := "!"
            case UnaryOperation.Kind.BITWISE_NOT: op := "~"
            default: unreachable
        }
        out.write("((\{getJavaType(u.type)}) \{op}")
        if u.operand-!>IntegerLiteral
            out.write("(")
        generateValueCode(u.operand)
        if u.operand-!>IntegerLiteral
            out.write(")")
        out.write(")")
    }
    
    @pre(b.left.type = IntType.UINT64)
    method generateUInt64BinaryCode(b:BinaryOperation, op:String) {
        -- not the most efficient way to implement these, but I've got bigger 
        -- fish to fry right now
        switch b.kind {
            case BinaryOperationType.INT_DIVIDE: {
                out.write("panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").divide(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")).longValue()")
            }
            case BinaryOperationType.REMAINDER: {
                out.write("panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").remainder(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")).longValue()")
            }
            case BinaryOperationType.LESS_THAN, 
                    BinaryOperationType.LESS_THAN_OR_EQUAL,
                    BinaryOperationType.GREATER_THAN, 
                    BinaryOperationType.GREATER_THAN_OR_EQUAL: {
                out.write("(panda.core.PandaCore.UInt64(")
                generateValueCode(b.left)
                out.write(").compareTo(panda.core.PandaCore.UInt64(")
                generateValueCode(b.right)
                out.write(")) " + op + " 0)")
            }
            default: {
                out.write("(")
                generateValueCode(b.left)
                out.write(" ")
                out.write(op)
                out.write(" ")
                generateValueCode(b.right)
                out.write(")")
            }
        }
    }

    method generateBinaryCode(b:BinaryOperation, op:String) {
        var operandType := b.left.type
        if operandType = IntType.UINT64 {
            generateUInt64BinaryCode(b, op)
            return
        }
        if b.type = IntType.UINT32
            out.write("(int) (")
        else if b.type.isInteger & b.type.convert()->PrimitiveType.size < 4 | 
                b.type = CharType.CHAR
            out.write("(\{getJavaType(b.type)}) ")
        out.write("(")
        if operandType = IntType.UINT32 {
            out.write("(((long) ")
            generateValueCode(b.left)
            out.write(") & 0xFFFFFFFF)")
        }
        else
            generateValueCode(b.left)
        out.write(" ")
        out.write(op)
        out.write(" ")
        if operandType = IntType.UINT32 {
            out.write("(((long) ")
            generateValueCode(b.right)
            out.write(") & 0xFFFFFFFF)")
        }
        else
            generateValueCode(b.right)
        out.write(")")
        if b.type = IntType.UINT32
            out.write(" & 0xFFFFFFFF)")
    }

    method generateBinaryCode(b:BinaryOperation) {
        def op:String
        switch b.kind {
            case BinaryOperationType.EQUAL: op := "=="
            case BinaryOperationType.INT_DIVIDE: op := "/"
            case BinaryOperationType.AND: op := "&&"
            case BinaryOperationType.OR:  op := "||"
            case BinaryOperationType.XOR: op := "^"
            case BinaryOperationType.BITWISE_AND: op := "&"
            case BinaryOperationType.BITWISE_OR:  op := "|"
            case BinaryOperationType.BITWISE_XOR: op := "^"
            default: op := BinaryOperation.operatorSymbol(b.kind)
        }
        generateBinaryCode(b, op)
    }

    method generateIndexValueCode(i:PrimitiveArrayIndexValue) {
        out.write("((" + getJavaType(i.type) + ") ")
        generateValueCode(i.array)
        out.write(".get(")
        generateValueCode(i.index)
        out.write("))")
    }
    
    method generateFieldReferenceCode(f:FieldReference) {
        if f.field.annotations.isClass | f.field.annotations.isThread
            generateClassLiteralNamespaceCode(f.field.owner)
        else
            generateValueCode(f.object)
        out.write(".")
        out.write(getName(f.field))
        if f.field.annotations.isThread
            out.write(".get()")
    }
    
    method generateConstructCode(c:Construct) {
        def m := c.initCall.methodStub
        out.write(getJavaType(c.type))
        out.write(".create")
        out.write(getName(m))
        out.write("(")
        for (i, p) in c.initCall.parameters.enumeration {
            if i > 0
                out.write(", ")
            generateValueCode(p)
        }
        out.write(")")
    }
    
    method generateNewPrimitiveArrayWithLengthCode(n:NewPrimitiveArrayWithLength) {
        out.write("(" + getJavaType(n.type) + ".newWithLength(")
        generateValueCode(n.arrayLength)
        out.write("))")
    }
    
    method generateNewPrimitiveArrayWithValuesCode(n:NewPrimitiveArrayWithValues) {
        out.write("(" + getJavaType(n.type) + ".newWithValues(")
        for (i, v) in n.values.enumeration {
            if i > 0
                out.write(", ")
            generateValueCode(v)
        }
        out.write("))")
    }
    
    method generateArrayLiteralCode(a:ArrayLiteral) {
        out.write("new " + getJavaType(a.type) + "(")
        if a.values.count > 0 {
            for (i, v) in a.values.enumeration {
                if i > 0
                    out.write(", ")
                generateValueCode(v)
            }
        }
        else {
            def elementType := a.type->GenericType.parameters[0]
            out.write("new \{getJavaType(elementType)}[0]")
        }
        out.write(")")
    }
    
    method generatePrimitiveArrayCopy(c:PrimitiveArrayCopy) {
        out.write("(" + getJavaType(c.type) + ".newWithValues(")
        generateValueCode(c.array)
        out.write(".contents))")
    }

    method generateIntegerLiteralCode(i:IntegerLiteral) {
        if i.type = IntType.INT32
            out.write(i.value)
        else if i.type = IntType.INT64
            out.write(i.value + "L")
        else if i.type = IntType.UINT32
            out.write(i.value.convert()->Int32)
        else if i.type = IntType.UINT64
            out.write(i.value.convert()->Int64 + "L")
        else
            out.write("((" + getJavaType(i.type) + ") " + i.value + ")")
    }

    method generateSuperCode(s:Super) {
        out.write("this")
    }
    
    method generateCastCode(c:Cast) {
        var srcType := c.value.type
        var destType := c.type
        var mask := srcType.isInteger & srcType.convert()->PrimitiveType.size < 8 & 
                !srcType->IntType.signed & destType.isInteger
        out.write("((" + getJavaType(destType) + ") ")
        if mask {
            out.write("(")
            generateValueCode(c.value)
            out.write(" & 0x" + srcType.convert()->PrimitiveType.size * 2 * "F")
            if destType.convert()->PrimitiveType.size = 8
                out.write("L")
            out.write(")")
        }
        else {
            def check := !c.safe & !srcType.isPrimitive & 
                    context.compilerSettings.checkCasts
            if check {
                if destType.isNullable
                    out.write("panda.core.PandaCore.checkCastNullable(")
                else
                    out.write("panda.core.PandaCore.checkCast(")
            }
            generateValueCode(c.value)
            if check {
                out.write(", ")
                out.write(getJavaType(destType))
                out.write(".class)")
            }
        }
        out.write(")")
    }

    method generateDynamicCallCode(d:DynamicCall) {
        if d.type != VoidType.VOID {
            out.write("((")
            if d.type.isPrimitive
                out.write(getJavaReferenceType(d.type))
            else
                out.write(getJavaType(d.type))
            out.write(") ")
        }
        out.write("((")
        out.write(getJavaMethodType(d.methodValue.type.unwrapNullable->MethodType))
        out.write(") ")
        generateValueCode(d.methodValue)
        out.write(").\{MethodNode.CLOSURE_NAME}(")
        for (i, p) in d.parameters.enumeration {
            if i > 0
                out.write(", ")
            generateValueCode(p)
            if p.type.isWrapper
                out.write(".$value")
        }
        out.write(")")
        if d.type != VoidType.VOID
            out.write(")")
    }

    method generateClassLiteralNamespaceCode(cl:ClassType) {
        out.write(getName(context.getStub(cl)))
    }

    method generateClassLiteralObjectCode(cl:ClassType) {
        out.write(PANDACORE + '.getClass("')
        out.write(getJavaType(cl))
        out.write('", "')
        out.write(getDisplayName(context.getStub(cl)))
        out.write('")')
    }

    method generateReusedValueDefinitionCode(rvd:ReusedValueDefinition,
            topLevel:Bit) {
        def name := "$reused" + variableIndex
        variableIndex += 1
        names[rvd] := name
        if !topLevel
            out.write("(")
        out.write(name + " = ")
        generateValueCode(rvd.value)
        if !topLevel
            out.write(")")
        reusedValueDefinitions.append(getJavaType(rvd.type) + " " +
                name + ";\n")
    }

    method generateReusedValueCode(rv:ReusedValue) {
        def name := names[rv.owner]
        assert name != null: "ReusedValue at \{rv.position} has not been named"
        out.write(name)
    }

    method generateClosureCode(c:Closure) {
        generateCastCode(Cast(c.position, c.instance, c.type, 
                Cast.Kind.IMPLICIT))
    }

    method generateSkippedValueCode(s:SkippedValue) {
        out.write("((\{getJavaType(s.type)}) panda.core.PandaCore.skip(")
        generateValueCode(s.discardedValue)
        out.write(", ")
        generateValueCode(s.actualValue)
        out.write("))")        
    }

    method generateValueCode(v:Value, topLevel:Bit) {
        if v-?>VariableAssignment
            generateVariableAssignmentCode(v->VariableAssignment, topLevel)
        else if v-?>MethodCall
            generateMethodCallCode(v->MethodCall)
        else if v-?>BinaryOperation
            generateBinaryCode(v->BinaryOperation)
        else if v-?>UnaryOperation
            generateUnaryOperationCode(v->UnaryOperation)
        else if v-?>PrimitiveArrayIndexValue
            generateIndexValueCode(v->PrimitiveArrayIndexValue)
        else if v-?>IntegerLiteral
            generateIntegerLiteralCode(v->IntegerLiteral)
        else if v-?>RealLiteral {
            out.write(v->RealLiteral.value)
            if v.type = RealType.REAL32
                out.write("f")
        }
        else if v-?>StringLiteral {
            def i := stringConstants.count
            stringConstants.add(v->StringLiteral.value)
            out.write(STRING_CONSTANT_PREFIX + i)
        }
        else if v-?>BitLiteral
            out.write(v->BitLiteral.value)
        else if v-?>ClassLiteral
            generateClassLiteralObjectCode(v->ClassLiteral.value)
        else if v-?>VariableReference 
            out.write(getName(v->VariableReference.variable))
        else if v-?>FieldReference
            generateFieldReferenceCode(v->FieldReference)
        else if v-?>NullLiteral {
            out.write("((")
            out.write(getJavaType(v.type))
            out.write(") null)")
        }
        else if v-?>Cast {
            if topLevel
                generateValueCode(v->Cast.value, true)
            else
                generateCastCode(v->Cast)
        }
        else if v-?>Construct
            generateConstructCode(v->Construct)
        else if v-?>NewPrimitiveArrayWithLength
            generateNewPrimitiveArrayWithLengthCode(v->NewPrimitiveArrayWithLength)
        else if v-?>NewPrimitiveArrayWithValues
            generateNewPrimitiveArrayWithValuesCode(v->NewPrimitiveArrayWithValues)
        else if v-?>ArrayLiteral
            generateArrayLiteralCode(v->ArrayLiteral)
        else if v-?>PrimitiveArrayCopy
            generatePrimitiveArrayCopy(v->PrimitiveArrayCopy)
        else if v-?>Unwrap
            generateValueCode(v->Unwrap.value)
        else if v-?>ReusedValueDefinition {
            generateReusedValueDefinitionCode(v->ReusedValueDefinition,
                    topLevel)
        }
        else if v-?>ReusedValue
            generateReusedValueCode(v->ReusedValue)
        else if v-?>DynamicCall
            generateDynamicCallCode(v->DynamicCall)
        else if v-?>Super
            generateSuperCode(v->Super)
        else if v-?>Closure
            generateClosureCode(v->Closure)
        else if v-?>SkippedValue
            generateSkippedValueCode(v->SkippedValue)
        else {
            throw InternalCompilerException("unsupported value type: " + 
                    "\{v}:\{v.class.name}", v.position)
        }
    }

    method generateValueCode(v:Value) {
        generateValueCode(v, false)
    }
    
    method generateIfCode(i:If) {
        out.write("if (")
        generateValueCode(i.test)
        out.write(") ")
        if i.thenStatement-!>Block
            out.writeLine("{")
        generateStatementCode(i.thenStatement)
        if i.thenStatement-!>Block
            out.writeLine("}")
        var elseStatement := i.elseStatement
        if elseStatement != null {
            out.write("else ")
            if i.elseStatement-!>Block
                out.writeLine("{")
            generateStatementCode(elseStatement)
            if i.elseStatement-!>Block
                out.writeLine("}")
        }
    }
    
    method generateLoopCode(l:Loop) {
        loops.push(l)
        var label := l.label
        if label != null
            out.write(label + ": ")
        out.write("for (;;) ")
        generateStatementCode(l.statement)
        assert loops.pop() = l
    }
    
    method generateLoopWithContinueBlockCode(l:LoopWithContinueBlock) {
        loops.push(l)
        var label := l.label
        if label != null
            out.write(label + ": ")
        out.writeLine("for (;;) {")
        out.level += 1
        generateStatementCode(l.statement)
        if l.statement-!>Block | !l.statement->Block.endsInBranchOrThrow()
            generateBlockCode(l.continueBlock)
        out.level -= 1
        out.writeLine("}")
        assert loops.pop() = l
    }
    
    method generateWhileCode(w:While) {
        loops.push(w)
        var label := w.label
        if label != null
            out.write(label + ": ")
        out.write("while (")
        generateValueCode(w.test)
        out.write(") ")
        generateStatementCode(w.statement)
        assert loops.pop() = w
    }
    
    method generateDoCode(d:Do) {
        loops.push(d)
        var label := d.label
        if label != null
            out.write(label + ": ")
        out.write("do ")
        generateStatementCode(d.statement)
        out.write(" while (")
        generateValueCode(d.test)
        out.write(");")
        assert loops.pop() = d
    }

    method generateVariableAssignmentCode(va:VariableAssignment, topLevel:Bit) {
        if !topLevel
            out.write("(")
        out.write(getName(va.variable) + " = ")
        generateValueCode(va.value)
        if !topLevel
            out.write(")")
    }
    
    method generateFieldAssignmentCode(fa:FieldAssignment) {
        if fa.fieldNode.annotations.isClass | fa.fieldNode.annotations.isThread
            generateClassLiteralNamespaceCode(fa.fieldNode.owner)
        else
            generateValueCode(fa.object)
        out.write(".")
        out.write(getName(fa.fieldNode))
        if fa.fieldNode.annotations.isThread {
            out.write(".set(")
            generateValueCode(fa.value)
            out.write(")")
        }
        else {
            out.write(" = ")
            generateValueCode(fa.value)
        }
        out.writeLine(";")
    }
    
    method generateIndexedAssignmentCode(ia:PrimitiveArrayIndexAssignment) {
        generateValueCode(ia.array)
        out.write(".set(")
        generateValueCode(ia.index)
        out.write(", ")
        generateValueCode(ia.value)
        out.writeLine(");")
    }
    
    method generateAssertCode(a:Assert) {
        out.write("if (!")
        generateValueCode(a.test)
        out.writeLine(")")
        out.level += 1
        def error := a.error
        if error = null {
            out.writeLine("throw new panda.core.PandaException(" + 
                    "panda.core.AssertionError.createnew$init_panda$core$String(" +
                    "panda.core.PandaCore.newString(\"" +
                    "assertion error\")));")
        }
        else if error.type = ClassType.STRING {
            out.write("throw new panda.core.PandaException(" +
                    "panda.core.AssertionError.createnew$init_panda$core$String(")
            generateValueCode(error)
            out.writeLine("));")
        }
        else {
            out.write("throw new panda.core.PandaException(")
            generateValueCode(error)
            out.writeLine(");")
        }
        out.level -= 1
    }
    
    method generateThrowCode(t:Throw) {
        out.write("throw new panda.core.PandaException(")
        generateValueCode(t.error)
        out.writeLine(");")
    }

    method generateTryCode(t:Try) {
        out.write("try ")
        generateStatementCode(t.statement)
        def rawName := "$e" + variableIndex
        variableIndex += 1
        out.writeLine("catch (panda.core.PandaException \{rawName}) {")
        out.level += 1
        def eName := "$e" + variableIndex
        variableIndex += 1
        out.writeLine("panda.core.Error \{eName} = \{rawName}.getPandaError();")
        for (i, c) in t.catches.enumeration {
            if i > 1
                out.write("else ")
            out.writeLine("if (\{eName} instanceof " + 
                    getJavaType(c.error.type) + ") {")
            out.level += 1
            out.writeLine("\{getName(c.error)} = (" + 
                    "\{getJavaType(c.error.type)}) \{eName};")
            generateStatementCode(c.statement)
            out.level -= 1
            out.writeLine("}")
        }
        out.writeLine("else throw \{rawName};")
        out.level -= 1
        out.writeLine("}")
    }

    method generateReturnCode(r:Return) {
        out.write("return")
        var value := r.value
        if value != null {
            out.write(" ")
            generateValueCode(value)
        }
        out.writeLine(";")
    }
    
    function findLoop(label:String?):AbstractLoop {
        if label = null
            return loops.peek()
        for i in 0 .. loops.count {
            if loops.peek(i).label = label
                return loops.peek(i)
        }
        unreachable
    }

    method generateBreakCode(b:Break) {
        def target := findLoop(b.label)
        out.write("break")
        var label := b.label
        if label != null
            out.write(" " + label)
        out.writeLine(";")
    }
    
    method generateContinueCode(c:Continue) {
        def target := findLoop(c.label)
        if target-?>LoopWithContinueBlock {
            out.write("{")
            generateBlockCode(target->LoopWithContinueBlock.continueBlock)
        }
        out.write("continue")
        var label := c.label
        if label != null
            out.write(" " + label)
        out.writeLine(";")
        if target-?>LoopWithContinueBlock {
            out.write("}")
        }
    }

    method generateUnreachableCode(u:Unreachable) {
        def error := u.error
        if error = null {
            out.writeLine("throw new panda.core.PandaException(" + 
                    "panda.core.AssertionError.createnew$init_panda$core$String(" +
                    "panda.core.PandaCore.newString(\"" +
                    "assertion error\")));")
        }
        else if error.type = ClassType.STRING {
            out.write("throw new panda.core.PandaException(" +
                    "panda.core.AssertionError.createnew$init_panda$core$String(")
            generateValueCode(error)
            out.writeLine("));")
        }
        else {
            out.write("throw new panda.core.PandaException(")
            generateValueCode(error)
            out.writeLine(");")
        }
    }
    
    method generateStatementCode(s:Statement) {
        switch s.class {
            case ValueStatement: {
                def value := s->ValueStatement.value
                generateValueCode(value, true)
                out.writeLine(";")
            }
            case FieldAssignment: generateFieldAssignmentCode(
                    s->FieldAssignment)
            case PrimitiveArrayIndexAssignment: 
                    generateIndexedAssignmentCode(
                        s->PrimitiveArrayIndexAssignment)
            case If: generateIfCode(s->If)
            case Loop: generateLoopCode(s->Loop)
            case LoopWithContinueBlock: 
                    generateLoopWithContinueBlockCode(s->LoopWithContinueBlock)
            case While: generateWhileCode(s->While)
            case Do: generateDoCode(s->Do)
            case Block: generateBlockCode(s->Block)
            case Assert: generateAssertCode(s->Assert)
            case Return: generateReturnCode(s->Return)
            case Break: generateBreakCode(s->Break)
            case Continue: generateContinueCode(s->Continue)
            case Throw: generateThrowCode(s->Throw)
            case Try: generateTryCode(s->Try)
            case Unreachable: generateUnreachableCode(s->Unreachable)
            default: out.writeLine("unsupported:" + s.class.name + "(" + s + 
                    ")")
        }
    }
    
    method generateBlockCode(b:Block) {
        generateBlockCode(b, false)
    }

    method generateBlockCode(b:Block, topLevel:Bit) {
        out.writeLine("{")
        if topLevel {
            -- HACK: we need to look at the CFG to determine whether the block
            -- can be exited, in order to know whether we need to add a 
            -- "return null;" at the end of it. Just a quick hack to avoid
            -- unreachable code errors until I get the CFG analysis in place.
            def m := currentMethod->MethodNode.stub
            if isMethodClass(m.owner) & m.returnType = VoidType.VOID
                out.writeLine("if (true) { // FIXME hack!")
        }
        out.level += 1
        if topLevel {
            def m := currentMethod->MethodNode
            for v in m.localVariables {
                out.writeLine(getJavaType(v.type) + " " + 
                        getName(v) + ";")
            }
        }
        for s in b.statements
            generateStatementCode(s->Statement)
        if topLevel {
            def m := currentMethod->MethodNode.stub
            if isMethodClass(m.owner) & m.returnType = VoidType.VOID
                out.writeLine("} return null;")
        }
        out.level -= 1
        out.writeLine("}")
    }
    
    method generateFieldCode(f:FieldNode) {
        def cl := currentClass->ClassNode.stub
        if (cl.annotations.isUnspecified & 
                !f.annotations.isThread &
                !f.annotations.isClass) |
                f.kind = Variable.Kind.PROPERTY
            return
        if f.name = FieldNode.ELEMENTS_NAME {
            var type := getJavaType(f.type)
            out.writeLine("public " + type + "[] contents = new " + type + 
                    "[0];")
        }
        else {
            if f.annotations.isThread {
                def type := "java.lang.ThreadLocal<" + 
                        getJavaReferenceType(f.type) + ">"
                out.writeLine("public static " + type + " " + getName(f) + 
                        " = new " + type + "()")
                if f.initialValue != null {
                    out.writeLine(" {")
                    out.level += 1
                    out.writeLine("protected " + 
                            getJavaReferenceType(f.type) + " initialValue() {")
                    out.level += 1
                    out.writeLine("return " + 
                            IRGenerator.getThreadLocalInitializerName(f) + "();")
                    out.level -= 1
                    out.writeLine("}")
                    out.level -= 1
                    out.write("}")
                    out.writeLine(";")
                }
            }
            else {
                out.write("public ")
                if f.annotations.isClass
                    out.write("static ")
                out.write(getJavaType(f.type) + " " + getName(f))
                out.writeLine(";")
            }
        }
    }

    method generateMethodDeclaration(m:MethodStub) {
        if context.getStub(m.owner).annotations.isUnspecified & 
                !m.annotations.isClass
            return
        out.write("public ")
        if isClass(m)
            out.write("static ")
        if m.annotations.isAbstract
            out.write("abstract ")
        else if context.getStub(m.owner).classCategory = ClassCategory.INTERFACE & 
                !isClass(m)
            out.write("default ")
        def returnType:String
        if isMethodClass(m.owner) {
            if m.returnType = VoidType.VOID
                returnType := getJavaType(ClassType.OBJECT)
            else
                returnType := getJavaReferenceType(m.returnType)
        }
        else
            returnType := getJavaType(m.returnType)
        out.write("\{returnType} \{getName(m)}(")
        if m.methodType = MethodNodeType.INIT {
            out.write("\{getJavaType(m.owner)} $this")
            if m.parameters.count > 0
                out.write(", ")
        }
        if m.annotations.isWrapperMethod {
            out.write("\{getJavaType(m.owner.convert()->PrimitiveType)} $this")
            if m.parameters.count > 0
                out.write(", ")
        }
        for (i, p) in m.parameters.enumeration {
            if i > 0
                out.write(", ")
            out.write(getJavaType(p.type) + " " + p.name)
        }
        if m.parameters.count = 0 & getName(m) = 
                JavaMethodNamingStrategy.PANDAMAIN_NAME
            out.write("panda.collections.ListView$.$Lpanda$core$String$R $arg")
        out.write(");")

    }
    
    method generateMethodCode(m:MethodNode) {
        if currentClass->ClassNode.stub.annotations.isUnspecified & 
                !m.stub.annotations.isClass
            return
        currentMethod := m
        if m.stub.name = MethodNode.CLASS_INIT_NAME
            hasClassInit := true
        out.write("public ")
        if isClass(m.stub)
            out.write("static ")
        if m.stub.annotations.isAbstract
            out.write("abstract ")
        else if context.getStub(m.stub.owner).classCategory = ClassCategory.INTERFACE &
                !isClass(m.stub)
            out.write("default ")
        def returnType:String
        if isMethodClass(m.stub.owner) {
            if m.stub.returnType = VoidType.VOID
                returnType := getJavaType(ClassType.OBJECT)
            else
                returnType := getJavaReferenceType(m.stub.returnType)
        }
        else
            returnType := getJavaType(m.stub.returnType)
        if isMethodClass(m.stub.owner) & m.stub.name = MethodNode.CLOSURE_NAME
            out.write("\{returnType} \{MethodNode.CLOSURE_NAME}(")
        else
            out.write("\{returnType} \{getName(m.stub)}(")
        if m.stub.methodType = MethodNodeType.INIT {
            out.write("\{getJavaType(m.stub.owner)} $this")
            if m.stub.parameters.count > 0
                out.write(", ")
        }
        else if m.stub.annotations.isWrapperMethod {
            out.write("\{getJavaType(m.stub.owner.convert()->PrimitiveType)} $this")
            if m.parameters.count > 0
                out.write(", ")
        }
        for (i, p) in m.parameters.enumeration {
            if i > 0
                out.write(", ")
            out.write(getJavaType(p.type) + " " + getName(p))
        }
        if m.parameters.count = 0 & getName(m.stub) = 
                JavaMethodNamingStrategy.PANDAMAIN_NAME
            out.write("panda.collections.ListView$.$Lpanda$core$String$R $arg")
        out.write(")")
        if m.stub.annotations.isAbstract
            out.writeLine(";")
        else {
            if m.stub.annotations.isExternal {
                out.writeLine(" {")
                if m.stub.returnType != VoidType.VOID
                    out.write("return ")
                out.write("$external." + getName(m.stub) + "(")
                for (i, p) in m.parameters.enumeration {
                    if i > 0
                        out.write(", ")
                    out.write(getName(p))
                }
                out.writeLine(");")
                out.writeLine("}")
            }
            else {
                out.writeLine("{")
                def buffer := MemoryOutputStream()
                def oldOut := out
                out := IndentedOutputStream(buffer)

                -- DEBUG:temp
                out.indentSize := 0

                reusedValueDefinitions.clear()
                generateBlockCode(m.body, true)
                out := oldOut
                out.write(reusedValueDefinitions)
                out.write(buffer.convert())
                out.writeLine("}")
            }
        }
        
        if m.stub.methodType = MethodNodeType.INIT & 
                !context.getStub(m.stub.owner).annotations.isAbstract {
            def type := getJavaType(m.stub.owner)
            out.write("public static \{type} create\{getName(m.stub)}(")
            for (i, p) in m.parameters.enumeration {
                if i > 0
                    out.write(", ")
                out.write(getJavaType(p.type) + " " + getName(p))
            }
            out.writeLine(") {")
            out.level += 1
            out.writeLine("\{type} $this = new \{type}();")
            out.writeLine("$this.$cl = " + PANDACORE + '.getClass("' +
                    getJavaType(m.stub.owner) + '", "' +
                    getDisplayName(context.getStub(m.stub.owner)) + '");')
            out.write(getName(m.stub) + "($this")
            for (i, p) in m.parameters.enumeration
                out.write(", " + getName(p))
            out.writeLine(");")
            out.writeLine("return $this;")
            out.level -= 1
            out.writeLine("}")
        }
        if getName(m.stub) = 
                JavaMethodNamingStrategy.PANDAMAIN_NAME {
            out.writeLine(
                    "public static void main(java.lang.String[] arg) {")
            out.level += 1
            out.write(JavaMethodNamingStrategy.PANDAMAIN_NAME + 
                    "(" + PANDACORE + ".convertArgs(arg));")
            out.level -= 1
            out.writeLine("}")
        }
        currentMethod := null
    }

    @pre(m.annotations.isExternal)
    method generateExternalMethodCode(m:MethodStub) {
        if context.getStub(m.owner).annotations.isUnspecified & 
                !m.annotations.isClass
            return
        out.write("public ")
        if isClass(m)
            out.write("static ")
        else if context.getStub(m.owner).classCategory = ClassCategory.INTERFACE & 
                !isClass(m)
            out.write("default ")
        out.write("\{getJavaType(m.returnType)} \{getName(m)}(")
        if m.annotations.isWrapperMethod {
            out.write("\{getJavaType(m.owner.convert()->PrimitiveType)} $this")
            if m.parameters.count > 0
                out.write(", ")
        }
        for (i, p) in m.parameters.enumeration {
            if i > 0
                out.write(", ")
            out.write(getJavaType(p.type) + " " + p.name)
        }
        if m.parameters.count = 0 & getName(m) = 
                JavaMethodNamingStrategy.PANDAMAIN_NAME
            out.write("panda.collections.ListView$.$Lpanda$core$String$R $arg")
        out.writeLine(") {")
        if m.returnType != VoidType.VOID
            out.write("return ")
        out.write("$external." + getName(m) + "(")
        if !m.annotations.isClass {
            if m.annotations.isWrapperMethod
                out.write("$this")
            else
                out.write("this")
            if m.parameters.count > 0
                out.write(", ")
        }
        for (i, p) in m.parameters.enumeration {
            if i > 0
                out.write(", ")
            out.write(p.name)
        }
        out.writeLine(");")
        out.writeLine("}")
    }

    method generateStringConstants() {
        for i in 0 .. stringConstants.count {
            out.writeLine("public static final " + String.name + " " + 
                    STRING_CONSTANT_PREFIX + i + " = " + PANDACORE + 
                    '.newString("' + StringLiteral.escape(stringConstants[i]) + 
                    '");')
        }
    }
    
    function isMethodClass(cl:ClassType):Bit {
        def superclass := context.getStub(cl).superclass
        return superclass != null & (superclass = ClassType.METHOD | 
                    superclass.name = ClassType.MUTABLE_METHOD)
    }

    method writeClassInitializer(cl:ClassStub) {
        out.write("static { " + PANDACORE + ".initClass(" + PANDACORE + 
                '.getClass("' + getName(cl) + '", "' +
                getDisplayName(cl) + '"), ')
        if cl.superclass != null {
            out.write('panda.core.PandaCore.getClass("' + 
                    getName(getStub(cl.superclass)) + '", "' + 
                    getDisplayName(getStub(cl.superclass)) + '")')
        }
        else
            out.write("null")
        out.write(", new panda.core.Class[] { ")
        for (i, intf) in cl.interfaces.enumeration {
            if i > 0
                out.write(", ")
            out.write('panda.core.PandaCore.getClass("' + 
                    getName(getStub(intf)) + '", "' + 
                    getDisplayName(getStub(intf)) + '")')
        }
        out.writeLine("}); }")    
    }

    method generateClassCode(cl:ClassNode) {
        if cl.stub.isExternal
            return
        currentClass := cl
        hasClassInit := false
        stringConstants := Array<String>()
        var rootPath := self.rootPath
        assert rootPath != null
        def dest := rootPath.resolve(getName(cl.stub).replace(".", "/") + 
                ".java")
        var parent := dest.parent()
        if parent = null {
            throw CompilerException("could not determine parent of '" + 
                    dest.path + "'")
        }
        parent.createDirectories()
        out := IndentedOutputStream(BufferedOutputStream(
                dest.openOutputStream()))

        -- DEBUG:temp
        out.indentSize := 0

        var packageName := getJavaType(cl.stub.type)
        var index := packageName.indexOf("<")
        if index != null
            packageName := packageName[..index]
        index := packageName.lastIndexOf(".")
        if index != null {
            packageName := packageName[..index]
            out.writeLine("package " + packageName + ";")
        }
        else
            out.writeLine("package " + UNNAMED + ";")
        out.write("public ")
        if cl.stub.annotations.isAbstract | cl.stub.annotations.isUnspecified
            out.write("abstract ")
        if cl.stub.classCategory = ClassCategory.INTERFACE
            out.write("interface ")
        else 
            out.write("class ")
        def simpleName := getSimpleName(cl.stub)
        out.write(simpleName)
        def superclass := cl.stub.superclass
        if cl.stub.classCategory = ClassCategory.INTERFACE {
            for (i, intf) in cl.stub.interfaces.enumeration {
                if i = 0
                    out.write(" extends ")
                else
                    out.write(", ")
                out.write(getName(getStub(intf)))
            }
        }
        else {
            if superclass != null
                out.write(" extends " + getName(getStub(superclass)))
            if cl.stub.type = ClassType.OBJECT
                out.write(" implements java.lang.Cloneable")
            else if isMethodClass(cl.stub.type) {
                def m := cl.stub.methods.filter(
                        m => m.name = MethodNode.CLOSURE_NAME).iterator.next()
                def parameters := Array<Type>()
                for p in m.parameters
                    parameters.add(p.type)
                def returnType := IRGenerator.toASTType(cl.position,
                        m.returnType)
                def methodType := MethodType(parameters, m.returnType, false, 
                        true)
                out.write(" implements " + getJavaMethodType(
                        methodType->MethodType))
            }
            else {
                for (i, intf) in cl.stub.interfaces.enumeration {
                    if i = 0
                        out.write(" implements ")
                    else
                        out.write(", ")
                    out.write(getName(getStub(intf)))
                }
            }
        }
        out.writeLine(" {")
        out.level += 1

        -- add $external if needed
        for m in cl.stub.methods {
            if m.annotations.isExternal {
                def className := getName(cl.stub) + "_External"
                out.writeLine("    private static final " + className + 
                        " $external = new " + className + "Impl();")
                break
            }
        }

        if cl.stub.classCategory != ClassCategory.INTERFACE
            writeClassInitializer(cl.stub)
        else {
            def initializerName := "$CLINIT"
            out.writeLine("static class \{initializerName} {")
            out.level += 1
            writeClassInitializer(cl.stub)
            out.writeLine("static final java.lang.Object init() { return null; }")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("static final java.lang.Object $force = " +
                    initializerName + ".init();")
        }

        if cl.stub.type.isPrimitiveArray {
            def elementType := getJavaType(cl.stub.type.convert()->PrimitiveArrayType.
                    elementType->Type)

            -- no-arg init
            out.writeLine("public \{simpleName}() {")
            out.writeLine("}")
            out.writeLine("public static " + simpleName + 
                    " newWithLength(int size) {")
            out.level += 1
            out.writeLine(simpleName + " result = new " + simpleName + 
                    "();")
            out.writeLine('result.$cl = panda.core.PandaCore.getClass("' + 
                    getName(cl.stub) + '", "' + getDisplayName(cl.stub) + '");')
            out.writeLine("result.contents = new " + elementType + "[size];")
            out.writeLine("result.$$length = size;")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            out.writeLine("public static " + simpleName + " newWithRange(" +
                    elementType + "[] source, int offset, " +
                    "int arrayLength) {")
            out.level += 1
            out.writeLine(simpleName + " result = new " + simpleName + 
                    "();")
            out.writeLine('result.$cl = panda.core.PandaCore.getClass("' + 
                    getName(cl.stub) + '", "' + getDisplayName(cl.stub) + '");')
            out.writeLine("result.contents = new " + elementType + 
                    "[arrayLength];")
            out.writeLine("java.lang.System.arraycopy(source, offset, " +
                    "result.contents, 0, arrayLength);")
            out.writeLine("result.$$length = arrayLength;")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            -- newWithValues
            out.writeLine("public static " + simpleName + " newWithValues(" +
                    elementType + "... values) {")
            out.level += 1
            out.writeLine(simpleName + " result = newWithLength(values.length);")
            out.writeLine("java.lang.System.arraycopy(values, 0, result.contents, 0, values.length);")
            out.writeLine("return result;")
            out.level -= 1
            out.writeLine("}")

            -- get
            out.writeLine("public " + elementType + " get(int i) {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            out.writeLine("if (i >= $$length) throw new java.lang.IndexOutOfBoundsException(String.valueOf(i));")
            out.writeLine("return contents[i];")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (java.lang.IndexOutOfBoundsException e) {")
            out.writeLine("throw new panda.core.PandaException(panda.collections.IndexOutOfBoundsError.createnew$init_panda$core$String(panda.core.PandaCore.newString(\"PrimitiveArray index out of bounds: requested element \" + i + \", array length is \" + $$length)));")
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")

            -- set
            out.writeLine("public void set(int i, " + elementType + " v) {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            out.writeLine("if (i >= $$length) throw new java.lang.IndexOutOfBoundsException(String.valueOf(i));")
            out.writeLine("contents[i] = v;")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (java.lang.IndexOutOfBoundsException e) {")
            out.writeLine("throw new panda.core.PandaException(panda.collections.IndexOutOfBoundsError.createnew$init_panda$core$String(panda.core.PandaCore.newString(\"PrimitiveArray index out of bounds: requested element \" + i + \", array length is \" + $$length)));")
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")
        }
        var oldOut := out
        var buffer := MemoryOutputStream()
        out := IndentedOutputStream(buffer)

        for m in cl.methods
            generateMethodCode(m)
        for m in cl.stub.methods.filter(m => m.annotations.isExternal)
            generateExternalMethodCode(m)
        for m in cl.stub.methods.filter(m => m.annotations.isAbstract)
            generateMethodDeclaration(m)
        for f in cl.stub.fields
            generateFieldCode(f)
        out.close()
        out := oldOut
        generateStringConstants()
        if hasClassInit
            out.writeLine("static { " + MethodNode.CLASS_INIT_NAME + "_class(); }")
        out.write(buffer.convert())

        if cl.stub.name = Object.name {
            out.writeLine("public Object clone() {")
            out.level += 1
            out.writeLine("try {")
            out.level += 1
            out.writeLine("return (panda.core.Object) super.clone();")
            out.level -= 1
            out.writeLine("}")
            out.writeLine("catch (CloneNotSupportedException e) {")
            out.level += 1
            out.writeLine("throw new RuntimeException(e);")
            out.level -= 1
            out.writeLine("}")
            out.level -= 1
            out.writeLine("}")
        }
        out.level -= 1
        out.writeLine("}")
        out.close()
    }

    method generateMethodTypeCode(mt:MethodType) {
        def rootPath := self.rootPath
        assert rootPath != null : "no rootPath"
        def name := getJavaMethodType(mt)
        def lastIndex := name.lastIndexOf(".")
        assert lastIndex != null : "expected '.' in \{name}"
        def parent := rootPath.resolve(name[0 .. lastIndex].replace(".", 
                "/"))
        parent.createDirectories()
        def dest := parent.resolve(name[lastIndex + 1..] + ".java")
        def out := dest.openOutputStream()
        out.writeLine("package " + name[0 .. lastIndex] + ";")
        out.writeLine("public interface " + name[lastIndex + 1..] + " {")
        out.write("    java.lang.Object \{MethodNode.CLOSURE_NAME}(")
        for (i, t) in mt.methodParameters.enumeration {
            if i > 0
                out.write(", ")
            if t.unwrapNullable.isWrapper
                out.write(getJavaType(t.convert()->PrimitiveType) + " param" + i)
            else
                out.write(getJavaType(t) + " param" + i)
        }
        out.writeLine(");")
        out.writeLine("}")
        out.close()
    }

    @override
    method generateCode(target:File) {
        if target.exists() & !target.isDirectory()
            throw CompilerException("Java output must be to a directory")
        rootPath := target
        var rootPath := self.rootPath
        assert rootPath != null
        rootPath.createDirectories()
        for cl in program.classes.values
            generateClassCode(cl)
        for mt in methodTypes
            generateMethodTypeCode(mt)
    }
}