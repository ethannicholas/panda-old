package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.Symbol

class SymbolIterator (Iterator<(String, Symbol)>) {
    def symbols:SymbolTable

    def parentIterator:Iterator<(String, Symbol)>

    def selfIterator:Iterator<(String, Symbol)>

    def seen := new HashSet<String>()

    def nextSelf:(String, Symbol)?

    constructor(symbols:SymbolTable) {
        assert symbols.parent != null
        self.symbols := symbols
        parentIterator := symbols.parent.iterator
        selfIterator := symbols.symbols.iterator
    }

    @override
    function done():Bit {
        return parentIterator.done() & nextSelf = null
    }

    @private
    @pre(parentIterator.done())
    method getNextSelf() {
        nextSelf := null
        while !selfIterator.done() {
            nextSelf := selfIterator.next()
            if !seen.contains(nextSelf[0])
                break
        }
    }

    @override
    method next():(String, Symbol) {
        if !parentIterator.done() {
            def name := parentIterator.next()[0]
            seen.add(name)
            if parentIterator.done()
                getNextSelf()
            return (name, symbols[name])
        }
        loop {
            def result := nextSelf
            getNextSelf()
            return result
        }
    }
}

class SymbolTable (Map<String, Symbol>) {
    @private
    def parent:SymbolTable?

    @private
    def symbols := new OrderedMap<String, Symbol>()

    constructor() {
    }

    constructor(symbols:MapView<String, Symbol>) {
        self.symbols.addAll(symbols)
    }

    constructor(parent:SymbolTable) {
        self.parent := parent
    }    

    @override
    function [](name:String):Symbol? {
        var result := symbols[name]
        if parent != null {
            if result = null
                return parent[name]
            if result-?>Methods {
                def prev := parent[name]
                if prev-?>Methods {
                    return prev->Methods + result->Methods
                }
            }
        }
        return result
    }

    @override
    @self
    method []:=(name:String, s:Symbol) {
        --assert symbols[name] = null : "symbol '\{s}' was already defined"
        symbols[name] := s
    }

    @override
    @safeReturn
    function iterator():Iterator<(String, Symbol)> {
        if parent != null
            return new SymbolIterator(self)
        return symbols.iterator
    }

    @override
    function contains(name:String):Bit {
        return self[name] != null
    }

    @override
    function length():Int {
        return symbols.length
    }

    @override
    method remove(name:String) {
        symbols.remove(name)
    }

    @override
    method clear() {
        symbols.clear()
    }

    @override
    method addAll(map:MapView<String, Symbol>) {
        for (k, v) in map {
            if v-?>Methods {
                var methods := v->Methods
                def existing := self[k]
                if existing-?>Methods {
                    var oldMethods := existing->Methods
                    oldMethods += methods
                    methods := oldMethods
                }
                self[k] := methods
            }
            else
                self[k] := v
        }
    }

    @override
    function format(fmt:String):String {
        return symbols.format(fmt)
    }
}