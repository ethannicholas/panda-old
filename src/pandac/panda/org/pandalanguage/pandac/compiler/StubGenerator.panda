package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTAnnotation
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTChoice
uses org.pandalanguage.pandac.ast.ASTClass
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTField
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTInstanceDeclaration
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTMethod
uses org.pandalanguage.pandac.ast.ASTMethodType
uses org.pandalanguage.pandac.ast.ASTNestedDeclaration
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSwitch
uses org.pandalanguage.pandac.ast.ASTSwitchCase
uses org.pandalanguage.pandac.ast.ASTTupleType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnparsedClass
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
uses org.pandalanguage.pandac.ast.ClassCategory
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Package
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.stubs.TypeSymbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class MutablePackage (Symbol) {
    def _name:String

    @private
    def symbols := HashMap<String, Symbol>()

    init(name:String) {
        self._name := name
    }

    function get_name():String {
        return _name
    }

    function [](name:String):Symbol? {
        return symbols[name]
    }

    method []:=(name:String, symbol:Symbol) {
        symbols[name] := symbol
    }

    @override
    function convert():String {
        return "MutablePackage(\{name}, \{symbols})"
    }

    function convert():Package {
        def children := HashMap<String, Symbol>()
        for (name, symbol) in symbols {
            if symbol-?>MutablePackage
                children[name] := symbol->MutablePackage.convert()->Package
            else
                children[name] := symbol
        }
        return Package(self.name, children)
    }
}

class ClassContext {
    def currentPackage:String?

    def lookupContext:LookupContext

    init(currentPackage:String?, lookupContext:LookupContext) {
        self.currentPackage := currentPackage
        self.lookupContext := lookupContext
    }
}

class StubGenerator {
    constant INDEX_SUFFIX := "$index"

    def files:CollectionView<ASTFile>

    def errors:ErrorReporter

    def root := MutablePackage("")

    def types := HashMap<String, Type>()

    def astClasses := HashMap<String, (ASTClass, ClassContext, ClassType?)>()

    def astUnparsedClasses := HashMap<String, ASTUnparsedClass>()

    def astChoices := HashMap<String, (ASTChoice, ClassContext, ClassType?)>()

    def nestedClasses := HashMap<String, List<String>>()

    def stubs := HashMap<String, ClassStub>()

    def masterSymbolTable:SymbolTable

    def knownInstances := HashSet<Type>()

    init(files:CollectionView<ASTFile>, errors:ErrorReporter) {
        self.files := Array<ASTFile>(files)
        self.errors := errors
        addType(BitType.BIT, Position.INTERNAL)
        addType(CharType.CHAR, Position.INTERNAL)
        addType(IntType.INT8, Position.INTERNAL)
        addType(IntType.INT16, Position.INTERNAL)
        addType(IntType.INT32, Position.INTERNAL)
        addType(IntType.INT64, Position.INTERNAL)
        addType(IntType.UINT8, Position.INTERNAL)
        addType(IntType.UINT16, Position.INTERNAL)
        addType(IntType.UINT32, Position.INTERNAL)
        addType(IntType.UINT64, Position.INTERNAL)
        addType(RealType.REAL32, Position.INTERNAL)
        addType(RealType.REAL64, Position.INTERNAL)
        addType(NullType.NULL, Position.INTERNAL)
        addType(NativePointerType.NATIVE_POINTER, Position.INTERNAL)
        def symbolTable := SymbolTable()
        def dummy := HashMap<String, String>()
        aliasType("Int", IntType.INT32, symbolTable, dummy)
        aliasType("UInt", IntType.UINT32, symbolTable, dummy)
        aliasType("Real", RealType.REAL64, symbolTable, dummy)
        aliasType("$null", NullType.NULL, symbolTable, dummy)
        masterSymbolTable := symbolTable
        findClassNames()
        scanFiles()
    }

    @private
    method addNestedClass(parent:String, child:String) {
        var list := nestedClasses[parent]
        if list != null 
            list.add(child)
        else
            nestedClasses[parent] := [child]
    }

    @private
    method findClassNames(prefix:String?, cl:ASTClass, nested:Bit) {
        var name := cl.name
        if nested
            addNestedClass(prefix, name)
        if prefix != null
            name := prefix + "." + name
        def type:ClassType
        if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
            def symbolTable := SymbolTable()
            usePackage("panda.core", symbolTable, 
                    Array<String>(), Position.INTERNAL)
            type := WrapperType(resolveType(ASTClassType(
                    cl.position, name[0 .. name.length - 
                        "Wrapper".length], null, false), 
                    symbolTable)->PrimitiveType)
        }
        else
            type := ClassType(name)
        addType(type, cl.position, nested)
        for nestedClass in cl.contents.filter(n => n-?>ASTClass)
            findClassNames(name, nestedClass->ASTClass, true)
        for nestedChoice in cl.contents.filter(n => n-?>ASTChoice) {
            def nestedName := nestedChoice->ASTChoice.name
            def choiceType := ClassType(name + "." + nestedName)
            addType(choiceType, nestedChoice.position, true)
            addNestedClass(name, nestedName)
        }
    }

    @private
    method findClassNames() {
        var currentPackage:String?
        for f in files {
            currentPackage := null
            for decl in f.entries {
                if decl-?>ASTClass
                    findClassNames(currentPackage, decl->ASTClass, false)
                else if decl-?>ASTChoice {
                    var name := decl->ASTChoice.name
                    if currentPackage != null
                        name := currentPackage + "." + name
                    addType(ClassType(name), decl.position)
                }
                else if decl-?>ASTUnparsedClass {
                    def up := decl->ASTUnparsedClass
                    def name := up.name
                    def type:Type
                    if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
                        def symbolTable := SymbolTable()
                        usePackage("panda.core", symbolTable, 
                                Array<String>(), Position.INTERNAL)
                        type := WrapperType(resolveType(ASTClassType(
                                decl.position, name[0 .. name.length - 
                                    "Wrapper".length], null, false), 
                                symbolTable)->PrimitiveType)
                    }
                    else
                        type := ClassType(name)
                    addType(type, decl.position, up.containingClass != null)
                }
                else if decl-?>ASTPackageDeclaration
                    currentPackage := decl->ASTPackageDeclaration.name
            }
        }
    }

    @private
    method scanFiles() {
        def defaultPackages := Array<String>()
        defaultPackages.add("panda.collections")
        defaultPackages.add("panda.core")
        defaultPackages.add("panda.io")
        defaultPackages.add("panda.math")
        defaultPackages.add("panda.threads")
        for f in files {
            var currentPackage:String? := null
            def packageUses := Array<String>()
            def classAliases := HashMap<String, String>()
            def symbolTable := SymbolTable(masterSymbolTable)
            for p in defaultPackages
                usePackage(p, symbolTable, packageUses, Position.INTERNAL)
            def implicitClassSymbols := SymbolTable(masterSymbolTable)
            def implicitType := ClassType("$Implicit")
            var needImplicit := false
            def mainStatements := Array<ASTStatement>()
            for decl in f.entries {
                if decl-?>ASTUsesDeclaration {
                    def u := decl->ASTUsesDeclaration
                    if u.name.endsWith(".*") {
                        if u.alias != null {
                            errors.error("package imports may not have an alias",
                                    u.position)
                        }
                        usePackage(u.name[..u.name.length - ".*".length], 
                                symbolTable, packageUses, u.position)
                    }
                    else {
                        if u.alias != null 
                            aliasType(u.alias->String, 
                                    resolveType(ASTClassType(u.position, 
                                    u.name, null, false), symbolTable), symbolTable, 
                                    classAliases)
                        else {
                            var name := u.name
                            def index := name.lastIndexOf(".")
                            if index != null
                                name := name[index + 1..]
                            aliasType(name, 
                                    resolveType(ASTClassType(u.position, 
                                    u.name, null, false), symbolTable), symbolTable,
                                    classAliases)
                        }
                    }
                }
                else if decl-?>ASTClass {
                    var name := decl->ASTClass.name
                    if currentPackage != null
                        name := currentPackage + "." + name
                    def type:Type
                    if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
                        def symbolTable := SymbolTable()
                        usePackage("panda.core", symbolTable, 
                                Array<String>(), Position.INTERNAL)
                        type := WrapperType(resolveType(ASTClassType(
                                decl.position, name[0 .. name.length - 
                                    "Wrapper".length], null, false), 
                                symbolTable)->PrimitiveType)
                    }
                    else
                        type := ClassType(name)
                    astClasses[name] := (decl->ASTClass, ClassContext(
                            currentPackage, LookupContext(packageUses,
                                classAliases)), null)
                }
                else if decl-?>ASTUnparsedClass {
                    def aup := decl->ASTUnparsedClass
                    astUnparsedClasses[aup.name] := aup
                }
                else if decl-?>ASTChoice {
                    var name := decl->ASTChoice.name
                    if currentPackage != null
                        name := currentPackage + "." + name
                    astChoices[name] := (decl->ASTChoice, ClassContext(
                            currentPackage, LookupContext(packageUses,
                                classAliases)), null)
                }
                else if decl-?>ASTPackageDeclaration
                    currentPackage := decl->ASTPackageDeclaration.name
                else if decl-?>ASTMethod {
                    var m := convertMethod(false, decl->ASTMethod, 
                            implicitType, symbolTable)
                    if m != null {
                        m := MethodStub(m.position, m.name, 
                                m.annotations + Annotations.Kind.CLASS,
                                m.methodType, m.parameters, m.returnType, 
                                m.body, m.owner)
                        checkMethodSignature(m)
                        addSymbol(m, implicitClassSymbols.mySymbols, errors)
                        needImplicit := true
                    }
                }
                else if decl-?>ASTStatement
                    mainStatements.add(decl->ASTStatement)
                else if decl-?>ASTInstanceDeclaration {
                    def type := decl->ASTInstanceDeclaration.type
                    knownInstances.add(resolveType(type, masterSymbolTable))
                }
                else {
                    throw InternalCompilerException(
                            "unsupported file entry: \{decl}")
                }
            }
            if mainStatements.count > 0 {
                def position := Position(f.path, 0)
                def main := MethodStub(position, MethodNode.MAIN_NAME, 
                        Annotations(position, [Annotations.Kind.CLASS]),
                        MethodNodeType.METHOD, Array<FormalParameter>(), 
                        VoidType.VOID, ASTBlock(Position.INTERNAL, 
                        mainStatements), implicitType)
                addSymbol(main, implicitClassSymbols.mySymbols, errors)
                needImplicit := true
            }
            if needImplicit {
                def implicitClass := ClassStub(Position.INTERNAL, 
                        implicitType, ClassCategory.CLASS, 
                        Annotations(Position.INTERNAL), 
                        null, Array<ClassType>(), 
                        implicitClassSymbols.mySymbols, 
                        LookupContext(packageUses, classAliases), 
                        Array<ASTInvariant>(), null, false, null)
                astClasses[implicitClass.name] := (ASTClass(
                        Position.INTERNAL, implicitClass.name, 
                        ClassCategory.CLASS, null, null, null, null, null, [], 
                        false), ClassContext(currentPackage, 
                            LookupContext(packageUses, classAliases)), 
                        null)
                stubs[implicitClass.name] := implicitClass
                addType(implicitClass.type, implicitClass.position)
            }
        }
    }

    method addType(type:Type, position:Position) {
        addType(type, position, false)
    }

    method addType(type:Type, position:Position, nested:Bit) {
        if nested {
            types[type.name] := type
            return
        }
        var currentPackage := root
        def components := type.name.split(".")
        def currentName := MutableString()
        for (i, c) in components.enumeration {
            if i > 0
                currentName.append(".")
            currentName.append(c)
            if i < components.count - 1 {
                var next := currentPackage[c]
                if next = null {
                    next := MutablePackage(currentName.convert())
                    currentPackage[c] := next
                }
                else if next-!>MutablePackage {
                    errors.error("name conflict between class '\{currentName}'" +
                            "and package '\{currentName}'", position)
                }
                currentPackage := next->MutablePackage
            }
            else {
                assert currentPackage[c] = null : "package '\{currentPackage}'" +
                        " already contains a symbol named '\{c}'"
                currentPackage[c] := TypeSymbol(type)
                types[type.name] := type
            }
        }
    }

    method convertAnnotations(position:Position, 
            annotations:ListView<ASTAnnotation>?):Annotations {
        def result := Array<Annotations.Kind>()
        if annotations != null {
            for ann in annotations {
                if ann-?>ASTSimpleAnnotation {
                    def name := ann->ASTSimpleAnnotation.name
                    switch name {
                        case "protected": result.add(Annotations.Kind.PROTECTED)
                        case "private": result.add(Annotations.Kind.PRIVATE)
                        case "abstract": result.add(Annotations.Kind.ABSTRACT)
                        case "class": result.add(Annotations.Kind.CLASS)
                        case "thread": result.add(Annotations.Kind.THREAD)
                        case "external": result.add(Annotations.Kind.EXTERNAL)
                        case "final": result.add(Annotations.Kind.FINAL)
                        case "override": result.add(Annotations.Kind.OVERRIDE)
                        case "readonly": result.add(Annotations.Kind.READONLY)
                        case "limited": result.add(Annotations.Kind.LIMITED)
                        case "self": result.add(Annotations.Kind.SELF)
                        case "safeReturn": result.add(Annotations.Kind.SAFERETURN)
                        case "unsafeFunction": result.add(Annotations.Kind.UNSAFEFUNCTION)
                        case "synthetic": result.add(Annotations.Kind.SYNTHETIC)
                        case "unspecialized": result.add(Annotations.Kind.UNSPECIALIZED)
                        case "$wrapperMethod": result.add(Annotations.Kind.WRAPPER_METHOD)
                        case "math(overflow)": result.add(Annotations.Kind.OVERFLOW)
                        default:
                            errors.error("unsupported annotation '@\{name}'",
                                    ann.position)
                    }
                }
                else {
                    -- handle pre / post / invariant
                }
            }
        }
        return Annotations(position, result)
    }

    method resolveType(s:String?):ClassType? {
        if s = null
            return null
        return resolveType(ASTClassType(Position.INTERNAL, s, null, 
                false), masterSymbolTable)->ClassType
    }

    method resolveType(type:ASTType, symbols:SymbolTable):Type? {
        def result := resolveTypeWithExtras(type, symbols)
        if result = null
            return null
        if result[1].count > 0 {
            errors.error("type '\{type}' not found", type.position)
            return null
        }
        return result[0]
    }

    @private
    method resolveExtraComponents(type:Type, extras:ListView<String>,
            nullable:Bit):(Type, ListView<String>) {
        var current := type
        for (i, name) in extras.enumeration {
            def stub := getStub(current.convert()->ClassType.name)
            assert stub != null : "no stub for \{current.name}"
            def next := stub.symbols[name]
            if next = null | next-!>TypeSymbol
                return (current, extras[i..])
            current := next->TypeSymbol.type
        }
        if nullable
            current := NullableType(current)
        return (current, [])
    }

    method resolveTypeWithExtras(type:ASTType, 
            symbols:SymbolTable):(Type, ListView<String>)? {
        var result:Type?
        if type-?>ASTClassType {
            def name := type->ASTClassType.name
            def gps := type->ASTClassType.genericParameters
            var base:Type?
            def baseSymbol := symbols[name]
            if baseSymbol-!>TypeSymbol {
                base := types[name]
                if base = null {
                    if gps = null {
                        def components := name.split(".")
                        for i in components.count - 2 ... 0 by -1 {
                            def symbol := symbols[components[0 ... i].join(".")]
                            if symbol-?>TypeSymbol {
                                return resolveExtraComponents(
                                        symbol->TypeSymbol.type, 
                                        components[i + 1..], type.isNullable)
                            }
                        }
                    }
                    errors.error("type '\{type}' not found", type.position)
                    return null
                }
            }
            else
                base := baseSymbol->TypeSymbol.type
            if gps != null {
                if base-!>ClassType {
                    errors.error("type '\{base.name}' does not take generic " +
                            "parameters", type.position)
                    return null
                }
                if base.name = PrimitiveArray.name |
                        base.name = ImmutablePrimitiveArray.name {
                    if gps.count != 1 {
                        errors.error("PrimitiveArray requires exactly 1 " + 
                                "parameter", type.position)
                        return null
                    }
                    def parameter := resolveType(gps[0], symbols)
                    if parameter = null
                        return null
                    result := PrimitiveArrayType(base->ClassType, 
                            parameter)
                }
                else {
                    def parameters := Array<Type>()
                    for gp in gps {
                        def p := resolveType(gp, symbols)
                        if p = null
                            return null
                        parameters.add(p)
                    }
                    result := GenericType(base->ClassType, parameters)
                }
            }
            else
                result := base
        }
        else if type-?>ASTMethodType {
            def m := type->ASTMethodType
            def parameters := Array<Type>()
            for p in m.parameters {
                def resolved := resolveType(p, symbols)
                if resolved = null
                    return null
                parameters.add(resolved)
            }
            def returnType:Type?
            if m.returnType != null {
                returnType := resolveType(m.returnType->ASTType, symbols)
                if returnType = null
                    return null
            }
            else
                returnType := VoidType.VOID
            result := MethodType(parameters, returnType, m.isFunction,
                    m.isImmutable)
        }
        else if type-?>ASTTupleType {
            def tuple := type->ASTTupleType
            def values := Array<Type>()
            for t in tuple.types {
                def resolved := resolveType(t, symbols)
                if resolved = null
                    return null
                values.add(resolved)
            }
            result := TupleType(values)
        }
        else
            unreachable
        if result = null
            return null
        if type.isNullable & !result.isNullable {
            if result.isPrimitive
                result := result.convert()->ClassType
            result := NullableType(result)
        }
        def cached := types[result.name]
        if cached != null
            return (cached, [])
        types[result.name] := result
        return (result, [])
    }

    @private
    function getBaseType(var t:Type):Type {
        t := t.unwrapNullable
        if t-?>GenericType
            return t->GenericType.base
        return t
    }

    ============================================================================
    Verify that a method has a legal signature. In the case of overloaded
    operators, there are many constraints (such as addition must be a function
    rather than a method) which could result in a method not being legal.
    ============================================================================
    @private
    method checkMethodSignature(m:MethodStub) {
        -- wrappers are allowed to have overloads applying to their primitive
        -- equivalents, so don't bother checking them
        if m.owner.isWrapper
            return
        switch m.name {
            case "+", "-", "*", "/", "//", "^", ">", "<", ">=", "<=", "%",
                    "&", "&&", "|", "||", "~", "~~", "<<", ">>": {
                var name:String
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    if m.parameters.count != 2 {
                        errors.error("expected \{name} " +
                                "to have exactly two parameters", m.position)
                    }
                    else if m.parameters[0].type != m.owner & 
                            m.parameters[1].type != m.owner {
                        errors.error("expected \{name} to " +
                                "take \{m.owner} as at least one of " +
                                "its two parameters", m.position)
                    }
                }
                else {
                    name := "operator '" + m.name + "'"
                    if m.parameters.count != 1 {
                        errors.error("expected \{name} to " + 
                                "have exactly one parameter", m.position)
                    }
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a " +
                            "function", m.position)
                }
            }
            case "=": {
                if m.annotations.isClass {
                    errors.error("operator '=' cannot be " +
                            "declared '@class'", m.position)
                }
                if m.parameters.count != 1 | 
                        m.parameters[0].type != ClassType.OBJECT {
                    errors.error("operator '=' must take " +
                            "exactly one parameter of type 'panda.core.Object'",
                            m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected operator '=' to " +
                            "be a function", m.position)
                }
            }
            case "[]": {
                var name:String
                if m.annotations.isClass
                    name := "@class operator '\{m.name}'"
                else
                    name := "operator '\{m.name}'"
                if m.parameters.count != 1 {
                    errors.error("expected \{name} to have " +
                            "exactly one parameter", m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a " +
                            "function", m.position)
                }
            }
            case "[]:=": {
                var name:String
                if m.annotations.isClass {
                    errors.error("indexed assignment is not " + 
                            "permitted on classes", m.position)
                    return
                }
                else
                    name := "operator '\{m.name}'"
                if m.parameters.count != 2 {
                    errors.error("expected \{name} to have " +
                            "exactly two parameters", m.position)
                }
                if m.methodType = MethodNodeType.FUNCTION {
                    errors.error("\{name} may not be a function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    errors.error("\{name} may not return a value", m.position)
                }
            }
            case "[..]", "[...]": {
                var name:String
                if m.annotations.isClass
                    name := "@class operator '\{m.name}'"
                else
                    name := "operator '\{m.name}'"
                if m.parameters.count > 3 {
                    errors.error("expected \{name} to have " +
                            "zero to three parameters", m.position)
                    return
                }
                if m.parameters.count = 3 & 
                        m.parameters[2].type.isNullable {
                    errors.error("expected parameter " + 
                            "'\{m.parameters[2].name}' of \{name} " + 
                            "to be non-nullable", m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a function", 
                            m.position)
                }
            }
            case "[..]:=", "[...]:=": {
                var name:String
                if m.annotations.isClass {
                    errors.error("slice assignment is not permitted on classes",
                            m.position)
                    return
                }
                else
                    name := "operator '\{m.name}'"
                if m.parameters.count < 1 | 
                        m.parameters.count > 4 {
                    errors.error("expected \{name} to have one to four " +
                            "parameters", m.position)
                    return
                }
                if m.parameters.count = 4 & 
                        m.parameters[2].type.isNullable {
                    errors.error("expected parameter " + 
                            "'\{m.parameters[2].name}' of \{name} " +
                            "to be non-nullable", m.position)
                }
                if m.methodType = MethodNodeType.FUNCTION {
                    errors.error("\{name} may not be a function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    errors.error("\{name} may not return a value", m.position)
                }
            }
            case "main": {
                if m.returnType != VoidType.VOID {
                    errors.error("method 'main' may not return a value", 
                            m.position)
                }
                if !m.annotations.isClass {
                    errors.error("method 'main' must be declared '@class'", 
                            m.position)
                }
-*                if m.parameters.count > 1 | (m.parameters.count = 1 &
                        m.parameters[0].type != ClassType.ARRAY_STRING) {
                    errors.error("method 'main' must accept " +
                            "either no parameters or one parameter of type " +
                            "'\{PrimitiveArray<String>.name}'", m.position)
                }*-
            }
            default: {
                if m.name.endsWith(":=") {
                    var name:String
                    if m.annotations.isClass
                        name := "@class operator '\{m.name}'"
                    else
                        name := "operator '\{m.name}'"
                    if m.parameters.count != 1 {
                        errors.error("expected \{name} to " +
                                "have exactly one parameter", m.position)
                    }
                    if m.methodType = MethodNodeType.FUNCTION {
                        errors.error("\{name} may not be a " +
                                "function", m.position)
                    }
                    if m.returnType != VoidType.VOID {
                        errors.error("\{name} may not return " +
                                "a value", m.position)
                    }
                    if !m.annotations.isSelf {
                        errors.error("\{name} must be " +
                                "declared '@self'", m.position)
                    }
                }
            }
        }
    }

    method convertMethod(isExternal:Bit, m:ASTMethod, owner:ClassType,
            symbolTable:SymbolTable):MethodStub? {
        def parameters := Array<FormalParameter>()
        var annotations := convertAnnotations(m.position, m.annotations)
        if m.body = null & !isExternal & !annotations.isExternal
            annotations += Annotations.Kind.ABSTRACT
        for (i, p) in m.parameters.enumeration {
            var type := resolveType(p.type, symbolTable)
            if type != null {
                if p.isVarArg {
                    if i < m.parameters.count - 1 {
                        errors.error("only the last parameter of a method " + 
                                "may accept a variable number of arguments",
                                p.position)
                    }
                    def gp := Array<Type>()
                    gp.add(type)
                    type := GenericType(ClassType.LIST_VIEW, gp)
                }
                parameters.add(FormalParameter(p.position, p.name, type, 
                        p.isVar, p.isVarArg))
            }
            else
                return null
        }
        def returnType:Type?
        if m.returnType != null {
            returnType := resolveType(m.returnType->ASTType, symbolTable)
            if returnType = null
                return null
        }
        else
            returnType := VoidType.VOID

        var original:String
        if m.annotations = null
            original := "<none>"
        else
            original := m.annotations->Object.convert()
        return MethodStub(m.position, m.name, 
                annotations, m.methodType, parameters, returnType, m.body, 
                owner)
    }

    method convertFields(f:ASTField, owner:ClassType, symbolTable:SymbolTable) {
        def result := Array<FieldNode>()
        var annotations := convertAnnotations(f.position, f.annotations)
        if f.decl.kind = Variable.Kind.CONSTANT
            annotations += Annotations.Kind.CLASS
        for (i, v) in f.decl.vars.enumeration {
            var type:Type? := null
            if v.type != null
                type := resolveType(v.type->ASTType, symbolTable)
            if type = null {
                type := UnresolvedType("<field:\{v.identifier}>", 
                        v.position)
            }
            def name := v.identifier
            if name = "_" {
                if f.decl.vars.count = 1 {
                    errors.error("'_' is only permitted in multiple " +
                            "assignments from a tuple", f.decl.position)
                }
                continue
            }
            def tuplePosition:Int?
            if f.decl.vars.count = 1
                tuplePosition := null
            else
                tuplePosition := i
            def field := FieldNode(f.position, owner, name, 
                    annotations, f.decl.kind, type, f.decl.initializer, 
                    tuplePosition)
            addSymbol(field, field.position, symbolTable.mySymbols, errors)
            if annotations.isThread {
                def indexAnnotations := Array<Annotations.Kind>()
                indexAnnotations.add(Annotations.Kind.CLASS)
                indexAnnotations.add(Annotations.Kind.SYNTHETIC)
                def initializer := ASTCallExpression(ASTDotExpression(
                        ASTIdentifier(f.position, "Panda"), "allocThreadLocal"), 
                        Array<ASTExpression>())
                def fieldIndex := FieldNode(f.position, owner, 
                        v.identifier + INDEX_SUFFIX, Annotations(f.position,
                            indexAnnotations),
                        Variable.Kind.DEF, IntType.INT32, initializer, 0)
                addSymbol(fieldIndex, fieldIndex.position, 
                        symbolTable.mySymbols, errors)
            }
        }
    }

    method createClassInit(position:Position, owner:ClassType,
            symbols:SymbolTable):(FieldNode, MethodStub)? {
        var createInit := false
        def body := Array<ASTStatement>()
        for s in symbols.mySymbols.values {
            if s-?>FieldNode {
                def f := s->FieldNode
                if f.annotations.isClass | 
                        f.annotations.isThread {
                    -- for @thread, we just ensure that the class init method
                    -- exists (it doesn't have to contain anything). This is so
                    -- code generators can easily do required thread local 
                    -- setup.
                    createInit := true
                    if f.annotations.isClass {
                        def value := f.initialValue
                        if value != null {
                            def target := Array<ASTExpression>()
                            target.add(ASTIdentifier(f.position, f.name))
                            body.add(ASTAssignment(target, null, value))
                        }
                    }
                }
            }
        }
        if createInit {
            -- FIXME need to use array syntax when it's wired up
            def classAnnotations := Array<Annotations.Kind>()
            classAnnotations.add(Annotations.Kind.CLASS)
            def classInited := FieldNode(position, owner->ClassType, 
                    FieldNode.CLASS_INITED_NAME, Annotations(position, 
                        classAnnotations), 
                    Variable.Kind.VAR, BitType.BIT, null, null)

            def targets := Array<ASTExpression>()
            targets.add(ASTIdentifier(position, classInited.name))
            def setInited := ASTAssignment(targets, null, ASTBitLiteral(position, true))
            def bail := ASTIf(position, ASTIdentifier(position, classInited.name),
                    ASTReturn(position, null), setInited)
            body.insert(0, bail)

            def classInit := MethodStub(position, 
                    MethodNode.CLASS_INIT_NAME, Annotations(position, 
                        classAnnotations),
                    MethodNodeType.METHOD, Array<FormalParameter>(), 
                    VoidType.VOID, ASTBlock(position, body), 
                    owner->ClassType)

            return (classInited, classInit)
        }
        return null
    }

    function isAbstract(cl:ASTClass):Bit {
        if cl.classCategory = ClassCategory.INTERFACE
            return true
        def annotations := cl.annotations
        if annotations != null {
            for a in annotations {
                if a-?>ASTSimpleAnnotation & 
                        a->ASTSimpleAnnotation.name = "abstract"
                    return true
            }
        }
        return false
    }

    @private
    method addNestedAliases(name:String, symbols:SymbolTable) {
        def nested := nestedClasses[name]
        if nested != null {
            for n in nested
                symbols.add(n, TypeSymbol(types[name + "." + n]))
        }
    }

    @private
    method addNestedAliases(stub:ClassStub, symbols:SymbolTable) {
        addNestedAliases(stub.name, symbols)
        if stub.superclass != null
            addNestedAliases(getStub(stub.superclass.name), symbols)
        for intf in stub.interfaces
            addNestedAliases(getStub(intf.name), symbols)
    }

    method convertClass(cl:ASTClass, currentPackage:String?,
            parentSymbolTable:SymbolTable, rawPackageUses:ListView<String>,
            rawClassAliases:Map<String, String>,
            containingClass:ClassType?):ClassStub {
        def packageUses := Array<String>(rawPackageUses)
        def classAliases := HashMap<String, String>(rawClassAliases)
        def symbolTable := SymbolTable(parentSymbolTable)
        def className:String
        if containingClass != null
            className := containingClass.name + "." + cl.name
        else if currentPackage != null {
            className := currentPackage + "." + cl.name
            usePackage(currentPackage, symbolTable, packageUses, cl.position)
        }
        else {
            className := cl.name
            usePackage("", symbolTable, packageUses, cl.position)
        }
        def classType := resolveType(ASTClassType(cl.position, className, 
                null, false), symbolTable)->ClassType
        if cl.genericParameters != null {
            for p in cl.genericParameters->ListView<ASTTypedIdentifier> {
                def bound:Type
                if p.type != null {
                    def resolved := resolveType(p.type->ASTType, 
                            symbolTable)
                    if resolved != null
                        bound := resolved
                    else
                        bound := NullableType.ANY
                }
                else
                    bound := NullableType.ANY
                def type := GenericParameterType("\{className}.\{p.identifier}", 
                        bound)
                symbolTable.add(TypeSymbol(type))
                aliasType(p.identifier, type, symbolTable, classAliases)
            }
        }
        def symbols := SymbolTable(symbolTable)
        def interfaces := Array<ClassType>()
        var superclass:Type?
        if cl.superclass != null {
            superclass := resolveType(cl.superclass->ASTType, symbolTable)
            if superclass != null & superclass-!>ClassType {
                errors.error("cannot subclass \{superclass.displayName}", 
                        cl.position)
                superclass := null
            }
            if superclass != null {
                def stub := getStub(superclass.name)
                if stub != null
                    addNestedAliases(stub, symbols)
            }
        }
        else {
            if className = Object.name
                superclass := null
            else
                superclass := ClassType.OBJECT
        }
        if containingClass != null
            addNestedAliases(getStub(containingClass.name), symbols)
        if cl.interfaces != null {
            for t in cl.interfaces->ListView<ASTType> {
                def type := resolveType(t, symbolTable)
                if type-?>ClassType {
                    interfaces.add(type->ClassType)
                    def stub := getStub(type.name)
                    if stub != null
                        addNestedAliases(stub, symbols)
                }
                else if type != null {
                    errors.error("\{type.displayName} is not an interface",
                            cl.position)
                }
            }
        }
        var foundInit := false
        def invariants := Array<ASTInvariant>()
        for node in cl.contents {
            if node-?>ASTClass {
                def nestedClass := node->ASTClass
                def fullName := className + "." + nestedClass.name
                astClasses[fullName] := (nestedClass, 
                        ClassContext(currentPackage, LookupContext(packageUses, 
                            classAliases)), 
                        classType)
                def nestedType := resolveType(ASTClassType(cl.position, 
                        fullName, null, false), symbolTable)->ClassType
                addSymbol(TypeSymbol(nestedType), nestedClass.name, 
                        nestedClass.position, symbols.mySymbols, errors)
            }
            else if node-?>ASTChoice {
                def nestedChoice := node->ASTChoice
                def fullName := className + "." + nestedChoice.name
                astChoices[fullName] := (nestedChoice, 
                        ClassContext(currentPackage, LookupContext(packageUses, 
                            classAliases)), 
                        classType)
                def nestedType := resolveType(ASTClassType(cl.position, 
                        fullName, null, false), symbolTable)->ClassType
                addSymbol(TypeSymbol(nestedType), nestedChoice.name, 
                        nestedChoice.position, symbols.mySymbols, errors)
            }
            else if node-?>ASTNestedDeclaration {
                def nestedType := resolveType(node->ASTNestedDeclaration.type, 
                        symbolTable)->ClassType
                def name := nestedType.name
                def simpleName := name[name.lastIndexOf(".")->Int + 1..]
                addSymbol(TypeSymbol(nestedType), simpleName, node.position, 
                        symbols.mySymbols, errors)
            }
        }
        for node in cl.contents {
            if node-?>ASTMethod {
                def m := node->ASTMethod
                def converted := convertMethod(cl.isExternal, m, classType, 
                        symbols)
                if converted != null {
                    checkMethodSignature(converted)
                    addSymbol(converted, symbols.mySymbols, errors)
                    foundInit |= converted.methodType = 
                            MethodNodeType.INIT
                }
            }
            else if node-?>ASTField
                convertFields(node->ASTField, classType, symbols)
            else if node-?>ASTInvariant
                invariants.add(node->ASTInvariant)
        }
        if cl.classCategory != ClassCategory.INTERFACE & !foundInit {
            -- create implicit no-arg init
            def statements := Array<ASTStatement>()
            def superInit := ASTDotExpression(
                    ASTSuper(cl.position), MethodNode.INIT_NAME)
            statements.add(ASTExpressionStatement(ASTCallExpression(
                    superInit, Array<ASTExpression>())))
            def block := ASTBlock(cl.position, statements)
            def c := MethodStub(cl.position, 
                    MethodNode.INIT_NAME, 
                    Annotations(cl.position), 
                    MethodNodeType.INIT, 
                    Array<FormalParameter>(), VoidType.VOID, block, 
                    classType)
            addSymbol(c, symbols.mySymbols, errors)
        }
        var annotations := convertAnnotations(cl.position, cl.annotations)
        if cl.genericParameters != null
            annotations += Annotations.Kind.UNSPECIFIED
        if cl.isExternal
            annotations += Annotations.Kind.EXTERNAL
        else {
            def initMethod := createClassInit(cl.position, classType, symbols)
            if initMethod != null {
                symbols.mySymbols.remove(MethodNode.CLASS_INIT_NAME)
                symbols.mySymbols.remove(FieldNode.CLASS_INITED_NAME)
                addSymbol(initMethod[0], initMethod[0].position, 
                        symbols.mySymbols, errors)
                addSymbol(initMethod[1], symbols.mySymbols, errors)
            }
        }
        def genericParameters:Array<(String, Type?)>?
        if cl.genericParameters != null {
            genericParameters := Array<(String, Type?)>()
            for gp in cl.genericParameters {
                def type:Type?
                if gp.type != null
                    type := resolveType(gp.type, symbolTable)
                else
                    type := null
                genericParameters.add((gp.identifier, type))
            }
        }
        else
            genericParameters := null
        return ClassStub(cl.position, classType, 
                cl.classCategory, annotations, superclass->ClassType?, 
                interfaces, symbols.mySymbols, LookupContext(packageUses, 
                        classAliases), 
                invariants, genericParameters, cl.isExternal, 
                containingClass)
    }

    method createChoiceInit(c:ASTChoice, classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def superInit := ASTDotExpression(
                ASTSuper(c.position), MethodNode.INIT_NAME)
        statements.add(ASTExpressionStatement(ASTCallExpression(
                superInit, Array<ASTExpression>())))
        def block := ASTBlock(c.position, statements)
        def initAnnotations := Array<Annotations.Kind>()
        initAnnotations.add(Annotations.Kind.PRIVATE)
        return MethodStub(c.position, MethodNode.INIT_NAME, 
                Annotations(c.position, initAnnotations), 
                MethodNodeType.INIT, Array<FormalParameter>(), 
                VoidType.VOID, block, classType)
    }

    method createChoiceConvertToInt(c:ASTChoice, 
            classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def cases := Array<ASTSwitchCase>()
        for (i, v) in c.values.enumeration {
            def caseValues := Array<ASTExpression>()
            caseValues.add(ASTIdentifier(c.position, v.name))
            cases.add(ASTSwitchCase(c.position, caseValues, ASTReturn(c.position,
                    ASTIntegerLiteral(c.position, i->UInt64, false))))
        }
        statements.add(ASTSwitch(c.position, ASTSelf(c.position), cases,
                ASTUnreachable(c.position, null)))
        def block := ASTBlock(c.position, statements)
        return MethodStub(c.position, 
                MethodNode.CONVERT_NAME, 
                Annotations(c.position, Array<Annotations.Kind>()), 
                MethodNodeType.FUNCTION, Array<FormalParameter>(), 
                IntType.INT32, block, classType)
    }

    method createChoiceConvertToString(c:ASTChoice, 
            classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def cases := Array<ASTSwitchCase>()
        for (i, v) in c.values.enumeration {
            def caseValues := Array<ASTExpression>()
            caseValues.add(ASTIdentifier(c.position, v.name))
            cases.add(ASTSwitchCase(c.position, caseValues, ASTReturn(c.position,
                    ASTStringLiteral(c.position, v.name))))
        }
        statements.add(ASTSwitch(c.position, ASTSelf(c.position), cases,
                ASTUnreachable(c.position, null)))
        def block := ASTBlock(c.position, statements)
        return MethodStub(c.position, 
                MethodNode.CONVERT_NAME, 
                Annotations(c.position, Array<Annotations.Kind>()), 
                MethodNodeType.FUNCTION, Array<FormalParameter>(), 
                ClassType.STRING, block, classType)
    }

    method createChoiceFromInt(c:ASTChoice, classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def cases := Array<ASTSwitchCase>()
        for (i, v) in c.values.enumeration {
            def caseValues := Array<ASTExpression>()
            caseValues.add(ASTIntegerLiteral(c.position, i->UInt64, false))
            cases.add(ASTSwitchCase(c.position, caseValues, ASTReturn(c.position,
                    ASTIdentifier(c.position, v.name))))
        }
        statements.add(ASTSwitch(c.position, 
                ASTIdentifier(c.position, "value"), cases,
                ASTUnreachable(c.position, null)))
        def block := ASTBlock(c.position, statements)
        def cvtAnnotations := Array<Annotations.Kind>()
        cvtAnnotations.add(Annotations.Kind.CLASS)
        def convertParameters := Array<FormalParameter>()
        convertParameters.add(FormalParameter(c.position, "value", 
                IntType.INT32, false, false))
        return MethodStub(c.position, "fromInt", 
                Annotations(c.position, cvtAnnotations), 
                MethodNodeType.FUNCTION, convertParameters, 
                classType, block, classType)
    }

    method createChoiceFromString(c:ASTChoice, classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def cases := Array<ASTSwitchCase>()
        for v in c.values {
            def caseValues := Array<ASTExpression>()
            caseValues.add(ASTStringLiteral(c.position, v.name))
            cases.add(ASTSwitchCase(c.position, caseValues, ASTReturn(c.position,
                    ASTIdentifier(c.position, v.name))))
        }
        statements.add(ASTSwitch(c.position, 
                ASTIdentifier(c.position, "value"), cases,
                ASTUnreachable(c.position, null)))
        def block := ASTBlock(c.position, statements)
        def cvtAnnotations := Array<Annotations.Kind>()
        cvtAnnotations.add(Annotations.Kind.CLASS)
        def convertParameters := Array<FormalParameter>()
        convertParameters.add(FormalParameter(c.position, "value", 
                ClassType.STRING, false, false))
        return MethodStub(c.position, "fromString", 
                Annotations(c.position, cvtAnnotations), 
                MethodNodeType.FUNCTION, convertParameters, 
                classType, block, classType)
    }

    method convertChoice(c:ASTChoice, currentPackage:String?,
            symbolTable:SymbolTable, containingClass:ClassType?):ClassStub {
        def className:String
        if containingClass != null
            className := containingClass.name + "." + c.name
        else if currentPackage != null {
            className := currentPackage + "." + c.name
            usePackage(currentPackage, symbolTable, [], c.position)
        }
        else
            className := c.name
        def classType := resolveType(ASTClassType(c.position, className, 
                null, false), symbolTable)->ClassType
        def symbols := SymbolTable(masterSymbolTable)
        def fieldAnnotations := Array<Annotations.Kind>()
        fieldAnnotations.add(Annotations.Kind.CLASS)
        for v in c.values {
            def initialValue := ASTNew(v.position, 
                    ASTClassType(c.position, className, null, false),
                    Array<ASTExpression>())
            symbols.add(FieldNode(v.position, classType, v.name, 
                    Annotations(v.position, fieldAnnotations), 
                    Variable.Kind.DEF, classType, initialValue, null))
        }
        if !c.isExternal {
            def initMethod := createClassInit(c.position, classType, symbols)
            if initMethod != null {
                addSymbol(initMethod[0], initMethod[0].position, 
                        symbols.mySymbols, errors)
                addSymbol(initMethod[1], symbols.mySymbols, errors)
            }
        }
        
        addSymbol(createChoiceInit(c, classType), symbols.mySymbols, errors)
        addSymbol(createChoiceConvertToInt(c, classType), symbols.mySymbols, 
                errors)
        addSymbol(createChoiceConvertToString(c, classType), symbols.mySymbols, 
                errors)
        addSymbol(createChoiceFromInt(c, classType), symbols.mySymbols, errors)
        addSymbol(createChoiceFromString(c, classType), symbols.mySymbols, 
                errors)

        def annotations := convertAnnotations(c.position, c.annotations)
        return ClassStub(c.position, classType, ClassCategory.CLASS,
                annotations, ClassType.CHOICE, Array<ClassType>(), 
                symbols.mySymbols, LookupContext(), Array<ASTInvariant>(), null, 
                c.isExternal, containingClass)
    }

    @class
    method addSymbol(m:MethodStub, map:Map<String, Symbol>, 
            errors:ErrorReporter) {
        def methods := map[m.name]
        if methods = null {
            def list := Array<MethodStub>()
            list.add(m)
            map[m.name] := Methods(list)
        }
        else if methods-?>Methods
            map[m.name] := methods->Methods + m
        else {
            errors.error("invalid redefinition of symbol '\{m.name}'",
                    m.position)
        }
    }

    @class
    method addSymbol(s:Symbol, position:Position, map:Map<String, Symbol>, 
            errors:ErrorReporter) {
        addSymbol(s, s.name, position, map, errors)
    }

    @class
    method addSymbol(s:Symbol, name:String, position:Position, 
            map:Map<String, Symbol>, errors:ErrorReporter) {
        if map[name] != null {
            errors.error("invalid redefinition of symbol '\{name}'",
                    position)
        }
        else
            map[name] := s
    }

    method getPackage(name:String, position:Position):MutablePackage? {
        var current := root
        if name.length > 0 {
            for component in name.split(".") {
                def s := current[component]
                if s-?>MutablePackage
                    current := s->MutablePackage
                else {
                    errors.error("no package named '\{name}'", position)
                    return null
                }
            }
        }
        return current
    }

    method usePackage(name:String, symbolTable:SymbolTable, position:Position) {
        def p := getPackage(name, position)
        if p != null {
            for s in p.symbols.values {
                if s-?>TypeSymbol {
                    var cl := s.name
                    def dot := cl.lastIndexOf(".")
                    if dot != null
                        cl := cl[dot + 1..]
                    symbolTable.add(cl, s)
                }
            }
        }
        else
            errors.error("no package named '\{name}'", position)
    }

    method usePackage(name:String, symbolTable:SymbolTable, 
            packageUses:List<String>, position:Position) {
        packageUses.add(name)
        usePackage(name, symbolTable, position)
    }

    method aliasType(alias:String, type:Type, symbolTable:SymbolTable) {
        symbolTable.add(alias, TypeSymbol(type))
    }

    method aliasType(alias:String, type:Type?, symbolTable:SymbolTable,
            classAliases:Map<String, String>) {
        if type != null {
            classAliases[alias] := type.name
            aliasType(alias, type, symbolTable)
        }
    }

    function getSymbolTable(lookupContext:LookupContext):SymbolTable {
        def symbolTable := SymbolTable(masterSymbolTable)
        for p in lookupContext.packageUses
            usePackage(p, symbolTable, Position.INTERNAL)
        for (alias, type) in lookupContext.classAliases {
            aliasType(alias, resolveType(ASTClassType(Position.INTERNAL, 
                    type, null, false), symbolTable), symbolTable)
        }
        return symbolTable
    }

    @class
    function getPackage(name:String):String? {
        def index := name.lastIndexOf(".")
        if index = null
            return null
        return name[0 .. index]
    }
 
    method getStub(name:String):ClassStub? {
        var result := stubs[name]
        if result = null {
            def unparsedClass := astUnparsedClasses[name]
            if unparsedClass != null {
                def parsed := PandaParser(errors).parseBodyEntry(
                        unparsedClass.text, Position(File("<internal>.plink"), 0))
                if parsed-?>ASTClass {
                    def cl := parsed->ASTClass
                    def symbolTable := SymbolTable(masterSymbolTable)
                    result := convertClass(cl, getPackage(name), symbolTable,
                            [], HashMap<String, String>(), 
                            resolveType(unparsedClass.containingClass))
                    stubs[name] := result
                }
                else if parsed-?>ASTChoice {
                    def c := parsed->ASTChoice
                    def symbolTable := SymbolTable(masterSymbolTable)
                    result := convertChoice(c, getPackage(name), symbolTable,
                            resolveType(unparsedClass.containingClass))
                    stubs[name] := result
                }
            }
            else {
                def classLookup := astClasses[name]
                if classLookup != null {
                    def cl, context, containingClass := classLookup
                    def symbolTable := getSymbolTable(context.lookupContext)
                    result := convertClass(cl, getPackage(name), symbolTable,
                            context.lookupContext.packageUses, 
                            HashMap<String, String>(
                                context.lookupContext.classAliases),
                            containingClass)
                    stubs[name] := result
                }
                else {
                    def choiceLookup := astChoices[name]
                    if choiceLookup != null {
                        def cl, context, containingClass := choiceLookup
                        def symbolTable := getSymbolTable(context.lookupContext)
                        result := convertChoice(cl, getPackage(name), 
                                symbolTable, containingClass)
                        stubs[name] := result
                    }
                }
            }
        }
        return result
    }

    method getRootPackage():Package {
        return root.convert()->Package
    }
}