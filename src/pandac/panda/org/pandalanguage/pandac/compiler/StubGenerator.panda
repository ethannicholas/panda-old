package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTAnnotation
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTClass
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTField
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTMethod
uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType

class StubGenerator {
    def files:CollectionView<ASTFile>

    def typeResolver:TypeResolver

    def errors:ErrorReporter

    constructor(files:CollectionView<ASTFile>, typeResolver:TypeResolver,
            errors:ErrorReporter) {
        self.files := new Array<ASTFile>(files)
        self.typeResolver := typeResolver
        self.errors := errors
    }

    method convertAnnotations(position:Position, 
            annotations:ListView<ASTAnnotation>?):Annotations {
        def result := new Array<AnnotationType>()
        if annotations != null {
            for ann in annotations {
                if ann-?>(ASTSimpleAnnotation) {
                    switch ann->(ASTSimpleAnnotation).name {
                        case "protected":  result.add(AnnotationType.PROTECTED)
                        case "private":  result.add(AnnotationType.PRIVATE)
                        case "abstract":  result.add(AnnotationType.ABSTRACT)
                        case "class":  result.add(AnnotationType.CLASS)
                        case "thread":  result.add(AnnotationType.THREAD)
                        case "external":  result.add(AnnotationType.EXTERNAL)
                        case "final":  result.add(AnnotationType.FINAL)
                        case "override":  result.add(AnnotationType.OVERRIDE)
                        case "readonly":  result.add(AnnotationType.READONLY)
                        case "limited":  result.add(AnnotationType.LIMITED)
                        case "self":  result.add(AnnotationType.SELF)
                        case "safeReturn":  result.add(AnnotationType.SAFERETURN)
                        case "unsafeFunction":  result.add(AnnotationType.UNSAFEFUNCTION)
                        case "synthetic":  result.add(AnnotationType.SYNTHETIC)
                        case "$wrapperMethod":  result.add(AnnotationType.WRAPPER_METHOD)
                        -- default: handle math(overflow)
                    }
                }
                else {
                    -- handle pre / post / invariant
                }
            }
        }
        return new Annotations(position, result)
    }

    method resolveType(type:ASTType, lookupContext:LookupContext):Type? {
        def result := typeResolver.resolve(type, lookupContext)
        if result = null
            errors.error("type '\{type}' not found", type.position)
        return result
    }

    @private
    function getBaseType(var t:Type):Type {
        t := t.unwrapNullable
        if t-?>(GenericType)
            return t->(GenericType).base
        return t
    }

    ============================================================================
    Verify that a method has a legal signature. In the case of overloaded
    operators, there are many constraints (such as addition must be a function
    rather than a method) which could result in a method not being legal.
    ============================================================================
    @private
    method checkMethodSignature(m:MethodStub) {
        -- wrappers are allowed to have overloads applying to their primitive
        -- equivalents, so don't bother checking them
        if m.owner.isWrapper
            return
        switch m.name {
            case "+", "-", "*", "/", "//", "^", ">", "<", ">=", "<=", "%",
                    "&", "&&", "|", "||", "~", "~~", "<<", ">>": {
                var name:String
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    if m.parameters.length != 2 {
                        errors.error("expected \{name} " +
                                "to have exactly two parameters", m.position)
                    }
                    else if m.parameters[0].type != m.owner & 
                            m.parameters[1].type != m.owner {
                        errors.error("expected \{name} to " +
                                "take \{m.owner} as at least one of " +
                                "its two parameters", m.position)
                    }
                }
                else {
                    name := "operator '" + m.name + "'"
                    if m.parameters.length != 2 {
                        errors.error("expected \{name} to " + 
                                "have exactly one parameter", m.position)
                    }
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a " +
                            "function", m.position)
                }
            }
            case "=": {
                if m.annotations.isClass {
                    errors.error("operator '=' cannot be " +
                            "declared '@class'", m.position)
                }
                if m.parameters.length != 2 | 
                        m.parameters[1].type != ClassType.OBJECT {
                    errors.error("operator '=' must take " +
                            "exactly one parameter of type 'panda.core.Object'",
                            m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected operator '=' to " +
                            "be a function", m.position)
                }
            }
            case "[]": {
                var name:String
                var start:Int
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    start := 0
                }
                else {
                    name := "operator '\{m.name}'"
                    start := 1
                }
                if m.parameters.length - start != 1 {
                    errors.error("expected \{name} to have " +
                            "exactly one parameter", m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a " +
                            "function", m.position)
                }
            }
            case "[]:=": {
                var name:String
                var start:Int
                if m.annotations.isClass {
                    errors.error("indexed assignment is not " + 
                            "permitted on classes", m.position)
                    return
                }
                else {
                    name := "operator '\{m.name}'"
                    start := 1
                }
                if m.parameters.length - start != 2 {
                    errors.error("expected \{name} to have " +
                            "exactly two parameters", m.position)
                }
                if m.methodType = MethodNodeType.FUNCTION {
                    errors.error("\{name} may not be a function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    errors.error("\{name} may not return a value", m.position)
                }
            }
            case "[..]", "[...]": {
                var name:String
                var start:Int
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    start := 0
                }
                else {
                    name := "operator '\{m.name}'"
                    start := 1
                }
                if m.parameters.length - start > 3 {
                    errors.error("expected \{name} to have " +
                            "zero to three parameters", m.position)
                    return
                }
                if m.parameters.length - start = 3 & 
                        m.parameters[start + 2].type.isNullable {
                    errors.error("expected parameter " + 
                            "'\{m.parameters[start + 2].name}' of \{name} " + 
                            "to be non-nullable", m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a function", 
                            m.position)
                }
            }
            case "[..]:=", "[...]:=": {
                var name:String
                var start:Int
                if m.annotations.isClass {
                    errors.error("slice assignment is not permitted on classes",
                            m.position)
                    return
                }
                else {
                    name := "operator '\{m.name}'"
                    start := 1
                }
                if m.parameters.length - start < 1 | 
                        m.parameters.length - start > 4 {
                    errors.error("expected \{name} to have one to four " +
                            "parameters", m.position)
                    return
                }
                if m.parameters.length - start = 4 & 
                        m.parameters[start + 2].type.isNullable {
                    errors.error("expected parameter " + 
                            "'\{m.parameters[start + 2].name}' of \{name} " +
                            "to be non-nullable", m.position)
                }
                if m.methodType = MethodNodeType.FUNCTION {
                    errors.error("\{name} may not be a function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    errors.error("\{name} may not return a value", m.position)
                }
            }
            case "->>": {
                if m.annotations.isClass {
                    constant name := "@class operator '->>'"
                    if m.parameters.length != 1 {
                        errors.error("expected \{name} to " +
                                "take a single parameter", m.position)
                    }
                    if m.returnType != m.owner & 
                            getBaseType(m.returnType) != m.owner {
                        errors.error("expected \{name} to " +
                                "return '\{m.owner.displayName}'", 
                                m.position)
                    }
                    if m.parameters[0].type = m.owner {
                        errors.error("parameter type and " + 
                                "return types of \{name} must be different", 
                                m.position)
                    }
                }
                else {
                    constant name := "operator '->>'"
                    if m.parameters.length != 1 {
                        errors.error("expected \{name} to take " +
                                "no parameters", m.position)
                    }
                }
                if m.methodType = MethodNodeType.METHOD & 
                        !m.annotations.isSelf {
                    errors.error("convert methods must " + 
                            "have the '@self' annotation", m.position)
                }
            }
            case "main": {
                if m.returnType != VoidType.VOID {
                    errors.error("method 'main' may not return a value", 
                            m.position)
                }
                if !m.annotations.isClass {
                    errors.error("method 'main' must be declared '@class'", 
                            m.position)
                }
-*                if m.parameters.length > 1 | (m.parameters.length = 1 &
                        m.parameters[0].type != ClassType.ARRAY_STRING) {
                    errors.error("method 'main' must accept " +
                            "either no parameters or one parameter of type " +
                            "'\{class(PrimitiveArray<String>).name}'", m.position)
                }*-
            }
            default: {
                if m.name.endsWith(":=") {
                    var name:String
                    var start:Int
                    if m.annotations.isClass {
                        name := "@class operator '\{m.name}'"
                        start := 0
                    }
                    else {
                        name := "operator '\{m.name}'"
                        start := 1
                    }
                    if m.parameters.length - start != 1 {
                        errors.error("expected \{name} to " +
                                "have exactly one parameter", m.position)
                    }
                    if m.methodType = MethodNodeType.FUNCTION {
                        errors.error("\{name} may not be a " +
                                "function", m.position)
                    }
                    if m.returnType != VoidType.VOID {
                        errors.error("\{name} may not return " +
                                "a value", m.position)
                    }
                    if !m.annotations.isSelf {
                        errors.error("\{name} must be " +
                                "declared '@self'", m.position)
                    }
                }
            }
        }
    }

    method convertMethod(isExternal:Bit, m:ASTMethod, owner:ClassType,
            lookupContext:LookupContext):MethodStub? {
        def parameters := new Array<FormalParameter>()
        var annotations := convertAnnotations(m.position, m.annotations)
        if m.body = null & !isExternal
            annotations += AnnotationType.ABSTRACT
        if !annotations.isClass {
            def type:Type
            if annotations.isWrapperMethod
                type := owner->>(PrimitiveType)
            else
                type := owner
            parameters.add(new FormalParameter(m.position, Parameter.SELF_NAME, 
                    type, false, false, false))
        }
        for p in m.parameters {
            var type := resolveType(p.type, lookupContext)
            if type != null {
                if p.isVarArg {
                    type := new PrimitiveArrayType(ClassType.PRIMITIVE_ARRAY,
                            type)
                }
                parameters.add(new FormalParameter(p.position, p.name, type, 
                        p.isVar, p.isConvert, p.isVarArg))
            }
            else
                return null
        }
        var returnType:Type?
        if m.returnType != null {
            returnType := resolveType(m.returnType->(ASTType), lookupContext)
            if returnType = null
                return null
        }
        else
            returnType := VoidType.VOID

        var original:String
        if m.annotations = null
            original := "<none>"
        else
            original := m.annotations->(Object)->>(String)
        def result := new MethodStub(m.position, m.name, 
                annotations, m.methodType, parameters, returnType, m.body, 
                owner)
        checkMethodSignature(result)
        return result
    }

    method convertFields(f:ASTField, owner:ClassType, 
            lookupContext:LookupContext):ListView<FieldNode> {
        def result := new Array<FieldNode>()
        var annotations := convertAnnotations(f.position, f.annotations)
        if f.decl.varType = VariableType.CONSTANT
            annotations += AnnotationType.CLASS
        for i, v in f.decl.vars {
            var type:Type? := null
            if v.type != null
                type := resolveType(v.type->(ASTType), lookupContext)
            if type = null {
                type := new UnresolvedType("<field:\{v.identifier}>", 
                        v.position)
            }
            result.add(new FieldNode(f.position, owner, v.identifier, 
                    annotations, f.decl.varType, type, f.decl.initializer, i))
        }
        return result
    }

    method createClassInit(position:Position, owner:ClassType,
            fields:ListView<FieldNode>):(FieldNode, MethodStub)? {
        var createInit := false
        def body := new Array<ASTStatement>()
        for f in fields {
            if f.annotations.isClass | 
                    f.annotations.isThread {
                -- for isThread, we just ensure that the class init method
                -- exists (it doesn't have to contain anything). This is so
                -- code generators can easily do required thread local 
                -- setup.
                createInit := true
                if f.annotations.isClass {
                    def value := f.initialValue
                    if value != null {
                        def target := new Array<ASTExpression>()
                        target.add(new ASTIdentifier(f.position, f.name))
                        body.add(new ASTAssignment(target, null, value))
                    }
                }
            }
        }
        if createInit {
            -- FIXME need to use array syntax when it's wired up
            def classAnnotations := new Array<AnnotationType>()
            classAnnotations.add(AnnotationType.CLASS)
            def classInited := new FieldNode(position, owner->(ClassType), 
                    FieldNode.CLASS_INITED_NAME, new Annotations(position, 
                        classAnnotations), 
                    VariableType.VAR, BitType.BIT, null, null)

            -*def methodBody := new PandaParser().parseBlock(
                    "{ if \{owner.name}.\{classInited.name} return " +
                    "\{owner.name}.\{classInited.name} := true \{body} }",
                    position)*-

            def classInit := new MethodStub(position, 
                    MethodNode.CLASS_INIT_NAME, new Annotations(position, 
                        classAnnotations),
                    MethodNodeType.METHOD, new Array<FormalParameter>(), 
                    VoidType.VOID, new ASTBlock(position, body), 
                    owner->(ClassType))

            return (classInited, classInit)
        }
        return null
    }

    function isAbstract(cl:ASTClass):Bit {
        if cl.isInterface 
            return true
        def annotations := cl.annotations
        if annotations != null {
            for a in annotations {
                if a-?>(ASTSimpleAnnotation) & 
                        a->(ASTSimpleAnnotation).name = "abstract"
                    return true
            }
        }
        return false
    }

    method convertClass(cl:ASTClass, currentPackage:String?,
            var lookupContext:LookupContext):ClassStub {
        def className:String
        if currentPackage != null
            className := currentPackage + "." + cl.name
        else
            className := cl.name
        def classType := typeResolver.resolveName(className, 
                lookupContext)->(ClassType)
        if cl.genericParameters != null {
            for p in cl.genericParameters->(ListView<ASTTypedIdentifier>) {
                def bound:Type
                if p.type != null {
                    def resolved := resolveType(p.type->(ASTType), 
                            lookupContext)
                    if resolved != null
                        bound := resolved
                    else
                        bound := NullableType.ANY
                }
                else
                    bound := NullableType.ANY
                def type := new GenericParameterType(className + "." + 
                        p.identifier, bound)
                typeResolver.types[type.name] := type
                def newAliases := new HashMap<String, String>(
                        lookupContext.classAliases)
                newAliases[p.identifier] := type.name
                lookupContext := new LookupContext(lookupContext.packageUses,
                        newAliases)
            }
        }
        def interfaces := new Array<ClassType>()
        var superclass:Type?
        if cl.superclass != null {
            superclass := resolveType(cl.superclass->(ASTType), lookupContext)
            if superclass != null & superclass-!>(ClassType) {
                errors.error("cannot subclass \{superclass.displayName}", 
                        cl.position)
                superclass := null
            }
        }
        else {
            if className = class(Object).name
                superclass := null
            else
                superclass := ClassType.OBJECT
        }
        if cl.interfaces != null {
            for t in cl.interfaces->(ListView<ASTType>) {
                def type := resolveType(t, lookupContext)
                if type-?>(ClassType)
                    interfaces.add(type->(ClassType))
                else if type != null {
                    errors.error("\{type.displayName} is not an interface",
                            cl.position)
                }
            }
        }
        def methods := new Array<MethodStub>()
        var foundConstructor := false
        for m in cl.methods {
            def converted := convertMethod(cl.isExternal, m, classType, 
                    lookupContext)
            if converted != null {
                methods.add(converted)
                foundConstructor |= converted.methodType = 
                        MethodNodeType.CONSTRUCTOR
            }
        }
        if !foundConstructor & !isAbstract(cl) {
            def statements := new Array<ASTStatement>()
            def superConstructor := new ASTDotExpression(
                    new ASTSuper(cl.position), MethodNode.CONSTRUCTOR_NAME)
            statements.add(new ASTExpressionStatement(new ASTCallExpression(
                    superConstructor, new Array<ASTExpression>())))
            def block := new ASTBlock(cl.position, statements)
            def params := new Array<FormalParameter>()
            params.add(new FormalParameter(cl.position, 
                    Parameter.SELF_NAME, classType, false, false, false))
            def c := new MethodStub(cl.position, MethodNode.CONSTRUCTOR_NAME, 
                    new Annotations(cl.position), MethodNodeType.CONSTRUCTOR, 
                    params, VoidType.VOID, block, classType)
            methods.add(c)
        }
        def fields := new Array<FieldNode>()
        for f in cl.fields
            fields.addAll(convertFields(f, classType, lookupContext))
        var annotations := convertAnnotations(cl.position, cl.annotations)
        if cl.genericParameters != null
            annotations += AnnotationType.UNSPECIFIED
        if !cl.isExternal {
            def init := createClassInit(cl.position, classType, fields)
            if init != null {
                fields.add(init[0])
                methods.add(init[1])
            }
        }
        return new ClassStub(cl.position, classType, 
                cl.isInterface, annotations, lookupContext, 
                superclass->(ClassType?), interfaces, methods, fields, 
                cl.invariants, cl.genericParameters, cl.isExternal)
    }

    method generateStubs(f:ASTFile):CollectionView<ClassStub> {
        def result := new Array<ClassStub>()
        var currentPackage:String? := null
        def classAliases := new HashMap<String, String>()
        def packageUses := new Array<String>()
        def mainStatements := new Array<ASTStatement>()
        def implicitClassMethods := new Array<MethodStub>()
        packageUses.add("panda.collections")
        packageUses.add("panda.core")
        packageUses.add("panda.io")
        packageUses.add("panda.math")
        packageUses.add("panda.threads")
        for e in f.entries {
            if e-?>(ASTPackageDeclaration) {
                currentPackage := e->(ASTPackageDeclaration).name
            }
            else if e-?>(ASTUsesDeclaration) {
                def u := e->(ASTUsesDeclaration)
                if u.name.endsWith(".*") {
                    if u.alias != null {
                        errors.error("package imports may not have an alias",
                                u.position)
                    }
                    packageUses.add(u.name[..u.name.length - ".*".length])
                }
                else {
                    if u.alias != null 
                        classAliases[u.name] := u.alias->(String)
                    else
                        classAliases[u.name] := u.name
                }
            }
            else if e-?>(ASTClass) {
                def cl := e->(ASTClass)
                result.add(convertClass(cl, currentPackage, 
                        new LookupContext(packageUses, classAliases)))
            }
            else if e-?>(ASTStatement)
                mainStatements.add(e->(ASTStatement))
            else {
                throw new InternalCompilerException("unsupported file entry: " +
                        e)
            }
        }
        def implicitType := new ClassType("$Implicit")
        if mainStatements.length > 0 {
            def position := new Position(f.name, 1, 1)
            def classAnnotations := new Array<AnnotationType>()
            classAnnotations.add(AnnotationType.CLASS)
            implicitClassMethods.add(new MethodStub(position, 
                    MethodNode.MAIN_NAME, new Annotations(
                        position, classAnnotations),
                    MethodNodeType.METHOD, new Array<FormalParameter>(), 
                    VoidType.VOID, new ASTBlock(Position.INTERNAL, 
                    mainStatements), implicitType))
        }
        if implicitClassMethods.length > 0 {
            def implicitClass := new ClassStub(Position.INTERNAL, 
                    implicitType, false, 
                    new Annotations(Position.INTERNAL), 
                    new LookupContext(packageUses, classAliases), 
                    null, new Array<ClassType>(), implicitClassMethods, 
                    new Array<FieldNode>(), new Array<ASTInvariant>(),
                    null, false)
            result.add(implicitClass)
        }
        return result
    }

    method generateStubs():ImmutableHashMap<String, ClassStub> {
        def result := new HashMap<String, ClassStub>()
        for f in files {
            def classes := generateStubs(f)
            for cl in classes
                result[cl.name] := cl
        }
        return new ImmutableHashMap<String, ClassStub>(result)
    }
}