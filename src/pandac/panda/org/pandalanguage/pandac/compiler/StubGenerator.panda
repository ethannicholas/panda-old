package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTAnnotation
uses org.pandalanguage.pandac.ast.ASTArrowExpression
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTChoice
uses org.pandalanguage.pandac.ast.ASTClass
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTField
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTInstanceDeclaration
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTMethod
uses org.pandalanguage.pandac.ast.ASTMethodType
uses org.pandalanguage.pandac.ast.ASTNestedDeclaration
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSwitch
uses org.pandalanguage.pandac.ast.ASTSwitchCase
uses org.pandalanguage.pandac.ast.ASTTupleType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnparsedClass
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Package
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.stubs.TypeSymbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class MutablePackage (Symbol) {
    def _name:String

    @private
    def symbols := HashMap<String, Symbol>()

    init(name:String) {
        self._name := name
    }

    function get_name():String {
        return _name
    }

    function [](name:String):Symbol? {
        return symbols[name]
    }

    method []:=(name:String, symbol:Symbol) {
        symbols[name] := symbol
    }

    @override
    function convert():String {
        return "MutablePackage(\{name}, \{symbols})"
    }

    function convert():Package {
        def children := HashMap<String, Symbol>()
        for (name, symbol) in symbols {
            if symbol-?>MutablePackage {
                children[name] := symbol->MutablePackage.convert()->Package
            }
            else {
                children[name] := symbol
            }
        }
        return Package(self.name, children)
    }
}

class ClassContext {
    def currentPackage:String?

    def lookupContext:LookupContext

    init(currentPackage:String?, lookupContext:LookupContext) {
        self.currentPackage := currentPackage
        self.lookupContext := lookupContext
    }
}

class StubGenerator {
    constant INDEX_SUFFIX := "$index"

    def files:CollectionView<ASTFile>

    def errors:ErrorReporter

    def root := MutablePackage("")

    def types := HashMap<String, Type>()

    def astClasses := HashMap<String, (ASTClass, ClassContext, ClassType?)>()

    def astUnparsedClasses := HashMap<String, ASTUnparsedClass>()

    def astChoices := HashMap<String, (ASTChoice, ClassContext, ClassType?)>()

    def nestedClasses := HashMap<String, List<String>>()

    def stubs := HashMap<String, ClassStub>()

    def masterSymbolTable:SymbolTable

    def knownInstances := HashSet<Type>()

    def symbolTables := HashMap<ClassType, SymbolTable>()

    def unspecializedClasses := HashSet<String>()

    init(files:CollectionView<ASTFile>, errors:ErrorReporter) {
        self.files := Array<ASTFile>(files)
        self.errors := errors
        addType(BitType.BIT, Position.INTERNAL)
        addType(CharType.CHAR, Position.INTERNAL)
        addType(IntType.INT8, Position.INTERNAL)
        addType(IntType.INT16, Position.INTERNAL)
        addType(IntType.INT32, Position.INTERNAL)
        addType(IntType.INT64, Position.INTERNAL)
        addType(IntType.UINT8, Position.INTERNAL)
        addType(IntType.UINT16, Position.INTERNAL)
        addType(IntType.UINT32, Position.INTERNAL)
        addType(IntType.UINT64, Position.INTERNAL)
        addType(RealType.REAL32, Position.INTERNAL)
        addType(RealType.REAL64, Position.INTERNAL)
        addType(NullType.NULL, Position.INTERNAL)
        addType(NativePointerType.NATIVE_POINTER, Position.INTERNAL)
        def symbolTable := SymbolTable()
        def dummy := HashMap<String, String>()
        aliasType("Int", IntType.INT64, symbolTable, dummy)
        aliasType("UInt", IntType.UINT64, symbolTable, dummy)
        aliasType("Real", RealType.REAL64, symbolTable, dummy)
        aliasType("$null", NullType.NULL, symbolTable, dummy)
        masterSymbolTable := symbolTable
        findClassNames()
        scanFiles()
    }

    @private
    method addNestedClass(parent:String, child:String) {
        var list := nestedClasses[parent]
        if list != null {
            list.add(child)
        }
        else {
            nestedClasses[parent] := [child]
        }
    }

    @private
    method findClassNames(prefix:String?, cl:ASTClass, nested:Bit) {
        var name := cl.name
        if nested {
            addNestedClass(prefix, name)
        }
        if prefix != null {
            name := prefix + "." + name
        }
        def type:ClassType
        if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
            def symbolTable := SymbolTable()
            usePackage("panda.core", symbolTable, 
                    Array<String>(), Position.INTERNAL)
            type := WrapperType(resolveType(ASTClassType(
                    cl.position, name[0 .. name.length - 
                        "Wrapper".length], null, false), 
                    symbolTable)->PrimitiveType)
        }
        else {
            type := ClassType(name)
        }
        addType(type, cl.position, nested)
        for nestedClass in cl.contents.filter(n => n-?>ASTClass) {
            findClassNames(name, nestedClass->ASTClass, true)
        }
        for nestedChoice in cl.contents.filter(n => n-?>ASTChoice) {
            def nestedName := nestedChoice->ASTChoice.name
            def choiceType := ClassType(name + "." + nestedName)
            addType(choiceType, nestedChoice.position, true)
            addNestedClass(name, nestedName)
        }
    }

    @private
    method findClassNames() {
        var currentPackage:String?
        for f in files {
            currentPackage := null
            for decl in f.entries {
                if decl-?>ASTClass {
                    findClassNames(currentPackage, decl->ASTClass, false)
                }
                else if decl-?>ASTChoice {
                    var name := decl->ASTChoice.name
                    if currentPackage != null {
                        name := currentPackage + "." + name
                    }
                    addType(ClassType(name), decl.position)
                }
                else if decl-?>ASTUnparsedClass {
                    def up := decl->ASTUnparsedClass
                    def name := up.name
                    def type:Type
                    if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
                        def symbolTable := SymbolTable()
                        usePackage("panda.core", symbolTable, 
                                Array<String>(), Position.INTERNAL)
                        type := WrapperType(resolveType(ASTClassType(
                                decl.position, name[0 .. name.length - 
                                    "Wrapper".length], null, false), 
                                symbolTable)->PrimitiveType)
                    }
                    else {
                        type := ClassType(name)
                    }
                    addType(type, decl.position, up.containingClass != null)
                }
                else if decl-?>ASTPackageDeclaration {
                    currentPackage := decl->ASTPackageDeclaration.name
                }
            }
        }
    }

    @private
    method scanFiles() {
        def defaultPackages := Array<String>()
        defaultPackages.add("panda.collections")
        defaultPackages.add("panda.core")
        defaultPackages.add("panda.io")
        defaultPackages.add("panda.math")
        defaultPackages.add("panda.threads")
        for f in files {
            var currentPackage:String? := null
            def packageUses := Array<String>()
            def classAliases := HashMap<String, String>()
            def symbolTable := SymbolTable(masterSymbolTable)
            for p in defaultPackages {
                usePackage(p, symbolTable, packageUses, Position.INTERNAL)
            }
            def implicitClassSymbols := SymbolTable(masterSymbolTable)
            def implicitType := ClassType("$Implicit")
            var needImplicit := false
            def mainStatements := Array<ASTStatement>()
            for decl in f.entries {
                if decl-?>ASTUsesDeclaration {
                    def u := decl->ASTUsesDeclaration
                    if u.name.endsWith(".*") {
                        if u.alias != null {
                            errors.error("package imports may not have an alias",
                                    u.position)
                        }
                        usePackage(u.name[..u.name.length - ".*".length], 
                                symbolTable, packageUses, u.position)
                    }
                    else {
                        if u.alias != null {
                            aliasType(u.alias->String, 
                                    resolveType(ASTClassType(u.position, 
                                    u.name, null, false), symbolTable), symbolTable, 
                                    classAliases)
                        }
                        else {
                            var name := u.name
                            def index := name.lastIndexOf(".")
                            if index != null {
                                name := name[index + 1..]
                            }
                            aliasType(name, 
                                    resolveType(ASTClassType(u.position, 
                                    u.name, null, false), symbolTable), symbolTable,
                                    classAliases)
                        }
                    }
                }
                else if decl-?>ASTClass {
                    var name := decl->ASTClass.name
                    if currentPackage != null {
                        name := currentPackage + "." + name
                    }
                    def type:Type
                    if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
                        def symbolTable := SymbolTable()
                        usePackage("panda.core", symbolTable, 
                                Array<String>(), Position.INTERNAL)
                        type := WrapperType(resolveType(ASTClassType(
                                decl.position, name[0 .. name.length - 
                                    "Wrapper".length], null, false), 
                                symbolTable)->PrimitiveType)
                    }
                    else {
                        type := ClassType(name)
                    }
                    astClasses[name] := (decl->ASTClass, ClassContext(
                            currentPackage, LookupContext(packageUses,
                                classAliases)), null)
                }
                else if decl-?>ASTUnparsedClass {
                    def aup := decl->ASTUnparsedClass
                    astUnparsedClasses[aup.name] := aup
                }
                else if decl-?>ASTChoice {
                    var name := decl->ASTChoice.name
                    if currentPackage != null {
                        name := currentPackage + "." + name
                    }
                    astChoices[name] := (decl->ASTChoice, ClassContext(
                            currentPackage, LookupContext(packageUses,
                                classAliases)), null)
                }
                else if decl-?>ASTPackageDeclaration {
                    currentPackage := decl->ASTPackageDeclaration.name
                }
                else if decl-?>ASTMethod {
                    var m := convertMethod(false, decl->ASTMethod, 
                            implicitType, null, symbolTable)
                    if m != null {
                        m := MethodStub(m.position, m.name, 
                                m.annotations + Annotations.Kind.CLASS,
                                m.kind, m.parameters, null, m.returnType, 
                                m.body, m.owner)
                        checkMethodSignature(m)
                        addSymbol(m, implicitClassSymbols.mySymbols, errors)
                        needImplicit := true
                    }
                }
                else if decl-?>ASTStatement {
                    mainStatements.add(decl->ASTStatement)
                }
                else if decl-?>ASTInstanceDeclaration {
                    def type := decl->ASTInstanceDeclaration.type
                    knownInstances.add(resolveType(type, masterSymbolTable))
                }
                else {
                    throw InternalCompilerException(
                            "unsupported file entry: \{decl}")
                }
            }
            if mainStatements.count > 0 {
                def position := Position(f.path, 1, 1)
                def main := MethodStub(position, MethodNode.MAIN_NAME, 
                        Annotations(position, [Annotations.Kind.CLASS]),
                        MethodStub.Kind.METHOD, Array<FormalParameter>(), null,
                        VoidType.VOID, ASTBlock(Position.INTERNAL, 
                        mainStatements), implicitType)
                addSymbol(main, implicitClassSymbols.mySymbols, errors)
                needImplicit := true
            }
            if needImplicit {
                def implicitClass := ClassStub(Position.INTERNAL, 
                        implicitType, ClassStub.Kind.CLASS, 
                        Annotations(Position.INTERNAL), 
                        null, Array<ClassType>(), 
                        implicitClassSymbols.mySymbols, 
                        LookupContext(packageUses, classAliases), 
                        Array<ASTInvariant>(), null, false, null)
                astClasses[implicitClass.name] := (ASTClass(
                        Position.INTERNAL, implicitClass.name, 
                        ClassStub.Kind.CLASS, null, null, null, null, null, [], 
                        false), ClassContext(currentPackage, 
                            LookupContext(packageUses, classAliases)), 
                        null)
                stubs[implicitClass.name] := implicitClass
                addType(implicitClass.type, implicitClass.position)
            }
        }
    }

    method addType(type:Type, position:Position) {
        addType(type, position, false)
    }

    method addType(type:Type, position:Position, nested:Bit) {
        if nested {
            types[type.name] := type
            return
        }
        var currentPackage := root
        def components := type.name.split(".")
        def currentName := MutableString()
        for (i, c) in components.enumeration {
            if i > 0 {
                currentName.append(".")
            }
            currentName.append(c)
            if i < components.count - 1 {
                var next := currentPackage[c]
                if next = null {
                    next := MutablePackage(currentName.convert())
                    currentPackage[c] := next
                }
                else if next-!>MutablePackage {
                    errors.error("name conflict between class '\{currentName}'" +
                            "and package '\{currentName}'", position)
                }
                currentPackage := next->MutablePackage
            }
            else {
                assert currentPackage[c] = null : "package '\{currentPackage}'" +
                        " already contains a symbol named '\{c}'"
                currentPackage[c] := TypeSymbol(type)
                types[type.name] := type
            }
        }
    }

    method convertAnnotations(position:Position, 
            annotations:ListView<ASTAnnotation>?):Annotations {
        def result := Array<Annotations.Kind>()
        if annotations != null {
            for ann in annotations {
                if ann-?>ASTSimpleAnnotation {
                    def name := ann->ASTSimpleAnnotation.name
                    switch name {
                        case "protected": result.add(Annotations.Kind.PROTECTED)
                        case "private": result.add(Annotations.Kind.PRIVATE)
                        case "abstract": result.add(Annotations.Kind.ABSTRACT)
                        case "class": result.add(Annotations.Kind.CLASS)
                        case "thread": result.add(Annotations.Kind.THREAD)
                        case "external": result.add(Annotations.Kind.EXTERNAL)
                        case "final": result.add(Annotations.Kind.FINAL)
                        case "override": result.add(Annotations.Kind.OVERRIDE)
                        case "readonly": result.add(Annotations.Kind.READONLY)
                        case "limited": result.add(Annotations.Kind.LIMITED)
                        case "self": result.add(Annotations.Kind.SELF)
                        case "safeReturn": result.add(Annotations.Kind.SAFERETURN)
                        case "unsafeFunction": result.add(Annotations.Kind.UNSAFEFUNCTION)
                        case "synthetic": result.add(Annotations.Kind.SYNTHETIC)
                        case "specialize": result.add(Annotations.Kind.SPECIALIZE)
                        case "$wrapperMethod": result.add(Annotations.Kind.WRAPPER_METHOD)
                        case "math(overflow)": result.add(Annotations.Kind.OVERFLOW)
                        default:
                            errors.error("unsupported annotation '@\{name}'",
                                    ann.position)
                    }
                }
                else {
                    -- handle pre / post / invariant
                }
            }
        }
        return Annotations(position, result)
    }

    method resolveType(s:String?):ClassType? {
        if s = null {
            return null
        }
        return resolveType(ASTClassType(Position.INTERNAL, s, null, 
                false), masterSymbolTable)->ClassType
    }

    method resolveType(type:ASTType, symbols:SymbolTable):Type? {
        def result := resolveTypeWithExtras(type, symbols)
        if result = null {
            return null
        }
        if result[1].count > 0 {
            var symbol:Symbol? := getStub(result[0].name)
            for name in result[1] {
                if symbol-!>ClassStub {
                    break
                }
                symbol := symbol->ClassStub.symbols[name]
                if symbol = null {
                    errors.error("type '\{type}' not found", type.position)
                    return null
                }
            }
            if symbol-?>TypeSymbol {
                return symbol->TypeSymbol.type
            }
            errors.error("type '\{type}' not found", type.position)
            return null
        }
        return result[0]
    }

    @private
    method resolveExtraComponents(type:Type, extras:ListView<String>,
            nullable:Bit):(Type, ListView<String>) {
        var current := type
        for (i, name) in extras.enumeration {
            def stub := getStub(current.convert()->ClassType)
            assert stub != null : "no stub for \{current.name}"
            def next := stub.symbols[name]
            if next = null | next-!>TypeSymbol {
                return (current, extras[i..])
            }
            current := next->TypeSymbol.type
        }
        if nullable {
            current := NullableType(current)
        }
        return (current, [])
    }

    ============================================================================
    Returns the effective type of `type` within the context of `owner`. For
    instance, given:

    @SOURCE(
        class Example<T> {
            def array := Array<T>()
        }
    )

    The field `array` has type `Array<T>`. But within an instance of 
    `Example<Int>`, it has an *effective* type of `Array<Int>`.
    ============================================================================
    function effectiveType(owner:ClassType, type:Type):Type {
        return stubGenerator.effectiveType(owner, type)
    }

    method resolveTypeWithExtras(type:ASTType, 
            symbols:SymbolTable):(Type, ListView<String>)? {
        var result:Type?
        if type-?>ASTClassType {
            def name := type->ASTClassType.name
            def gps := type->ASTClassType.genericParameters
            var base:Type?
            def baseSymbol := symbols[name]
            if baseSymbol-!>TypeSymbol {
                base := types[name]
                if base = null {
                    if gps = null {
                        def components := name.split(".")
                        for i in components.count - 2 ... 0 by -1 {
                            def name := components[0 ... i].join(".")
                            def symbol := symbols[name]
                            if symbol-?>TypeSymbol {
                                return resolveExtraComponents(
                                        symbol->TypeSymbol.type, 
                                        components[i + 1..], type.isNullable)
                            }
                            def resolved := types[name]
                            if resolved != null {
                                return resolveExtraComponents(resolved, 
                                        components[i + 1..], type.isNullable)
                            }
                        }
                    }
                    errors.error("type '\{type}' not found", type.position)
                    return null
                }
            }
            else {
                base := baseSymbol->TypeSymbol.type
            }
            if gps != null {
                if base-!>ClassType {
                    errors.error("type '\{base.name}' does not take generic " +
                            "parameters", type.position)
                    return null
                }
                if base.name = PrimitiveArray.name |
                        base.name = ImmutablePrimitiveArray.name {
                    if gps.count != 1 {
                        errors.error("PrimitiveArray requires exactly 1 " + 
                                "parameter", type.position)
                        return null
                    }
                    def parameter := resolveType(gps[0], symbols)
                    if parameter = null {
                        return null
                    }
                    result := PrimitiveArrayType(base->ClassType, 
                            parameter)
                }
                else {
                    def parameters := Array<Type>()
                    for gp in gps {
                        def p := resolveType(gp, symbols)
                        if p = null {
                            return null
                        }
                        parameters.add(p)
                    }
                    result := GenericType(base->ClassType, parameters)
                }
            }
            else {
                result := base
            }
        }
        else if type-?>ASTMethodType {
            def m := type->ASTMethodType
            def parameters := Array<Type>()
            for p in m.parameters {
                def resolved := resolveType(p, symbols)
                if resolved = null {
                    return null
                }
                parameters.add(resolved)
            }
            def returnType:Type?
            if m.returnType != null {
                returnType := resolveType(m.returnType->ASTType, symbols)
                if returnType = null {
                    return null
                }
            }
            else {
                returnType := VoidType.VOID
            }
            result := MethodType(parameters, returnType, m.isFunction,
                    m.isImmutable)
        }
        else if type-?>ASTTupleType {
            def tuple := type->ASTTupleType
            def values := Array<Type>()
            for t in tuple.types {
                def resolved := resolveType(t, symbols)
                if resolved = null {
                    return null
                }
                values.add(resolved)
            }
            result := TupleType(values)
        }
        else if type-?>IRGenerator.ASTWrappedType {
            return (type->IRGenerator.ASTWrappedType.type, [])
        }
        else {
            unreachable
        }
        if result = null {
            return null
        }
        if type.isNullable & !result.isNullable {
            if result.isPrimitive {
                result := result.convert()->ClassType
            }
            result := NullableType(result)
        }
        def cached := types[result.name]
        if cached != null {
            return (cached, [])
        }
        types[result.name] := result
        return (result, [])
    }

    @private
    function getBaseType(var t:Type):Type {
        t := t.unwrapNullable
        if t-?>GenericType {
            return t->GenericType.base
        }
        return t
    }

    ============================================================================
    Verify that a method has a legal signature. In the case of overloaded
    operators, there are many constraints (such as addition must be a function
    rather than a method) which could result in a method not being legal.
    ============================================================================
    @private
    method checkMethodSignature(m:MethodStub) {
        -- wrappers are allowed to have overloads applying to their primitive
        -- equivalents, so don't bother checking them
        if m.owner.isWrapper {
            return
        }
        switch m.name {
            case "+", "-", "*", "/", "//", "^", ">", "<", ">=", "<=", "%",
                    "&", "&&", "|", "||", "~", "~~", "<<", ">>":
                var name:String
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    if m.parameters.count != 2 {
                        errors.error("expected \{name} " +
                                "to have exactly two parameters", m.position)
                    }
                    else if m.parameters[0].type != m.owner & 
                            m.parameters[1].type != m.owner {
                        errors.error("expected \{name} to " +
                                "take \{m.owner} as at least one of " +
                                "its two parameters", m.position)
                    }
                }
                else {
                    name := "operator '" + m.name + "'"
                    if m.parameters.count != 1 {
                        errors.error("expected \{name} to " + 
                                "have exactly one parameter", m.position)
                    }
                }
                if m.kind != MethodStub.Kind.FUNCTION {
                    errors.error("expected \{name} to be a " +
                            "function", m.position)
                }
            case "=":
                if m.annotations.isClass {
                    errors.error("operator '=' cannot be " +
                            "declared '@class'", m.position)
                }
                if m.parameters.count != 1 | 
                        m.parameters[0].type != ClassType.OBJECT {
                    errors.error("operator '=' must take " +
                            "exactly one parameter of type 'panda.core.Object'",
                            m.position)
                }
                if m.kind != MethodStub.Kind.FUNCTION {
                    errors.error("expected operator '=' to " +
                            "be a function", m.position)
                }
            case "[]":
                var name:String
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                }
                else {
                    name := "operator '\{m.name}'"
                }
                if m.parameters.count != 1 {
                    errors.error("expected \{name} to have " +
                            "exactly one parameter", m.position)
                }
                if m.kind != MethodStub.Kind.FUNCTION {
                    errors.error("expected \{name} to be a " +
                            "function", m.position)
                }
            case "[]:=":
                var name:String
                if m.annotations.isClass {
                    errors.error("indexed assignment is not " + 
                            "permitted on classes", m.position)
                    return
                }
                else {
                    name := "operator '\{m.name}'"
                }
                if m.parameters.count != 2 {
                    errors.error("expected \{name} to have " +
                            "exactly two parameters", m.position)
                }
                if m.kind = MethodStub.Kind.FUNCTION {
                    errors.error("\{name} may not be a function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    errors.error("\{name} may not return a value", m.position)
                }
            case "[..]", "[...]":
                var name:String
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                }
                else {
                    name := "operator '\{m.name}'"
                }
                if m.parameters.count > 3 {
                    errors.error("expected \{name} to have " +
                            "zero to three parameters", m.position)
                    return
                }
                if m.parameters.count = 3 & 
                        m.parameters[2].type.isNullable {
                    errors.error("expected parameter " + 
                            "'\{m.parameters[2].name}' of \{name} " + 
                            "to be non-nullable", m.position)
                }
                if m.kind != MethodStub.Kind.FUNCTION {
                    errors.error("expected \{name} to be a function", 
                            m.position)
                }
            case "[..]:=", "[...]:=":
                var name:String
                if m.annotations.isClass {
                    errors.error("slice assignment is not permitted on classes",
                            m.position)
                    return
                }
                else {
                    name := "operator '\{m.name}'"
                }
                if m.parameters.count < 1 | 
                        m.parameters.count > 4 {
                    errors.error("expected \{name} to have one to four " +
                            "parameters", m.position)
                    return
                }
                if m.parameters.count = 4 & 
                        m.parameters[2].type.isNullable {
                    errors.error("expected parameter " + 
                            "'\{m.parameters[2].name}' of \{name} " +
                            "to be non-nullable", m.position)
                }
                if m.kind = MethodStub.Kind.FUNCTION {
                    errors.error("\{name} may not be a function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    errors.error("\{name} may not return a value", m.position)
                }
            case "main":
                if m.returnType != VoidType.VOID {
                    errors.error("method 'main' may not return a value", 
                            m.position)
                }
                if !m.annotations.isClass {
                    errors.error("method 'main' must be declared '@class'", 
                            m.position)
                }
-*                if m.parameters.count > 1 | (m.parameters.count = 1 &
                        m.parameters[0].type != ClassType.ARRAY_STRING) {
                    errors.error("method 'main' must accept " +
                            "either no parameters or one parameter of type " +
                            "'\{PrimitiveArray<String>.name}'", m.position)
                }*-
            default:
                if m.name.endsWith(":=") {
                    var name:String
                    if m.annotations.isClass {
                        name := "@class operator '\{m.name}'"
                    }
                    else {
                        name := "operator '\{m.name}'"
                    }
                    if m.parameters.count != 1 {
                        errors.error("expected \{name} to " +
                                "have exactly one parameter", m.position)
                    }
                    if m.kind = MethodStub.Kind.FUNCTION {
                        errors.error("\{name} may not be a " +
                                "function", m.position)
                    }
                    if m.returnType != VoidType.VOID {
                        errors.error("\{name} may not return " +
                                "a value", m.position)
                    }
                    if !m.annotations.isSelf {
                        errors.error("\{name} must be " +
                                "declared '@self'", m.position)
                    }
                }
        }
    }

    method convertMethod(isExternal:Bit, m:ASTMethod, owner:ClassType,
            classGenerics:ListView<ASTTypedIdentifier>?,
            symbolTable:SymbolTable):MethodStub? {
        def parameters := Array<FormalParameter>()
        var annotations := convertAnnotations(m.position, m.annotations)
        if m.body = null & !isExternal & !annotations.isExternal {
            annotations += Annotations.Kind.ABSTRACT
        }
        for (i, p) in m.parameters.enumeration {
            var type := resolveType(p.type, symbolTable)
            if type != null {
                if p.isVarArg {
                    if i < m.parameters.count - 1 {
                        errors.error("only the last parameter of a method " + 
                                "may accept a variable number of arguments",
                                p.position)
                    }
                    def gp := Array<Type>()
                    gp.add(type)
                    type := GenericType(ClassType.LIST_VIEW, gp)
                }
                parameters.add(FormalParameter(p.position, p.name, type, 
                        p.isVar, p.isVarArg))
            }
            else {
                return null
            }
        }
        def returnType:Type?
        if m.returnType != null {
            returnType := resolveType(m.returnType->ASTType, symbolTable)
            if returnType = null {
                return null
            }
        }
        else {
            returnType := VoidType.VOID
        }
        def genericParameters:Array<(String, Type?)>?
        if classGenerics != null {
            genericParameters := Array<(String, Type?)>()
            for g in classGenerics {
                def type:Type?
                if g.type != null {
                    type := resolveType(g.type!, symbolTable)
                }
                else {
                    type := null
                }
                genericParameters.add((g.identifier, type))
            }
        }
        else {
            genericParameters := null
        }

        var original:String
        if m.annotations = null {
            original := "<none>"
        }
        else {
            original := m.annotations->Object.convert()
        }
        return MethodStub(m.position, m.name, annotations, m.kind, parameters, 
                genericParameters, returnType, m.body, owner)
    }

    method convertFields(f:ASTField, owner:ClassType, symbolTable:SymbolTable) {
        def result := Array<FieldNode>()
        var annotations := convertAnnotations(f.position, f.annotations)
        if f.decl.kind = Variable.Kind.CONSTANT {
            annotations += Annotations.Kind.CLASS
        }
        for (i, v) in f.decl.vars.enumeration {
            var type:Type? := null
            if v.type != null {
                type := resolveType(v.type!, symbolTable)
            }
            if type = null {
                type := UnresolvedType("<field:\{v.identifier}>", 
                        v.position)
            }
            def name := v.identifier
            if name = "_" {
                if f.decl.vars.count = 1 {
                    errors.error("'_' is only permitted in multiple " +
                            "assignments from a tuple", f.decl.position)
                }
                continue
            }
            def tuplePosition:Int?
            if f.decl.vars.count = 1 {
                tuplePosition := null
            }
            else {
                tuplePosition := i
            }
            def field := FieldNode(f.position, owner, name, 
                    annotations, f.decl.kind, type, f.decl.initializer, 
                    tuplePosition)
            addSymbol(field, field.position, symbolTable.mySymbols, errors)
            if annotations.isThread {
                def indexAnnotations := Array<Annotations.Kind>()
                indexAnnotations.add(Annotations.Kind.CLASS)
                indexAnnotations.add(Annotations.Kind.SYNTHETIC)
                def initializer := ASTCallExpression(ASTDotExpression(
                        ASTIdentifier(f.position, "Panda"), "allocThreadLocal"), 
                        Array<ASTExpression>())
                def fieldIndex := FieldNode(f.position, owner, 
                        v.identifier + INDEX_SUFFIX, Annotations(f.position,
                            indexAnnotations),
                        Variable.Kind.DEF, IntType.INT, initializer, 0)
                addSymbol(fieldIndex, fieldIndex.position, 
                        symbolTable.mySymbols, errors)
            }
        }
    }

    method createClassInit(position:Position, owner:ClassType,
            symbols:SymbolTable):(FieldNode, MethodStub)? {
        var createInit := false
        def body := Array<ASTStatement>()
        for s in symbols.mySymbols.values {
            if s-?>FieldNode {
                def f := s->FieldNode
                if f.annotations.isClass | 
                        f.annotations.isThread {
                    -- for @thread, we just ensure that the class init method
                    -- exists (it doesn't have to contain anything). This is so
                    -- code generators can easily do required thread local 
                    -- setup.
                    createInit := true
                    if f.annotations.isClass {
                        def value := f.initialValue
                        if value != null {
                            def target := Array<ASTExpression>()
                            target.add(ASTIdentifier(f.position, f.name))
                            body.add(ASTAssignment(target, null, value))
                        }
                    }
                }
            }
        }
        if createInit {
            -- FIXME need to use array syntax when it's wired up
            def classAnnotations := Array<Annotations.Kind>()
            classAnnotations.add(Annotations.Kind.CLASS)
            def classInited := FieldNode(position, owner->ClassType, 
                    FieldNode.CLASS_INITED_NAME, Annotations(position, 
                        classAnnotations), 
                    Variable.Kind.VAR, BitType.BIT, null, null)

            def targets := Array<ASTExpression>()
            targets.add(ASTIdentifier(position, classInited.name))
            def setInited := ASTAssignment(targets, null, ASTBitLiteral(position, true))
            def bail := ASTIf(position, ASTIdentifier(position, classInited.name),
                    ASTReturn(position, null), setInited)
            body.insert(0, bail)

            def classInit := MethodStub(position, 
                    MethodNode.CLASS_INIT_NAME, Annotations(position, 
                        classAnnotations),
                    MethodStub.Kind.METHOD, Array<FormalParameter>(), null,
                    VoidType.VOID, ASTBlock(position, body), 
                    owner->ClassType)

            return (classInited, classInit)
        }
        return null
    }

    function isAbstract(cl:ASTClass):Bit {
        if cl.kind = ClassStub.Kind.INTERFACE {
            return true
        }
        def annotations := cl.annotations
        if annotations != null {
            for a in annotations {
                if a-?>ASTSimpleAnnotation & 
                        a->ASTSimpleAnnotation.name = "abstract" {
                    return true
                }
            }
        }
        return false
    }

    @private
    method addNestedAliases(name:String, symbols:SymbolTable) {
        def nested := nestedClasses[name]
        if nested != null {
            for n in nested {
                symbols.add(n, TypeSymbol(types[name + "." + n]))
            }
        }
    }

    @private
    method addNestedAliases(stub:ClassStub, symbols:SymbolTable) {
        addNestedAliases(stub.name, symbols)
        if stub.superclass != null {
            addNestedAliases(getStub(stub.superclass), symbols)
        }
        for intf in stub.interfaces {
            addNestedAliases(getStub(intf), symbols)
        }
    }

    @pre(child.name = parent.name)
    function isOverride(child:MethodStub, parent:MethodStub, 
            genericParameters:ListView<Type>):Bit {
        if child.annotations.isClass != parent.annotations.isClass {
            return false
        }
        if child.parameters.count != parent.parameters.count {
            return false
        }
        def type := parent.typeWithGenerics(genericParameters)
        if type.returnType != child.returnType {
            return false
        }
        for i in 0 .. type.methodParameters.count {
            if type.methodParameters[i] != child.parameters[i].type {
                return false
            }
        }
        return true
    }

    ============================================================================
    Create an artificial method of type `type` which wraps the method `m`. For
    instance, given 

        method foo(a:Object):Object { ... }

    then `createShim(<foo>, <(String)=>(String)>)` would create:

        method foo(a:String):String { return foo(a->Object)->Object }
    ============================================================================
    @pre(type.methodParameters.count = m.parameters.count)
    method createShim(m:MethodStub, type:MethodType):MethodStub {
        def parameters := Array<FormalParameter>()
        def args := Array<ASTExpression>()
        Console.writeLine("reminder: broken generic varargs")
        for i in 0 .. m.parameters.count {
            def p := m.parameters[i]
            def target := p.type
            parameters.add(FormalParameter(p.position, p.name, 
                    target, p.isVar, p.isVarArg))
            Console.writeLine("arg cast \{p.name} to \{target}")
            args.add(ASTArrowExpression(ASTArrowExpression.Kind.FORCE_CAST,
                    ASTIdentifier(m.position, p.name), 
                    IRGenerator.toASTType(m.position, target)))
        }
        def body := Array<ASTStatement>()
        def call := ASTCallExpression(ASTIdentifier(m.position, m.name), args)
        if type.returnType = VoidType.VOID {
            body.add(ASTExpressionStatement(call))
        }
        else {
            def cast1 := ASTArrowExpression(ASTArrowExpression.Kind.FORCE_CAST, 
                    call, IRGenerator.toASTType(m.position, m.returnType))
            def cast2 := ASTArrowExpression(ASTArrowExpression.Kind.FORCE_CAST, 
                    cast1, IRGenerator.toASTType(m.position, type.returnType))
            body.add(ASTReturn(m.position, cast2))
        }
        def result := MethodStub(m.position, m.name, m.annotations + 
                Annotations.Kind.SHIM + Annotations.Kind.SYNTHETIC, m.kind, 
                m.parameters, m.genericParameters, type.returnType, 
                ASTBlock(m.position, body), m.owner)
        return result
    }

    method getSymbolTable(cl:ClassType):SymbolTable {
        var result := symbolTables[cl]
        if result = null {
            def stub := getStub(cl)
            if stub.isUnspecialized & cl-?>GenericType {
                def g := cl->GenericType
                result := UnspecializedTypeSymbolTable(self, g, 
                        getSymbolTable(g.base))
            }
            else {
                def parents := Array<SymbolTable>()
                if stub.superclass != null {
                    def superclass := effectiveType(cl, 
                            stub.superclass)->ClassType
                    parents.add(getSymbolTable(superclass))
                }
                else {
                    parents.add(masterSymbolTable)
                }
                for raw in stub.interfaces {
                    def intf := effectiveType(cl, raw)->ClassType
                    parents.add(getSymbolTable(intf))
                }
                def containingClass := stub.containingClass
                if containingClass != null {
                    parents.add(getSymbolTable(containingClass))
                }
                result := SymbolTable(parents)
                usePackage("panda.collections", result, Position.INTERNAL)
                usePackage("panda.core", result, Position.INTERNAL)
                usePackage("panda.io", result, Position.INTERNAL)
                usePackage("panda.math", result, Position.INTERNAL)
                usePackage("panda.threads", result, Position.INTERNAL)
                for p in stub.lookupContext.packageUses {
                    usePackage(p, result, stub.position)
                }
                for (alias, target) in stub.lookupContext.classAliases {
                    def resolved := resolveType(ASTClassType(stub.position, 
                            target, null, false), result)
                    assert resolved != null
                    aliasType(alias, resolved, result)
                }
                result.addAll(stub.symbols)
            }
            symbolTables[cl] := result
        }
        return result
    }

    function effectiveType(owner:ClassType, type:Type):Type {
        if owner-!>GenericType | owner-?>PrimitiveArrayType {
            return type
        }
        def symbols := SymbolTable()
        var stub := getStub(owner)
        def genericType := owner->GenericType
        if stub.genericParameters = null {
            stub := getRawStub(genericType.base)
        }
        for (i, p) in stub.genericParameters.enumeration {
            def symbol := TypeSymbol(genericType.parameters[i])
            symbols.add(p[0], symbol)
            symbols.add(owner->GenericType.base.name + "." + p[0], symbol)
        }
        return GenericType.getType(type, symbols)->ClassType
    }

    ============================================================================
    If, due to generics, a method overrides a method with different actual types
    (for instance in
        class A<T1> { method foo(a:T1) { } }
        class B<T2:Random> : A<T2> { @override method foo(b:T2) { } }
        B.foo has actual type (Random)=>(), while A.foo is type (Object?)=>(),
        yet B.foo overrides A.foo),
    creates a shim of the required method type to actually override the parent
    method (in this case, a method B.foo(Object?) which calls B.foo(Random)).
    ============================================================================
    method createShimIfNeeded(m:MethodStub, parent:ClassType):MethodStub? {
        def stub := getRawStub(parent)
        assert stub != null : "null stub: \{parent}"
        if stub.isUnspecialized {
            def methods := stub.symbols[m.name]
            if methods = null {
                return null
            }
            def genericParameters := parent->GenericType.parameters
            for m2 in methods->Methods.entries {
                if isOverride(m, m2, genericParameters) {
                    if m.type.unwrapGenerics != m2.type.unwrapGenerics {
                        return createShim(m, m2.type)
                    }
                }
            }
        }
        if stub.superclass != null {
            def result := createShimIfNeeded(m, effectiveType(parent, 
                    stub.superclass)->ClassType)
            if result != null {
                return result
            }
        }
        for intf in stub.interfaces {
            def result := createShimIfNeeded(m, effectiveType(parent, 
                    intf)->ClassType)
            if result != null {
                return result
            }
        }
        return null
    }

    method createShimIfNeeded(m:MethodStub, superclass:ClassType?,
            interfaces:ListView<ClassType>):MethodStub? {
        if superclass != null {
            def result := createShimIfNeeded(m, superclass)
            if result != null {
                return result
            }
        }
        for intf in interfaces {
            def result := createShimIfNeeded(m, intf)
            if result != null {
                return result
            }
        }
        return null
    }

    method convertClass(cl:ASTClass, currentPackage:String?,
            parentSymbolTable:SymbolTable, rawPackageUses:ListView<String>,
            rawClassAliases:Map<String, String>,
            containingClass:ClassType?):ClassStub {
        def packageUses := Array<String>(rawPackageUses)
        def classAliases := HashMap<String, String>(rawClassAliases)
        def symbolTable := SymbolTable(parentSymbolTable)
        def className:String
        if containingClass != null {
            className := containingClass.name + "." + cl.name
        }
        else if currentPackage != null {
            className := currentPackage + "." + cl.name
            usePackage(currentPackage, symbolTable, packageUses, cl.position)
        }
        else {
            className := cl.name
            usePackage("", symbolTable, packageUses, cl.position)
        }
        var classType:ClassType
        switch className {
            case WrapperType.INT8_WRAPPER.name: 
                classType := WrapperType.INT8_WRAPPER 
            case WrapperType.INT16_WRAPPER.name: 
                classType := WrapperType.INT16_WRAPPER 
            case WrapperType.INT32_WRAPPER.name: 
                classType := WrapperType.INT32_WRAPPER 
            case WrapperType.INT64_WRAPPER.name: 
                classType := WrapperType.INT64_WRAPPER 
            case WrapperType.UINT8_WRAPPER.name: 
                classType := WrapperType.UINT8_WRAPPER 
            case WrapperType.UINT16_WRAPPER.name: 
                classType := WrapperType.UINT16_WRAPPER 
            case WrapperType.UINT32_WRAPPER.name: 
                classType := WrapperType.UINT32_WRAPPER 
            case WrapperType.UINT64_WRAPPER.name: 
                classType := WrapperType.UINT64_WRAPPER 
            case WrapperType.REAL32_WRAPPER.name: 
                classType := WrapperType.REAL32_WRAPPER 
            case WrapperType.REAL64_WRAPPER.name: 
                classType := WrapperType.REAL64_WRAPPER 
            case WrapperType.BIT_WRAPPER.name: 
                classType := WrapperType.BIT_WRAPPER 
            case WrapperType.CHAR_WRAPPER.name: 
                classType := WrapperType.CHAR_WRAPPER 
            default: classType := ClassType(className)
        }
        def symbols := SymbolTable(symbolTable)
        var annotations := convertAnnotations(cl.position, cl.annotations)
        if cl.genericParameters != null {
            if !annotations.isSpecialize {
                unspecializedClasses.add(cl.name)
            }
            def types := Array<Type>()
            for p in cl.genericParameters! {
                def bound:Type
                if p.type != null {
                    def resolved := resolveType(p.type->ASTType, 
                            symbolTable)
                    if resolved != null {
                        bound := resolved
                    }
                    else {
                        bound := NullableType.ANY
                    }
                }
                else {
                    bound := NullableType.ANY
                }
                def type := GenericParameterType("\{className}.\{p.identifier}", 
                        bound)
                types.add(type)
                self.types[type.name] := type
                symbols.add(p.identifier, TypeSymbol(type))
                aliasType(p.identifier, type, symbolTable, classAliases)
            }
        }
        def interfaces := Array<ClassType>()
        var superclass:Type?
        if cl.superclass != null {
            superclass := resolveType(cl.superclass->ASTType, symbolTable)
            if superclass != null & superclass-!>ClassType {
                errors.error("cannot subclass \{superclass.displayName}", 
                        cl.position)
                superclass := null
            }
            if superclass != null {
                def stub := getRawStub(superclass->ClassType)
                if stub != null {
                    if cl.kind = ClassStub.Kind.CLASS &
                            stub.kind = ClassStub.Kind.INTERFACE {
                        errors.error("classes cannot subclass interfaces",
                                cl.superclass.position)
                    }
                    if cl.kind = ClassStub.Kind.INTERFACE &
                            stub.kind = ClassStub.Kind.CLASS {
                        errors.error("interfaces cannot subclass classes",
                                cl.superclass.position)
                    }
                    addNestedAliases(stub, symbols)
                }
            }
        }
        else {
            if className = Object.name {
                superclass := null
            }
            else {
                superclass := ClassType.OBJECT
            }
        }
        if containingClass != null {
            addNestedAliases(getRawStub(containingClass), symbols)
        }
        if cl.interfaces != null {
            for t in cl.interfaces->ListView<ASTType> {
                def type := resolveType(t, symbolTable)
                if type-?>ClassType {
                    interfaces.add(type->ClassType)
                    def stub := getRawStub(type->ClassType)
                    if stub.kind != ClassStub.Kind.INTERFACE {
                        errors.error("'\{stub.name}' is not an interface",
                                t.position)
                    }
                    if stub != null {
                        addNestedAliases(stub, symbols)
                    }
                }
                else if type != null {
                    errors.error("\{type.displayName} is not an interface",
                            cl.position)
                }
            }
        }
        var foundInit := false
        def invariants := Array<ASTInvariant>()
        for node in cl.contents {
            if node-?>ASTClass {
                def nestedClass := node->ASTClass
                def fullName := className + "." + nestedClass.name
                astClasses[fullName] := (nestedClass, 
                        ClassContext(currentPackage, LookupContext(packageUses, 
                            classAliases)), 
                        classType)
                def nestedType := resolveType(ASTClassType(cl.position, 
                        fullName, null, false), symbolTable)->ClassType
                addSymbol(TypeSymbol(nestedType), nestedClass.name, 
                        nestedClass.position, symbols.mySymbols, errors)
            }
            else if node-?>ASTChoice {
                def nestedChoice := node->ASTChoice
                def fullName := className + "." + nestedChoice.name
                astChoices[fullName] := (nestedChoice, 
                        ClassContext(currentPackage, LookupContext(packageUses, 
                            classAliases)), 
                        classType)
                def nestedType := resolveType(ASTClassType(cl.position, 
                        fullName, null, false), symbolTable)->ClassType
                addSymbol(TypeSymbol(nestedType), nestedChoice.name, 
                        nestedChoice.position, symbols.mySymbols, errors)
            }
            else if node-?>ASTNestedDeclaration {
                def nestedType := resolveType(node->ASTNestedDeclaration.type, 
                        symbolTable)->ClassType
                def name := nestedType.name
                def simpleName := name[name.lastIndexOf(".")->Int + 1..]
                addSymbol(TypeSymbol(nestedType), simpleName, node.position, 
                        symbols.mySymbols, errors)
            }
        }
        for node in cl.contents {
            if node-?>ASTMethod {
                def m := node->ASTMethod
                var converted := convertMethod(cl.isExternal, m, classType, 
                        cl.genericParameters, symbols)
                if converted != null {
                    checkMethodSignature(converted)
                    def shim := createShimIfNeeded(converted, 
                            superclass->ClassType?, interfaces)
                    if shim != null {
                        addSymbol(shim, symbols.mySymbols, errors)
                    }
                    addSymbol(converted, symbols.mySymbols, errors)
                    foundInit |= converted.kind = 
                            MethodStub.Kind.INIT
                }
            }
            else if node-?>ASTField {
                convertFields(node->ASTField, classType, symbols)
            }
            else if node-?>ASTInvariant {
                invariants.add(node->ASTInvariant)
            }
        }
        if cl.kind != ClassStub.Kind.INTERFACE & !foundInit {
            -- create implicit no-arg init
            def statements := Array<ASTStatement>()
            def superInit := ASTDotExpression(
                    ASTSuper(cl.position), MethodNode.INIT_NAME)
            statements.add(ASTExpressionStatement(ASTCallExpression(
                    superInit, Array<ASTExpression>())))
            def block := ASTBlock(cl.position, statements)
            def c := MethodStub(cl.position, MethodNode.INIT_NAME, 
                    Annotations(cl.position), MethodStub.Kind.INIT, 
                    Array<FormalParameter>(), null, VoidType.VOID, block, 
                    classType)
            addSymbol(c, symbols.mySymbols, errors)
        }
        if cl.genericParameters != null & annotations.isSpecialize {
            annotations += Annotations.Kind.UNSPECIFIED
        }
        if cl.isExternal {
            annotations += Annotations.Kind.EXTERNAL
        }
        else {
            def initMethod := createClassInit(cl.position, classType, symbols)
            if initMethod != null {
                symbols.mySymbols.remove(MethodNode.CLASS_INIT_NAME)
                symbols.mySymbols.remove(FieldNode.CLASS_INITED_NAME)
                addSymbol(initMethod[0], initMethod[0].position, 
                        symbols.mySymbols, errors)
                addSymbol(initMethod[1], symbols.mySymbols, errors)
            }
        }
        def genericParameters:Array<(String, Type?)>?
        if cl.genericParameters != null {
            genericParameters := Array<(String, Type?)>()
            for gp in cl.genericParameters {
                def type:Type?
                if gp.type != null {
                    type := resolveType(gp.type, symbolTable)
                }
                else {
                    type := null
                }
                genericParameters.add((gp.identifier, type))
            }
        }
        else {
            genericParameters := null
        }
        return ClassStub(cl.position, classType, 
                cl.kind, annotations, superclass->ClassType?, interfaces, 
                symbols.mySymbols, LookupContext(packageUses, classAliases), 
                invariants, genericParameters, cl.isExternal, 
                containingClass)
    }

    method createChoiceInit(c:ASTChoice, classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def superInit := ASTDotExpression(
                ASTSuper(c.position), MethodNode.INIT_NAME)
        statements.add(ASTExpressionStatement(ASTCallExpression(
                superInit, Array<ASTExpression>())))
        def block := ASTBlock(c.position, statements)
        def initAnnotations := Array<Annotations.Kind>()
        initAnnotations.add(Annotations.Kind.PRIVATE)
        return MethodStub(c.position, MethodNode.INIT_NAME, 
                Annotations(c.position, initAnnotations), MethodStub.Kind.INIT, 
                Array<FormalParameter>(), null, VoidType.VOID, block, classType)
    }

    method createChoiceConvertToInt(c:ASTChoice, 
            classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def cases := Array<ASTSwitchCase>()
        for (i, v) in c.values.enumeration {
            def caseValues := Array<ASTExpression>()
            caseValues.add(ASTIdentifier(c.position, v.name))
            cases.add(ASTSwitchCase(c.position, caseValues, ASTReturn(c.position,
                    ASTIntegerLiteral(c.position, i->UInt64, false))))
        }
        statements.add(ASTSwitch(c.position, ASTSelf(c.position), cases,
                ASTUnreachable(c.position, null)))
        def block := ASTBlock(c.position, statements)
        return MethodStub(c.position, 
                MethodNode.CONVERT_NAME, 
                Annotations(c.position, Array<Annotations.Kind>()), 
                MethodStub.Kind.FUNCTION, Array<FormalParameter>(), null,
                IntType.INT, block, classType)
    }

    method createChoiceConvertToString(c:ASTChoice, 
            classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def cases := Array<ASTSwitchCase>()
        for (i, v) in c.values.enumeration {
            def caseValues := Array<ASTExpression>()
            caseValues.add(ASTIdentifier(c.position, v.name))
            cases.add(ASTSwitchCase(c.position, caseValues, ASTReturn(c.position,
                    ASTStringLiteral(c.position, v.name))))
        }
        statements.add(ASTSwitch(c.position, ASTSelf(c.position), cases,
                ASTUnreachable(c.position, null)))
        def block := ASTBlock(c.position, statements)
        return MethodStub(c.position, 
                MethodNode.CONVERT_NAME, 
                Annotations(c.position, Array<Annotations.Kind>()), 
                MethodStub.Kind.FUNCTION, Array<FormalParameter>(), null,
                ClassType.STRING, block, classType)
    }

    method createChoiceFromInt(c:ASTChoice, classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def cases := Array<ASTSwitchCase>()
        for (i, v) in c.values.enumeration {
            def caseValues := Array<ASTExpression>()
            caseValues.add(ASTIntegerLiteral(c.position, i->UInt64, false))
            cases.add(ASTSwitchCase(c.position, caseValues, ASTReturn(c.position,
                    ASTIdentifier(c.position, v.name))))
        }
        statements.add(ASTSwitch(c.position, 
                ASTIdentifier(c.position, "value"), cases,
                ASTUnreachable(c.position, null)))
        def block := ASTBlock(c.position, statements)
        def cvtAnnotations := Array<Annotations.Kind>()
        cvtAnnotations.add(Annotations.Kind.CLASS)
        def convertParameters := Array<FormalParameter>()
        convertParameters.add(FormalParameter(c.position, "value", 
                IntType.INT, false, false))
        return MethodStub(c.position, "fromInt", 
                Annotations(c.position, cvtAnnotations), 
                MethodStub.Kind.FUNCTION, convertParameters, null, classType, 
                block, classType)
    }

    method createChoiceFromString(c:ASTChoice, classType:ClassType):MethodStub {
        def statements := Array<ASTStatement>()
        def cases := Array<ASTSwitchCase>()
        for v in c.values {
            def caseValues := Array<ASTExpression>()
            caseValues.add(ASTStringLiteral(c.position, v.name))
            cases.add(ASTSwitchCase(c.position, caseValues, 
                    ASTReturn(c.position, ASTIdentifier(c.position, v.name))))
        }
        statements.add(ASTSwitch(c.position, 
                ASTIdentifier(c.position, "value"), cases,
                ASTUnreachable(c.position, null)))
        def block := ASTBlock(c.position, statements)
        def cvtAnnotations := Array<Annotations.Kind>()
        cvtAnnotations.add(Annotations.Kind.CLASS)
        def convertParameters := Array<FormalParameter>()
        convertParameters.add(FormalParameter(c.position, "value", 
                ClassType.STRING, false, false))
        return MethodStub(c.position, "fromString", 
                Annotations(c.position, cvtAnnotations), 
                MethodStub.Kind.FUNCTION, convertParameters,  null, classType, 
                block, classType)
    }

    method convertChoice(c:ASTChoice, currentPackage:String?,
            symbolTable:SymbolTable, containingClass:ClassType?):ClassStub {
        def className:String
        if containingClass != null {
            className := containingClass.name + "." + c.name
        }
        else if currentPackage != null {
            className := currentPackage + "." + c.name
            usePackage(currentPackage, symbolTable, [], c.position)
        }
        else {
            className := c.name
        }
        def classType := resolveType(ASTClassType(c.position, className, 
                null, false), symbolTable)->ClassType
        def symbols := SymbolTable(masterSymbolTable)
        def fieldAnnotations := Array<Annotations.Kind>()
        fieldAnnotations.add(Annotations.Kind.CLASS)
        for v in c.values {
            def initialValue := ASTNew(v.position, 
                    ASTClassType(c.position, className, null, false),
                    Array<ASTExpression>())
            symbols.add(FieldNode(v.position, classType, v.name, 
                    Annotations(v.position, fieldAnnotations), 
                    Variable.Kind.DEF, classType, initialValue, null))
        }
        if !c.isExternal {
            def initMethod := createClassInit(c.position, classType, symbols)
            if initMethod != null {
                addSymbol(initMethod[0], initMethod[0].position, 
                        symbols.mySymbols, errors)
                addSymbol(initMethod[1], symbols.mySymbols, errors)
            }
        }
        
        addSymbol(createChoiceInit(c, classType), symbols.mySymbols, errors)
        addSymbol(createChoiceConvertToInt(c, classType), symbols.mySymbols, 
                errors)
        addSymbol(createChoiceConvertToString(c, classType), symbols.mySymbols, 
                errors)
        addSymbol(createChoiceFromInt(c, classType), symbols.mySymbols, errors)
        addSymbol(createChoiceFromString(c, classType), symbols.mySymbols, 
                errors)

        def annotations := convertAnnotations(c.position, c.annotations)
        return ClassStub(c.position, classType, ClassStub.Kind.CLASS,
                annotations, ClassType.CHOICE, Array<ClassType>(), 
                symbols.mySymbols, LookupContext(), Array<ASTInvariant>(), null, 
                c.isExternal, containingClass)
    }

    @class
    method addSymbol(m:MethodStub, map:Map<String, Symbol>, 
            errors:ErrorReporter) {
        def methods := map[m.name]
        if methods = null {
            map[m.name] := Methods(m)
        }
        else if methods-?>Methods {
            map[m.name] := methods->Methods + m
        }
        else {
            errors.error("invalid redefinition of symbol '\{m.name}'",
                    m.position)
        }
    }

    @class
    method addSymbol(s:Symbol, position:Position, map:Map<String, Symbol>, 
            errors:ErrorReporter) {
        addSymbol(s, s.name, position, map, errors)
    }

    @class
    method addSymbol(s:Symbol, name:String, position:Position, 
            map:Map<String, Symbol>, errors:ErrorReporter) {
        if map[name] != null {
            errors.error("invalid redefinition of symbol '\{name}'",
                    position)
        }
        else {
            map[name] := s
        }
    }

    method getPackage(name:String, position:Position):MutablePackage? {
        var current := root
        if name.length > 0 {
            for component in name.split(".") {
                def s := current[component]
                if s-?>MutablePackage {
                    current := s->MutablePackage
                }
                else {
                    errors.error("no package named '\{name}'", position)
                    return null
                }
            }
        }
        return current
    }

    method usePackage(name:String, symbolTable:SymbolTable, position:Position) {
        def p := getPackage(name, position)
        if p != null {
            for s in p.symbols.values {
                if s-?>TypeSymbol {
                    var cl := s.name
                    def dot := cl.lastIndexOf(".")
                    if dot != null {
                        cl := cl[dot + 1..]
                    }
                    symbolTable.add(cl, s)
                }
            }
        }
        else {
            errors.error("no package named '\{name}'", position)
        }
    }

    method usePackage(name:String, symbolTable:SymbolTable, 
            packageUses:List<String>, position:Position) {
        packageUses.add(name)
        usePackage(name, symbolTable, position)
    }

    method aliasType(alias:String, type:Type, symbolTable:SymbolTable) {
        symbolTable.add(alias, TypeSymbol(type))
    }

    method aliasType(alias:String, type:Type?, symbolTable:SymbolTable,
            classAliases:Map<String, String>) {
        if type != null {
            classAliases[alias] := type.name
            aliasType(alias, type, symbolTable)
        }
    }

    function getSymbolTable(lookupContext:LookupContext):SymbolTable {
        def symbolTable := SymbolTable(masterSymbolTable)
        for p in lookupContext.packageUses {
            usePackage(p, symbolTable, Position.INTERNAL)
        }
        for (alias, type) in lookupContext.classAliases {
            aliasType(alias, resolveType(ASTClassType(Position.INTERNAL, 
                    type, null, false), symbolTable), symbolTable)
        }
        return symbolTable
    }

    @class
    function getPackage(name:String):String? {
        def index := name.lastIndexOf(".")
        if index = null {
            return null
        }
        return name[0 .. index]
    }

    @private
    method getRawStub(name:String):ClassStub? {
        var result := stubs[name]
        if result = null {
            def unparsedClass := astUnparsedClasses[name]
            if unparsedClass != null {
                def parsed := PandaParser(errors).parseBodyEntry(
                        unparsedClass.text, Position(File("<internal>.plink"), 
                        1, 1))
                if parsed-?>ASTClass {
                    def cl := parsed->ASTClass
                    def symbolTable := SymbolTable(masterSymbolTable)
                    result := convertClass(cl, getPackage(name), symbolTable,
                            [], HashMap<String, String>(), 
                            resolveType(unparsedClass.containingClass))
                    stubs[name] := result
                }
                else if parsed-?>ASTChoice {
                    def c := parsed->ASTChoice
                    def symbolTable := SymbolTable(masterSymbolTable)
                    result := convertChoice(c, getPackage(name), symbolTable,
                            resolveType(unparsedClass.containingClass))
                    stubs[name] := result
                }
            }
            else {
                def classLookup := astClasses[name]
                if classLookup != null {
                    def cl, context, containingClass := classLookup
                    def symbolTable := getSymbolTable(context.lookupContext)
                    result := convertClass(cl, getPackage(name), symbolTable,
                            context.lookupContext.packageUses, 
                            HashMap<String, String>(
                                context.lookupContext.classAliases),
                            containingClass)
                    stubs[name] := result
                }
                else {
                    def choiceLookup := astChoices[name]
                    if choiceLookup != null {
                        def cl, context, containingClass := choiceLookup
                        def symbolTable := getSymbolTable(context.lookupContext)
                        result := convertChoice(cl, getPackage(name), 
                                symbolTable, containingClass)
                        stubs[name] := result
                    }
                }
            }
        }
        return result
    }

    method getRawStub(type:ClassType):ClassStub? {
        if type-?>GenericType {
            return getRawStub(type->GenericType.base.name)
        }
        else {
            return getRawStub(type.name)
        }
    }


    @private
    function isKnown(type:Type):Bit {
        return knownInstances.contains(type)
    }

    method isUnspecified(t:Type):Bit {
        if t.isPrimitive {
            return false
        }
        if t.unwrapNullable-?>GenericParameterType {
            return !unspecializedClasses.contains(
                    t.name[..t.name.lastIndexOf(".")!])
        }
        def stub := getStub(t.name)
        if stub.isUnspecialized {
            if t-?>GenericType {
                def g := t->GenericType
                for p in g.parameters {
                    if isUnspecified(p) {
                        return true
                    }
                }
            }
            return true
        }
        return stub.annotations.isUnspecified
    }

    @private
    method createStub(name:String):ClassStub? {
        var type := resolveType(
                PandaParser(errors).parseType(name, Position.INTERNAL), 
                masterSymbolTable)
        if type = null {
            return null
        }
        type := type.unwrapNullable
        if type-?>PrimitiveArrayType {
            def array := type->PrimitiveArrayType
            def unspecified := isUnspecified(array.elementType)
            def result := array.createStub(unspecified, isKnown(type))
            return result
        }
        else if type-?>GenericType {
            def generic := type->GenericType
            def baseStub := getStub(generic.base.name)
            if baseStub.isUnspecialized {
                return baseStub
            }
            def parameterStubs := Array<ClassStub?>()
            for p in generic.parameters {
                if p-!>PrimitiveType & p-!>GenericParameterType {
                    parameterStubs.add(getStub(p.convert()->ClassType))
                }
                else {
                    parameterStubs.add(null)
                }
            }
            def result := generic.createStub(baseStub, parameterStubs, 
                    isKnown(type), self)
            return result
        }
        else if type-?>GenericParameterType {
            return getStub(type->GenericParameterType.bound.name)
        }
        else if type-?>TupleType {
            def tuple := type->TupleType
            def stubs := Array<ClassStub?>()
            var unspecified := false
            for t in tuple.types {
                if isUnspecified(t) {
                    unspecified := true
                    break
                }
            }
            return tuple.createStub(unspecified, isKnown(type), self)
        }
        else if type-?>MethodType {
            if type.isImmutable(self) {
                return getStub(ClassType.METHOD)
            }
            else {
                return getStub(ClassType.MUTABLE_METHOD)
            }
        }
        else {
            return getRawStub(type.convert()->ClassType)
        }
    }

    function getStub(name:String):ClassStub {
        if name.endsWith("?") {
            return getStub(name[0 .. name.length - 1])
        }
        var result := stubs[name]
        if result = null {
            result := createStub(name)
            assert result != null : "failed to create stub for \{name}"
            stubs[name] := result
        }
        return result
    }

    function getStub(cl:ClassType):ClassStub {
        return getStub(cl.name)
    }

    method getRootPackage():Package {
        return root.convert()->Package
    }
}