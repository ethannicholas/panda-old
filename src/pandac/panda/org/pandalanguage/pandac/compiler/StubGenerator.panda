package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTAnnotation
uses org.pandalanguage.pandac.ast.ASTClass
uses org.pandalanguage.pandac.ast.ASTField
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTMethod
uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType

class StubGenerator {
    def files:CollectionView<ASTFile>

    def typeResolver:TypeResolver

    def errors:ErrorReporter

    constructor(files:CollectionView<ASTFile>, errors:ErrorReporter) {
        self.files := new Array<ASTFile>(files)
        self.errors := errors
        self.typeResolver := new TypeResolver(files, errors)
    }

    function convertAnnotations(position:Position, 
            annotations:ListView<ASTAnnotation>?):Annotations {
        return new Annotations(position, new Array<AnnotationType>())
    }

    function resolveType(type:ASTType, lookupContext:LookupContext):Type? {
        return typeResolver.resolve(type, lookupContext)
    }

    function convertMethod(m:ASTMethod, owner:ClassType,
            lookupContext:LookupContext):MethodStub {
        def parameters := new Array<FormalParameter>()
        def annotations := convertAnnotations(m.position, m.annotations)
        if !annotations.isClass {
            parameters.add(new FormalParameter(m.position, Parameter.SELF_NAME, 
                    owner, false, false, false))
        }
        for p in m.parameters {
            def type := resolveType(p.type, lookupContext)
            if type != null {
                parameters.add(new FormalParameter(p.position, p.name, type, 
                        p.isVar, p.isConvert, p.isVarArg))
            }
        }
        var returnType:Type?
        if m.returnType != null {
            returnType := resolveType(m.returnType->(ASTType), lookupContext)
            if returnType = null
                returnType := VoidType.VOID
        }
        else
            returnType := VoidType.VOID

        return new MethodStub(m.position, m.name, 
                annotations, m.methodType, parameters, returnType, m.body, 
                owner)
    }

    function convertFields(f:ASTField, owner:ClassType, 
            lookupContext:LookupContext):ListView<FieldNode> {
        def result := new Array<FieldNode>()
        def annotations := convertAnnotations(f.position, f.annotations)
        for i, v in f.decl.vars {
            var type:Type? := null
            if v.type != null
                type := resolveType(v.type->(ASTType), lookupContext)
            if type = null
                type := new UnresolvedType(v.identifier, v.position)
            result.add(new FieldNode(f.position, owner, v.identifier, 
                    annotations, f.decl.varType, type, f.decl.initializer, i))
        }
        return result
    }

    method convertClass(cl:ASTClass, currentPackage:String?,
            lookupContext:LookupContext):ClassStub {
        def className:String
        if currentPackage != null
            className := currentPackage + "." + cl.name
        else
            className := cl.name
        def classType := new ClassType(className)
        def interfaces := new Array<ClassType>()
        var superclass:Type?
        if cl.superclass != null {
            superclass := resolveType(cl.superclass->(ASTType), lookupContext)
            if superclass != null & superclass-!>(ClassType) {
                errors.error("cannot subclass \{superclass.displayName}", 
                        cl.position)
                superclass := null
            }
        }
        else
            superclass := null
        if cl.interfaces != null {
            for t in cl.interfaces->(ListView<ASTType>) {
                def type := resolveType(t, lookupContext)
                if type-?>(ClassType)
                    interfaces.add(type->(ClassType))
                else if type != null {
                    errors.error("\{type.displayName} is not an interface",
                            cl.position)
                }
            }
        }
        def methods := new Array<MethodStub>()
        for m in cl.methods
            methods.add(convertMethod(m, classType, lookupContext))
        def fields := new Array<FieldNode>()
        for f in cl.fields
            fields.addAll(convertFields(f, classType, lookupContext))
        return new ClassStub(cl.position, className, cl.isInterface, 
                convertAnnotations(cl.position, cl.annotations), lookupContext, 
                superclass->(ClassType?), interfaces, methods, fields, 
                cl.invariants, cl.genericParameters, cl.isExternal)
    }

    method generateStubs(f:ASTFile):CollectionView<ClassStub> {
        def result := new Array<ClassStub>()
        var currentPackage:String? := null
        def classAliases := new HashMap<String, String>()
        def packageUses := new Array<String>() 
        for e in f.entries {
            if e-?>(ASTPackageDeclaration) {
                currentPackage := e->(ASTPackageDeclaration).name
            }
            else if e-?>(ASTUsesDeclaration) {
                def u := e->(ASTUsesDeclaration)
                if u.name.endsWith(".*") {
                    if u.alias != null {
                        errors.error("package imports may not have an alias",
                                u.position)
                    }
                    packageUses.add(u.name[..u.name.length - ".*".length])
                }
                else {
                    if u.alias != null 
                        classAliases[u.name] := u.alias->(String)
                    else
                        classAliases[u.name] := u.name
                }
            }
            else if e-?>(ASTClass) {
                def cl := e->(ASTClass)
                result.add(convertClass(cl, currentPackage, 
                        new LookupContext(packageUses, classAliases)))
            }
        }
        return result
    }

    method generateStubs():ImmutableHashMap<String, ClassStub> {
        def result := new HashMap<String, ClassStub>()
        for f in files {
            def classes := generateStubs(f)
            for cl in classes
                result[cl.name] := cl
        }
        return new ImmutableHashMap<String, ClassStub>(result)
    }
}