package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTAnnotation
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTClass
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTEnum
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTField
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTInstanceDeclaration
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTMethod
uses org.pandalanguage.pandac.ast.ASTMethodType
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSwitch
uses org.pandalanguage.pandac.ast.ASTSwitchCase
uses org.pandalanguage.pandac.ast.ASTTupleType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Package
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.stubs.TypeSymbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class MutablePackage (Symbol) {
    property name:String

    @private
    def symbols := new HashMap<String, Symbol>()

    constructor(name:String) {
        self.name := name
    }

    function [](name:String):Symbol? {
        return symbols[name]
    }

    method []:=(name:String, symbol:Symbol) {
        symbols[name] := symbol
    }

    function format(fmt:String):String {
        return "MutablePackage(\{name}, \{symbols})"
    }

    function ->>():Package {
        def children := new HashMap<String, Symbol>()
        for (name, symbol) in symbols {
            if symbol-?>(MutablePackage)
                children[name] := symbol->(MutablePackage)->>(Package)
            else
                children[name] := symbol
        }
        return new Package(self.name, children)
    }
}

class ClassContext {
    def currentPackage:String?

    def lookupContext:LookupContext

    constructor(currentPackage:String?, lookupContext:LookupContext) {
        self.currentPackage := currentPackage
        self.lookupContext := lookupContext
    }
}

class StubGenerator {
    constant INDEX_SUFFIX := "$index"

    def files:CollectionView<ASTFile>

    def errors:ErrorReporter

    def root := new MutablePackage("")

    def types := new HashMap<String, Type>()

    def astClasses := new HashMap<String, (ASTClass, ClassContext)>()

    def astEnums := new HashMap<String, (ASTEnum, ClassContext)>()

    def stubs := new HashMap<String, ClassStub>()

    def masterSymbolTable:SymbolTable

    def knownInstances := new HashSet<Type>()

    constructor(files:CollectionView<ASTFile>, errors:ErrorReporter) {
        self.files := new Array<ASTFile>(files)
        self.errors := errors
        addType(BitType.BIT, Position.INTERNAL)
        addType(CharType.CHAR, Position.INTERNAL)
        addType(IntType.INT8, Position.INTERNAL)
        addType(IntType.INT16, Position.INTERNAL)
        addType(IntType.INT32, Position.INTERNAL)
        addType(IntType.INT64, Position.INTERNAL)
        addType(IntType.UINT8, Position.INTERNAL)
        addType(IntType.UINT16, Position.INTERNAL)
        addType(IntType.UINT32, Position.INTERNAL)
        addType(IntType.UINT64, Position.INTERNAL)
        addType(RealType.REAL32, Position.INTERNAL)
        addType(RealType.REAL64, Position.INTERNAL)
        addType(NativePointerType.NATIVE_POINTER, Position.INTERNAL)
        def symbolTable := new SymbolTable()
        def dummy := new HashMap<String, String>()
        aliasType("Int", IntType.INT32, symbolTable, dummy)
        aliasType("UInt", IntType.UINT32, symbolTable, dummy)
        aliasType("Real", RealType.REAL64,symbolTable, dummy)
        masterSymbolTable := symbolTable
        findClassNames()
        scanFiles()
    }

    @private
    method findClassNames() {
        var currentPackage:String?
        for f in files {
            currentPackage := null
            for decl in f.entries {
                if decl-?>(ASTClass) {
                    var name := decl->(ASTClass).name
                    if currentPackage != null
                        name := currentPackage + "." + name
                    def type:Type
                    if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
                        def symbolTable := new SymbolTable()
                        usePackage("panda.core", symbolTable, 
                                new Array<String>(), Position.INTERNAL)
                        type := new WrapperType(resolveType(new ASTClassType(
                                decl.position, name[0 .. name.length - 
                                    "Wrapper".length], null, false), 
                                symbolTable)->(PrimitiveType))
                    }
                    else
                        type := new ClassType(name)
                    addType(type, decl.position)
                }
                else if decl-?>(ASTEnum) {
                    var name := decl->(ASTEnum).name
                    if currentPackage != null
                        name := currentPackage + "." + name
                    addType(new ClassType(name), decl.position)
                }
                else if decl-?>(ASTPackageDeclaration)
                    currentPackage := decl->(ASTPackageDeclaration).name
            }
        }
    }

    @private
    method scanFiles() {
        def defaultPackages := new Array<String>()
        defaultPackages.add("panda.collections")
        defaultPackages.add("panda.core")
        defaultPackages.add("panda.io")
        defaultPackages.add("panda.math")
        defaultPackages.add("panda.threads")
        for f in files {
            var currentPackage:String? := null
            def packageUses := new Array<String>()
            def classAliases := new HashMap<String, String>()
            def symbolTable := new SymbolTable(masterSymbolTable)
            for p in defaultPackages
                usePackage(p, symbolTable, packageUses, Position.INTERNAL)
            def implicitClassSymbols := new SymbolTable(masterSymbolTable)
            def implicitType := new ClassType("$Implicit")
            var needImplicit := false
            def mainStatements := new Array<ASTStatement>()
            for decl in f.entries {
                if decl-?>(ASTUsesDeclaration) {
                    def u := decl->(ASTUsesDeclaration)
                    if u.name.endsWith(".*") {
                        if u.alias != null {
                            errors.error("package imports may not have an alias",
                                    u.position)
                        }
                        usePackage(u.name[..u.name.length - ".*".length], 
                                symbolTable, packageUses, u.position)
                    }
                    else {
                        if u.alias != null 
                            aliasType(u.alias->(String), 
                                    resolveType(new ASTClassType(u.position, 
                                    u.name, null, false), symbolTable), symbolTable, 
                                    classAliases)
                        else {
                            var name := u.name
                            def index := name.lastIndexOf(".")
                            if index != null
                                name := name[index + 1..]
                            aliasType(name, 
                                    resolveType(new ASTClassType(u.position, 
                                    u.name, null, false), symbolTable), symbolTable,
                                    classAliases)
                        }
                    }
                }
                else if decl-?>(ASTClass) {
                    var name := decl->(ASTClass).name
                    if currentPackage != null
                        name := currentPackage + "." + name
                    def type:Type
                    if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
                        def symbolTable := new SymbolTable()
                        usePackage("panda.core", symbolTable, 
                                new Array<String>(), Position.INTERNAL)
                        type := new WrapperType(resolveType(new ASTClassType(
                                decl.position, name[0 .. name.length - 
                                    "Wrapper".length], null, false), 
                                symbolTable)->(PrimitiveType))
                    }
                    else
                        type := new ClassType(name)
                    astClasses[name] := (decl->(ASTClass), new ClassContext(
                            currentPackage, new LookupContext(packageUses,
                                classAliases)))
                }
                else if decl-?>(ASTEnum) {
                    var name := decl->(ASTEnum).name
                    if currentPackage != null
                        name := currentPackage + "." + name
                    astEnums[name] := (decl->(ASTEnum), new ClassContext(
                            currentPackage, new LookupContext(packageUses,
                                classAliases)))
                }
                else if decl-?>(ASTPackageDeclaration)
                    currentPackage := decl->(ASTPackageDeclaration).name
                else if decl-?>(ASTMethod) {
                    var m := convertMethod(false, decl->(ASTMethod), 
                            implicitType, symbolTable)
                    if m != null {
                        m := new MethodStub(m.position, m.name, 
                                m.annotations + AnnotationType.CLASS,
                                m.methodType, m.parameters, m.returnType, 
                                m.body, m.owner)
                        checkMethodSignature(m)
                        addSymbol(m, implicitClassSymbols, errors)
                        needImplicit := true
                    }
                }
                else if decl-?>(ASTStatement)
                    mainStatements.add(decl->(ASTStatement))
                else if decl-?>(ASTInstanceDeclaration) {
                    def type := decl->(ASTInstanceDeclaration).type
                    knownInstances.add(resolveType(type, masterSymbolTable))
                }
                else {
                    throw new InternalCompilerException(
                            "unsupported file entry: \{decl}")
                }
            }
            if mainStatements.length > 0 {
                def position := new Position(f.path, 0)
                def classAnnotations := new Array<AnnotationType>()
                classAnnotations.add(AnnotationType.CLASS)
                def main := new MethodStub(position, MethodNode.MAIN_NAME, 
                        new Annotations(position, classAnnotations),
                        MethodNodeType.METHOD, new Array<FormalParameter>(), 
                        VoidType.VOID, new ASTBlock(Position.INTERNAL, 
                        mainStatements), implicitType)
                addSymbol(main, implicitClassSymbols, errors)
                needImplicit := true
            }
            if needImplicit {
                def implicitClass := new ClassStub(Position.INTERNAL, 
                        implicitType, false, 
                        new Annotations(Position.INTERNAL), 
                        null, new Array<ClassType>(), 
                        new OrderedMap<String, Symbol>(implicitClassSymbols), 
                        new LookupContext(packageUses, classAliases), 
                        new Array<ASTInvariant>(), null, false, null)
                astClasses[implicitClass.name] := (new ASTClass(
                        Position.INTERNAL, implicitClass.name, false, 
                        null, null, null, null, null, [], [], [], false),
                        new ClassContext(currentPackage, 
                            new LookupContext(packageUses, classAliases)))
                stubs[implicitClass.name] := implicitClass
                addType(implicitClass.type, implicitClass.position)
            }
        }
    }

    method addType(type:Type, position:Position) {
        var currentPackage := root
        def components := type.name.split(".")
        def currentName := new MutableString()
        for i, c in components {
            if i > 0
                currentName.append(".")
            currentName.append(c)
            if i < components.length - 1 {
                var next := currentPackage[c]
                if next = null {
                    next := new MutablePackage(currentName->>(String))
                    currentPackage[c] := next
                }
                else if next-!>(MutablePackage) {
                    errors.error("name conflict between class '\{currentName}'" +
                            "and package '\{currentName}'", position)
                }
                currentPackage := next->(MutablePackage)
            }
            else {
                assert currentPackage[c] = null : "package '\{currentPackage}'" +
                        " already contains a symbol named '\{c}'"
                currentPackage[c] := new TypeSymbol(type)
                types[type.name] := type
            }
        }
    }

    method convertAnnotations(position:Position, 
            annotations:ListView<ASTAnnotation>?):Annotations {
        def result := new Array<AnnotationType>()
        if annotations != null {
            for ann in annotations {
                if ann-?>(ASTSimpleAnnotation) {
                    switch ann->(ASTSimpleAnnotation).name {
                        case "protected": result.add(AnnotationType.PROTECTED)
                        case "private": result.add(AnnotationType.PRIVATE)
                        case "abstract": result.add(AnnotationType.ABSTRACT)
                        case "class": result.add(AnnotationType.CLASS)
                        case "thread": result.add(AnnotationType.THREAD)
                        case "external": result.add(AnnotationType.EXTERNAL)
                        case "final": result.add(AnnotationType.FINAL)
                        case "override": result.add(AnnotationType.OVERRIDE)
                        case "readonly": result.add(AnnotationType.READONLY)
                        case "limited": result.add(AnnotationType.LIMITED)
                        case "self": result.add(AnnotationType.SELF)
                        case "safeReturn": result.add(AnnotationType.SAFERETURN)
                        case "unsafeFunction": result.add(AnnotationType.UNSAFEFUNCTION)
                        case "synthetic": result.add(AnnotationType.SYNTHETIC)
                        case "$wrapperMethod": result.add(AnnotationType.WRAPPER_METHOD)
                        case "math(overflow)": result.add(AnnotationType.OVERFLOW)
                        default: unreachable
                    }
                }
                else {
                    -- handle pre / post / invariant
                }
            }
        }
        return new Annotations(position, result)
    }

    method resolveType(type:ASTType, symbols:MapView<String, Symbol>):Type? {
        var result:Type?
        if type-?>(ASTClassType) {
            def name := type->(ASTClassType).name
            var base:Type?
            def baseSymbol := symbols[name]
            if baseSymbol-!>(TypeSymbol) {
                base := types[name]
                if base = null {
                    errors.error("type '\{type}' not found", type.position)
                    Panda.dumpStack()
                    return null
                }
            }
            else
                base := baseSymbol->(TypeSymbol).type
            def gps := type->(ASTClassType).genericParameters
            if gps != null {
                if base-!>(ClassType) {
                    errors.error("type '\{base.name}' does not take generic " +
                            "parameters", type.position)
                    return null
                }
                if base.name = class(PrimitiveArray).name |
                        base.name = class(ImmutablePrimitiveArray).name {
                    if gps.length != 1 {
                        errors.error("PrimitiveArray requires exactly 1 " + 
                                "parameter", type.position)
                        return null
                    }
                    def parameter := resolveType(gps[0], symbols)
                    if parameter = null
                        return null
                    result := new PrimitiveArrayType(base->(ClassType), 
                            parameter)
                }
                else {
                    def parameters := new Array<Type>()
                    for gp in gps {
                        def p := resolveType(gp, symbols)
                        if p = null
                            return null
                        parameters.add(p)
                    }
                    result := new GenericType(base->(ClassType), parameters)
                }
            }
            else
                result := base
        }
        else if type-?>(ASTMethodType) {
            def m := type->(ASTMethodType)
            def parameters := new Array<Type>()
            for p in m.parameters {
                def resolved := resolveType(p, symbols)
                if resolved = null
                    return null
                parameters.add(resolved)
            }
            def returnType:Type?
            if m.returnType != null {
                returnType := resolveType(m.returnType->(ASTType), symbols)
                if returnType = null
                    return null
            }
            else
                returnType := VoidType.VOID
            result := new MethodType(parameters, returnType, m.isFunction,
                    m.isImmutable)
        }
        else if type-?>(ASTTupleType) {
            def tuple := type->(ASTTupleType)
            def values := new Array<Type>()
            for t in tuple.types {
                def resolved := resolveType(t, symbols)
                if resolved = null
                    return null
                values.add(resolved)
            }
            result := new TupleType(values)
        }
        else
            unreachable
        if result = null
            return null
        if type.isNullable & !result.isNullable {
            if result.isPrimitive
                result := result->>(ClassType)
            result := new NullableType(result)
        }
        def cached := types[result.name]
        if cached != null
            return cached
        types[result.name] := result
        return result
    }

    @private
    function getBaseType(var t:Type):Type {
        t := t.unwrapNullable
        if t-?>(GenericType)
            return t->(GenericType).base
        return t
    }

    ============================================================================
    Verify that a method has a legal signature. In the case of overloaded
    operators, there are many constraints (such as addition must be a function
    rather than a method) which could result in a method not being legal.
    ============================================================================
    @private
    method checkMethodSignature(m:MethodStub) {
        -- wrappers are allowed to have overloads applying to their primitive
        -- equivalents, so don't bother checking them
        if m.owner.isWrapper
            return
        switch m.name {
            case "+", "-", "*", "/", "//", "^", ">", "<", ">=", "<=", "%",
                    "&", "&&", "|", "||", "~", "~~", "<<", ">>": {
                var name:String
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    if m.parameters.length != 2 {
                        errors.error("expected \{name} " +
                                "to have exactly two parameters", m.position)
                    }
                    else if m.parameters[0].type != m.owner & 
                            m.parameters[1].type != m.owner {
                        errors.error("expected \{name} to " +
                                "take \{m.owner} as at least one of " +
                                "its two parameters", m.position)
                    }
                }
                else {
                    name := "operator '" + m.name + "'"
                    if m.parameters.length != 1 {
                        errors.error("expected \{name} to " + 
                                "have exactly one parameter", m.position)
                    }
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a " +
                            "function", m.position)
                }
            }
            case "=": {
                if m.annotations.isClass {
                    errors.error("operator '=' cannot be " +
                            "declared '@class'", m.position)
                }
                if m.parameters.length != 1 | 
                        m.parameters[0].type != ClassType.OBJECT {
                    errors.error("operator '=' must take " +
                            "exactly one parameter of type 'panda.core.Object'",
                            m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected operator '=' to " +
                            "be a function", m.position)
                }
            }
            case "[]": {
                var name:String
                if m.annotations.isClass
                    name := "@class operator '\{m.name}'"
                else
                    name := "operator '\{m.name}'"
                if m.parameters.length != 1 {
                    errors.error("expected \{name} to have " +
                            "exactly one parameter", m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a " +
                            "function", m.position)
                }
            }
            case "[]:=": {
                var name:String
                if m.annotations.isClass {
                    errors.error("indexed assignment is not " + 
                            "permitted on classes", m.position)
                    return
                }
                else
                    name := "operator '\{m.name}'"
                if m.parameters.length != 2 {
                    errors.error("expected \{name} to have " +
                            "exactly two parameters", m.position)
                }
                if m.methodType = MethodNodeType.FUNCTION {
                    errors.error("\{name} may not be a function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    errors.error("\{name} may not return a value", m.position)
                }
            }
            case "[..]", "[...]": {
                var name:String
                if m.annotations.isClass
                    name := "@class operator '\{m.name}'"
                else
                    name := "operator '\{m.name}'"
                if m.parameters.length > 3 {
                    errors.error("expected \{name} to have " +
                            "zero to three parameters", m.position)
                    return
                }
                if m.parameters.length = 3 & 
                        m.parameters[2].type.isNullable {
                    errors.error("expected parameter " + 
                            "'\{m.parameters[2].name}' of \{name} " + 
                            "to be non-nullable", m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    errors.error("expected \{name} to be a function", 
                            m.position)
                }
            }
            case "[..]:=", "[...]:=": {
                var name:String
                if m.annotations.isClass {
                    errors.error("slice assignment is not permitted on classes",
                            m.position)
                    return
                }
                else
                    name := "operator '\{m.name}'"
                if m.parameters.length < 1 | 
                        m.parameters.length > 4 {
                    errors.error("expected \{name} to have one to four " +
                            "parameters", m.position)
                    return
                }
                if m.parameters.length = 4 & 
                        m.parameters[2].type.isNullable {
                    errors.error("expected parameter " + 
                            "'\{m.parameters[2].name}' of \{name} " +
                            "to be non-nullable", m.position)
                }
                if m.methodType = MethodNodeType.FUNCTION {
                    errors.error("\{name} may not be a function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    errors.error("\{name} may not return a value", m.position)
                }
            }
            case "->>": {
                if m.annotations.isClass {
                    constant name := "@class operator '->>'"
                    if m.parameters.length != 1 {
                        errors.error("expected \{name} to " +
                                "take a single parameter", m.position)
                    }
                    if m.returnType != m.owner & 
                            getBaseType(m.returnType) != m.owner {
                        errors.error("expected \{name} to " +
                                "return '\{m.owner.displayName}'", 
                                m.position)
                    }
                    if m.parameters[0].type = m.owner {
                        errors.error("parameter type and " + 
                                "return types of \{name} must be different", 
                                m.position)
                    }
                }
                else {
                    constant name := "operator '->>'"
                    if m.parameters.length != 0 {
                        errors.error("expected \{name} to take " +
                                "no parameters", m.position)
                    }
                }
                if m.methodType = MethodNodeType.METHOD & 
                        !m.annotations.isSelf {
                    errors.error("convert methods must " + 
                            "have the '@self' annotation", m.position)
                }
            }
            case "main": {
                if m.returnType != VoidType.VOID {
                    errors.error("method 'main' may not return a value", 
                            m.position)
                }
                if !m.annotations.isClass {
                    errors.error("method 'main' must be declared '@class'", 
                            m.position)
                }
-*                if m.parameters.length > 1 | (m.parameters.length = 1 &
                        m.parameters[0].type != ClassType.ARRAY_STRING) {
                    errors.error("method 'main' must accept " +
                            "either no parameters or one parameter of type " +
                            "'\{class(PrimitiveArray<String>).name}'", m.position)
                }*-
            }
            default: {
                if m.name.endsWith(":=") {
                    var name:String
                    if m.annotations.isClass
                        name := "@class operator '\{m.name}'"
                    else
                        name := "operator '\{m.name}'"
                    if m.parameters.length != 1 {
                        errors.error("expected \{name} to " +
                                "have exactly one parameter", m.position)
                    }
                    if m.methodType = MethodNodeType.FUNCTION {
                        errors.error("\{name} may not be a " +
                                "function", m.position)
                    }
                    if m.returnType != VoidType.VOID {
                        errors.error("\{name} may not return " +
                                "a value", m.position)
                    }
                    if !m.annotations.isSelf {
                        errors.error("\{name} must be " +
                                "declared '@self'", m.position)
                    }
                }
            }
        }
    }

    method convertMethod(isExternal:Bit, m:ASTMethod, owner:ClassType,
            symbolTable:MapView<String, Symbol>):MethodStub? {
        def parameters := new Array<FormalParameter>()
        var annotations := convertAnnotations(m.position, m.annotations)
        if m.body = null & !isExternal & !annotations.isExternal
            annotations += AnnotationType.ABSTRACT
        for p in m.parameters {
            var type := resolveType(p.type, symbolTable)
            if type != null {
                if p.isVarArg {
                    def gp := new Array<Type>()
                    gp.add(type)
                    type := new GenericType(ClassType.LIST_VIEW, gp)
                }
                parameters.add(new FormalParameter(p.position, p.name, type, 
                        p.isVar, p.isConvert, p.isVarArg))
            }
            else
                return null
        }
        var returnType:Type?
        if m.returnType != null {
            returnType := resolveType(m.returnType->(ASTType), symbolTable)
            if returnType = null
                return null
        }
        else
            returnType := VoidType.VOID

        var original:String
        if m.annotations = null
            original := "<none>"
        else
            original := m.annotations->(Object)->>(String)
        return new MethodStub(m.position, m.name, 
                annotations, m.methodType, parameters, returnType, m.body, 
                owner)
    }

    method convertFields(f:ASTField, owner:ClassType, 
            symbolTable:SymbolTable, dest:SymbolTable) {
        def result := new Array<FieldNode>()
        var annotations := convertAnnotations(f.position, f.annotations)
        if f.decl.varType = VariableType.CONSTANT
            annotations += AnnotationType.CLASS
        for i, v in f.decl.vars {
            var type:Type? := null
            if v.type != null
                type := resolveType(v.type->(ASTType), symbolTable)
            if type = null {
                type := new UnresolvedType("<field:\{v.identifier}>", 
                        v.position)
            }
            def name:String
            if f.decl.varType = VariableType.PROPERTY
                name := v.identifier + "$PROPERTY"
            else
                name := v.identifier
            def field := new FieldNode(f.position, owner, name, 
                    annotations, f.decl.varType, type, f.decl.initializer, i)
            addSymbol(field, field.position, dest, errors)
            if annotations.isThread {
                def indexAnnotations := new Array<AnnotationType>()
                indexAnnotations.add(AnnotationType.CLASS)
                indexAnnotations.add(AnnotationType.SYNTHETIC)
                def initializer := new ASTCallExpression(new ASTDotExpression(
                        new ASTIdentifier(f.position, "Panda"), "allocThreadLocal"), 
                        new Array<ASTExpression>())
                def fieldIndex := new FieldNode(f.position, owner, 
                        v.identifier + INDEX_SUFFIX, new Annotations(f.position,
                            indexAnnotations),
                        VariableType.DEF, IntType.INT32, initializer, 0)
                addSymbol(fieldIndex, fieldIndex.position, dest, errors)
            }
        }
    }

    method createClassInit(position:Position, owner:ClassType,
            symbols:MapView<String, Symbol>):(FieldNode, MethodStub)? {
        var createInit := false
        def body := new Array<ASTStatement>()
        for s in symbols.values {
            if s-?>(FieldNode) {
                def f := s->(FieldNode)
                if f.annotations.isClass | 
                        f.annotations.isThread {
                    -- for @thread, we just ensure that the class init method
                    -- exists (it doesn't have to contain anything). This is so
                    -- code generators can easily do required thread local 
                    -- setup.
                    createInit := true
                    if f.annotations.isClass {
                        def value := f.initialValue
                        if value != null {
                            def target := new Array<ASTExpression>()
                            target.add(new ASTIdentifier(f.position, f.name))
                            body.add(new ASTAssignment(target, null, value))
                        }
                    }
                }
            }
        }
        if createInit {
            -- FIXME need to use array syntax when it's wired up
            def classAnnotations := new Array<AnnotationType>()
            classAnnotations.add(AnnotationType.CLASS)
            def classInited := new FieldNode(position, owner->(ClassType), 
                    FieldNode.CLASS_INITED_NAME, new Annotations(position, 
                        classAnnotations), 
                    VariableType.VAR, BitType.BIT, null, null)

            def targets := new Array<ASTExpression>()
            targets.add(new ASTIdentifier(position, classInited.name))
            def setInited := new ASTAssignment(targets, null, new ASTBitLiteral(position, true))
            def bail := new ASTIf(position, new ASTIdentifier(position, classInited.name),
                    new ASTReturn(position, null), setInited)
            body.insert(0, bail)

            def classInit := new MethodStub(position, 
                    MethodNode.CLASS_INIT_NAME, new Annotations(position, 
                        classAnnotations),
                    MethodNodeType.METHOD, new Array<FormalParameter>(), 
                    VoidType.VOID, new ASTBlock(position, body), 
                    owner->(ClassType))

            return (classInited, classInit)
        }
        return null
    }

    function isAbstract(cl:ASTClass):Bit {
        if cl.isInterface 
            return true
        def annotations := cl.annotations
        if annotations != null {
            for a in annotations {
                if a-?>(ASTSimpleAnnotation) & 
                        a->(ASTSimpleAnnotation).name = "abstract"
                    return true
            }
        }
        return false
    }

    method convertClass(cl:ASTClass, currentPackage:String?,
            parentSymbolTable:SymbolTable, rawPackageUses:ListView<String>,
            classAliases:HashMap<String, String>):ClassStub {
        def packageUses := new Array<String>(rawPackageUses)
        def symbolTable := new SymbolTable(parentSymbolTable)
        def className:String
        if currentPackage != null {
            className := currentPackage + "." + cl.name
            usePackage(currentPackage, symbolTable, packageUses, cl.position)
        }
        else {
            className := cl.name
            usePackage("", symbolTable, packageUses, cl.position)
        }
        def classType := resolveType(new ASTClassType(cl.position, className, 
                null, false), symbolTable)->(ClassType)
        if cl.genericParameters != null {
            for p in cl.genericParameters->(ListView<ASTTypedIdentifier>) {
                def bound:Type
                if p.type != null {
                    def resolved := resolveType(p.type->(ASTType), 
                            symbolTable)
                    if resolved != null
                        bound := resolved
                    else
                        bound := NullableType.ANY
                }
                else
                    bound := NullableType.ANY
                def type := new GenericParameterType("\{className}.\{p.identifier}", 
                        bound)
                symbolTable[type.name] := new TypeSymbol(type)
                aliasType(p.identifier, type, symbolTable, classAliases)
            }
        }
        def interfaces := new Array<ClassType>()
        var superclass:Type?
        if cl.superclass != null {
            superclass := resolveType(cl.superclass->(ASTType), symbolTable)
            if superclass != null & superclass-!>(ClassType) {
                errors.error("cannot subclass \{superclass.displayName}", 
                        cl.position)
                superclass := null
            }
        }
        else {
            if className = class(Object).name
                superclass := null
            else
                superclass := ClassType.OBJECT
        }
        if cl.interfaces != null {
            for t in cl.interfaces->(ListView<ASTType>) {
                def type := resolveType(t, symbolTable)
                if type-?>(ClassType)
                    interfaces.add(type->(ClassType))
                else if type != null {
                    errors.error("\{type.displayName} is not an interface",
                            cl.position)
                }
            }
        }
        def symbols := new SymbolTable()
        var foundConstructor := false
        for m in cl.methods {
            def converted := convertMethod(cl.isExternal, m, classType, 
                    symbolTable)
            if converted != null {
                checkMethodSignature(converted)
                addSymbol(converted, symbols, errors)
                foundConstructor |= converted.methodType = 
                        MethodNodeType.CONSTRUCTOR
            }
        }
        if !cl.isInterface & !foundConstructor {
            -- create implicit no-arg constructor
            def statements := new Array<ASTStatement>()
            def superConstructor := new ASTDotExpression(
                    new ASTSuper(cl.position), MethodNode.CONSTRUCTOR_NAME)
            statements.add(new ASTExpressionStatement(new ASTCallExpression(
                    superConstructor, new Array<ASTExpression>())))
            def block := new ASTBlock(cl.position, statements)
            def c := new MethodStub(cl.position, 
                    MethodNode.CONSTRUCTOR_NAME, 
                    new Annotations(cl.position), 
                    MethodNodeType.CONSTRUCTOR, 
                    new Array<FormalParameter>(), VoidType.VOID, block, 
                    classType)
            addSymbol(c, symbols, errors)
        }
        for decl in cl.fields
            convertFields(decl, classType, symbolTable, symbols)
        var annotations := convertAnnotations(cl.position, cl.annotations)
        if cl.genericParameters != null
            annotations += AnnotationType.UNSPECIFIED
        if cl.isExternal
            annotations += AnnotationType.EXTERNAL
        else {
            def init := createClassInit(cl.position, classType, symbols)
            if init != null {
                symbols.remove(MethodNode.CLASS_INIT_NAME)
                symbols.remove(FieldNode.CLASS_INITED_NAME)
                addSymbol(init[0], init[0].position, symbols, errors)
                addSymbol(init[1], symbols, errors)
            }
        }
        return new ClassStub(cl.position, classType, 
                cl.isInterface, annotations, superclass->(ClassType?), 
                interfaces, new OrderedMap<String, Symbol>(symbols), 
                new LookupContext(packageUses, classAliases), cl.invariants, 
                cl.genericParameters, cl.isExternal, null)
    }

    method convertEnum(e:ASTEnum, currentPackage:String?,
            symbolTable:SymbolTable):ClassStub {
        def className:String
        if currentPackage != null
            className := currentPackage + "." + e.name
        else
            className := e.name
        def classType := resolveType(new ASTClassType(e.position, className, 
                null, false), symbolTable)->(ClassType)
        def symbols := new SymbolTable(masterSymbolTable)
        def fieldAnnotations := new Array<AnnotationType>()
        fieldAnnotations.add(AnnotationType.CLASS)
        for v in e.values {
            def initialValue := new ASTNew(v.position, 
                    new ASTClassType(e.position, className, null, false),
                    new Array<ASTExpression>())
            symbols[v.name] := new FieldNode(v.position, classType, v.name, 
                    new Annotations(v.position, fieldAnnotations), 
                    VariableType.DEF, classType, initialValue, null)
        }
        if !e.isExternal {
            def init := createClassInit(e.position, classType, symbols)
            if init != null {
                addSymbol(init[0], init[0].position, symbols, errors)
                addSymbol(init[1], symbols, errors)
            }
        }
        
        -- create implicit no-arg constructor
        var statements := new Array<ASTStatement>()
        def superConstructor := new ASTDotExpression(
                new ASTSuper(e.position), MethodNode.CONSTRUCTOR_NAME)
        statements.add(new ASTExpressionStatement(new ASTCallExpression(
                superConstructor, new Array<ASTExpression>())))
        var block := new ASTBlock(e.position, statements)
        def constructorAnnotations := new Array<AnnotationType>()
        constructorAnnotations.add(AnnotationType.PRIVATE)
        def c := new MethodStub(e.position, MethodNode.CONSTRUCTOR_NAME, 
                new Annotations(e.position, constructorAnnotations), 
                MethodNodeType.CONSTRUCTOR, new Array<FormalParameter>(), 
                VoidType.VOID, block, classType)
        addSymbol(c, symbols, errors)

        -- create convert to integer
        statements := new Array<ASTStatement>()
        var cases := new Array<ASTSwitchCase>()
        for i, v in e.values {
            def caseValues := new Array<ASTExpression>()
            caseValues.add(new ASTIdentifier(e.position, v.name))
            cases.add(new ASTSwitchCase(e.position, caseValues, new ASTReturn(e.position,
                    new ASTIntegerLiteral(e.position, i->(UInt64)))))
        }
        statements.add(new ASTSwitch(e.position, new ASTSelf(e.position), cases,
                new ASTUnreachable(e.position)))
        block := new ASTBlock(e.position, statements)
        def convertToInt := new MethodStub(e.position, 
                MethodNode.CONVERT_NAME, 
                new Annotations(e.position, new Array<AnnotationType>()), 
                MethodNodeType.FUNCTION, new Array<FormalParameter>(), 
                IntType.INT32, block, classType)
        addSymbol(convertToInt, symbols, errors)

        -- create convert to string
        statements := new Array<ASTStatement>()
        cases := new Array<ASTSwitchCase>()
        for i, v in e.values {
            def caseValues := new Array<ASTExpression>()
            caseValues.add(new ASTIdentifier(e.position, v.name))
            cases.add(new ASTSwitchCase(e.position, caseValues, new ASTReturn(e.position,
                    new ASTStringLiteral(e.position, v.name))))
        }
        statements.add(new ASTSwitch(e.position, new ASTSelf(e.position), cases,
                new ASTUnreachable(e.position)))
        block := new ASTBlock(e.position, statements)
        def convertToString := new MethodStub(e.position, 
                MethodNode.CONVERT_NAME, 
                new Annotations(e.position, new Array<AnnotationType>()), 
                MethodNodeType.FUNCTION, new Array<FormalParameter>(), 
                ClassType.STRING, block, classType)
        addSymbol(convertToString, symbols, errors)

        -- create convert from integer
        statements := new Array<ASTStatement>()
        cases := new Array<ASTSwitchCase>()
        for i, v in e.values {
            def caseValues := new Array<ASTExpression>()
            caseValues.add(new ASTIntegerLiteral(e.position, i->(UInt64)))
            cases.add(new ASTSwitchCase(e.position, caseValues, new ASTReturn(e.position,
                    new ASTIdentifier(e.position, v.name))))
        }
        statements.add(new ASTSwitch(e.position, new ASTIdentifier(e.position, "value"), cases,
                new ASTUnreachable(e.position)))
        block := new ASTBlock(e.position, statements)
        def cvtAnnotations := new Array<AnnotationType>()
        cvtAnnotations.add(AnnotationType.CLASS)
        def convertParameters := new Array<FormalParameter>()
        convertParameters.add(new FormalParameter(e.position, "value", 
                IntType.INT32, false, false, false))
        def convertFromInt := new MethodStub(e.position, 
                MethodNode.CONVERT_NAME, 
                new Annotations(e.position, cvtAnnotations), 
                MethodNodeType.FUNCTION, convertParameters, 
                classType, block, classType)
        addSymbol(convertFromInt, symbols, errors)

        def annotations := convertAnnotations(e.position, e.annotations)
        return new ClassStub(e.position, classType, 
                false, annotations, ClassType.ENUMERATION, 
                new Array<ClassType>(), new OrderedMap<String, Symbol>(symbols),
                new LookupContext(), new Array<ASTInvariant>(), null, 
                e.isExternal, null)
    }

    @class
    method addSymbol(m:MethodStub, map:Map<String, Symbol>, 
            errors:ErrorReporter) {
        def methods := map[m.name]
        if methods = null {
            def list := new Array<MethodStub>()
            list.add(m)
            map[m.name] := new Methods(list)
        }
        else if methods-?>(Methods)
            map[m.name] := methods->(Methods) + m
        else {
            errors.error("invalid redefinition of symbol '\{m.name}'",
                    m.position)
        }
    }

    @class
    method addSymbol(s:Symbol, position:Position, map:Map<String, Symbol>, 
            errors:ErrorReporter) {
        if map[s.name] != null {
            errors.error("invalid redefinition of symbol '\{s.name}'",
                    position)
        }
        else
            map[s.name] := s
    }

    method getPackage(name:String, position:Position):MutablePackage? {
        var current := root
        if name.length > 0 {
            for component in name.split(".") {
                def s := current[component]
                if s-?>(MutablePackage)
                    current := s->(MutablePackage)
                else {
                    errors.error("no package named '\{name}'", position)
                    return null
                }
            }
        }
        return current
    }

    method usePackage(name:String, symbolTable:SymbolTable, position:Position) {
        def p := getPackage(name, position)
        if p != null {
            for s in p.symbols.values {
                if s-?>(TypeSymbol) {
                    var cl := s.name
                    def dot := cl.lastIndexOf(".")
                    if dot != null
                        cl := cl[dot + 1..]
                    symbolTable[cl] := s
                }
            }
        }
        else
            errors.error("no package named '\{name}'", position)
    }

    method usePackage(name:String, symbolTable:SymbolTable, 
            packageUses:List<String>, position:Position) {
        packageUses.add(name)
        usePackage(name, symbolTable, position)
    }

    method aliasType(alias:String, type:Type, symbolTable:SymbolTable) {
        symbolTable[alias] := new TypeSymbol(type)
    }

    method aliasType(alias:String, type:Type?, symbolTable:SymbolTable,
            classAliases:Map<String, String>) {
        if type != null {
            classAliases[alias] := type.name
            aliasType(alias, type, symbolTable)
        }
    }

    function getSymbolTable(lookupContext:LookupContext):SymbolTable {
        def symbolTable := new SymbolTable(masterSymbolTable)
        for p in lookupContext.packageUses
            usePackage(p, symbolTable, Position.INTERNAL)
        for (alias, type) in lookupContext.classAliases {
            aliasType(alias, resolveType(new ASTClassType(Position.INTERNAL, 
                    type, null, false), symbolTable), symbolTable)
        }
        return symbolTable
    }

    @class
    function getPackage(name:String):String? {
        def index := name.lastIndexOf(".")
        if index = null
            return null
        return name[0 .. index]
    }
 
    method getStub(name:String):ClassStub? {
        var result := stubs[name]
        if result = null {
            def classLookup := astClasses[name]
            if classLookup != null {
                def cl, context := classLookup
                def symbolTable := getSymbolTable(context.lookupContext)
                result := convertClass(cl, getPackage(name), symbolTable,
                        context.lookupContext.packageUses, 
                        new HashMap<String, String>(
                                context.lookupContext.classAliases))
                stubs[name] := result
            }
            else {
                def enumLookup := astEnums[name]
                if enumLookup != null {
                    def cl, context := enumLookup
                    def symbolTable := getSymbolTable(context.lookupContext)
                    result := convertEnum(cl, getPackage(name), symbolTable)
                    stubs[name] := result
                }
            }
        }
        return result
    }

    method getRootPackage():Package {
        return root->>(Package)
    }
}