-*package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class HeaderCodeGenerator (CodeGenerator) {
    constant HEADER := "// This file was automatically generated by the " +
                "Panda compiler"

    def program:Program

    def compilerSettings:CompilerSettings

    def methodNamer:MethodNamer

    def context:Context

    constructor(program:Program, compilerSettings:CompilerSettings) {
        self.program := program
        self.compilerSettings := compilerSettings
        def errors := new FatalErrorReporter()
        self.context := new Context(program.typeResolver, program.stubs, errors, 
                compilerSettings)
        self.methodNamer := new MethodNamer(context, 
                new CMethodNamingStrategy())
    }

    @override
    function defaultExtension():String {
        return ".h"
    }
    
    method getName(cl:ClassStub):String {
        return getName(cl.type())
    }

    function getName(f:FieldNode):String {
        if f.name = FieldNode.ELEMENTS_NAME
            return "contents"
        return f.name
    }
    
    function getName(m:MethodNode):String {
        return methodNamer.getName(m)
    }
    
    @private
    function getLLVMName(t:Type):String {
        switch t {
            case IntType.INT8,  IntType.UINT8:  return "i8"
            case IntType.INT16, IntType.UINT16: return "i16"
            case IntType.INT32, IntType.UINT32: return "i32"
            case IntType.INT64, IntType.UINT64: return "i64"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case CharType.CHAR:   return "char"
            case BitType.BIT:     return "i1"
            case VoidType.VOID:   return "void"
            default:              return "<unknown:"+ t + ">"
        }
    }
    
    function getName(t:Type):String {
        if t.isNullable
            return getName(t.unwrapNullable)
        if t.isPrimitiveArray {
            var e := t.elementType
            var suffix:String
            if t.isImmutable
                suffix := "$ImmutableArray"
            else
                suffix := "$Array"
            if e.isNullable
                return getName(e) + "$Z" + suffix
            else
                return getName(e) + suffix
        }
        if t.isMethod {
            return "void*" -- FIXME implement this
        }
        if t = NativePointerType.NATIVE_POINTER
            return "void*"
        if t = VoidType.VOID
            return "void"
        if t.isPrimitive {
            assert t.name.startsWith(ClassNode.CORE)
            return t.name[ClassNode.CORE.length..]
        }
        return MethodNamer.escapeTypeName(t.name)
    }
    
    function getCType(t:Type):String {
        var name := getName(t)
        if !t.isPrimitive & t != VoidType.VOID
            name += "*"
        return name
    }

    method writeFields(cl:ClassNode, out:OutputStream) {
        var superclass := cl.superclass
        if superclass != null
            writeFields(superclass, out)
        for i in 0 ... cl.length - 1 {
            if cl[i]-?>(FieldNode) {
                var f := cl[i]->(FieldNode)
                if !f.annotations.isClass {
                    out.write("    " + getCType(f.type))
                    if f.name = FieldNode.ELEMENTS_NAME
                        out.write("*")
                    out.writeLine(" " + getName(f) + ";")
                }
            }
        }
    }
    
    method writeMethods(cl:ClassNode, out:OutputStream) {
        var methods := cl.virtualMethods
        for i, m in methods {
            if m.parent = cl {
                def name := getName(m)
                out.writeLine("#define " + name + "_INDEX " + i)
                out.write("typedef ")
                out.write(getCType(m.returnType))
                out.write("(" + name + "_TYPE)")
                out.write("(")
                for j in 0 ... m.parameters.length - 1 {
                    if j > 0
                        out.write(", ")
                    out.write(getCType(m.parameters[j].type))
                }
                out.writeLine(");")
            }
        }

        for m in cl.methods {
            if m.annotations.isExternal | 
                    m.annotations.isClass |
                    m.methodType = MethodNodeType.CONSTRUCTOR {
                out.write(getCType(m.returnType))
                out.write(" " + getName(m) + "(")
                for i, p in m.parameters {
                    if i > 0
                        out.write(", ")
                    out.write(getCType(p.type))
                }
                out.writeLine(");")
            }
        }
    }

    method generateStruct(cl:ClassNode, out:OutputStream) {
        out.writeLine("struct " + getName(cl) + " {")
        writeFields(cl, out)
        if cl.name = ClassNode.PRIMITIVE_ARRAY_NAME {
            out.writeLine("    Int32 $length;")
            out.writeLine("    Int32 $maxLength;")
            out.writeLine("    void* contents;")
        }
        if cl.name = ClassNode.CLASS_NAME {
            out.writeLine("    struct itable* itables;")
            out.writeLine("    void** vtable;")
        }
        out.writeLine("};")
    }

    method generateHeader(cl:ClassNode, dest:File) {
        var out := new BufferedOutputStream(dest.openOutputStream())
        out.writeLine(HEADER)
        out.writeLine("#ifndef " + getName(cl) + "_H")
        out.writeLine("#define " + getName(cl) + "_H")
        generateStruct(cl, out)
        out.writeLine()
        out.writeLine("extern panda$core$Class " + 
                getName(cl) + "_class;")
        writeMethods(cl, out)
        for child in cl.children {
            if child-?>(FieldNode) {
                def f := child->(FieldNode)
                if f.annotations.isClass {
                    def t := f.parent->(ClassNode).type()
                    out.writeLine("extern " + getCType(f.type) + " class_" + 
                            getName(t) + "$" + getName(f) + ";")
                }
            }
        }
        out.writeLine("#endif")
        out.close()
    }
    
    @override
    method generateCode(target:File) {
        MethodNamer.nameMethods(new CMethodNamingStrategy())
        def out := new BufferedOutputStream(target.openOutputStream())
        out.writeLine(HEADER)
        if target.name = "panda.h"
            out.writeLine('#include "panda_base.h"')
        for cl in program.classes {
            if cl.state = ClassNodeState.DEFINED & !cl.annotations.isUnspecified {
                out.writeLine("#ifndef " + getName(cl) + "_TYPEDEF")
                out.writeLine("#define " +  getName(cl) + "_TYPEDEF")
                out.writeLine("typedef struct " + getName(cl) + " " + 
                        getName(cl) + ";")
                out.writeLine("#endif")
            }
        }
        var parent := target.parent()
        if parent = null {
            throw new CompilerException("could not determine parent of " + 
                    target)
        }
        for cl in classes {
            if cl.state = ClassNodeState.DEFINED & !cl.annotations.isUnspecified {
                out.writeLine('#include "' + getName(cl) + '.h"')
                var dest := parent.resolve(getName(cl) + ".h")
                generateHeader(cl, dest)
            }
        }
        out.close()
    }
}*-