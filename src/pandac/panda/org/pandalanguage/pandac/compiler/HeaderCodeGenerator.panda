package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class HeaderCodeGenerator (CodeGenerator) {
    constant HEADER := "// This file was automatically generated by the " +
                "Panda compiler"
    @override
    function defaultExtension():String {
        return ".h"
    }
    
    method getName(cl:ClassNode):String {
        return getName(cl.type())
    }

    function getName(f:FieldNode):String {
        if f.name = FieldNode.ELEMENTS_NAME
            return "contents"
        return f.name
    }
    
    function getName(m:MethodNode):String {
        return LLVMCodeGenerator.getName(m)
    }
    
    @private
    function getLLVMName(t:Type):String {
        switch t {
            case IntType.INT8,  IntType.UINT8:  return "i8"
            case IntType.INT16, IntType.UINT16: return "i16"
            case IntType.INT32, IntType.UINT32: return "i32"
            case IntType.INT64, IntType.UINT64: return "i64"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case CharType.CHAR:   return "char"
            case BitType.BIT:     return "i1"
            case VoidType.VOID:   return "void"
            default:              return "<unknown:"+ t + ">"
        }
    }
    
    function getName(t:Type):String {
        if t.isNullable
            return getName(t->(NullableType).nonNullableVersion)
        if t.isArray {
            var e := t.elementType
            var suffix:String
            if t.isImmutable
                suffix := "$ImmutableArray"
            else
                suffix := "$Array"
            if e.isNullable
                return getName(e) + "$Z" + suffix
            else
                return getName(e) + suffix
        }
        if t.isMethod {
            return "void*" -- FIXME implement this
        }
        if t = NativePointerType.NATIVE_POINTER
            return "void*"
        if t = VoidType.VOID
            return "void"
        if t.isPrimitive {
            assert t.name.startsWith(ClassNode.CORE)
            return t.name[ClassNode.CORE.length..]
        }
        return MethodNamer.escapeTypeName(t.name)
    }
    
    function getCType(t:Type):String {
        var name := getName(t)
        if !t.isPrimitive & t != VoidType.VOID
            name += "*"
        return name
    }

    method writeFields(cl:ClassNode, out:OutputStream) {
        var superclass := cl.superclass
        if superclass != null
            writeFields(superclass, out)
        for i in 0 ... cl.length - 1 {
            if cl[i]-?>(FieldNode) {
                var f := cl[i]->(FieldNode)
                if !f.annotations.isClass {
                    out.write("    " + getCType(f.type))
                    if f.name = FieldNode.ELEMENTS_NAME
                        out.write("*")
                    out.writeLine(" " + getName(f) + ";")
                }
            }
        }
    }
    
    method writeMethods(cl:ClassNode, out:OutputStream) {
        var methods := cl.virtualMethods
        for i in 0 ... methods.length - 1 {
            var m := methods[i]

            if m.parent = cl {
                var name := getName(m)
                out.writeLine("#define " + name + "_INDEX " + i)
                out.write("typedef ")
                out.write(getCType(m.returnType))
                out.write("(" + name + "_TYPE)")
                out.write("(")
                for j in 0 ... m.parameters.length - 1 {
                    if j > 0
                        out.write(", ")
                    out.write(getCType(m.parameters[j].type))
                }
                out.writeLine(");")
            }
        }

        for i in 0 ... cl.length - 1 {
            if cl[i]-?>(MethodNode) {
                var m := cl[i]->(MethodNode)
                if m.annotations.isExternal | 
                        m.annotations.isClass |
                        m.methodType = MethodNodeType.CONSTRUCTOR {
                    out.write(getCType(m.returnType))
                    out.write(" " + getName(m) + "(")
                    for j in 0 ... m.parameters.length - 1 {
                        if j > 0
                            out.write(", ")
                        out.write(getCType(m.parameters[j].type))
                    }
                    out.writeLine(");")
                }
            }
        }
    }

    method generateStruct(cl:ClassNode, out:OutputStream) {
        out.writeLine("struct " + getName(cl) + " {")
        writeFields(cl, out)
        if cl.name = ClassNode.ARRAY_NAME {
            out.writeLine("    Int32 $length;")
            out.writeLine("    Int32 $maxLength;")
            out.writeLine("    void* contents;")
        }
        if cl.name = ClassNode.CLASS_NAME {
            out.writeLine("    struct itable* itables;")
            out.writeLine("    void** vtable;")
        }
        out.writeLine("};")
    }

    method generateHeader(cl:ClassNode, dest:File) {
        var out := new BufferedOutputStream(dest.openOutputStream())
        out.writeLine(HEADER)
        out.writeLine("#ifndef " + getName(cl) + "_H")
        out.writeLine("#define " + getName(cl) + "_H")
        generateStruct(cl, out)
        out.writeLine()
        out.writeLine("extern panda$core$Class " + 
                getName(cl) + "_class;")
        writeMethods(cl, out)
        for i in 0 ... cl.length - 1 {
            if cl[i]-?>(FieldNode) {
                var f := cl[i]->(FieldNode)
                if f.annotations.isClass {
                    var t := f.parent->(ClassNode).type()
                    out.writeLine("extern " + getCType(f.type) + " class_" + 
                            getName(t) + "$" + getName(f) + ";")
                }
            }
        }
        out.writeLine("#endif")
        out.close()
    }
    
    @override
    method generateCode(target:File) {
        MethodNamer.nameMethods(new CMethodNamingStrategy())
        var out := new BufferedOutputStream(target.openOutputStream())
        out.writeLine(HEADER)
        if target.name = "panda.h"
            out.writeLine('#include "panda_base.h"')
        var classes := SymbolTable.master.classes
        for i in 0 ... classes.length - 1 {
            var cl := classes[i]
            if cl.state = ClassNodeState.DEFINED {
                out.writeLine("#ifndef " + getName(cl) + "_TYPEDEF")
                out.writeLine("#define " +  getName(cl) + "_TYPEDEF")
                out.writeLine("typedef struct " + getName(cl) + " " + 
                        getName(cl) + ";")
                out.writeLine("#endif")
            }
        }
        var parent := target.parent()
        if parent = null {
            throw new CompilerException("could not determine parent of " + 
                    target)
        }
        for i in 0 ... classes.length - 1 {
            var cl := classes[i]
            if cl.state = ClassNodeState.DEFINED {
                out.writeLine('#include "' + getName(cl) + '.h"')
                var dest := parent.resolve(getName(cl) + ".h")
                generateHeader(cl, dest)
            }
        }
        out.close()
    }
}