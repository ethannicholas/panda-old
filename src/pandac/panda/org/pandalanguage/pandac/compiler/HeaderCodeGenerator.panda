package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class HeaderCodeGenerator (CodeGenerator) {
    constant HEADER := "// This file was automatically generated by the " +
                "Panda compiler"

    def program:Program

    def compilerSettings:CompilerSettings

    def methodNamer:MethodNamer

    def context:Context

    init(p:Program, compilerSettings:CompilerSettings) {
        self.program := p
        self.compilerSettings := compilerSettings
        def errors := FatalErrorReporter()
        self.context := IRGenerator(p.root, p.stubs, p.stubGenerator, 
                compilerSettings, errors).context
        self.methodNamer := MethodNamer(context, 
                CMethodNamingStrategy())
    }

    @override
    function defaultExtension():String? {
        return ".h"
    }
    
    method getName(cl:ClassStub):String {
        return getName(cl.type)
    }

    function getName(f:FieldNode):String {
        if f.name = FieldNode.ELEMENTS_NAME
            return "contents"
        return f.name
    }
    
    method getName(m:MethodStub):String {
        return methodNamer.getName(m)
    }
    
    @private
    function getLLVMName(t:Type):String {
        switch t {
            case IntType.INT8,  IntType.UINT8:  return "i8"
            case IntType.INT16, IntType.UINT16: return "i16"
            case IntType.INT32, IntType.UINT32: return "i32"
            case IntType.INT64, IntType.UINT64: return "i64"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case CharType.CHAR:   return "char"
            case BitType.BIT:     return "i1"
            case VoidType.VOID:   return "void"
            default:              return "<unknown:"+ t + ">"
        }
    }
    
    method getName(raw:Type):String {
        def t := raw.unwrapUnspecializedGenerics(context)
        if t.isNullable
            return getName(t.unwrapNullable)
        if t.isMethod {
            return "void*" -- FIXME implement this
        }
        if t = NativePointerType.NATIVE_POINTER
            return "void*"
        if t = VoidType.VOID
            return "void"
        if t.isPrimitive {
            constant CORE := "panda.core."
            assert t.name.startsWith(CORE)
            return t.name[CORE.length..]
        }
        if t-?>GenericParameterType
            return getName(t->GenericParameterType.bound)
        return MethodNamer.escapeTypeName(
                context.getStub(t.convert()->ClassType).name)
    }
    
    method getCType(t:Type):String {
        var name := getName(t)
        if !t.isPrimitive & t != VoidType.VOID & 
                t != NativePointerType.NATIVE_POINTER
            name += "*"
        return name
    }

    method writeFields(cl:ClassStub, out:OutputStream) {
        def superclass := cl.superclass
        if superclass != null
            writeFields(context.getStub(superclass), out)
        for f in cl.fields {
            if !f.annotations.isClass & !f.annotations.isThread & 
                    f.kind != Variable.Kind.PROPERTY {
                out.write("    " + getCType(f.type))
                if f.name = FieldNode.ELEMENTS_NAME
                    out.write("*")
                out.writeLine(" " + getName(f) + ";")
            }
        }
    }
    
    method writeMethods(cl:ClassStub, out:OutputStream) {
        def methods := Array<MethodStub>()
        for m in cl.type.virtualMethods(context)
            methods.add(m.stub)
        for (i, m) in methods.enumeration {
            if m.owner = cl.type {
                def name := getName(m)
                out.writeLine("#define " + name + "_INDEX " + i)
                out.write("typedef ")
                out.write(getCType(m.returnType))
                out.write("(" + name + "_TYPE)")
                out.write("(")
                var first := true
                if !m.annotations.isClass {
                    if m.annotations.isWrapperMethod
                        out.write("\{getCType(m.owner.convert()->PrimitiveType)} self")
                    else
                        out.write("\{getCType(m.owner)} self")
                    first := false
                }
                for (j, p) in m.parameters.enumeration {
                    if first
                        first := false
                    else
                        out.write(", ")
                    out.write(getCType(p.type))
                }
                out.writeLine(");")
            }
        }

        for entry in cl.methods {
            def m := entry.stub
            if !methods.contains(m) | m.annotations.isExternal {
                out.write(getCType(m.returnType))
                out.write(" " + getName(m) + "(")
                var first := true
                if !m.annotations.isClass {
                    if m.annotations.isWrapperMethod
                        out.write("\{getCType(m.owner.convert()->PrimitiveType)} self")
                    else
                        out.write("\{getCType(m.owner)} self")
                    first := false
                }
                for (i, p) in m.parameters.enumeration {
                    if first
                        first := false
                    else
                        out.write(", ")
                    out.write(getCType(p.type))
                }
                out.writeLine(");")
            }
        }
    }

    method generateStruct(cl:ClassStub, out:OutputStream) {
        out.writeLine("struct " + getName(cl) + " {")
        writeFields(cl, out)
        if cl.name = PrimitiveArray.name {
            out.writeLine("    Int32 $length;")
            out.writeLine("    Int32 $maxLength;")
            out.writeLine("    void* contents;")
        }
        if cl.name = Class.name {
            out.writeLine("    struct itable* itables;")
            out.writeLine("    void** vtable;")
        }
        out.writeLine("};")
    }

    method generateHeader(cl:ClassStub, dest:File) {
        var out := BufferedOutputStream(dest.openOutputStream())
        out.writeLine(HEADER)
        out.writeLine("#ifndef " + getName(cl) + "_H")
        out.writeLine("#define " + getName(cl) + "_H")
        generateStruct(cl, out)
        out.writeLine()
        out.writeLine("extern panda$core$Class " + 
                getName(cl) + "_class;")
        writeMethods(cl, out)
        for f in cl.fields {
            if f.annotations.isClass | f.annotations.isThread {
                def t := f.owner
                out.writeLine("extern " + getCType(f.type) + " class_" + 
                        getName(t) + "$" + getName(f) + ";")
            }
        }
        out.writeLine("#endif")
        out.close()
    }
    
    @override
    method generateCode(target:File) {
        def out := BufferedOutputStream(target.openOutputStream())
        out.writeLine(HEADER)
        if target.name = "panda.h"
            out.writeLine('#include "panda_base.h"')
        for cl in program.stubs.values {
            if !cl.isExternal & !cl.annotations.isUnspecified {
                out.writeLine("#ifndef " + getName(cl) + "_TYPEDEF")
                out.writeLine("#define " +  getName(cl) + "_TYPEDEF")
                out.writeLine("typedef struct " + getName(cl) + " " + 
                        getName(cl) + ";")
                out.writeLine("#endif")
            }
        }
        var parent := target.parent()
        if parent = null {
            throw CompilerException("could not determine parent of " + 
                    target)
        }
        for cl in program.stubs.values {
            if !cl.isExternal & !cl.annotations.isUnspecified {
                out.writeLine('#include "' + getName(cl) + '.h"')
                var dest := parent.resolve(getName(cl) + ".h")
                generateHeader(cl, dest)
            }
        }
        out.close()
    }
}