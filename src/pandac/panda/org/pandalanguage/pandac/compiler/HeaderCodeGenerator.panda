package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class HeaderCodeGenerator (CodeGenerator) {
    constant HEADER := "// This file was automatically generated by the " +
                "Panda compiler"

    constant KEYWORDS := HashSet<String>(["auto", "case", "char", "const",
            "double", "enum", "extern", "float", "goto", "int", "long",
            "register", "short", "signed", "sizeof", "static", "struct",
            "switch", "typedef", "union", "unsigned", "void", "volatile"])

    def program:Program

    def compilerSettings:CompilerSettings

    def methodNamer:MethodNamer

    def context:Context

    init(p:Program, compilerSettings:CompilerSettings) {
        self.program := p
        self.compilerSettings := compilerSettings
        def errors := FatalErrorReporter()
        self.context := IRGenerator(p.root, p.stubs, p.stubGenerator, 
                compilerSettings, errors).context
        self.methodNamer := MethodNamer(context, 
                CMethodNamingStrategy())
    }

    @override
    function defaultExtension():String? {
        return ".h"
    }
    
    method getName(cl:ClassStub):String {
        return getName(cl.type)
    }

    function getName(f:FieldNode):String {
        if f.name = FieldNode.ELEMENTS_NAME {
            return "contents"
        }
        if KEYWORDS.contains(f.name) {
            return "$" + f.name
        }
        return f.name
    }
    
    method getName(m:MethodStub):String {
        return methodNamer.getName(m)
    }
    
    method getName(raw:Type):String {
        def t := raw.unwrapUnspecializedGenerics(context)
        if t.isNullable {
            return getName(t.unwrapNullable)
        }
        if t.isMethod {
            return "void*" -- FIXME implement this
        }
        if t = NativePointerType.NATIVE_POINTER {
            return "void*"
        }
        if t = VoidType.VOID {
            return "void"
        }
        if t.isPrimitive {
            constant CORE := "panda.core."
            assert t.name.startsWith(CORE)
            return t.name[CORE.length..]
        }
        if t-?>GenericParameterType {
            return getName(t->GenericParameterType.bound)
        }
        return MethodNamer.escapeTypeName(
                context.getStub(t.convert()->ClassType).name)
    }
    
    method getCType(t:Type):String {
        var name := getName(t)
        if !t.isPrimitive & t != VoidType.VOID & 
                t != NativePointerType.NATIVE_POINTER {
            name += "*"
        }
        return name
    }

    method writeFields(cl:ClassStub, out:OutputStream) {
        def superclass := cl.superclass
        if superclass != null {
            writeFields(context.getStub(superclass), out)
        }
        for f in cl.fields {
            if !f.annotations.isClass & !f.annotations.isThread & 
                    f.kind != Variable.Kind.PROPERTY {
                out.write("    " + getCType(f.type))
                if f.name = FieldNode.ELEMENTS_NAME {
                    out.write("*")
                }
                out.writeLine(" " + getName(f) + ";")
            }
        }
    }
    
    method writeMethods(cl:ClassStub, out:OutputStream) {
        def methods := Array<MethodStub>()
        for m in cl.type.virtualMethods(context.stubGenerator) {
            methods.add(m)
        }
        var classType := cl.type
        while classType-?>GenericType {
            classType := classType->GenericType.base
        }
        for (i, raw) in methods.enumeration {
            def m:MethodStub
            if raw.base != null {
                m := raw.base
            }
            else {
                m := raw
            }
            var owner := m.owner
            while owner-?>GenericType {
                owner := owner->GenericType.base
            }
            if owner = classType {
                def name := getName(m)
                out.writeLine("#define " + name + "_INDEX " + i)
                out.write("typedef ")
                out.write(getCType(m.returnType))
                out.write("(" + name + "_TYPE)")
                out.write("(")
                var first := true
                if !m.annotations.isClass {
                    if m.annotations.isWrapperMethod {
                        out.write("\{getCType(m.owner.convert()->PrimitiveType)} self")
                    }
                    else {
                        out.write("\{getCType(m.owner)} self")
                    }
                    first := false
                }
                for (j, p) in m.parameters.enumeration {
                    if first {
                        first := false
                    }
                    else {
                        out.write(", ")
                    }
                    out.write(getCType(p.type))
                }
                out.writeLine(");")
            }
        }

        for entry in cl.methods {
            def m := entry
            if !program.isEffectivelyVirtual(m) | m.annotations.isExternal {
                out.write(getCType(m.returnType))
                out.write(" " + getName(m) + "(")
                var first := true
                if !m.annotations.isClass {
                    if m.annotations.isWrapperMethod {
                        out.write("\{getCType(m.owner.convert()->PrimitiveType)} self")
                    }
                    else {
                        out.write("\{getCType(m.owner)} self")
                    }
                    first := false
                }
                for (i, p) in m.parameters.enumeration {
                    if first {
                        first := false
                    }
                    else {
                        out.write(", ")
                    }
                    out.write(getCType(p.type))
                }
                out.writeLine(");")

                if m.kind = MethodStub.Kind.INIT {
                    out.write(getCType(cl.type))
                    out.write(" new_\{getName(m)}(")
                    first := true
                    for (i, p) in m.parameters.enumeration {
                        if first {
                            first := false
                        }
                        else {
                            out.write(", ")
                        }
                        out.write(getCType(p.type))
                    }
                    out.writeLine(");")
                }
            }
        }
    }

    method generateStruct(cl:ClassStub, out:OutputStream) {
        out.writeLine("struct \{getName(cl)} {")
        writeFields(cl, out)
        if cl.name = PrimitiveArray.name {
            out.writeLine("    Int64 $length;")
            out.writeLine("    void* contents;")
        }
        if cl.name = Class.name {
            out.writeLine("    struct itable* itables;")
            out.writeLine("    void* vtable[];")
        }
        out.writeLine("};")
    }

    method generateClass(cl:ClassStub, externalFields:Bit, out:OutputStream) {
        out.writeLine("#ifndef CLASS_\{getName(cl)}")
        out.writeLine("#define CLASS_\{getName(cl)}")
        generateStruct(cl, out)
        out.writeLine()
        writeMethods(cl, out)
        if !externalFields {
            out.writeLine("#endif")
        }
        for f in cl.fields {
            if f.annotations.isClass | f.annotations.isThread {
                def t := f.owner
                if externalFields {
                    out.write("extern ")
                }
                out.writeLine(getCType(f.type) + " class_" + 
                        getName(t) + "$" + getName(f) + ";")
            }
        }
        if externalFields {
            out.writeLine("#endif")
        }
    }

    method generateHeader(cl:ClassStub, dest:File) {
        var out := BufferedOutputStream(dest.openOutputStream())
        out.writeLine(HEADER)
        out.writeLine("#ifndef " + getName(cl) + "_H")
        out.writeLine("#define " + getName(cl) + "_H")
        out.writeLine("extern panda$core$Class " + 
                getName(cl) + "_class;")
        generateClass(cl, true, out)
        out.writeLine("#endif")
        out.close()
    }
    
    @override
    method generateCode(target:File) {
        def out := BufferedOutputStream(target.openOutputStream())
        out.writeLine(HEADER)
        if target.name = "panda.h" {
            out.writeLine('#include "panda_base.h"')
        }
        for cl in program.stubs.values {
            if !cl.isExternal & !cl.annotations.isUnspecified {
                out.writeLine("#ifndef \{getName(cl)}_TYPEDEF")
                out.writeLine("#define \{getName(cl)}_TYPEDEF")
                out.writeLine("typedef struct \{getName(cl)} \{getName(cl)};")
                out.writeLine("#endif")
            }
        }
        var parent := target.parent()
        if parent = null {
            throw CompilerException("could not determine parent of " + 
                    target)
        }
        for cl in program.stubs.values {
            if !cl.isExternal & !cl.annotations.isUnspecified {
                out.writeLine('#include "' + getName(cl) + '.h"')
                var dest := parent.resolve(getName(cl) + ".h")
                generateHeader(cl, dest)
            }
        }
        out.close()
    }
}