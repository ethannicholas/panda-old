package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.VoidType

-- FIXME: revamp this to use IndentedOutputStream
class PLinkCodeGenerator (CodeGenerator) {
    var out:OutputStream := new MemoryOutputStream()
    var indent := 0

    @override
    function defaultExtension():String {
        return ".plink"
    }
    
    method generateFieldCode(f:FieldNode) {
        if f.annotations.isSynthetic
            return
        out.writeLine(indent * " " + f.annotations)
        out.write(indent * " " + "var " + f.name)
        if f.type-!>(UnresolvedType)
            out.write(":" + f.type.name)
        if f.owner.annotations.isUnspecified & f.pendingValue != null
            out.write(" := " + f.pendingValue->(Object))
        out.writeLine()
    }

    method generateMethodCode(m:MethodNode) {
        out.writeLine(indent * " " + m.annotations)
        out.write(indent * " ")
        switch m.methodType {
            case MethodNodeType.METHOD: out.write("method")
            case MethodNodeType.FUNCTION: out.write("function")
            case MethodNodeType.CONSTRUCTOR: out.write("constructor")
            default: unreachable
        }
        if m.methodType != MethodNodeType.CONSTRUCTOR
            out.write(" " + m.name)
        out.write("(")
        var first := true
        var start := 0
        if !m.annotations.isClass
            start := 1
        for i in start .. m.parameters.length {
            if !first
                out.write(", ")
            else
                first := false
            var p := m.parameters[i]
            out.write(p.name)
            if p.isConvert
                out.write("->>")
            else
                out.write(":")
            if p.isVarArg {
                out.write(p.type.elementType.name)
                out.write("...")
            }
            else
                out.write(p.type.name)
        }
        out.write(")")
        if m.returnType != VoidType.VOID
            out.write(":" + m.returnType.name)
        out.writeLine()
        if m.owner.annotations.isUnspecified & !m.annotations.isClass &
                m.parseNode != null
            out.writeLine(m.parseNode->(ParseNode))
        for p in m.annotations.post {
            if m.annotations.isOverride
                out.writeLine("@postAnd(" + p + ")")
            else
                out.writeLine("@post(" + p + ")")
        }
    }
    
    method generateClassCode(cl:ClassNode) {
        def packageName := cl.packageName
        if packageName != null
            out.writeLine(indent * " " + "package " + packageName)
        out.writeLine(indent * " " + cl.annotations)
        out.write(indent * " ")
        if cl.isInterface {
            out.write("interface")
            out.write(" " + cl.simpleName)
            if cl.genericParameterTypes.length > 0 {
                out.write("<")
                for i, p in cl.genericParameterTypes {
                    if i > 0
                        out.write(", ")
                    out.write("\{p.simpleName}:\{p.bound.name}")
                }
                out.write(">")
            }
            if cl.interfaces.length > 0 {
                out.write(" : ")
                for i, intf in cl.interfaces {
                    if i > 0
                        out.write(", ")
                    out.write(intf.name)
                }
            }
        }
        else {
            out.write("class")
            out.write(" " + cl.simpleName)
            if cl.genericParameterTypes.length > 0 {
                out.write("<")
                for i, p in cl.genericParameterTypes {
                    if i > 0
                        out.write(", ")
                    out.write("\{p.simpleName}:\{p.bound.name}")
                }
                out.write(">")
            }
            var superclass := cl.superclass
            if superclass != null
                out.write(":" + superclass.name)
            if cl.interfaces.length > 0 {
                out.write(" (")
                for i, intf in cl.interfaces {
                    if i > 0
                        out.write(", ")
                    out.write(intf.name)
                }
                out.write(")")
            }
        }
        out.writeLine(" {")
        indent += 4
        var first := true
        for i in 0 .. cl.length {
            if !first
                out.writeLine()
            first := false
            if cl[i]-?>(MethodNode)
                generateMethodCode(cl[i]->(MethodNode))
            else if cl[i]-?>(FieldNode)
                generateFieldCode(cl[i]->(FieldNode))
            else
                unreachable
        }
        indent -= 4
        out.writeLine(indent * " " + "}")
    }

    @override
    method generateCode(target:File) {
        out := new BufferedOutputStream(target.openOutputStream())
        out.writeLine("-- This file was autogenerated by the Panda compiler --")
        out.writeLine()
        var first := true
        Console.writeLine("remember to sort packageless classes first!")
        for cl in SymbolTable.classes {
            if cl.state != ClassNodeState.DEFINED | cl.isPrimitiveArray() | cl.isTuple() |
                    cl.type()-?>(GenericType)
                continue
            if first {
                out.writeLine()
                first := false
            }
            generateClassCode(cl)
        }
        for cl in SymbolTable.classes {
            if cl.state != ClassNodeState.DEFINED | (!cl.isPrimitiveArray() &
                    !cl.isTuple()) | cl.annotations.isUnspecified
                continue
            out.writeLine(indent * " " + "@$instance " + cl.name)
        }
        out.close()
    }
}