package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.compiler.CompilerSettings
uses org.pandalanguage.pandac.compiler.Dummy
uses org.pandalanguage.pandac.stubs.TypedClassStub 
uses org.pandalanguage.pandac.stubs.TypedMethodStub 
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithRange
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedType
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

@private 
class ClassConstant : Immutable {
    def name:String
    def type:String
    def methods:ImmutableArray<TypedMethodStub>
    
    constructor(name:String, type:String, methods:ListView<TypedMethodStub>) {
        self.name := name
        self.type := type
        self.methods := new ImmutableArray<TypedMethodStub>(methods)
    }
}

class LLVMCodeGenerator (CodeGenerator) {
    constant POINTER_SIZE := 8

    @private
    constant SHARED_LINKAGE := "weak_odr"
    
    def debug := false

    var tempVariable := 0

    var currentBlockLabel:String := "0"

    def compilerSettings:CompilerSettings

    def stubs:MapView<String, TypedClassStub>

    def classes:MapView<String, ClassNode>

    def classConstants := new HashMap<String, ClassConstant>()

    def methodNames:MapView<TypedMethodStub, String>

    var nameCount:Int
    
    var charArrayCount := 0

    def stringConstants := new HashMap<String, String>()

    def types:MapView<String, Type>

    def nextLabels := new HashMap<AbstractLoop, String>()

    def endLabels := new HashMap<AbstractLoop, String>()

    def headerBuffer := new MemoryOutputStream()

    def header := new IndentedOutputStream(headerBuffer)

    def bodyBuffer := new MemoryOutputStream()

    def body := new IndentedOutputStream(bodyBuffer)

    var currentMethod:MethodNode?

    constructor(p:Program) {
        self.compilerSettings := p.compilerSettings
        self.stubs := p.stubs
        self.classes := p.classes
        self.types := p.types
        self.methodNames := new MethodNamer().nameMethods(stubs, 
                new CMethodNamingStrategy())
    }

    @protected
    method writeBody(text:String, comment:String) {
        body.write(text)
        if debug {
            body.write("; ")
            body.write(comment)
        }
        body.writeLine()
    }
    
    @override
    function defaultExtension():String {
        return ".ll"
    }

    ============================================================================
    Returns the LLVM name for a type. Note that method types are a bit 
    complicated: sometimes we want a method type identified as an instance of 
    class Method, and sometimes we want a method type identified as an actual
    function pointer. This method always returns the Method class, and the
    getLLVMMethodType() method may be used to get the function pointer type
    corresponding to a method.
    ============================================================================
    method getLLVMType(t:Type):String {
        switch t {
            case IntType.INT8:  return "i8"
            case IntType.INT16: return "i16"
            case IntType.INT32: return "i32"
            case IntType.INT64: return "i64"
            case IntType.UINT8:  return "i8"
            case IntType.UINT16: return "i16"
            case IntType.UINT32: return "i32"
            case IntType.UINT64: return "i64"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case BitType.BIT: return "i1"
            case CharType.CHAR: return "i16"
            case VoidType.VOID: return "void"
            case NativePointerType.NATIVE_POINTER: return "i8*"
        }
        return "%" + getName(getStub(t->>(ClassType))) + "*"
    }

    method getLLVMMethodType(t:TypedMethodStub):String {
        def result := new MutableString()
        def returnType := t.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        def parameters := t.parameters
        for i, p in parameters {
            if i > 0
                result.append(", ")
            result.append(getLLVMType(p.type))
        }
        result.append(")*")
        return result->>(String)
    }

    method getLLVMMethodType(t:MethodType):String {
-*        def result := new MutableString()
        def returnType := t.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        def parameters := t.methodParameters
        for i, p in parameters {
            if i > 0
                result.append(", ")
            result.append(getLLVMType(p))
        }
        result.append(")*")
        return result->>(String)*-
        throw new NotSupportedException()
    }

    @protected
    method getTempVariable():String {
        def result := "%" + tempVariable
        tempVariable += 1
        return result
    }

    @private
    method getName(cl:TypedClassStub):String {
        return MethodNamer.escapeTypeName(cl.name)
    }

    @private
    function getName(m:MethodNode):String {
        return getName(m.stub)
    }

    @private
    function getName(m:TypedMethodStub):String {
        def result := methodNames[m]
        assert result != null : "no method name for \{m}"
        return result
    }

    @private
    function getName(v:Variable):String {
        return v.name
    }

    @private
    function getType(cl:TypedClassStub):ClassType {
        return types[cl.name]->(ClassType)
    }

    @private
    function getClass(cl:ClassType):ClassNode {
        return classes[cl.name]->(ClassNode)
    }

    @private
    function getStub(cl:ClassType):TypedClassStub {
        return getStub(cl.name)
    }

    @private
    function getStub(s:String):TypedClassStub {
        def result := stubs[s]
        -- FIXME TEMP
        if result = null
            return stubs["panda.core.Object"]->(TypedClassStub)
        return result
    }

    @private
    function size(t:Type):Int {
        if t.isPrimitive
            return t->>(PrimitiveType).size
        def stub := getStub(t->>(ClassType))
        var total := 0
        def sc := stub.superclass
        if sc != null
            total += size(sc)
        for field in stub.instanceFields(stubs) {
            def fieldSize:Int
            if field.type.isPrimitive
                fieldSize := size(field.type)
            else
                fieldSize := POINTER_SIZE
            def align := total % fieldSize
            if align != 0
                total += fieldSize - align
            assert total % fieldSize = 0
            total += fieldSize
        }
        return total
    }

    @private
    function isImmutable(t:Type):Bit {
        return t.isPrimitive
    }

    @protected
    method createBlock(label:String, comment:String) {
        currentBlockLabel := label
        if debug
            body.writeLine("; " + comment)
        body.writeLine(label + ":")
    }
    
    @protected
    method createLabel():String {
        nameCount += 1
        return "$label" + nameCount
    }
    
    @protected
    method writeTypeDescriptor(cl:TypedClassStub) {
        if debug
            header.writeLine("; " + cl.name)
        header.write("%" + getName(cl) + " = type { ")
        def fields := cl.instanceFields(stubs)
        for i, f in fields {
            if i != 0
                header.write(", ")
            if f.name = FieldNode.ELEMENTS_NAME
                header.write(getLLVMType(f.type) + "*")
            else
                header.write(getLLVMType(f.type))
        }
        if cl.name = ClassType.CLASS.name {
            -- Class is special, write out the VTABLE entry at the end of its fields
            header.write(", %$itable*, [0 x i8*]")
        }
        header.writeLine(" }")
    }

    @protected
    method createCallReference(codeString:String, comment:String):String {
        def result := getTempVariable()
        call(codeString, result, comment)
        return result
    }

    @protected
    method call(invocation:String, result:String?, comment:String?) {
        if result != null
            body.write(result + " = ")
        body.write("call " + invocation)
        if debug & comment != null
            body.writeLine("; " + comment)
        else
            body.writeLine()
    }

    @protected
    method call(invocation:String) {
        call(invocation, null, null)
    }

    @private
    function isConstant(expr:String):Bit {
        return expr.startsWith("%") | expr.matches(#/\d+/#)
    }

    @protected
    method createCommandReference(codeString:String, comment:String):String {
        if isConstant(codeString)
            return codeString
        def result := getTempVariable()
        writeBody(result + " = " + codeString, comment)
        return result
    }

    @protected
    method createConstructReference(construct:Construct):String {
        def targetType := construct.type
        def target := getStub(targetType)
        def cc := getClassConstant(target)
        def cast := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody(cast + " = bitcast " + cc.type + "* @" + cc.name +
                " to " + classType, "convert class pointer")
        def alloc := createCallReference("i8* @_pandaNew(" + classType + " " + 
                cast + ", i32 " + size(targetType) + ")", 
                "allocate " + targetType.name)
    
        def result := createCommandReference("bitcast i8* " + alloc + " to " + 
                getLLVMType(targetType), "convert pointer to " + 
                targetType.name)

        def parameters := construct.constructorCall.parameters
        def m := construct.constructorCall.methodStub
        def methodRef := "@" + getName(m)
        def text := new MutableString("fastcc void \{methodRef}(")
        text.append(getLLVMType(targetType) + " " + result)
        for i, p in parameters[1..] {
            text.append(", ")
            text.append(getTypedReference(p))
        }
        text.append(")")
        call(text->>(String))
        return result
    }

    @protected
    method createMethodCallReference(mc:MethodCall):String? {
        def m := mc.methodStub
        def methodRef:String
-*        if m.isEffectivelyVirtual & mc.isVirtual {
            assert !m.annotations.isClass : "expected method not to be @class"
            assert mc.parameters.length >= 1 : "expected method to have a self parameter"
            def target := mc.parameters[0]
            def classNode := target.type.classNode
            if classNode.isInterface
                methodRef := getInterfaceMethodReference(mc)
            else
                methodRef := getVirtualMethodReference(mc)
        }
        else *-
            methodRef := "@" + getName(m)
        def text := new MutableString("fastcc \{getLLVMMethodType(m)} \{methodRef}(")
        def parameters := mc.parameters
        for i, p in parameters {
            if i > 0
                text.append(", ")
            text.append(getTypedReference(p))
        }
        text.append(")")
        if mc.type = VoidType.VOID {
            call(text->>(String))
            return null
        }
        else
            return createCallReference(text->>(String), mc->>(String))
    }

    @protected
    method createVariableAssignmentReference(va:VariableAssignment):String {
        def variable := va.variable
        def lref := getLLVMType(variable.type) + "* %" + getName(variable)
        def result := createReference(va.value)
        assert result != null : 
                "expected non-null result in createVariableAssignmentReference"
        writeBody("store " + getLLVMType(variable.type) + " " + result + ", " + 
                lref, va->>(String))
        return result
    }
    
    @private
    method getITable(cl:TypedClassStub):String {
        def visited := new HashSet<TypedClassStub>()
        def interfaces := cl.allInterfaces(stubs)
        var previous := "%$itable* null"
        for intf in interfaces {
            if visited.contains(intf)
                continue
            visited.add(intf)
            def intfCC := getClassConstant(intf)
            def methods := cl.interfaceMethods(intf, stubs)
            def name := "@" + getName(cl) + "$." + getName(intf)
            def type := "{ " + getLLVMType(ClassType.CLASS) + 
                    ", %$itable*, [" + methods.length + " x i8*] }"
            header.write(name + " = " + SHARED_LINKAGE + " constant ")
            header.write(type + " { " + 
                    getLLVMType(ClassType.CLASS) + " bitcast(" + intfCC.type + 
                    "* @" + intfCC.name + " to " + 
                    getLLVMType(ClassType.CLASS) + "), " + previous + ", [" + 
                    methods.length + " x i8*][")
            for i, m in methods {
                if i > 0
                    header.write(", ")
                if m.annotations.isAbstract
                    header.write("i8* null")
                else {
                    header.write("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            header.writeLine("] }")
            previous := "%$itable* bitcast(" + type + "* " + name + 
                    " to %$itable*)" 
        }
        return previous
    }

    @protected
    method getClassConstant(cl:TypedClassStub):ClassConstant {
        var name := cl.name
        var cc := classConstants[name]
        if cc = null {
            def methods := cl.virtualMethods(stubs)
            def className := getName(cl)
            cc := new ClassConstant(
                    className + "_class",
                    "{ " + getLLVMType(ClassType.CLASS) + ", " + 
                    getLLVMType(ClassType.STRING) +  ", " + 
                    getLLVMType(ClassType.CLASS) + ", i1, i1, %$itable*, [" + 
                    methods.length + " x i8*] }", methods)
            classConstants[name] := cc
            if types[name]-?>(WrapperType) {
                assert name.endsWith("Wrapper") : "invalid wrapper class name"
                name := name[0 .. name.length - "Wrapper".length]
            }
            -- go ahead and get other class constants here, before we've written
            -- anything -- this could cause other class definitions to be
            -- printed, and we don't want to be in the middle of output when
            -- that happens
            var nameRef := "<error>"
            if !cl.isExternal
                nameRef := getStringConstantReference(name)
            getClassConstant(getStub(ClassType.CLASS.name))

            def superclassConstant:ClassConstant?
            def superclass := cl.superclass
            if superclass != null
                superclassConstant := getClassConstant(getStub(superclass))
            else
                superclassConstant := null
            if cl.isExternal {
                header.write("@" + cc.name + " = ")
                header.writeLine("external global " + cc.type)
                return cc
            }
            def intf := getITable(cl)
            header.write("@" + cc.name + " = ")
            header.write(SHARED_LINKAGE + " ")
            def superclassRef:String
            if superclassConstant != null
                superclassRef := "bitcast(" + superclassConstant.type + "* @" + 
                        superclassConstant.name + " to " + 
                        getLLVMType(ClassType.CLASS) + ")"
            else
                superclassRef := "null"
            -- class constant includes vtable. Doesn't include statics, as 
            -- those are just globals.
            var overridesFinalize := false
            for m in cl.methods {
                if m.name = MethodNode.FINALIZE_NAME & 
                        !m.annotations.isClass & 
                        m.parameters.length = 1
                    overridesFinalize := true
            }
            def classClass := getStub(ClassType.CLASS)
            def classClassConstant := getClassConstant(classClass)
            header.write("constant " + cc.type + 
                    " { " + getLLVMType(ClassType.CLASS) + " bitcast(" + 
                    classClassConstant.type + "* @" + classClassConstant.name + 
                    " to " + getLLVMType(ClassType.CLASS) + "), " + 
                    getLLVMType(ClassType.STRING) + " " + nameRef + ", " + 
                    getLLVMType(ClassType.CLASS) + " " + superclassRef + 
                    ", i1 1, i1 " + overridesFinalize + ", " + intf + ", [" + 
                    methods.length + " x i8*] [ ")
            for i, m in methods {
                if i > 0
                    header.write(", ")
                if m.annotations.isAbstract
                    header.write("i8* null")
                else {
                    header.write("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            header.writeLine(" ] }")
        }
        return cc
    }

    @private
    method getCharPrimitiveArrayConstantReference(chars:PrimitiveArray<Char>):String {
        def charPrimitiveArrayClass := getStub(
                PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
        def cc := getClassConstant(charPrimitiveArrayClass)
        def charsType := "[\{chars.length} x \{getLLVMType(CharType.CHAR)}]"
        def type := "{ " + cc.type + "*, " +
                getLLVMType(IntType.INT32) + ", " + 
                getLLVMType(IntType.INT32) + ", " + 
                charsType + "* }"
        def result := "ca" + charArrayCount
        charArrayCount += 1
        def charsName := "@\{result}_chars"
        header.write(charsName + " = private unnamed_addr constant " + 
                charsType + " [")
        for i, c in chars {
            if i != 0
                header.write(", ")
            header.write(getLLVMType(CharType.CHAR) + " " + c->(Int))
        }
        header.writeLine("]")

        header.writeLine("@" + result + " = private unnamed_addr constant " + 
                type + " { " + cc.type + "* @" + cc.name + ", " + 
                getLLVMType(IntType.INT32) + " " + chars.length + ", " +
                getLLVMType(IntType.INT32) + " " + chars.length + ", " + 
                charsType + "* " + charsName + " }, align " +
                POINTER_SIZE)
        return "bitcast(" + type + "* @" + result + " to " + 
                getLLVMType(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY) + ")"
    }

    @private
    method getStringConstantReference(s:String):String {
        var result := stringConstants[s]
        if result = null {
            def string := getStub(ClassType.STRING)
            def primitiveChars := new PrimitiveArray<Char>()
            for c in s
                primitiveChars.append(c)
            def chars := getCharPrimitiveArrayConstantReference(primitiveChars)
            result := "@s" + stringConstants.length
            stringConstants[s] := result
            def charPrimitiveArrayType := PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY
            def cc := getClassConstant(string)
            if debug
                header.writeLine("; " + StringLiteral.escape(s))
            header.writeLine(result + " = private unnamed_addr constant " + 
                    '%panda$core$String { ' + 
                    getLLVMType(ClassType.CLASS) + " bitcast(" + cc.type + 
                    "* @" + cc.name + " to " + getLLVMType(ClassType.CLASS) + 
                    "), " + getLLVMType(charPrimitiveArrayType) + " " + chars + " }," +
                    " align " + POINTER_SIZE)
            stringConstants[s] := result
        }
        return result
    }

    @private
    method createOverflowCheckedBinaryOperationReference(value:BinaryOperation, 
            op:String):String {
        def typeString := getLLVMType(value.type)
        def left := getTypedReference(value.left)
        def right := getTypedReference(value.right)
        def result := createCommandReference("call { " + typeString + 
                ", i1 } @llvm." + op + ".with.overflow." + typeString + "(" + 
                left + ", " + right + ")", value->>(String))
                var flag := getTempVariable()
        writeBody(flag + " = extractvalue { " + typeString + 
                ", i1 } " + result + ", 1", "extract overflow flag")
        def p := value.position
        call("void @pandaCheckOverflow(i1 " + flag + ")")
        return createCommandReference("extractvalue { " + typeString + 
                ", i1 } " + result + ", 0", "load results of '" + op + "'")
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation,
            var op:String):String {
        def cm := currentMethod
        assert cm != null : 
                "currentMethod unexpectedly null in createBinaryOperationReference"
        if (op = "add" | op = "sub" | op = "mul") & 
                !cm.annotations.isOverflow &
                compilerSettings.overflowChecking &
                !b.permitOverflow {
            if b.type.isInteger & b.type->(IntType).signed
                op := "s" + op
            else
                op := "u" + op
            return createOverflowCheckedBinaryOperationReference(b, op)
        }
        def left := createReference(b.left)
        def right := createReference(b.right)
        assert left != null & right != null : 
                "expected left and right to be non-null in createBinaryOperationReference"
        return createCommandReference(op + " " + getLLVMType(b.left.type) + 
                " " + left + ", " + right, b->>(String))
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation, sop:String?, 
            uop:String?, fop:String?):String {
        def operandType := b.left.type
        def op:String?
        if operandType.isReal
            op := fop
        else if operandType = CharType.CHAR | (operandType.isInteger & 
                !operandType->(IntType).signed)
            op := uop
        else
            op := sop
        if op = null {
            throw new CompilerException("cannot compile '" + b + 
                    "', invalid types", b.position)
        }
        return createBinaryOperationReference(b, op)
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation, iop:String?, 
            fop:String?):String {
        return createBinaryOperationReference(b, iop, iop, fop)
    }

    @pre(and.operation = BinaryOperationType.AND)
    method createAndReference(and:BinaryOperation):String {
        def left := createReference(and.left)
        assert left != null : "expected non-null left in createAndReference"
        def leftFromLabel := currentBlockLabel
        def rightLabel := createLabel()
        def endLabel := createLabel()
        writeBody("br i1 " + left + ", label %" + rightLabel + 
                ", label %" + endLabel,
                "and test: " + and)
        body.writeLine()
        createBlock(rightLabel, "right: " + and)
        def right := createReference(and.right)
        assert right != null : "expected non-null right in createAndReference"
        def rightFromLabel := currentBlockLabel
        body.writeLine("br label %" + endLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + and)
        def result := getTempVariable()
        body.writeLine(result + " = phi i1 [false, %" + leftFromLabel + 
                "], [" + right + ", %" + rightFromLabel + "]")
        return result
    }
    
    @pre(or.operation = BinaryOperationType.OR)
    method createOrReference(or:BinaryOperation):String {
        def left := createReference(or.left)
        assert left != null : "expected non-null left in createOrReference"
        def leftFromLabel := currentBlockLabel
        def rightLabel := createLabel()
        def endLabel := createLabel()
        writeBody("br i1 " + left + ", label %" + endLabel + 
                ", label %" + rightLabel, "or test: " + or)
        body.writeLine()
        createBlock(rightLabel, "right: " + or)
        def right := createReference(or.right)
        assert right != null : "expected non-null right in createOrReference"
        def rightFromLabel := currentBlockLabel
        body.writeLine("br label %" + endLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + or)
        def result := getTempVariable()
        body.writeLine(result + " = phi i1 [true, %" + leftFromLabel + 
                "], [" + right + ", %" + rightFromLabel + "]")
        return result
    }
-*
    method createTernaryReference(t:Ternary):String {
        def test := createReference(t.test)
        assert test != null : "expected non-null test in createTernaryReference"
        def leftLabel := createLabel()
        def rightLabel := createLabel()
        def endLabel := createLabel()
        writeBody("br i1 " + test + ", label %" + leftLabel + 
                ", label %" + rightLabel, "ternary test: " + t)
        body.writeLine()

        createBlock(leftLabel, "left: " + t)
        def left := createReference(t.left)
        assert left != null : "expected non-null left in createTernaryReference"
        def leftFromLabel := currentBlockLabel
        body.writeLine("br label %" + endLabel)
        
        createBlock(rightLabel, "right: " + t)
        def right := createReference(t.right)
        assert right != null : "expected non-null right in createTernaryReference"
        def rightFromLabel := currentBlockLabel
        body.writeLine("br label %" + endLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + t)
        def result := getTempVariable()
        body.writeLine(result + " = phi " + getLLVMType(t.type) + 
                " [" + left + ", %" + leftFromLabel + 
                "], [" + right + ", %" + rightFromLabel + "]")
        return result
    }
*-
    @protected
    method createBinaryOperationReference(b:BinaryOperation):String {
        switch b.operation {
            case BinaryOperationType.ADD: 
                return createBinaryOperationReference(b, "add", "fadd")
            case BinaryOperationType.SUBTRACT:
                return createBinaryOperationReference(b, "sub", "fsub")
            case BinaryOperationType.MULTIPLY: 
                return createBinaryOperationReference(b, "mul", "fmul")
            case BinaryOperationType.DIVIDE: 
                return createBinaryOperationReference(b, null, "fdiv")
            case BinaryOperationType.INT_DIVIDE: {
                var op:String
                if b.type->(IntType).signed
                    op := "sdiv"
                else
                    op := "udiv"
                return createBinaryOperationReference(b, op, null)
            }
            case BinaryOperationType.REMAINDER: 
                return createBinaryOperationReference(b, "srem", "urem", null)
            case BinaryOperationType.SHIFT_LEFT: 
                return createBinaryOperationReference(b, "shl", null)
            case BinaryOperationType.SHIFT_RIGHT: {
                if b.type->(IntType).signed
                    return createBinaryOperationReference(b, "ashr", null)
                else
                    return createBinaryOperationReference(b, "lshr", null)
            }
            case BinaryOperationType.ADD: 
                return createAndReference(b)
            case BinaryOperationType.OR:
                return createOrReference(b)
            case BinaryOperationType.XOR: 
                return createBinaryOperationReference(b, "xor", null)
            case BinaryOperationType.BITWISE_AND: 
                return createBinaryOperationReference(b, "and", null)
            case BinaryOperationType.BITWISE_OR: 
                return createBinaryOperationReference(b, "or", null)
            case BinaryOperationType.BITWISE_XOR: 
                return createBinaryOperationReference(b, "xor", null)
            case BinaryOperationType.EQUAL: 
                return createBinaryOperationReference(b, "icmp eq", "fcmp oeq")
            case BinaryOperationType.IDENTITY: 
                return createBinaryOperationReference(b, "icmp eq")
            case BinaryOperationType.LESS_THAN: {
                return createBinaryOperationReference(b, "icmp slt", "icmp ult", 
                        "fcmp olt")
            }
            case BinaryOperationType.GREATER_THAN: {
                return createBinaryOperationReference(b, "icmp sgt", "icmp ugt",
                        "fcmp ogt")
            }
            case BinaryOperationType.LESS_THAN_OR_EQUAL: {
                return createBinaryOperationReference(b, "icmp sle", "icmp ule",
                        "fcmp ole")
            }
            case BinaryOperationType.GREATER_THAN_OR_EQUAL: {
                return createBinaryOperationReference(b, "icmp sge", "icmp uge",
                        "fcmp oge")
            }
            case BinaryOperationType.NOT_EQUAL:
                return createBinaryOperationReference(b, "icmp ne", "fcmp one")
            case BinaryOperationType.NOT_IDENTITY:
                return createBinaryOperationReference(b, "icmp ne")
            default:
                unreachable
        }
    }

    @protected
    method createCastReference(c:Cast):String? {
        def tempResult := createReference(c.value)
        assert tempResult != null : 
                "expected non-null tempResult in createCastReference"
        def actualType := c.value.type
        def destType := c.type
        if actualType = destType
            return tempResult
        def actualSize := size(actualType)
        def destSize := size(destType)
        var command:String? := null
        if actualSize = destSize & 
                (actualType.isInteger | actualType = CharType.CHAR) & 
                (destType.isInteger | destType = CharType.CHAR) {
            -- actual bits aren't changing, just the logical type
            return tempResult
        }
        if actualType.isInteger & (destType.isInteger | 
                destType = CharType.CHAR) {
            if actualSize > destSize
                -- int narrowing
                command := "trunc"
            else if actualType->(IntType).signed
                -- signed int widening
                command := "sext"
            else
                -- unsigned int widening
                command := "zext"
        }
        else if actualType.isReal & destType.isReal {
            if actualSize > destSize
                -- real64 ->> real32
                command := "fptrunc"
            else
                -- real32 ->> real64
                command := "fpext"
        }
        else if actualType.isReal & destType.isInteger {
            -- real to signed int
            command := "fptosi"
        }
        else if actualType.isInteger & destType.isReal {
            if actualType->(IntType).signed {
                -- signed int to real
                command := "sitofp"
            }
            else {
                -- unsigned int to real
                command := "uitofp"
            }
        }
        else if actualType = CharType.CHAR & destType.isInteger {
            if actualSize > destSize
                -- char narrowing
                command := "trunc"
            else
                -- char widening
                command := "zext"
        }
        else if actualType.isReal & destType = CharType.CHAR {
            -- real to char
            command := "fptoui"
        }
        else if actualType = CharType.CHAR & destType.isReal {
            -- char to real
            command := "uitofp"
        }
     
        if command != null {
            def result := getTempVariable()
            body.writeLine(result + " = " + command + " " + 
                    getLLVMType(actualType) + " " + tempResult + 
                    " to " + getLLVMType(destType), c.value + " -> " + 
                    destType.name)
            return result
        }
        else {
            -- casting one type of object to another, can simply bitcast the
            -- pointer
            assert !actualType.isPrimitive : 
                    "expected actualType to not be primitive"
            assert !destType.isPrimitive :
                    "expected destType to not be primitive"
            def checkCast := compilerSettings.checkCasts
            if checkCast {
-*                -- verify the cast. Use a dummy for the first 
                -- parameter just to get the type right.
                def params := new PrimitiveArray<Value>(new Dummy(actualType), 
                        new ClassObjectLiteral(destType.unwrapNullable()), 
                        new BitLiteral(destType.isNullable))
                def panda := ClassType.PANDA().classNode
                def check := panda.symbolTable.getMethod(c.position,
                        "checkCast", params, true)
                assert check != null : "expected check to be non-null"
                for i in 1 ... params.length - 1
                    getTypedReference(params[i])
                var intermediate := tempResult
                if actualType != ClassType.OBJECT() {
                    intermediate := getTempVariable()
                    writeBody(intermediate + " = bitcast " + 
                            getLLVMType(actualType) + " " + tempResult + 
                            " to " + getLLVMType(ClassType.OBJECT()),
                            c.value + " -> " + ClassType.OBJECT().name)
                }
                var callString := ("fastcc void @" + getName(check) + 
                        "(")->>(MutableString)
                callString.append(getLLVMType(ClassType.OBJECT()) + " " + 
                        intermediate)
                for i in 1 ... params.length - 1 {
                    callString.append(", ")
                    callString.append(getTypedReference(params[i]))
                }
                callString.append(")")
                call(callString->>(String), null, "check cast " + c + ":" + 
                        c.position)*-
            }
            def actualLLVMType := getLLVMType(actualType)
            def destLLVMType := getLLVMType(destType)
            if actualLLVMType = destLLVMType
                return tempResult
            def result := getTempVariable()
            writeBody("\{result} = bitcast \{actualLLVMType} \{tempResult} " +
                    " to \{destLLVMType}", "\{c.value} -> \{destType.name}")
            return result
        }
    }
    
    @protected
    method createVariableReference(vr:VariableReference):String {
        def variable := vr.variable
        if variable-?>(Parameter)
            return "%" + getName(variable)
        return createCommandReference("load " + getLLVMType(vr.type) + "* %" + 
                getName(variable), vr->>(String))
    }
        
    -- return value is nullable so void expressions (method calls) can return
    -- null
    @protected
    method createReference(v:Value):String? {
        switch v.class {
            case class(VariableAssignment): return createVariableAssignmentReference(v->(VariableAssignment))
            case class(BinaryOperation): return createBinaryOperationReference(v->(BinaryOperation))
            case class(Construct): return createConstructReference(v->(Construct))
            case class(MethodCall): return createMethodCallReference(v->(MethodCall))
            case class(StringLiteral): return getStringConstantReference(v->(StringLiteral).value)
            case class(IntegerLiteral): return v->(IntegerLiteral).value->>(String)
-*
            case class(RealLiteral): return createRealLiteralReference(v->(RealLiteral))
*-
            case class(VariableReference): return createVariableReference(v->(VariableReference))
-*
            case class(FieldReference): return createFieldReference(v->(FieldReference))
*-
            case class(Cast): return createCastReference(v->(Cast))
-*
            case class(Equal): return createBinaryOperationReference(v->(BinaryOperation), "icmp eq", "fcmp oeq")
            case class(Identity): return createBinaryOperationReference(v->(BinaryOperation), "icmp eq")
            case class(LessThan): return createBinaryOperationReference(v->(BinaryOperation), "icmp slt", "icmp ult", "fcmp olt")
            case class(GreaterThan): return createBinaryOperationReference(v->(BinaryOperation), "icmp sgt", "icmp ugt", "fcmp ogt")
            case class(LessThanOrEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp sle", "icmp ule", "fcmp ole")
            case class(GreaterThanOrEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp sge", "icmp uge", "fcmp oge")
            case class(NotEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp ne", "fcmp one")
            case class(NotIdentity): return createBinaryOperationReference(v->(BinaryOperation), "icmp ne")
            case class(BitLiteral): return v->(BitLiteral).value->>(String)
            case class(IndexValue): return createIndexValueReference(v->(IndexValue))
            case class(NewPrimitiveArrayWithLength): return createNewPrimitiveArrayWithLengthReference(v->(NewPrimitiveArrayWithLength))
            case class(NewPrimitiveArrayWithValues): return createNewPrimitiveArrayWithValuesReference(v->(NewPrimitiveArrayWithValues))
            case class(NewPrimitiveArrayWithRange): return createNewPrimitiveArrayWithRangeReference(v->(NewPrimitiveArrayWithRange))
            case class(Not): return createNotReference(v->(Not))
            case class(BitwiseNot): return createBitwiseNotReference(v->(BitwiseNot))
            case class(UnaryMinus): return createUnaryMinusReference(v->(UnaryMinus))
            case class(NullLiteral): return "null"
            case class(ClassObjectLiteral): return createClassObjectLiteralReference(v->(ClassObjectLiteral))
            case class(Ternary): return createTernaryReference(v->(Ternary))
            case class(Unwrap): return createReference(v->(Unwrap).value)
            case class(MethodValue): return createMethodValueReference(v->(MethodValue))
            case class(DynamicCall): return createDynamicCallReference(v->(DynamicCall))
            case class(ReusedValueDefinition): return createReusedValueDefinitionReference(v->(ReusedValueDefinition))
            case class(ReusedValue): return createReusedValueReference(v->(ReusedValue)) 
    *-
            case class(Unresolved): throw new InternalCompilerException(
                    "unresolved value \{v}", v.position)
            default: {
                throw new InternalCompilerException("unsupported value class: " + 
                        v.class.name, v.position)
            }
        }
    }

    @protected
    method getTypedReference(v:Value):String {
        def ref := createReference(v)
        assert ref != null : "expected non-null ref in getTypedReference"
        return getLLVMType(v.type) + " " + ref
    }
    
    @protected
    method generateValueStatementCode(v:ValueStatement) {
        createReference(v.value)
    }

    @protected
    method generateIfCode(i:If) {
        if debug
            body.writeLine("; " + i)
        def ifLabel := createLabel()
        def elseLabel := createLabel()
        def endLabel:String
        if i.elseBlock != null
            endLabel := createLabel()
        else
            endLabel := elseLabel
        writeBody("br " + getTypedReference(i.test) + 
                ", label %" + ifLabel + ", label %" + elseLabel, 
                "if test: " + i.test)
        body.writeLine()
        createBlock(ifLabel, "then: " + i)
        generateBlockCode(i.ifBlock)
        if !i.ifBlock.endsInBranch
            writeBody("br label %" + endLabel, "then -> end")
        body.writeLine()
        def elseBlock := i.elseBlock
        if elseBlock != null {
            createBlock(elseLabel, "else: " + i)
            generateBlockCode(elseBlock)
            if !elseBlock.endsInBranch
                writeBody("br label %" + endLabel, "else -> end")
            body.writeLine()
        }
        createBlock(endLabel, "end: " + i)
    }

    @protected
    method generateWhileCode(w:While) {
        def bodyLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[w] := nextLabel
        endLabels[w] := endLabel
        body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + w)
        writeBody("br " + getTypedReference(w.test) + 
                ", label %" + bodyLabel + ", label %" + endLabel,
                "while test: " + w.test)
        body.writeLine()
        createBlock(bodyLabel, "body: " + w)
        generateBlockCode(w.block())
        if !w.block.endsInBranch
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + w)
    }

    @protected
    method generateDoCode(d:Do) {
        def bodyLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[d] := nextLabel
        endLabels[d] := endLabel
        body.writeLine("br label %" + bodyLabel)
        body.writeLine()
        createBlock(bodyLabel, "body: " + d)
        generateBlockCode(d.block)
        if !d.block.endsInBranch
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + d)
        writeBody("br " + getTypedReference(d.test) + 
                ", label %" + bodyLabel + ", label %" + endLabel,
                "do test: " + d.test)
        body.writeLine()
        createBlock(endLabel, "end: " + d)
    }

    @protected
    method generateLoopCode(l:Loop) {
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[l] := nextLabel
        endLabels[l] := endLabel
        body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + l)
        generateBlockCode(l.block)
        if !l.block.endsInBranch
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + l)
    }

    @protected
    method generateReturnCode(ret:Return) {
        def value := ret.value
        if value = null
            body.writeLine("ret void ; " + ret)
        else
            writeBody("ret " + getTypedReference(value), ret->>(String))
    }
    
    @protected
    method generateStatementCode(s:Statement) {
        if debug
            body.writeLine("; " + s)
        switch s.class {
-*            case class(IndexedAssignment): 
                    generateIndexedAssignmentCode(s->(IndexedAssignment))
            case class(FieldAssignment): 
                    generateFieldAssignmentCode(s->(FieldAssignment)) *-
            case class(ValueStatement):
                    generateValueStatementCode(s->(ValueStatement))
            case class(If): generateIfCode(s->(If))
            case class(While): generateWhileCode(s->(While))
            case class(Do): generateDoCode(s->(Do))
            case class(Loop): generateLoopCode(s->(Loop))
-*            case class(LoopWithContinueBlock): 
                    generateLoopWithContinueBlockCode(s->(LoopWithContinueBlock))
*-
            case class(Block): generateBlockCode(s->(Block))
            case class(Return): generateReturnCode(s->(Return))
-*
            case class(Break): generateBreakCode(s->(Break))
            case class(Continue): generateContinueCode(s->(Continue))
            case class(Assert): generateAssertCode(s->(Assert))
            case class(Throw): generateThrowCode(s->(Throw))
            case class(Try): generateTryCode(s->(Try))
            case class(CatchExit): { }
            case class(Unreachable): generateUnreachableCode(s->(Unreachable)) *-
            default: 
                throw new InternalCompilerException("unsupported statement: " + 
                        s, s.position)
        }
    }

    @protected
    method generateBlockCode(b:Block) {
        for s in b.statements
            generateStatementCode(s)
    }

    @protected
    method writeMethodDeclaration(m:TypedMethodStub) {
        if m.annotations.isAbstract
            return
        def private := m.annotations.isPrivate
        def external := m.annotations.isExternal
        body.writeLine()
        if debug
            body.writeLine("; " + m)
        body.write("declare ")
        if !external
            body.write("fastcc ")
        body.write(getLLVMType(m.returnType) + " @\{getName(m)}(")
        for i, p in m.parameters {
            if i > 0
                body.write(", ")
            body.write(getLLVMType(p.type))
        }
        body.write(")")
        if m.methodType = MethodNodeType.FUNCTION & isImmutable(m.returnType)
            body.write(" readonly")
        body.writeLine()
    }

    @protected
    method generateMethodCode(m:MethodNode) {
        if m.annotations.isAbstract
            return
        currentMethod := m
        tempVariable := 1
        def private := m.annotations.isPrivate
        def external := m.annotations.isExternal
        body.writeLine()
        if debug
            body.writeLine("; " + m)
        if external
            body.write("declare ")
        else
            body.write("define ")
        if !external
            body.write("fastcc ")
        body.write(getLLVMType(m.returnType) + " @\{getName(m)}(")
        for i, p in m.parameters {
            if i > 0
                body.write(", ")
            body.write(getLLVMType(p.type))
            if !external {
                body.write(" %") 
                body.write(getName(p))
            }
        }
        body.write(")")
        if m.methodType = MethodNodeType.FUNCTION & isImmutable(m.returnType)
            body.write(" readonly")
        if external
            body.writeLine()
        else {
            body.writeLine(" {")
            body.level += 1
            currentBlockLabel := "0"
            for v in m.localVariables
                body.writeLine("%\{getName(v)} = alloca \{getLLVMType(v.type)}")
-*            for (source, promoted) in promotedParameters {
                body.writeLine("%" + getName(promoted) + " = alloca " + 
                        getLLVMType(promoted.type))
                body.writeLine("store " + getLLVMType(promoted.type) +
                        " %" + getName(source) + ", " + 
                        getLLVMType(promoted.type) + "* %" + getName(promoted))
            } *-
            
            def block := m.block
            assert block != null
            generateBlockCode(block)
            if !block.endsInBranch {
                if m.returnType = VoidType.VOID
                    body.writeLine("ret void")
                else
                    body.writeLine("unreachable")
            }
            body.level -= 1
            body.writeLine("}")
        }
    }

    method generateClassCode(cl:ClassNode) {
        for m in cl.methods
            generateMethodCode(m)
    }

    @override
    method generateCode(target:File) {
        if debug
            Console.writeLine("llvm debug output is enabled")
        header.writeLine('target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"')
        header.writeLine('target triple = "' + StaticSettings.TARGET_TRIPLE + 
                '"')
        header.writeLine('%$itable = type { %panda$core$Class*, %$itable*, ' +
                "[0 x i8*] }")
        for (_, cl) in stubs {
            if cl.genericParameters = null
                writeTypeDescriptor(cl)
        }
        for (_, cl) in stubs {
            if classes[cl.name] = null & cl.genericParameters = null {
                for m in cl.methods
                    writeMethodDeclaration(m)
            }
        }
-*        for (_, cl) in stubs {
            if cl.live & !cl.annotations.isUnspecified()
                getClassConstant(cl)
        }*-
        for (_, cl) in classes
            generateClassCode(cl)

        body.writeLine("declare void @pandaInit()")
        body.writeLine("declare void @pandaCheckLibVersion(i32)")
        body.writeLine("declare void @pandaCheckOverflow(i1)")
        body.writeLine("declare {i8, i1}  @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.sadd.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.uadd.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.uadd.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.uadd.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.ssub.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.ssub.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.ssub.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.usub.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.usub.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.usub.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.usub.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.smul.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.smul.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.smul.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.smul.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.umul.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.umul.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.umul.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.umul.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare void @llvm.trap() noreturn nounwind")
        body.writeLine("declare void @pandaCheckSignCasti8(i8)")
        body.writeLine("declare void @pandaCheckSignCasti16(i16)")
        body.writeLine("declare void @pandaCheckSignCasti32(i32)")
        body.writeLine("declare void @pandaCheckSignCasti64(i64)")

        body.writeLine("declare i8* @_pandaNew(%panda$core$Class*, " +
                getLLVMType(IntType.INT32) + ")")

        def parent := target.parent()
        if parent = null {
            throw new CompilerException("could not determine parent " +
                    "directory of " + target.path)
        }
        def unoptTarget := parent.resolve(target.name + ".unopt")
        def out := new BufferedOutputStream(unoptTarget.openOutputStream())
        out.write(headerBuffer->>(String))
        out.write(bodyBuffer->>(String))
        out.close()

        def opt := PandaCompiler.getLLVMHome().resolve("opt")
        System.exec(opt, unoptTarget.path, "-o", target.path, "-O3",
                "-q", "-f", "-S", "-std-compile-opts")
        if !compilerSettings.preserveTempArtifacts
            unoptTarget.delete()
    }
}