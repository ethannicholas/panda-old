package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.compiler.IRGenerator
uses org.pandalanguage.pandac.compiler.CompilerSettings
uses org.pandalanguage.pandac.compiler.Dummy
uses org.pandalanguage.pandac.compiler.StubGenerator
uses org.pandalanguage.pandac.stubs.ClassStub 
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.MethodStub 
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Closure
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodReference
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.SkippedValue
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

@private 
class ClassConstant : Immutable {
    def name:String
    def type:String
    def methods:ImmutableArray<MethodStub>
    
    init(name:String, type:String, methods:ListView<MethodStub>) {
        self.name := name
        self.type := type
        self.methods := ImmutableArray<MethodStub>(methods)
    }
}

class LLVMCodeGenerator (CodeGenerator) {
    constant POINTER_SIZE := 8

    @private
    constant SHARED_LINKAGE := "weak_odr"
    
    @private 
    constant CLASS_POINTER_INDEX := 0
    
    @private 
    constant ARRAY_CONTENTS_INDEX := 2

    -- index of the vtable within the class structure. Note that Class is 
    -- special and this information is spread between more locations than I
    -- would like; the vtable (and itable) are "special" fields programmatically
    -- added to the Class class here. The information shows up in a couple spots
    -- here in the LLVM output, and *also* shows up in the panda$core$Class.h 
    -- file generated by HeaderCodeGenerator (where the same extra fields are 
    -- added). All of these sources must agree with each other or nothing will 
    -- work.
    @private 
    constant VTABLE_INDEX := 6

    @private
    constant ITABLE_INDEX := 5

    @private
    constant FAIL_ASSERT_NAME := "@panda$core$Panda$failAssert"

    def program:Program

    def debug := false

    var tempVariable := 0

    def variableNames := HashMap<Variable, String>()

    var currentBlockLabel:String := "0"

    def classes:MapView<String, ClassNode>

    def classConstants := HashMap<String, ClassConstant>()

    var nameCount:Int
    
    var charArrayCount := 0

    def stringConstants := HashMap<String, String>()

    def references := HashMap<Value, String>()

    def methodReferences := HashMap<MethodStub, String>()

    def loops := Stack<AbstractLoop>()

    def nextLabels := HashMap<AbstractLoop, String>()

    def endLabels := HashMap<AbstractLoop, String>()

    def headerBuffer := MemoryOutputStream()

    def header := IndentedOutputStream(headerBuffer)

    def bodyBuffer := MemoryOutputStream()

    def body := IndentedOutputStream(bodyBuffer)

    def methodNamer:MethodNamer

    var currentMethod:MethodNode?

    var context:Context

    def writtenStubs := HashSet<String>()

    def writtenTypes := HashSet<String>()

    def tryStack := Stack<Try>()

    def landingPads := HashMap<Try, String>()

    def writtenMethods := HashSet<MethodStub>()

    def declarations := HashSet<String>()

    init(p:Program, compilerSettings:CompilerSettings) {
        self.program := p
        def errors := FatalErrorReporter()
        self.context := IRGenerator(p.root, p.stubs, p.stubGenerator, 
                compilerSettings, errors).context
        self.classes := p.classes
        self.methodNamer := MethodNamer(context, 
                CMethodNamingStrategy())
    }

    @protected
    method writeBody(text:String, comment:String) {
        body.write(text)
        if debug {
            body.write("; ")
            body.write(comment)
        }
        body.writeLine()
    }
    
    @override
    function defaultExtension():String? {
        return ".ll"
    }

    method getStub(name:String):ClassStub {
        def stub := context.getStub(name)
        if !writtenStubs.contains(name) {
            writtenStubs.add(name)
            if !stub.annotations.isUnspecified {
                writeTypeDescriptor(stub)
            }
            for f in stub.fields {
                if (!stub.annotations.isUnspecified | 
                        f.annotations.isClass | f.annotations.isThread) & 
                        f.owner.name = stub.name {
                    writeFieldDeclaration(f)
                }
            }
        }
        return stub
    }

    @private
    def typeCache := HashMap<Type, String>()
    ============================================================================
    Returns the LLVM name for a type. Note that method types are a bit 
    complicated: sometimes we want a method type identified as an instance of 
    class Method, and sometimes we want a method type identified as an actual
    function pointer. This method always returns the Method class, and the
    getLLVMMethodType() method may be used to get the function pointer type
    corresponding to a method.
    ============================================================================
    method getLLVMType(raw:Type):String {
        def t := raw.unwrapUnspecializedGenerics(context)
        var result := typeCache[t]
        if result = null {
            if t.isNullable {
                result := getLLVMType(t.unwrapNullable)
            }
            else {
                switch t {
                    case IntType.INT8:  result := "i8"
                    case IntType.INT16: result := "i16"
                    case IntType.INT32: result := "i32"
                    case IntType.INT64: result := "i64"
                    case IntType.UINT8:  result := "i8"
                    case IntType.UINT16: result := "i16"
                    case IntType.UINT32: result := "i32"
                    case IntType.UINT64: result := "i64"
                    case RealType.REAL32: result := "float"
                    case RealType.REAL64: result := "double"
                    case BitType.BIT: result := "i1"
                    case CharType.CHAR: result := "i16"
                    case VoidType.VOID: result := "void"
                    case NativePointerType.NATIVE_POINTER: result := "i8*"
                    default:
                        var cl := t.convert()->ClassType
                        if cl-?>MethodType {
                            if cl->MethodType.immutableMethod {
                                cl := ClassType.METHOD
                            }
                            else {
                                cl := ClassType.MUTABLE_METHOD
                            }
                        }
                        def stub := getStub(cl.name)
                        result := "%" + getName(stub) + "*"
                }
            }
            typeCache[t] := result
        }
        return result
    }

    method getLLVMMethodType(m:MethodStub):String {
        def result := MutableString()
        def returnType := m.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        def parameters := m.parameters
        var first := true
        if !m.annotations.isClass {
            first := false
            result.append(getSelfType(m))
        }
        for (i, p) in parameters.enumeration {
            if first {
                first := false
            }
            else {
                result.append(", ")
            }
            result.append(getLLVMType(p.type))
        }
        result.append(")*")
        return result.convert()
    }

    method getLLVMMethodType(t:MethodType):String {
        def result := MutableString()
        def returnType := t.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        def parameters := t.methodParameters
        for (i, p) in parameters.enumeration {
            if i > 0 {
                result.append(", ")
            }
            result.append(getLLVMType(p))
        }
        result.append(")*")
        return result.convert()
    }

    method getSelfType(m:MethodStub):String {
        if m.annotations.isWrapperMethod {
            return getLLVMType(m.owner.convert()->PrimitiveType)
        }
        return getLLVMType(m.owner)
    }

    @protected
    method getTempVariable():String {
        def result := "%" + tempVariable
        tempVariable += 1
        return result
    }

    @private
    def nameCache := HashMap<ClassStub, String>()
    @private
    function getName(cl:ClassStub):String {
        var result := nameCache[cl]
        if result = null {
            result := MethodNamer.escapeTypeName(cl.name)
            nameCache[cl] := result
        }
        return result
    }

    @private
    method getName(m:MethodNode):String {
        return getName(m.stub)
    }

    @private
    method getName(m:MethodStub):String {
        return methodNamer.getName(m)
    }

    @private
    method getName(v:Variable):String {
        var result := variableNames[v]
        if result = null {
            if v-?>FieldNode {
                def field := v->FieldNode
                def name := getName(getStub(field.owner)) + "$" + v.name
                if field.annotations.isClass {
                    result := "class_" + name
                }
                else {
                    result := name
                }
            }
            else {
                result := v.name
            }
            if v-?>LocalVariable {
                result += variableNames.count
            }
            variableNames[v] := result
        }
        return result
    }

    @private
    function getClass(cl:ClassType):ClassNode {
        return classes[cl.name]->ClassNode
    }

    @private
    method getStub(cl:ClassType):ClassStub {
        return getStub(cl.name)
    }

    @private
    method determineSize(t:Type):Int {
        if t.isPrimitive {
            return t.convert()->PrimitiveType.size
        }
        def stub := getStub(t.convert()->ClassType)
        var total := 0
        def sc := stub.superclass
        if sc != null {
            total += size(sc)
        }
        for field in stub.fields.filter(f => !f.annotations.isClass &
                !f.annotations.isThread & f.kind != Variable.Kind.PROPERTY) {
            def fieldSize:Int
            if field.type.isPrimitive {
                fieldSize := size(field.type)
            }
            else {
                fieldSize := POINTER_SIZE
            }
            def align := total % fieldSize
            if align != 0 {
                total += fieldSize - align
            }
            assert total % fieldSize = 0
            total += fieldSize
        }
        return total
    }

    @private
    def sizes := HashMap<Type, Int>()
    @private
    method size(t:Type):Int {
        var result := sizes[t]
        if result = null {
            result := determineSize(t)
            sizes[t] := result
        }
        return result
    }

    @protected
    method createBlock(label:String, comment:String) {
        currentBlockLabel := label
        if debug {
            body.writeLine("; block: " + comment.replace("\n", "\n; (block cont) "))
        }
        body.writeLine(label + ":")
    }

    @protected
    function endsInBranch(s:Statement):Bit {
        if s-?>Return | s-?>Break | s-?>Continue {
            return true
        }
        if s-?>Block {
            return s->Block.endsInBranch()
        }
        return false
    }
    
    @protected
    method createLabel():String {
        nameCount += 1
        return "$label" + nameCount
    }

    @protected
    method writeTypeDescriptor(var t:Type) {
        t := t.unwrapNullable
        if !t.isPrimitive & t-!>MethodType & 
                t != NativePointerType.NATIVE_POINTER {
            writeTypeDescriptor(getStub(t.convert()->ClassType))
        }
    }
    
    @protected
    method writeTypeDescriptor(cl:ClassStub) {
        if writtenTypes.contains(cl.name) {
            return
        }
        writtenTypes.add(cl.name)
        def result := MutableString()
        if debug {
            result.append("; " + cl.name + "\n")
        }
        result.append("%" + getName(cl) + " = type { ")
        def fields := cl.instanceFields(context)
        for (i, f) in fields.enumeration {
            if i != 0 {
                result.append(", ")
            }
            if f.name = FieldNode.ELEMENTS_NAME {
                result.append(getLLVMType(f.type) + "*")
            }
            else {
                result.append(getLLVMType(f.type))
            }
        }
        if cl.name = ClassType.CLASS.name {
            -- Class is special, write out the method tables the end of its 
            -- fields
            result.append(", %$itable*, [0 x i8*]")
        }
        result.append(" }")
        header.writeLine(result)
    }

    @protected
    method createCallReference(codeString:String, comment:String):String {
        def result := getTempVariable()
        call(codeString, result, comment)
        return result
    }

    @protected
    method call(invocation:String, result:String?, comment:String?) {
        if result != null {
            body.write(result + " = ")
        }
        if tryStack.count > 0 {
            var success := createLabel()
            var fail := landingPads[tryStack.peek()]
            if fail = null {
                fail := createLabel()
                landingPads[tryStack.peek()] := fail
            }
            body.writeLine("invoke " + invocation + " to label %" + success + 
                    " unwind label %" + fail)
            createBlock(success, "invoke success")
        }
        else {
            body.write("call " + invocation)
            if debug & comment != null {
                body.writeLine("; call: " + comment.replace("\n", "\n; (call cont) "))
            }
            else {
                body.writeLine()
            }
        }
    }

    @protected
    method call(invocation:String) {
        call(invocation, null, null)
    }

    @private
    constant DIGITS := /\d+/
    @private
    function isConstant(expr:String):Bit {
        return expr.startsWith("%") | expr.matches(DIGITS)
    }

    @protected
    method createCommandReference(codeString:String, comment:String):String {
        if isConstant(codeString) {
            return codeString
        }
        def result := getTempVariable()
        writeBody(result + " = " + codeString, comment)
        return result
    }

    @protected
    method createConstructReference(construct:Construct):String {
        def targetType := construct.type
        def target := getStub(targetType.convert()->ClassType)
        def cc := getClassConstant(target)
        def cast := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody(cast + " = bitcast " + cc.type + "* @" + cc.name +
                " to " + classType, "convert class pointer")
        declarations.add("declare i8* @_pandaNew(%panda$core$Class*, i64)")
        def alloc := createCallReference("i8* @_pandaNew(" + classType + " " + 
                cast + ", i64 " + size(targetType) + ")", 
                "allocate " + targetType.name)
    
        def result := createCommandReference("bitcast i8* " + alloc + " to " + 
                getLLVMType(targetType), "convert pointer to " + 
                targetType.name)

        def parameters := construct.initCall.parameters
        def m := construct.initCall.methodStub
        def methodRef := "@" + getName(m)
        def text := MutableString("fastcc void \{methodRef}(")
        text.append(getLLVMType(targetType) + " " + result)
        for (i, p) in parameters.enumeration {
            text.append(", ")
            text.append(getTypedReference(p))
        }
        text.append(")")
        call(text.convert())
        return result
    }

    @private
    @pre(target-!>ClassLiteral)
    method getVirtualMethodReference(target:Value, index:Int, 
            type:String):String {
        -- load class constant entry
        def cl := target.type.name
        var getep := "getelementptr inbounds " + 
                getTypedReference(target) + 
                ", i32 0, i32 " + CLASS_POINTER_INDEX
        if debug {
            getep += "; get pointer to pointer to " + cl
        }
        var ep := getTempVariable()
        body.writeLine(ep + " = " + getep)
        def load := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody("\{load} = load \{classType}* \{ep}", "get pointer to " + 
                cl)
        ep := getTempVariable()
        writeBody("\{ep} = getelementptr inbounds \{classType} \{load}, " +
                "i32 0, i32 \{VTABLE_INDEX}, i32 \{index}", 
                "get pointer to pointer to \{cl}.vtable[\{index}]")
        def cast := getTempVariable()
        writeBody("\{cast} = bitcast i8** \{ep} to \{type}*", 
                "convert pointer to method pointer to correct type")
        def methodRef := getTempVariable()
        writeBody("\{methodRef} = load \{type}* \{cast}", 
                "get \{cl}.vtable[\{index}]")
        return methodRef
    }

    @private
    method getVirtualMethodReference(mc:MethodCall):String {
        def m := mc.methodStub
        def cc := getClassConstant(getStub(m.owner))
        return getVirtualMethodReference(mc.target, 
                getMethodIndex(cc, m), getLLVMMethodType(m))
    }

    @private
    method getInterfaceMethodReference(mc:MethodCall):String {
        if debug {
            body.writeLine("; get pointer to first itable entry")
        }
        def m := mc.methodStub
        def methodType := getLLVMMethodType(m)
        -- load class constant entry
        def cl := getStub(mc.target.type.convert()->ClassType)
        def enter := createLabel()
        body.writeLine("br label %" + enter)
        createBlock(enter, "itable search entrance")
        def targetRef := getTypedReference(mc.target)
        def classPointer := getTempVariable()
        writeBody(classPointer + " = getelementptr inbounds " + 
                targetRef + ", i32 0, i32 " + CLASS_POINTER_INDEX, 
                "get pointer to pointer to " + cl)
        def loadedClass := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody(loadedClass + " = load " + classType + "* " + 
                classPointer, "get pointer to " + cl.name)
        def itableFirst := getTempVariable()
        writeBody(itableFirst + " = getelementptr inbounds " + 
                classType + " " + loadedClass + ", i32 0, i32 " + ITABLE_INDEX, 
                "get pointer to first itable")
        def next := createLabel()
        body.writeLine("br label %" + next)
        def leavingEnterLabel := currentBlockLabel
        createBlock(next, "itable next")
        def itableNext := "%itableNext" + nameCount
        nameCount += 1
        def itablePtrPtr := getTempVariable()
        def fail := createLabel()
        body.writeLine(itablePtrPtr + " = phi %$itable** [ " + itableFirst +
                ", %" + leavingEnterLabel + "], [ " + itableNext + ", %" + 
                fail + " ]")
        def itablePtr := getTempVariable()
        body.writeLine(itablePtr + " = load %$itable** " + itablePtrPtr)
        def itableClassPtr := getTempVariable()
        body.writeLine(itableClassPtr + " = getelementptr inbounds %$itable* " + 
                itablePtr + ", i32 0, i32 0")
        def itableClass := getTempVariable()
        body.writeLine(itableClass + " = load " + classType + "* " + 
                itableClassPtr)
        def test := getTempVariable()
        def intfCC := getClassConstant(getStub(m.owner))
        writeBody(test + " = icmp eq " + classType + " bitcast(" + 
                intfCC.type + "* @" + 
                intfCC.name + " to " + classType + "), " + itableClass,
                "check for correct interface class")
        def success := createLabel()
        body.writeLine("br i1 " + test + ", label %" + success + ", label %" +
                fail)

        createBlock(fail, "itable test fail")
        writeBody(itableNext + " = getelementptr inbounds " + 
                "%$itable* " + itablePtr + ", i32 0, i32 1",
                "get pointer to next itable")
        body.writeLine("br label %" + next)

        createBlock(success, "itable test success")
        def methodIndex := getMethodIndex(intfCC, m)
        def methodPtrPtr := getTempVariable()
        writeBody(methodPtrPtr + " = getelementptr inbounds " +
                "%$itable* " + itablePtr + ", i32 0, i32 2, i32 " + 
                methodIndex, "get pointer to pointer to " + m.owner.name + "." + 
                m.name + ":" + m.returnType.name)
        def cast := getTempVariable()
        body.writeLine(cast + " = bitcast i8** " + methodPtrPtr +
                " to " + methodType + "*; convert pointer to method " +
                "pointer to correct type")
        def methodPtr := getTempVariable()
        writeBody(methodPtr + " = load " + methodType + "* " + cast, "get " + m)
        return methodPtr
    }

    @protected
    function getMethodIndex(cl:ClassConstant, m:MethodStub):Int {
        def result := cl.methods.indexOf(m)
        assert result != null : m + " not found in class constant"
        return result
    }

    @protected
    method createMethodCallReference(mc:MethodCall):String? {
        def m := mc.methodStub
        def methodRef:String
        if program.isEffectivelyVirtual(m) & IRGenerator.unwrapCast(mc.target)-!>Super {
            assert !m.annotations.isClass : "expected method not to be @class"
            def target := mc.target->Value
            def classStub := getStub(target.type.convert()->ClassType)
            if classStub.kind = ClassStub.Kind.INTERFACE {
                methodRef := getInterfaceMethodReference(mc)
            }
            else {
                methodRef := getVirtualMethodReference(mc)
            }
        }
        else {
            methodRef := "@" + getName(m)
        }

        def text := MutableString("fastcc \{getLLVMMethodType(m)} \{methodRef}(")
        def parameters := mc.parameters
        if !m.annotations.isClass {
            text.append(getTypedReference(mc.target->Value))
            if parameters.count > 0 {
                text.append(", ")
            }
        }
        for (i, p) in parameters.enumeration {
            if i > 0 {
                text.append(", ")
            }
            text.append(getTypedReference(p))
        }
        text.append(")")
        if mc.type = VoidType.VOID {
            call(text.convert())
            return null
        }
        else {
            return createCallReference(text.convert(), "method call")
        }
    }

    @protected
    method createVariableAssignmentReference(va:VariableAssignment):String {
        var variable := va.variable
        def lref := getLLVMType(variable.type) + "* %" + getName(variable)
        def result := getReference(va.value)
        assert result != null : 
                "expected non-null result in createVariableAssignmentReference"
        writeBody("store " + getLLVMType(variable.type) + " " + result + ", " + 
                lref, "variable assignment")
        return result
    }
    
    @private
    method getITable(cl:ClassStub):String {
        def visited := HashSet<ClassStub>()
        def interfaces := cl.type.allInterfaces(context)
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := getStub(intfType)
            if visited.contains(intf) {
                continue
            }
            visited.add(intf)
            def intfCC := getClassConstant(intf)
            def methods := cl.type.interfaceMethods(intfType, context)
            header.writeLine("; ITABLE: \{cl.name}")
            def name := "@" + getName(cl) + "$." + getName(intf)
            def type := "{ " + getLLVMType(ClassType.CLASS) + 
                    ", %$itable*, [" + methods.count + " x i8*] }"
            def result := MutableString()
            result.append(name + " = " + SHARED_LINKAGE + " constant ")
            result.append(type + " { " + 
                    getLLVMType(ClassType.CLASS) + " bitcast(" + intfCC.type + 
                    "* @" + intfCC.name + " to " + 
                    getLLVMType(ClassType.CLASS) + "), " + previous + ", [" + 
                    methods.count + " x i8*][")
            for (i, entry) in methods.enumeration {
                def m := entry.stub
                program.liveMethods.add(m)
                if i > 0 {
                    result.append(", ")
                }
                if m.annotations.isAbstract {
                    result.append("i8* null")
                }
                else {
                    result.append("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            result.append("] }")
            header.writeLine(result)
            previous := "%$itable* bitcast(" + type + "* " + name + 
                    " to %$itable*)"
        }
        return previous
    }

    @protected
    method getClassConstant(cl:ClassStub):ClassConstant {
        var name := cl.name
        var cc := classConstants[name]
        if cc = null {
            getStub(ClassType.CLASS)
            getStub(ClassType.STRING)
            def methods := Array<MethodStub>()
            for m in cl.type.virtualMethods(context) {
                methods.add(m.stub)
            }
            def className := getName(cl)
            cc := ClassConstant(
                    className + "_class",
                    "{ \{getLLVMType(ClassType.CLASS)}, \{getLLVMType(ClassType.STRING)}, \{getLLVMType(ClassType.CLASS)}, i1, i1, %$itable*, [\{methods.count} x i8*] }", 
                    methods)
            classConstants[name] := cc
            if name.startsWith("panda.core.") & name.endsWith("Wrapper") {
                name := name[0 .. name.length - "Wrapper".length]
            }
            -- go ahead and get other class constants here, before we've written
            -- anything -- this could cause other class definitions to be
            -- printed, and we don't want to be in the middle of output when
            -- that happens
            var nameRef := "<error>"
            if !cl.isExternal {
                nameRef := getStringConstantReference(name)
                for m in methods {
                    program.liveMethods.add(m)
                }
            }
            getClassConstant(getStub(ClassType.CLASS.name))

            def superclassConstant:ClassConstant?
            def superclass := cl.superclass
            if superclass != null {
                superclassConstant := getClassConstant(getStub(superclass))
            }
            else {
                superclassConstant := null
            }
            if cl.isExternal {
                header.write("@\{cc.name} = ")
                header.writeLine("external global " + cc.type)
                return cc
            }
            def intf := getITable(cl)
            def code := MutableString("@\{cc.name} = \{SHARED_LINKAGE} ")
            def superclassRef:String
            if superclassConstant != null {
                superclassRef := "bitcast(\{superclassConstant.type}* @\{superclassConstant.name} to \{getLLVMType(ClassType.CLASS)})"
            }
            else {
                superclassRef := "null"
            }
            -- class constant includes vtable. Doesn't include statics, as 
            -- those are just globals.
            var overridesFinalize := false
            for entry in cl.methods {
                def m := entry.stub
                if m.name = MethodNode.FINALIZE_NAME & 
                        !m.annotations.isClass & 
                        m.parameters.count = 1 {
                    overridesFinalize := true
                }
            }
            def classClass := getStub(ClassType.CLASS)
            def classClassConstant := getClassConstant(classClass)
            code.append("constant \{cc.type} { \{getLLVMType(ClassType.CLASS)} bitcast(\{classClassConstant.type}* @\{classClassConstant.name} to \{getLLVMType(ClassType.CLASS)}), \{getLLVMType(ClassType.STRING)} \{nameRef}, \{getLLVMType(ClassType.CLASS)} \{superclassRef}, i1 1, i1 \{overridesFinalize}, \{intf}, [\{methods.count} x i8*] [ ")
            for (i, m) in methods.enumeration {
                if i > 0 {
                    code.append(", ")
                }
                if m.annotations.isAbstract {
                    code.append("i8* null")
                }
                else {
                    code.append("i8* bitcast(\{getLLVMMethodType(m)} @\{getName(m)} to i8*)")
                }
            }
            code.append(" ] }")
            header.writeLine(code)
        }
        return cc
    }

    @private
    method getCharPrimitiveArrayConstantReference(chars:ListView<Char>):String {
        def charPrimitiveArrayClass := getStub(
                PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
        def cc := getClassConstant(charPrimitiveArrayClass)
        def charsType := "[\{chars.count} x \{getLLVMType(CharType.CHAR)}]"
        def type := "{ " + cc.type + "*, " +
                getLLVMType(IntType.INT) + ", " + 
                charsType + "* }"
        def result := "ca" + charArrayCount
        charArrayCount += 1
        def charsName := "@\{result}_chars"
        header.write(charsName + " = private unnamed_addr constant " + 
                charsType + " [")
        for (i, c) in chars.enumeration {
            if i != 0 {
                header.write(", ")
            }
            header.write(getLLVMType(CharType.CHAR) + " " + c->Int)
        }
        header.writeLine("]")

        header.writeLine("@" + result + " = private unnamed_addr constant " + 
                type + " { " + cc.type + "* @" + cc.name + ", " + 
                getLLVMType(IntType.INT) + " " + chars.count + ", " + 
                charsType + "* " + charsName + " }, align " +
                POINTER_SIZE)
        return "bitcast(" + type + "* @" + result + " to " + 
                getLLVMType(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY) + ")"
    }

    @private
    method getStringConstantReference(s:String):String {
        var result := stringConstants[s]
        if result = null {
            def string := getStub(ClassType.STRING)
            def primitiveChars := Array<Char>()
            for c in s.characters {
                primitiveChars.add(c)
            }
            def chars := getCharPrimitiveArrayConstantReference(primitiveChars)
            result := "@s" + stringConstants.count
            stringConstants[s] := result
            def charPrimitiveArrayType := PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY
            def cc := getClassConstant(string)
            if debug {
                header.writeLine("; " + StringLiteral.escape(s))
            }
            header.writeLine(result + " = private unnamed_addr constant " + 
                    '%panda$core$String { ' + 
                    getLLVMType(ClassType.CLASS) + " bitcast(" + cc.type + 
                    "* @" + cc.name + " to " + getLLVMType(ClassType.CLASS) + 
                    "), " + getLLVMType(charPrimitiveArrayType) + " " + chars + " }," +
                    " align " + POINTER_SIZE)
            stringConstants[s] := result
        }
        return result
    }

    @private
    method createOverflowCheckedBinaryOperationReference(value:BinaryOperation, 
            op:String):String {
        def typeString := getLLVMType(value.type)
        def left := getTypedReference(value.left)
        def right := getTypedReference(value.right)
        declarations.add("declare {\{typeString}, i1} @llvm.\{op}.with.overflow.\{typeString}(\{typeString} %a, \{typeString} %b)")

        def result := createCommandReference("call { " + typeString + 
                ", i1 } @llvm." + op + ".with.overflow." + typeString + "(" + 
                left + ", " + right + ")", value.convert())
                var flag := getTempVariable()
        writeBody(flag + " = extractvalue { " + typeString + 
                ", i1 } " + result + ", 1", "extract overflow flag")
        def p := value.position
        declarations.add("declare void @pandaCheckOverflow(i1)")
        call("void @pandaCheckOverflow(i1 " + flag + ")")
        return createCommandReference("extractvalue { " + typeString + 
                ", i1 } " + result + ", 0", "load results of '" + op + "'")
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation,
            var op:String):String {
        def cm := currentMethod
        assert cm != null : 
                "currentMethod unexpectedly null in createBinaryOperationReference"
        if (op = "add" | op = "sub" | op = "mul") & 
                !cm.stub.annotations.isOverflow &
                context.compilerSettings.overflowChecking &
                !b.permitOverflow {
            if b.type.isInteger & b.type->IntType.signed {
                op := "s" + op
            }
            else {
                op := "u" + op
            }
            return createOverflowCheckedBinaryOperationReference(b, op)
        }
        def left := getReference(b.left)
        def right := getReference(b.right)
        assert left != null & right != null : 
                "expected left and right to be non-null in createBinaryOperationReference"
        return createCommandReference(op + " " + getLLVMType(b.left.type) + 
                " " + left + ", " + right, "binary operation")
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation, sop:String?, 
            uop:String?, fop:String?):String {
        def operandType := b.left.type
        def op:String?
        if operandType.isReal {
            op := fop
        }
        else if operandType = CharType.CHAR | (operandType.isInteger & 
                !operandType->IntType.signed) {
            op := uop
        }
        else {
            op := sop
        }
        if op = null {
            throw CompilerException("cannot compile '" + b + 
                    "' at \{b.position}", b.position)
        }
        return createBinaryOperationReference(b, op)
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation, iop:String?, 
            fop:String?):String {
        return createBinaryOperationReference(b, iop, iop, fop)
    }

    method createPrimitiveArrayIndexValueReference(iv:PrimitiveArrayIndexValue):String {
        def ep := getPrimitiveArrayElementPointer(iv.array, iv.index)
        return createCommandReference("load \{getLLVMType(iv.type)}* \{ep}", 
                iv.convert())
    }
    
    @pre(and.kind = BinaryOperation.Kind.AND)
    method createAndReference(and:BinaryOperation):String {
        def left := getReference(and.left)
        assert left != null : "expected non-null left in createAndReference"
        def leftFromLabel := currentBlockLabel
        def rightLabel := createLabel()
        def endLabel := createLabel()
        writeBody("br i1 \{left}, label %\{rightLabel}, label %\{endLabel}",
                "and test")
        body.writeLine()
        createBlock(rightLabel, "and right")
        def right := getReference(and.right)
        assert right != null : "expected non-null right in createAndReference"
        def rightFromLabel := currentBlockLabel
        body.writeLine("br label %\{endLabel}")
        body.writeLine()
        createBlock(endLabel, "and end")
        def result := getTempVariable()
        body.writeLine("\{result} = phi i1 [false, %\{leftFromLabel}], " +
                "[\{right}, %\{rightFromLabel}]")
        return result
    }
    
    @pre(or.kind = BinaryOperation.Kind.OR)
    method createOrReference(or:BinaryOperation):String {
        def left := getReference(or.left)
        assert left != null : "expected non-null left in createOrReference"
        def leftFromLabel := currentBlockLabel
        def rightLabel := createLabel()
        def endLabel := createLabel()
        writeBody("br i1 \{left}, label %\{endLabel}, label %\{rightLabel}", 
                "or test")
        body.writeLine()
        createBlock(rightLabel, "or right")
        def right := getReference(or.right)
        assert right != null : "expected non-null right in createOrReference"
        def rightFromLabel := currentBlockLabel
        body.writeLine("br label %\{endLabel}")
        body.writeLine()
        createBlock(endLabel, "or end")
        def result := getTempVariable()
        body.writeLine("\{result} = phi i1 [true, %\{leftFromLabel}], " +
                "[\{right}, %\{rightFromLabel}]")
        return result
    }

    method createUnaryOperationReference(u:UnaryOperation):String {
        switch u.kind {
            case UnaryOperation.Kind.MINUS:
                var op:String
                var zero:Value
                if u.type.isReal {
                    op := "fsub"
                    zero := RealLiteral(Position.INTERNAL, 0)
                }
                else {
                    op := "sub"
                    zero := IntegerLiteral(Position.INTERNAL, 0)
                }
                var zeroRef := getReference(zero)
                assert zeroRef != null : "expected non-null zeroRef"
                var valueRef := getReference(u.operand)
                assert valueRef != null : "expected non-null valueRef"
                return createCommandReference(op + " " + getLLVMType(u.type) + 
                        " " + zeroRef + ", " + valueRef, "unary minus")
            case UnaryOperation.Kind.NOT:
                return createCommandReference("xor " + 
                        getTypedReference(u.operand) + ", 1", "not")
            case UnaryOperation.Kind.BITWISE_NOT:
                return createCommandReference("xor " + 
                        getTypedReference(u.operand) + ", -1", "bitwise not")
            default: unreachable
        }
    }

    method createNewPrimitiveArrayWithLengthReference(na:NewPrimitiveArrayWithLength):String {
        def arrayClass := getStub(na.type.convert()->ClassType)
        def cc := getClassConstant(arrayClass)
        def cast := getTempVariable()
        def elementType := na.type.convert()->PrimitiveArrayType.elementType
        def classType := getLLVMType(ClassType.CLASS)
        writeBody("\{cast} = bitcast \{cc.type}* @\{cc.name} to \{classType}",
                "convert class pointer")
        def ref := getReference(na.arrayLength)
        assert ref != null : "expected non-null ref in createNewPrimitiveArrayWithLengthReference"
        declarations.add("declare i8* @pandaNewPrimitiveArrayWithLength(" + 
                getLLVMType(ClassType.CLASS) + ", " + 
                getLLVMType(IntType.INT) + ", " +
                getLLVMType(IntType.INT) + ", " +
                getLLVMType(BitType.BIT) + ")")
        def alloc := createCallReference(
                "i8* @pandaNewPrimitiveArrayWithLength(\{classType} \{cast}, " + 
                "\{getLLVMType(IntType.INT)} \{ref}, " +
                "\{getLLVMType(IntType.INT)} \{size(elementType)}, i1 " +
                !elementType.isPrimitive + ")", "allocate " + na.type.name)
        def result := createCommandReference("bitcast i8* \{alloc} to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }
    
    method createPrimitiveArrayCopyReference(na:PrimitiveArrayCopy):String {
        def arrayClass := getStub(na.type->PrimitiveArrayType)
        def cc := getClassConstant(arrayClass)
        def cast := getTempVariable()
        def elementType := na.type->PrimitiveArrayType.elementType
        def classType := getLLVMType(ClassType.CLASS)
        writeBody("\{cast} = bitcast \{cc.type}* @\{cc.name} to \{classType}", 
                "convert class pointer")
        def rawPrimitiveArray := getTypedReference(na.array)
        def arrayCast := getTempVariable()
        writeBody("\{arrayCast} = bitcast \{rawPrimitiveArray} to " + 
                getLLVMType(ClassType.PRIMITIVE_ARRAY), 
                "cast array pointer to PrimitiveArray")
        declarations.add("declare i8* @pandaNewPrimitiveArrayCopy(" + 
                getLLVMType(ClassType.CLASS) + ", " + 
                getLLVMType(ClassType.PRIMITIVE_ARRAY) + ", " + 
                getLLVMType(IntType.INT) + ", " +
                getLLVMType(BitType.BIT) + ")")
        def alloc := createCallReference("i8* " +
                "@pandaNewPrimitiveArrayCopy(\{classType} \{cast}, " + 
                "\{getLLVMType(ClassType.PRIMITIVE_ARRAY)} \{arrayCast}, " +
                "i64 \{size(elementType)}, i1 \{!elementType.isPrimitive})", 
                "allocate \{na.type.name}")
        var result := createCommandReference("bitcast i8* \{alloc} to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }
       
    method createNewPrimitiveArrayWithValuesReference(na:NewPrimitiveArrayWithValues):String {
        def elementType := na.type->PrimitiveArrayType.elementType
        def arrayClass := getStub(na.type->PrimitiveArrayType)
        def cc := getClassConstant(arrayClass)
        def cast := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody(cast + " = bitcast " + cc.type + "* @" + cc.name +
                " to " + classType, "convert class pointer")
        def type:Int
        constant ARRAY_INT8   := 0
        constant ARRAY_INT16  := 1
        constant ARRAY_INT32  := 2
        constant ARRAY_INT64  := 3
        constant ARRAY_REAL32 := 4
        constant ARRAY_REAL64 := 5
        constant ARRAY_PTR    := 6
        switch elementType {
            case IntType.INT8, IntType.UINT8, BitType.BIT: 
                type := ARRAY_INT8

            case IntType.INT16, IntType.UINT16, CharType.CHAR: 
                type := ARRAY_INT16

            case IntType.INT32, IntType.UINT32: 
                type := ARRAY_INT32

            case IntType.INT64, IntType.UINT64: 
                type := ARRAY_INT64

            case RealType.REAL32: 
                type := ARRAY_REAL32

            case RealType.REAL64: 
                type := ARRAY_REAL64

            default:
                type := ARRAY_PTR
        }
        def references := Array<String>()
        for v in na.values {
            var raw := getTypedReference(v)
            if type = ARRAY_REAL32 {
                -- varargs requires promotion of float to double, and evidently
                -- we have to do it ourselves
                references.add("double " + createCommandReference("fpext " + 
                        raw + " to double", "varargs promotion"))
            }
            else {
                references.add(raw)
            }
        }
        declarations.add("declare i8* @pandaNewPrimitiveArrayWithValues(" + 
                getLLVMType(ClassType.CLASS) + ", " + 
                getLLVMType(IntType.INT) + ", " + 
                getLLVMType(IntType.INT) + ", ...)")
        def code := MutableString("i8* (\{classType}, i64, i64, ...)* " +
                "@pandaNewPrimitiveArrayWithValues(\{classType} \{cast}, i64 " + 
                "\{na.values.count}, i64 \{type}")
        for r in references {
            code.append(", ")
            code.append(r)
        }
        code.append(")")
        def alloc := createCallReference(code.convert(), "allocate " + 
                na.type.name)
        def result := createCommandReference("bitcast i8* \{alloc} to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }

    @protected
    method createBinaryOperationReference(b:BinaryOperation):String {
        switch b.kind {
            case BinaryOperation.Kind.ADD: 
                return createBinaryOperationReference(b, "add", "fadd")
            case BinaryOperation.Kind.SUBTRACT:
                return createBinaryOperationReference(b, "sub", "fsub")
            case BinaryOperation.Kind.MULTIPLY: 
                return createBinaryOperationReference(b, "mul", "fmul")
            case BinaryOperation.Kind.DIVIDE: 
                return createBinaryOperationReference(b, null, "fdiv")
            case BinaryOperation.Kind.INT_DIVIDE:
                var op:String
                if b.type->IntType.signed {
                    op := "sdiv"
                }
                else {
                    op := "udiv"
                }
                return createBinaryOperationReference(b, op, null)
            case BinaryOperation.Kind.REMAINDER: 
                return createBinaryOperationReference(b, "srem", "urem", null)
            case BinaryOperation.Kind.SHIFT_LEFT: 
                return createBinaryOperationReference(b, "shl", null)
            case BinaryOperation.Kind.SHIFT_RIGHT:
                if b.type->IntType.signed {
                    return createBinaryOperationReference(b, "ashr", null)
                }
                else {
                    return createBinaryOperationReference(b, "lshr", null)
                }
            case BinaryOperation.Kind.AND: 
                return createAndReference(b)
            case BinaryOperation.Kind.OR:
                return createOrReference(b)
            case BinaryOperation.Kind.XOR: 
                return createBinaryOperationReference(b, "xor", null)
            case BinaryOperation.Kind.BITWISE_AND: 
                return createBinaryOperationReference(b, "and", null)
            case BinaryOperation.Kind.BITWISE_OR: 
                return createBinaryOperationReference(b, "or", null)
            case BinaryOperation.Kind.BITWISE_XOR: 
                return createBinaryOperationReference(b, "xor", null)
            case BinaryOperation.Kind.EQUAL: 
                return createBinaryOperationReference(b, "icmp eq", "fcmp oeq")
            case BinaryOperation.Kind.IDENTITY: 
                return createBinaryOperationReference(b, "icmp eq")
            case BinaryOperation.Kind.LESS_THAN:
                return createBinaryOperationReference(b, "icmp slt", "icmp ult", 
                        "fcmp olt")
            case BinaryOperation.Kind.GREATER_THAN:
                return createBinaryOperationReference(b, "icmp sgt", "icmp ugt",
                        "fcmp ogt")
            case BinaryOperation.Kind.LESS_THAN_OR_EQUAL:
                return createBinaryOperationReference(b, "icmp sle", "icmp ule",
                        "fcmp ole")
            case BinaryOperation.Kind.GREATER_THAN_OR_EQUAL:
                return createBinaryOperationReference(b, "icmp sge", "icmp uge",
                        "fcmp oge")
            case BinaryOperation.Kind.NOT_EQUAL:
                return createBinaryOperationReference(b, "icmp ne", "fcmp one")
            case BinaryOperation.Kind.NOT_IDENTITY:
                return createBinaryOperationReference(b, "icmp ne")
            default:
                Console.writeLine("no support for binary operation \{b.kind}")
                unreachable
        }
    }

    @private
    method callClassInit(cl:ClassStub) {
        if currentMethod->MethodNode.stub.name = MethodNode.CLASS_INIT_NAME &
                currentMethod->MethodNode.stub.owner = cl.type {
            return
        }
        def classInit := cl.methods.filter(
                m => m.stub.name = MethodNode.CLASS_INIT_NAME)
        assert classInit.count = 1 : "expected exactly one method named " +
                "'\{MethodNode.CLASS_INIT_NAME} in \{cl}, found " +
                classInit.count
        def stub := classInit.iterator.next().stub
        call("fastcc void @\{getName(stub)}()")
        program.liveMethods.add(stub)
    }
    
    @protected
    @pre(!object.type.isPrimitive)
    @pre(!field.annotations.isThread)
    method getFieldPointer(object:Value, field:FieldNode):String {
        if field.annotations.isClass {
            if field.name != FieldNode.CLASS_INITED_NAME {
                callClassInit(getStub(field.owner))
            }
            return "@" + getName(field)
        }
        else {
            def cl := getStub(object.type.convert()->ClassType)
            def fields := cl.instanceFields(context)
            for (i, f) in fields.enumeration {
                if f = field {
                    return createCommandReference("getelementptr inbounds " + 
                        getTypedReference(object) + 
                        ", i32 0, i32 " + i, "field pointer")
                }
            }
            unreachable : "could not find field \{field} in \{cl}"
        } 
    }

    @protected
    method createFieldReference(fr:FieldReference):String {
        if fr.field.annotations.isThread {
            def owner := fr.field.owner
            callClassInit(context.getStub(owner))
            var type := fr.type
            def suffix:String
            if type.isPrimitive {
                suffix := fr.type.name["panda.core.".length..]
            }
            else {
                suffix := "Object"
                type := ClassType.OBJECT
            }

            def threadLocalId := getTempVariable()
            def symbolTable := context.getSymbolTable(owner)
            def indexField := symbolTable[fr.field.name + 
                    StubGenerator.INDEX_SUFFIX]->FieldNode
            body.writeLine("load i64* @" + getName(indexField))
            def callString := MutableString("fastcc " + getLLVMType(type) + 
                    " @panda$core$Panda$getThreadLocal" + suffix + 
                    "(i64 " + threadLocalId + ", ")
            def stub := getStub(Panda.name).symbols["getThreadLocal" + 
                    suffix]->Methods.entries[0].stub
            program.liveMethods.add(stub)
            def initializer := symbolTable[
                        IRGenerator.getThreadLocalInitializerName(fr.field)
                    ]->Methods?
            if initializer != null {
                callString.append(
                        getLLVMType(NativePointerType.NATIVE_POINTER) + 
                        " bitcast(" + getLLVMType(fr.type) + "()* @" + 
                        getName(initializer.entries[0].stub) + " to " + 
                        getLLVMType(NativePointerType.NATIVE_POINTER) + "))")
                program.liveMethods.add(initializer.entries[0].stub)
            }
            else {
                callString.append("i8* null)") -- no initializer function
            }
            var ref := createCallReference(callString.convert(), "get field")
            if !fr.type.isPrimitive & fr.type != ClassType.OBJECT {
                def cast := getTempVariable()
                writeBody(cast + " = bitcast " + 
                        getLLVMType(type) + " " + ref + " to " + 
                        getLLVMType(fr.type), "cast Object to threadlocal")
                ref := cast
            }
            return ref
        }
        def ep := getFieldPointer(fr.object, fr.field)
        return createCommandReference(
                "load \{getLLVMType(fr.field.type)}* \{ep}", "get field")
    }

    @protected
    method createCastReference(c:Cast):String? {
        def tempResult := getReference(c.value)
        assert tempResult != null : 
                "expected non-null tempResult in createCastReference"
        def actualType := c.value.type
        def destType := c.type
        if actualType = destType {
            return tempResult
        }
        def actualSize := size(actualType)
        def destSize := size(destType)
        var command:String? := null
        if actualSize = destSize & 
                (actualType.isInteger | actualType = CharType.CHAR) & 
                (destType.isInteger | destType = CharType.CHAR) {
            -- actual bits aren't changing, just the logical type
            return tempResult
        }
        if actualType.isInteger & (destType.isInteger | 
                destType = CharType.CHAR) {
            if actualSize > destSize {
                -- int narrowing
                command := "trunc"
            }
            else if actualType->IntType.signed {
                -- signed int widening
                command := "sext"
            }
            else {
                -- unsigned int widening
                command := "zext"
            }
        }
        else if actualType.isReal & destType.isReal {
            if actualSize > destSize {
                -- real64 ->> real32
                command := "fptrunc"
            }
            else {
                -- real32 ->> real64
                command := "fpext"
            }
        }
        else if actualType.isReal & destType.isInteger {
            -- real to signed int
            command := "fptosi"
        }
        else if actualType.isInteger & destType.isReal {
            if actualType->IntType.signed {
                -- signed int to real
                command := "sitofp"
            }
            else {
                -- unsigned int to real
                command := "uitofp"
            }
        }
        else if actualType = CharType.CHAR & destType.isInteger {
            if actualSize > destSize {
                -- char narrowing
                command := "trunc"
            }
            else {
                -- char widening
                command := "zext"
            }
        }
        else if actualType.isReal & destType = CharType.CHAR {
            -- real to char
            command := "fptoui"
        }
        else if actualType = CharType.CHAR & destType.isReal {
            -- char to real
            command := "uitofp"
        }
     
        if command != null {
            def result := getTempVariable()
            body.writeLine(result + " = " + command + " " + 
                    getLLVMType(actualType) + " " + tempResult + 
                    " to " + getLLVMType(destType), "cast")
            return result
        }
        else {
            -- casting one type of object to another, can simply bitcast the
            -- pointer
            assert !actualType.isPrimitive : 
                    "expected actualType to not be primitive"
            assert !destType.isPrimitive :
                    "expected destType to not be primitive"
            if !c.safe & context.compilerSettings.checkCasts {
                def params := [Dummy(c.position, actualType), 
                        ClassLiteral(c.position, destType.unwrapNullable), 
                        BitLiteral(c.position, destType.isNullable)]
                def check := context.getMethod(
                        ClassLiteral(c.position, ClassType.PANDA),
                        "checkCast", params, VoidType.VOID)
                assert check != null : "expected check to be non-null"
                program.liveMethods.add(check)
                for i in 1 .. params.count {
                    getTypedReference(params[i])
                }
                var intermediate := tempResult
                if actualType != ClassType.OBJECT {
                    intermediate := getTempVariable()
                    writeBody(intermediate + " = bitcast " + 
                            getLLVMType(actualType) + " " + tempResult + 
                            " to " + getLLVMType(ClassType.OBJECT),
                            c.value + " -> " + ClassType.OBJECT.name)
                }
                var callString := MutableString("fastcc void @" + 
                        getName(check) + "(")
                callString.append(getLLVMType(ClassType.OBJECT) + " " + 
                        intermediate)
                for i in 1 .. params.count {
                    callString.append(", ")
                    callString.append(getTypedReference(params[i]))
                }
                callString.append(")")
                call(callString.convert(), null, "check cast " + c + ":" + 
                        c.position)
            }
            def actualLLVMType := getLLVMType(actualType)
            def destLLVMType := getLLVMType(destType)
            if actualLLVMType = destLLVMType {
                return tempResult
            }
            def result := getTempVariable()
            writeBody("\{result} = bitcast \{actualLLVMType} \{tempResult} " +
                    " to \{destLLVMType}", "cast")
            return result
        }
    }
    
    @protected
    method createVariableReference(vr:VariableReference):String {
        def variable := vr.variable
        if variable-?>Parameter & variable.kind = Variable.Kind.DEF {
            return "%" + getName(variable)
        }
        return createCommandReference("load " + getLLVMType(vr.type) + "* %" + 
                getName(variable) + "; \{variable.class.name}", vr.convert())
    }
        
    @protected
    method createSuperReference(s:Super):String {
        return "%self"
    }

    @protected
    method createReusedValueDefinitionReference(rvd:ReusedValueDefinition):String {
        def result := getReference(rvd.value)
        assert result != null : "null reference for ReusedValueDefinition " + rvd
        references[rvd] := result
        return result
    }

    @protected
    method createReusedValueReference(rv:ReusedValue):String {
        def result := references[rv.owner]
        assert result != null : "null reference for ReusedValue owner " + rv
        return result
    }

    @protected
    @math(overflow)
    method createRealLiteralReference(r:RealLiteral):String {
        var bits := Panda.real64Bits(r.value).convert()->UInt64
        -- LLVM's float representation is completely insane -- it's not a float,
        -- it's a double with the 29 low-order bits zeroed
        if r.type = RealType.REAL32 {
            bits := bits && ((-1)->UInt64 << 29->UInt64)
        }
        return "0x\{bits,0>16:h}"
    }
    
    @protected
    method createMethodReference(m:MethodReference):String? {
        def stub := m.methodStub
        var methodValue := methodReferences[stub]
        if methodValue = null {
            methodValue := "@" + getName(stub) + "_value"
            def methodClass := m.type.convert()->ClassType
            def cc := getClassConstant(getStub(methodClass))
            header.writeLine("\{methodValue} = private unnamed_addr " +
                    "constant %\{getName(getStub(methodClass))} { " + 
                    "\{getLLVMType(ClassType.CLASS)} bitcast(\{cc.type}" + 
                    "* @\{cc.name} to \{getLLVMType(ClassType.CLASS)}" + 
                    "), i8* bitcast(\{getLLVMMethodType(stub)} @" + 
                    "\{getName(stub)} to i8*) }, " +
                    "align \{POINTER_SIZE}")
            methodReferences[stub] := methodValue
        }
        return methodValue
    }

    @protected
    method createDynamicCallReference(d:DynamicCall):String? {
        def methodValue := getTypedReference(d.methodValue)
        def object := getClassConstant(getStub(ClassType.METHOD))
        var offset := object.methods.count
        -- the "real" type of the method includes a reference to the method 
        -- object before the formal parameters
        def baseType := d.methodValue.type.convert()->MethodType
        def realParameters := Array<Type>()
        realParameters.add(baseType)
        realParameters.addAll(baseType.methodParameters)
        def realType := MethodType(realParameters, baseType.returnType, 
                baseType.isMethod, baseType.immutableMethod)
        def methodPtr := getVirtualMethodReference(d.methodValue, offset,
                getLLVMMethodType(realType))
        def c := MutableString("fastcc ")
        c.append(getLLVMMethodType(realType))
        c.append(" ")
        c.append(methodPtr)
        c.append("(")
        c.append(getTypedReference(d.methodValue))
        for (i, p) in d.parameters.enumeration {
            c.append(", ")
            c.append(getTypedReference(p))
        }
        c.append(")")
        def result:String?
        if d.type = VoidType.VOID {
            result := null
        }
        else {
            result := getTempVariable()
        }
        call(c.convert(), result, "dynamic call")
        return result
    }

    @protected
    method createClassLiteralReference(cl:ClassLiteral):String {
        def stub := getStub(cl.value)
        def cc := getClassConstant(stub)
        def classType := getLLVMType(ClassType.CLASS)
        return "bitcast(\{cc.type}* @\{cc.name} to \{classType})"
    }

    @protected
    method createClosureReference(c:Closure):String {
        def cast := Cast(c.position, c.instance, c.type, Cast.Kind.IMPLICIT)
        cast.safe := true
        return createCastReference(cast)
    }

    @protected
    method createSkippedValueReference(s:SkippedValue):String {
        getReference(s.discardedValue)
        return getReference(s.actualValue)
    }

    -- return value is nullable so void expressions (method calls) can return
    -- null
    @protected
    method createReference(v:Value):String? {
        switch v.class {
            case VariableAssignment: return createVariableAssignmentReference(v->VariableAssignment)
            case UnaryOperation: return createUnaryOperationReference(v->UnaryOperation)
            case BinaryOperation: return createBinaryOperationReference(v->BinaryOperation)
            case Construct: return createConstructReference(v->Construct)
            case MethodCall: return createMethodCallReference(v->MethodCall)
            case StringLiteral: return getStringConstantReference(v->StringLiteral.value)
            case IntegerLiteral: return v->IntegerLiteral.value.convert()
            case RealLiteral: return createRealLiteralReference(v->RealLiteral)
            case VariableReference: return createVariableReference(v->VariableReference)
            case FieldReference: return createFieldReference(v->FieldReference)
            case Cast: return createCastReference(v->Cast)
            case BitLiteral: return v->BitLiteral.value.convert()
            case NewPrimitiveArrayWithLength: return createNewPrimitiveArrayWithLengthReference(v->NewPrimitiveArrayWithLength)
            case PrimitiveArrayCopy: return createPrimitiveArrayCopyReference(v->PrimitiveArrayCopy)
            case NewPrimitiveArrayWithValues: return createNewPrimitiveArrayWithValuesReference(v->NewPrimitiveArrayWithValues)
            case PrimitiveArrayIndexValue: return createPrimitiveArrayIndexValueReference(v->PrimitiveArrayIndexValue)
            case NullLiteral: return "null"
            case ClassLiteral: return createClassLiteralReference(v->ClassLiteral)
            case Unwrap: return createReference(v->Unwrap.value)
            case MethodReference: return createMethodReference(v->MethodReference)
            case DynamicCall: return createDynamicCallReference(v->DynamicCall)
            case ReusedValueDefinition: return createReusedValueDefinitionReference(v->ReusedValueDefinition)
            case ReusedValue: return createReusedValueReference(v->ReusedValue) 
            case Super: return createSuperReference(v->Super)
            case Closure: return createClosureReference(v->Closure)
            case SkippedValue: return createSkippedValueReference(v->SkippedValue)
            default:
                throw CompilerException("unsupported value class: " + 
                        "\{v.class.name}: \{v}", v.position)
        }
    }

    @protected
    method getTypedReference(v:Value):String {
        def ref := getReference(v)
        assert ref != null : "expected non-null ref in getTypedReference"
        return getLLVMType(v.type) + " " + ref
    }

    @protected
    method getReference(v:Value):String? {
        var result := references[v]
        if result = null {
            result := createReference(v)
            if result != null {
                references[v] := result
            }
        }
        return result
    }
    
    @protected
    method generateValueStatementCode(v:ValueStatement) {
        getReference(v.value)
    }

    @pre(array.type.isPrimitiveArray)
    @pre(index.type = IntType.INT)
    method getPrimitiveArrayElementPointer(array:Value, index:Value):String {
        def arrayRef := getTypedReference(array)
        def indexRef := getTypedReference(index)
        if context.compilerSettings.boundsChecking {
            def cast := getTempVariable()
            def arrayType := getLLVMType(ClassType.PRIMITIVE_ARRAY)
            body.writeLine("\{cast} = bitcast \{arrayRef} to \{arrayType}")
            declarations.add("declare void @pandaCheckBounds(\{getLLVMType(ClassType.PRIMITIVE_ARRAY)}, i64)")
            call("void @pandaCheckBounds(\{arrayType} \{cast}, \{indexRef})")
        }
        def arrayContentsPointer := createCommandReference("getelementptr " +
                "inbounds \{arrayRef}, i32 0, i32 \{ARRAY_CONTENTS_INDEX}", 
                "get pointer to pointer to array contents")
        def elementType := array.type.convert()->PrimitiveArrayType.elementType
        def arrayContents := createCommandReference("load " + 
                getLLVMType(elementType) + 
                "** " + arrayContentsPointer, 
                "get pointer to array contents")
        return createCommandReference("getelementptr inbounds " + 
                "\{getLLVMType(elementType)}* \{arrayContents}, \{indexRef}", 
                "primitive array element pointer")
    }

    @protected
    method generatePrimitiveArrayIndexAssignmentCode(ia:PrimitiveArrayIndexAssignment) {
        def ep := getPrimitiveArrayElementPointer(ia.array, ia.index)
        def elementType := ia.array.type.convert()->PrimitiveArrayType.elementType
        def lref := getLLVMType(elementType) + "* " + ep
        def ref := getReference(ia.value) 
        assert ref != null : "expected non-null ref in generateIndexAssignmentCode"
        writeBody("store \{getLLVMType(elementType)} \{ref}, \{lref}", 
                "primitive array []:=")
    }
    
    @protected
    method generateFieldAssignmentCode(fa:FieldAssignment) {
        if !fa.fieldNode.annotations.isThread {
            def ep := getFieldPointer(fa.object, fa.fieldNode)
            def lref := getLLVMType(fa.fieldNode.type) + "* " + ep
            def vref := getReference(fa.value)
            assert vref != null : "expected non-null vref in generateFieldAssignmentCode"
            writeBody("store \{getLLVMType(fa.fieldNode.type)} \{vref}, " + 
                    lref, "field assignment")
        }
        else {
            def owner := context.getStub(fa.fieldNode.owner)
            callClassInit(owner)
            def threadLocalId := getTempVariable()
            def indexField := owner.symbols[fa.fieldNode.name + 
                    StubGenerator.INDEX_SUFFIX]->Variable
            body.writeLine("load i64* @" + getName(indexField))
            var ref := getReference(fa.value)
            assert ref != null : "expected non-null ref in generateFieldAssignmentCode"
            if !fa.value.type.isPrimitive & 
                    fa.value.type != ClassType.OBJECT {
                var cast := getTempVariable()
                writeBody(cast + " = bitcast " + 
                        getLLVMType(fa.value.type) + " " + ref + " to " + 
                        getLLVMType(ClassType.OBJECT), 
                        "cast threadlocal to Object")
                ref := getLLVMType(ClassType.OBJECT) + " " + cast
            }
            else {
                ref := getLLVMType(fa.value.type) + " " + ref
            }
            var suffix:String
            if fa.value.type.isPrimitive {
                suffix := fa.value.type.name["panda.core.".length..]
            }
            else {
                suffix := "Object"
            }
            call("fastcc void @panda$core$Panda$setThreadLocal" + 
                    suffix + "(i64 " + threadLocalId + ", " + ref + ")")
            def stub := getStub(Panda.name).symbols["setThreadLocal" + 
                    suffix]->Methods.entries[0].stub
            program.liveMethods.add(stub)
        }
    }

    @protected
    method generateIfCode(i:If) {
        def ifLabel := createLabel()
        def elseLabel := createLabel()
        def endLabel:String
        if i.elseStatement != null {
            endLabel := createLabel()
        }
        else {
            endLabel := elseLabel
        }
        writeBody("br " + getTypedReference(i.test) + 
                ", label %" + ifLabel + ", label %" + elseLabel, 
                "if test")
        body.writeLine()
        createBlock(ifLabel, "then")
        generateStatementCode(i.thenStatement)
        if !endsInBranch(i.thenStatement) {
            writeBody("br label %" + endLabel, "then -> end")
        }
        body.writeLine()
        def elseStatement := i.elseStatement
        if elseStatement != null {
            createBlock(elseLabel, "else")
            generateStatementCode(elseStatement)
            if !endsInBranch(elseStatement) {
                writeBody("br label %" + endLabel, "else -> end")
            }
            body.writeLine()
        }
        createBlock(endLabel, "end if")
    }

    @protected
    method generateReturnCode(ret:Return) {
        def value := ret.value
        if value = null {
            body.writeLine("ret void ; " + ret)
        }
        else {
            body.writeLine("ret " + getTypedReference(value))
        }
    }
    
    @protected
    method generateWhileCode(w:While) {
        loops.push(w)
        def bodyLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[w] := nextLabel
        endLabels[w] := endLabel
        body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "while next")
        writeBody("br " + getTypedReference(w.test) + 
                ", label %" + bodyLabel + ", label %" + endLabel,
                "while test")
        body.writeLine()
        createBlock(bodyLabel, "while body")
        generateStatementCode(w.statement)
        if !endsInBranch(w.statement) {
            body.writeLine("br label %" + nextLabel)
        }
        body.writeLine()
        createBlock(endLabel, "while end")
        loops.pop()
    }
    @post(loops.count = @pre(loops.count))

    @protected
    method generateDoCode(d:Do) {
        loops.push(d)
        def bodyLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[d] := nextLabel
        endLabels[d] := endLabel
        body.writeLine("br label %" + bodyLabel)
        body.writeLine()
        createBlock(bodyLabel, "do body")
        generateStatementCode(d.statement)
        if !endsInBranch(d.statement) {
            body.writeLine("br label %" + nextLabel)
        }
        body.writeLine()
        createBlock(nextLabel, "do next")
        writeBody("br " + getTypedReference(d.test) + 
                ", label %" + bodyLabel + ", label %" + endLabel,
                "do test")
        body.writeLine()
        createBlock(endLabel, "do end")
        loops.pop()
    }
    @post(loops.count = @pre(loops.count))

    @protected
    method generateLoopCode(l:Loop) {
        loops.push(l)
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[l] := nextLabel
        endLabels[l] := endLabel
        body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "loop next")
        generateStatementCode(l.statement)
        if !endsInBranch(l.statement) {
            body.writeLine("br label %" + nextLabel)
        }
        body.writeLine()
        createBlock(endLabel, "loop end")
        loops.pop()
    }
    @post(loops.count = @pre(loops.count))

    @protected
    method generateLoopWithContinueBlockCode(l:LoopWithContinueBlock) {
        loops.push(l)
        def startLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[l] := nextLabel
        endLabels[l] := endLabel
        body.writeLine("br label %" + startLabel)
        body.writeLine()
        createBlock(startLabel, "loop start")
        generateStatementCode(l.statement)
        if !endsInBranch(l.statement) {
            body.writeLine("br label %" + nextLabel)
        }
        createBlock(nextLabel, "loop next")
        generateBlockCode(l.continueBlock)
        assert !endsInBranch(l.continueBlock) : "expected loop to not end in " +
                "branch in generateLoopWithContinueBlockCode"
        body.writeLine("br label %" + startLabel)
        body.writeLine()
        createBlock(endLabel, "loop end")
        loops.pop()
    }
    @post(loops.count = @pre(loops.count))

    function findLoop(label:String?):AbstractLoop {
        if label = null {
            return loops.peek()
        }
        for i in 0 .. loops.count {
            if loops.peek(i).label = label {
                return loops.peek(i)
            }
        }
        unreachable
    }

    @protected
    method generateBreakCode(br:Break) {
        def loopNode := findLoop(br.label)
        def endLabel := endLabels[loopNode]
        assert endLabel != null : "expected non-null endLabel in generateBreakCode"
        writeBody("br label %" + endLabel, br.convert())
    }

    @protected
    method generateContinueCode(c:Continue) {
        def loopNode := findLoop(c.label)
        def nextLabel := nextLabels[loopNode]
        assert nextLabel != null : "expected non-null nextLabel in generateContinueCode"
        writeBody("br label %" + nextLabel, c.convert())
    }

    @protected
    method generateAssertCode(a:Assert) {
        def succeedLabel := createLabel()
        def failLabel := createLabel()
        writeBody("br \{getTypedReference(a.test)}, label %\{succeedLabel}, " +
                "label %\{failLabel}", "assert test")
        body.writeLine()
        program.liveMethods.add(getStub(Panda.name).symbols["failAssert"]->Methods.entries[0].stub)
        createBlock(failLabel, "assert fail")
        var error := a.error
        if error != null {
            if error.type = ClassType.STRING {
                call("void \{FAIL_ASSERT_NAME}(\{getTypedReference(error)})")
            }
            else {
                assert error.type = ClassType.ERROR : 
                        "expected msg.type = ERROR but found \{error.type}"
                declarations.add("declare void @pandaThrow(\{getLLVMType(ClassType.ERROR)})")
                call("void @pandaThrow(\{getTypedReference(error)})")
            }
        }
        else {
            call("void \{FAIL_ASSERT_NAME}(\{getLLVMType(ClassType.STRING)}" +
                    " null)")
        }
        body.writeLine("unreachable")
        body.writeLine()
        createBlock(succeedLabel, "assert success")
    }
    
    @protected
    method generateUnreachableCode(u:Unreachable) {
        generateAssertCode(Assert(u.position, BitLiteral(u.position, false),
                u.error))
    }

    @protected
    method generateTryCode(t:Try) {
        def exitLabel := createLabel()
        tryStack.push(t)
        generateStatementCode(t.statement)
        tryStack.pop()
        if !endsInBranch(t.statement) {
            body.writeLine("br label %" + exitLabel)
        }
        def classType := getLLVMType(ClassType.CLASS)
        def objectType := getLLVMType(ClassType.OBJECT)
        def errorType := getLLVMType(ClassType.ERROR)
        def lpLabel := landingPads[t]
        def catchLabels := HashMap<Catch, String>()
        def catchTestLabels := HashMap<Catch, String>()
        if lpLabel != null {
            -- set up landing pad
            createBlock(lpLabel, "landing pad")
            def landingPad := getTempVariable()
            declarations.add("declare i32 @pandaPersonality(...)")
            body.writeLine(landingPad + 
                    " = landingpad { i8*, i32 } personality i8* bitcast " +
                    "(i32 (...)* @pandaPersonality to i8*)")
            body.level += 1
            for c in t.catches {
                catchTestLabels[c] := createLabel()
                def catchClass := getStub(c.error.type->ClassType)
                def cc := getClassConstant(catchClass)
                body.writeLine("catch i8* bitcast (" + cc.type + 
                        "* @" + cc.name + " to i8*)")
            }
            body.level -= 1
            
            -- get exception
            def nativeException := getTempVariable()
            body.writeLine(nativeException + 
                    " = extractvalue { i8*, i32 } " + landingPad + 
                    ", 0")
            def error := getTempVariable()
            declarations.add("declare \{getLLVMType(ClassType.ERROR)} @pandaCatch(i8*)")
            body.writeLine(error + 
                    " = call " + errorType + " @pandaCatch(i8* " + 
                    nativeException + ")")
            def errorObject := getTempVariable()
            body.writeLine(errorObject + " = bitcast " + errorType + 
                    " " + error + " to " + objectType)

            -- run through each catch type, checking to see if we have the right
            -- kind of variable
            def resumeLabel := createLabel()
            var first := true
            for (i, c) in t.catches.enumeration {
                if first {
                    if debug {
                        body.writeLine("; catch test for " + 
                                c.error.type.name)
                    }
                }
                else {
                    createBlock(catchTestLabels[c]->String,
                            "catch test for " + c.error.type.name)
                }
                first := false
                def catchLabel := createLabel()
                catchLabels[c] := catchLabel
                def catchClass := getStub(c.error.type->ClassType)
                def catchClassConstant := getClassConstant(catchClass)
                def test := getTempVariable()
                body.writeLine(test + 
                        " = call i1 " +
                        "@panda$core$Panda$instanceOf(" + 
                        objectType + " " + errorObject + ", " + classType + 
                        " bitcast(" + catchClassConstant.type + "* @" + 
                        catchClassConstant.name + " to " + classType + 
                        "), i1 0)")
                program.liveMethods.add(getStub(ClassType.PANDA).symbols[
                        "instanceOf"]->Methods.entries[0].stub)
                def nextLabel:String
                if i < t.catches.count - 1 {
                    nextLabel := catchTestLabels[t.catches[i + 1]]
                }
                else {
                    nextLabel := resumeLabel
                }
                -- either branch to the catch for this type or to the next
                -- test
                body.writeLine("br i1 " + test + ", label %" + 
                        catchLabel + ", label %" + nextLabel)
            }
            -- handle no match case
            createBlock(resumeLabel, "no match, re-throw")
            body.writeLine("resume { i8*, i32 } " + landingPad)
            
            -- write actual catch blocks
            for c in t.catches {
                createBlock(catchLabels[c]->String, "catch " + 
                        c.error.type.name)
                -- cast error to the right type and store it in its
                -- respective variable
                def cast := getTempVariable()
                body.writeLine(cast + " = bitcast " + errorType +
                        " " + error + " to " + 
                        getLLVMType(c.error.type))
                body.writeLine("store " + getLLVMType(c.error.type) + 
                        " " + cast + ", " + getLLVMType(c.error.type) + 
                        "* %" + getName(c.error))
                generateStatementCode(c.statement)
                if !endsInBranch(c.statement) {
                    body.writeLine("br label %" + exitLabel)
                }
            }
        }
        createBlock(exitLabel, "after try")
    }


    @protected
    method generateThrowCode(t:Throw) {
        declarations.add("declare void @pandaThrow(\{getLLVMType(ClassType.ERROR)})")
        call("void @pandaThrow(" + getTypedReference(t.error) + ")")
    }

    @protected
    method generateStatementCode(s:Statement) {
        if debug {
            body.writeLine("; statement:" + s.convert().replace("\n", "\n; (statement cont) "))
        }
        switch s.class {
            case PrimitiveArrayIndexAssignment: 
                    generatePrimitiveArrayIndexAssignmentCode(s->PrimitiveArrayIndexAssignment)
            case FieldAssignment: 
                    generateFieldAssignmentCode(s->FieldAssignment)
            case ValueStatement:
                    generateValueStatementCode(s->ValueStatement)
            case If: generateIfCode(s->If)
            case While: generateWhileCode(s->While)
            case Do: generateDoCode(s->Do)
            case Loop: generateLoopCode(s->Loop)
            case LoopWithContinueBlock: 
                    generateLoopWithContinueBlockCode(
                        s->LoopWithContinueBlock)
            case Block: generateBlockCode(s->Block)
            case Return: generateReturnCode(s->Return)
            case Break: generateBreakCode(s->Break)
            case Continue: generateContinueCode(s->Continue)
            case Assert: generateAssertCode(s->Assert)
            case Throw: generateThrowCode(s->Throw)
            case Try: generateTryCode(s->Try)
            case Unreachable: generateUnreachableCode(s->Unreachable)
            default: 
                throw InternalCompilerException("unsupported statement: " + 
                        s, s.position)
        }
    }

    @protected
    method generateBlockCode(b:Block) {
        for s in b.statements {
            generateStatementCode(s)
        }
    }

    @protected
    method getDefaultValue(f:FieldNode):String {
        def type := f.type
        if type.isInteger | type = CharType.CHAR {
            return "0"
        }
        else if type.isReal {
            return createRealLiteralReference(RealLiteral(Position.INTERNAL,
                    0, type))
        }
        else if type = BitType.BIT {
            return "false"
        }
        else {
            return "null"
        }
    }

    @protected
    method writeFieldDeclaration(f:FieldNode) {
        if f.kind = Variable.Kind.PROPERTY {
            return
        }
        def out := header
        if f.annotations.isClass {
            -- write class field
            def cl := getStub(f.owner)
            def type := getLLVMType(f.type)
            out.write("@" + getName(f) + " = ")
            if cl.isExternal {
                out.write("external ")
            }
            else if f.owner.isPrimitiveArray {
                out.write(SHARED_LINKAGE + " ")
            }
            out.write("global " + type)
            if !cl.isExternal {
                out.writeLine(" " + getDefaultValue(f))
            }
            else {
                out.writeLine()
            }
        }
        else if f.annotations.isThread {
            -- write thread field
            out.write("@" + getName(f) + " = ")
            def cl := getStub(f.owner)
            if cl.isExternal {
                out.write("external ")
            }
            out.write("global i64")
            if !cl.isExternal {
                out.writeLine(" 0")
            }
            else {
                out.writeLine()
            }
        }
    }

    @private
    method isKnownToBeImmutable(type:Type):Bit {
        if type.isPrimitive {
            return true
        }
        def stub := context.classes[type.name]
        if stub = null {
            return false
        }
        return type.isImmutable(context)
    }

    @protected
    method writeMethodDeclaration(m:MethodStub) {
        def external := m.annotations.isExternal
        if (m.name != MethodNode.CLASS_INIT_NAME & !program.liveMethods.contains(m) & !external) | 
                (m.annotations.isAbstract & !m.annotations.isExternal) |
                writtenMethods.contains(m) {
            writtenMethods.add(m)
            return
        }
        writtenMethods.add(m)
        def private := m.annotations.isPrivate
        def immutableReturn := m.returnType != VoidType.VOID & 
                isKnownToBeImmutable(m.returnType)
        for p in m.parameters {
            if context.classes[p.type.name] != null {
                writeTypeDescriptor(p.type)
            }
        }
        header.writeLine()
        if debug {
            header.writeLine("; method: " + m.convert().replace("\n", "\n; (method cont) "))
        }
        def result := MutableString()
        result.append("declare ")
        if !external {
            result.append("fastcc ")
        }
        result.append(getLLVMType(m.returnType) + " @\{getName(m)}(")
        var first := true
        if !m.annotations.isClass {
            result.append("\{getSelfType(m)} %self")
            first := false
        }
        for (i, p) in m.parameters.enumeration {
            if first {
                first := false
            }
            else {
                result.append(", ")
            }
            result.append(getLLVMType(p.type))
        }
        result.append(")")
        if m.kind = MethodStub.Kind.FUNCTION & immutableReturn {
            result.append(" readonly")
        }
        header.writeLine(result)
    }

    @protected
    method writeClassInitializers() {
-*        for (_, cl) in context.classes {
            def classInit := cl.methods.filter(
                    m => m.stub.name = MethodNode.CLASS_INIT_NAME)
            if classInit.count = 0
                continue
            def stub := classInit.iterator.next()
            program.liveMethods.add(stub)
            call("fastcc void @\{getName(stub)}()")
        }*-
    }

    @protected
    method generateMethodCode(m:MethodNode) {
        assert currentMethod = null
        if writtenMethods.contains(m.stub) {
            return
        }
        writtenMethods.add(m.stub)
        if m.stub.annotations.isAbstract {
            return
        }
        references.clear()
        nextLabels.clear()
        endLabels.clear()
        def immutableReturn := m.stub.returnType != VoidType.VOID & 
                isKnownToBeImmutable(m.stub.returnType)
        for p in m.stub.parameters {
            writeTypeDescriptor(p.type)
        }
        currentMethod := m
        tempVariable := 1
        def private := m.stub.annotations.isPrivate
        def external := m.stub.annotations.isExternal
        body.writeLine()
        if debug {
            body.writeLine("; method: " + m.convert().replace("\n", "\n; (method cont) "))
        }
        if external {
            body.write("declare ")
        }
        else {
            body.write("define ")
        }
        if !external {
            body.write("fastcc ")
        }
        body.write(getLLVMType(m.stub.returnType) + " @\{getName(m.stub)}(")
        var first := true
        if !m.stub.annotations.isClass {
            body.write("\{getSelfType(m.stub)} %self")
            first := false
        }
        for (i, p) in m.parameters.enumeration {
            if first {
                first := false
            }
            else {
                body.write(", ")
            }
            body.write(getLLVMType(p.type))
            if !external {
                body.write(" %") 
                body.write(getName(p))
                if p.kind = Variable.Kind.VAR {
                    body.write("$PARAM")
                }
            }
        }
        body.write(")")
        if m.stub.kind = MethodStub.Kind.FUNCTION & immutableReturn {
            body.write(" readonly")
        }
        if external {
            body.writeLine()
        }
        else {
            body.writeLine(" {")
            body.level += 1
            currentBlockLabel := "0"
            if m.stub.name = MethodNode.MAIN_NAME {
                writeClassInitializers()
            }
            for v in m.localVariables {
                body.writeLine("%\{getName(v)} = alloca \{getLLVMType(v.type)}")
            }
            for p in m.parameters.filter(p => p.kind = Variable.Kind.VAR) {
                body.writeLine("%" + getName(p) + " = alloca " + 
                        getLLVMType(p.type))
                body.writeLine("store " + getLLVMType(p.type) + " %" + 
                        getName(p) + "$PARAM, " + getLLVMType(p.type) + "* %" + 
                        getName(p))
            }

            def block := m.body
            generateBlockCode(block)
            if !endsInBranch(block) {
                if m.stub.returnType = VoidType.VOID {
                    body.writeLine("ret void")
                }
                else {
                    body.writeLine("unreachable")
                }
            }
            body.level -= 1
            body.writeLine("}")
        }
        currentMethod := null
    }

    method generateClassCode(cl:ClassNode) {
        for f in cl.stub.fields {
            if f.owner.name = cl.stub.name & !f.annotations.isClass &
                    !f.annotations.isThread {
                writeFieldDeclaration(f)
            }
        }
        for entry in cl.stub.methods {
            def m := entry.stub
            if m.annotations.isExternal {
                writeMethodDeclaration(m)
            }
        }
    }

    method writeMethods() {
        var progress:Bit
        do {
            progress := false
            for stub in context.classes.values.filter(stub => stub.isExternal) {
                for entry in stub.methods {
                    def m := entry.stub
                    if (!stub.annotations.isUnspecified | m.annotations.isClass) &
                            program.liveMethods.contains(m) & 
                            !writtenMethods.contains(m) {
                        progress := true
                        writeMethodDeclaration(m)
                    }
                }
            }
            for (_, cl) in classes {
                for m in cl.methods {
                    if (context.compilerSettings.isLibrary | 
                            program.liveMethods.contains(m.stub)) & 
                            !writtenMethods.contains(m.stub) {
                        generateMethodCode(m)
                        progress := true
                    }
                }
            }
        }
        while progress
    }

    @override
    method generateCode(target:File) {
        if debug {
            Console.writeLine("llvm debug output is enabled")
        }
        header.writeLine('target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"')
        header.writeLine('target triple = "' + StaticSettings.TARGET_TRIPLE + 
                '"')
        header.writeLine('%$itable = type { %panda$core$Class*, %$itable*, ' +
                "[0 x i8*] }")
        def stubs := HashMap<String, ClassStub>(context.classes)
        for (_, stub) in stubs {
            if context.compilerSettings.isLibrary & 
                    !stub.annotations.isUnspecified {
                getClassConstant(stub)
            }
            getStub(stub.type)
        }
        for (_, cl) in classes {
            generateClassCode(cl)
        }
        writeMethods()
        for decl in declarations {
            body.writeLine(decl)
        }

        def parent := target.parent()
        if parent = null {
            throw CompilerException("could not determine parent " +
                    "directory of " + target.path)
        }
        if context.compilerSettings.optimize {
            def unoptTarget := parent.resolve(target.name + ".unopt")
            def out := BufferedOutputStream(unoptTarget.openOutputStream())
            headerBuffer.sendTo(out)
            bodyBuffer.sendTo(out)
            out.close()

            def opt := PandaCompiler.getLLVMHome().resolve("opt")
            System.exec(opt, unoptTarget.path, "-o", target.path, "-O3",
                    "-q", "-f", "-S")
            if !context.compilerSettings.preserveTempArtifacts {
                unoptTarget.delete()
            }
        }
        else {
            def out := BufferedOutputStream(target.openOutputStream())
            headerBuffer.sendTo(out)
            bodyBuffer.sendTo(out)
            out.close()
        }
    }
}