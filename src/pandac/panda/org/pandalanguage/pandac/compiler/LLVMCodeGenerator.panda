package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.compiler.CompilerSettings
uses org.pandalanguage.pandac.compiler.Dummy
uses org.pandalanguage.pandac.stubs.TypedClassStub 
uses org.pandalanguage.pandac.stubs.TypedMethodStub 
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithRange
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedType
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

@private 
class ClassConstant : Immutable {
    def name:String
    def type:String
    def methods:ImmutableArray<TypedMethodStub>
    
    constructor(name:String, type:String, methods:ListView<TypedMethodStub>) {
        self.name := name
        self.type := type
        self.methods := new ImmutableArray<TypedMethodStub>(methods)
    }
}

class LLVMCodeGenerator (CodeGenerator) {
    constant POINTER_SIZE := 8

    @private
    constant SHARED_LINKAGE := "weak_odr"
    
    def debug := false

    var tempVariable := 0

    var currentBlockLabel := "0"

    def compilerSettings:CompilerSettings

    def stubs:MapView<String, TypedClassStub>

    def classes:MapView<String, ClassNode>

    def classConstants := new HashMap<String, ClassConstant>()

    def methodNames:MapView<TypedMethodStub, String>

    var charArrayCount := 0

    def stringConstants := new HashMap<String, String>()

    def types:MapView<String, Type>

    def headerBuffer := new MemoryOutputStream()

    def header := new IndentedOutputStream(headerBuffer)

    def bodyBuffer := new MemoryOutputStream()

    def body := new IndentedOutputStream(bodyBuffer)

    constructor(p:Program) {
        self.compilerSettings := p.compilerSettings
        self.stubs := p.stubs
        self.classes := p.classes
        self.types := p.types
        self.methodNames := new MethodNamer().nameMethods(stubs, 
                new CMethodNamingStrategy())
    }

    @protected
    method writeBody(text:String, comment:String) {
        body.write(text)
        if debug {
            body.write("; ")
            body.write(comment)
        }
        body.writeLine()
    }
    
    @override
    function defaultExtension():String {
        return ".ll"
    }

    ============================================================================
    Returns the LLVM name for a type. Note that method types are a bit 
    complicated: sometimes we want a method type identified as an instance of 
    class Method, and sometimes we want a method type identified as an actual
    function pointer. This method always returns the Method class, and the
    getLLVMMethodType() method may be used to get the function pointer type
    corresponding to a method.
    ============================================================================
    method getLLVMType(t:Type):String {
        switch t {
            case IntType.INT8:  return "i8"
            case IntType.INT16: return "i16"
            case IntType.INT32: return "i32"
            case IntType.INT64: return "i64"
            case IntType.UINT8:  return "i8"
            case IntType.UINT16: return "i16"
            case IntType.UINT32: return "i32"
            case IntType.UINT64: return "i64"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case BitType.BIT: return "i1"
            case CharType.CHAR: return "i16"
            case VoidType.VOID: return "void"
            case NativePointerType.NATIVE_POINTER: return "i8*"
        }
        return "%" + getName(getStub(t->>(ClassType))) + "*"
    }

    method getLLVMMethodType(t:TypedMethodStub):String {
        def result := new MutableString()
        def returnType := t.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        def parameters := t.parameters
        for i, p in parameters {
            if i > 0
                result.append(", ")
            result.append(getLLVMType(p.type))
        }
        result.append(")*")
        return result->>(String)
    }

    method getLLVMMethodType(t:MethodType):String {
-*        def result := new MutableString()
        def returnType := t.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        def parameters := t.methodParameters
        for i, p in parameters {
            if i > 0
                result.append(", ")
            result.append(getLLVMType(p))
        }
        result.append(")*")
        return result->>(String)*-
        throw new NotSupportedException()
    }

    @protected
    method getTempVariable():String {
        def result := "%" + tempVariable
        tempVariable += 1
        return result
    }

    @private
    method getName(cl:TypedClassStub):String {
        return MethodNamer.escapeTypeName(cl.name)
    }

    @private
    function getName(m:MethodNode):String {
        return getName(m.stub)
    }

    @private
    function getName(m:TypedMethodStub):String {
        def result := methodNames[m]
        assert result != null : "no method name for \{m}"
        return result
    }

    @private
    function getName(v:Variable):String {
        return v.name
    }

    @private
    function getType(cl:TypedClassStub):ClassType {
        return types[cl.name]->(ClassType)
    }

    @private
    function getClass(cl:ClassType):ClassNode {
        return classes[cl.name]->(ClassNode)
    }

    @private
    function getStub(cl:ClassType):TypedClassStub {
        return getStub(cl.name)
    }

    @private
    function getStub(s:String):TypedClassStub {
        def result := stubs[s]
        -- FIXME TEMP
        if result = null
            return stubs["panda.core.Object"]->(TypedClassStub)
        return result
    }

    @private
    function size(t:Type):Int {
        if t.isPrimitive
            return t->>(PrimitiveType).size
        def stub := getStub(t->>(ClassType))
        var total := 0
        def sc := stub.superclass
        if sc != null
            total += size(sc)
        for field in stub.instanceFields(stubs) {
            def fieldSize:Int
            if field.type.isPrimitive
                fieldSize := size(field.type)
            else
                fieldSize := POINTER_SIZE
            def align := total % fieldSize
            if align != 0
                total += fieldSize - align
            assert total % fieldSize = 0
            total += fieldSize
        }
        return total
    }

    @private
    function isImmutable(t:Type):Bit {
        return t.isPrimitive
    }

    @protected
    method writeTypeDescriptor(cl:TypedClassStub) {
        if debug
            header.writeLine("; " + cl.name)
        header.write("%" + getName(cl) + " = type { ")
        def fields := cl.instanceFields(stubs)
        for i, f in fields {
            if i != 0
                header.write(", ")
            if f.name = FieldNode.ELEMENTS_NAME
                header.write(getLLVMType(f.type) + "*")
            else
                header.write(getLLVMType(f.type))
        }
        if cl.name = ClassType.CLASS.name {
            -- Class is special, write out the VTABLE entry at the end of its fields
            header.write(", %$itable*, [0 x i8*]")
        }
        header.writeLine(" }")
    }

    @protected
    method createCallReference(codeString:String, comment:String):String {
        def result := getTempVariable()
        call(codeString, result, comment)
        return result
    }

    @protected
    method call(invocation:String, result:String?, comment:String?) {
        if result != null
            body.write(result + " = ")
        body.write("call " + invocation)
        if debug & comment != null
            body.writeLine("; " + comment)
        else
            body.writeLine()
    }

    @protected
    method call(invocation:String) {
        call(invocation, null, null)
    }

    @private
    function isConstant(expr:String):Bit {
        return expr.startsWith("%") | expr.matches(#/\d+/#)
    }

    @protected
    method createCommandReference(codeString:String, comment:String):String {
        if isConstant(codeString)
            return codeString
        def result := getTempVariable()
        writeBody(result + " = " + codeString, comment)
        return result
    }

    @protected
    method createConstructReference(construct:Construct):String {
        def targetType := construct.type
        def target := getStub(targetType)
        def cc := getClassConstant(target)
        def cast := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody(cast + " = bitcast " + cc.type + "* @" + cc.name +
                " to " + classType, "convert class pointer")
        def alloc := createCallReference("i8* @_pandaNew(" + classType + " " + 
                cast + ", i32 " + size(targetType) + ")", 
                "allocate " + targetType.name)
    
        def result := createCommandReference("bitcast i8* " + alloc + " to " + 
                getLLVMType(targetType), "convert pointer to " + 
                targetType.name)

        def parameters := construct.constructorCall.parameters
        def m := construct.constructorCall.methodStub
        def methodRef := "@" + getName(m)
        def text := new MutableString("fastcc void \{methodRef}(")
        text.append(getLLVMType(targetType) + " " + result)
        for i, p in parameters[1..] {
            text.append(", ")
            text.append(getTypedReference(p))
        }
        text.append(")")
        call(text->>(String))
        return result
    }

    @protected
    method createMethodCallReference(mc:MethodCall):String? {
        def m := mc.methodStub
        def methodRef:String
-*        if m.isEffectivelyVirtual & mc.isVirtual {
            assert !m.annotations.isClass : "expected method not to be @class"
            assert mc.parameters.length >= 1 : "expected method to have a self parameter"
            def target := mc.parameters[0]
            def classNode := target.type.classNode
            if classNode.isInterface
                methodRef := getInterfaceMethodReference(mc)
            else
                methodRef := getVirtualMethodReference(mc)
        }
        else *-
            methodRef := "@" + getName(m)
        def text := new MutableString("fastcc \{getLLVMMethodType(m)} \{methodRef}(")
        def parameters := mc.parameters
        for i, p in parameters {
            if i > 0
                text.append(", ")
            text.append(getTypedReference(p))
        }
        text.append(")")
        if mc.type = VoidType.VOID {
            call(text->>(String))
            return null
        }
        else
            return createCallReference(text->>(String), mc->>(String))
    }

    @protected
    method createVariableAssignmentReference(va:VariableAssignment):String {
        def variable := va.variable
        def lref := getLLVMType(variable.type) + "* %" + getName(variable)
        def result := createReference(va.value)
        assert result != null : 
                "expected non-null result in createVariableAssignmentReference"
        writeBody("store " + getLLVMType(variable.type) + " " + result + ", " + 
                lref, va->>(String))
        return result
    }
    
    @private
    method getITable(cl:TypedClassStub):String {
        def visited := new HashSet<TypedClassStub>()
        def interfaces := cl.allInterfaces(stubs)
        var previous := "%$itable* null"
        for intf in interfaces {
            if visited.contains(intf)
                continue
            visited.add(intf)
            def intfCC := getClassConstant(intf)
            def methods := cl.interfaceMethods(intf, stubs)
            def name := "@" + getName(cl) + "$." + getName(intf)
            def type := "{ " + getLLVMType(ClassType.CLASS) + 
                    ", %$itable*, [" + methods.length + " x i8*] }"
            header.write(name + " = " + SHARED_LINKAGE + " constant ")
            header.write(type + " { " + 
                    getLLVMType(ClassType.CLASS) + " bitcast(" + intfCC.type + 
                    "* @" + intfCC.name + " to " + 
                    getLLVMType(ClassType.CLASS) + "), " + previous + ", [" + 
                    methods.length + " x i8*][")
            for i, m in methods {
                if i > 0
                    header.write(", ")
                if m.annotations.isAbstract
                    header.write("i8* null")
                else {
                    header.write("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            header.writeLine("] }")
            previous := "%$itable* bitcast(" + type + "* " + name + 
                    " to %$itable*)" 
        }
        return previous
    }

    @protected
    method getClassConstant(cl:TypedClassStub):ClassConstant {
        var name := cl.name
        var cc := classConstants[name]
        if cc = null {
            def methods := cl.virtualMethods(stubs)
            def className := getName(cl)
            cc := new ClassConstant(
                    className + "_class",
                    "{ " + getLLVMType(ClassType.CLASS) + ", " + 
                    getLLVMType(ClassType.STRING) +  ", " + 
                    getLLVMType(ClassType.CLASS) + ", i1, i1, %$itable*, [" + 
                    methods.length + " x i8*] }", methods)
            classConstants[name] := cc
            if types[name]-?>(WrapperType) {
                assert name.endsWith("Wrapper") : "invalid wrapper class name"
                name := name[0 .. name.length - "Wrapper".length]
            }
            -- go ahead and get other class constants here, before we've written
            -- anything -- this could cause other class definitions to be
            -- printed, and we don't want to be in the middle of output when
            -- that happens
            var nameRef := "<error>"
            if !cl.isExternal
                nameRef := getStringConstantReference(name)
            getClassConstant(getStub(ClassType.CLASS.name))

            def superclassConstant:ClassConstant?
            def superclass := cl.superclass
            if superclass != null
                superclassConstant := getClassConstant(getStub(superclass))
            else
                superclassConstant := null
            if cl.isExternal {
                header.write("@" + cc.name + " = ")
                header.writeLine("external global " + cc.type)
                return cc
            }
            def intf := getITable(cl)
            header.write("@" + cc.name + " = ")
            header.write(SHARED_LINKAGE + " ")
            def superclassRef:String
            if superclassConstant != null
                superclassRef := "bitcast(" + superclassConstant.type + "* @" + 
                        superclassConstant.name + " to " + 
                        getLLVMType(ClassType.CLASS) + ")"
            else
                superclassRef := "null"
            -- class constant includes vtable. Doesn't include statics, as 
            -- those are just globals.
            var overridesFinalize := false
            for m in cl.methods {
                if m.name = MethodNode.FINALIZE_NAME & 
                        !m.annotations.isClass & 
                        m.parameters.length = 1
                    overridesFinalize := true
            }
            def classClass := getStub(ClassType.CLASS)
            def classClassConstant := getClassConstant(classClass)
            header.write("constant " + cc.type + 
                    " { " + getLLVMType(ClassType.CLASS) + " bitcast(" + 
                    classClassConstant.type + "* @" + classClassConstant.name + 
                    " to " + getLLVMType(ClassType.CLASS) + "), " + 
                    getLLVMType(ClassType.STRING) + " " + nameRef + ", " + 
                    getLLVMType(ClassType.CLASS) + " " + superclassRef + 
                    ", i1 1, i1 " + overridesFinalize + ", " + intf + ", [" + 
                    methods.length + " x i8*] [ ")
            for i, m in methods {
                if i > 0
                    header.write(", ")
                if m.annotations.isAbstract
                    header.write("i8* null")
                else {
                    header.write("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            header.writeLine(" ] }")
        }
        return cc
    }

    @private
    method getCharPrimitiveArrayConstantReference(chars:PrimitiveArray<Char>):String {
        def charPrimitiveArrayClass := getStub(
                PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
        def cc := getClassConstant(charPrimitiveArrayClass)
        def charsType := "[\{chars.length} x \{getLLVMType(CharType.CHAR)}]"
        def type := "{ " + cc.type + "*, " +
                getLLVMType(IntType.INT32) + ", " + 
                getLLVMType(IntType.INT32) + ", " + 
                charsType + "* }"
        def result := "ca" + charArrayCount
        charArrayCount += 1
        def charsName := "@\{result}_chars"
        header.write(charsName + " = private unnamed_addr constant " + 
                charsType + " [")
        for i, c in chars {
            if i != 0
                header.write(", ")
            header.write(getLLVMType(CharType.CHAR) + " " + c->(Int))
        }
        header.writeLine("]")

        header.writeLine("@" + result + " = private unnamed_addr constant " + 
                type + " { " + cc.type + "* @" + cc.name + ", " + 
                getLLVMType(IntType.INT32) + " " + chars.length + ", " +
                getLLVMType(IntType.INT32) + " " + chars.length + ", " + 
                charsType + "* " + charsName + " }, align " +
                POINTER_SIZE)
        return "bitcast(" + type + "* @" + result + " to " + 
                getLLVMType(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY) + ")"
    }

    @private
    method getStringConstantReference(s:String):String {
        var result := stringConstants[s]
        if result = null {
            def string := getStub(ClassType.STRING)
            def primitiveChars := new PrimitiveArray<Char>()
            for c in s
                primitiveChars.append(c)
            def chars := getCharPrimitiveArrayConstantReference(primitiveChars)
            result := "@s" + stringConstants.length
            stringConstants[s] := result
            def charPrimitiveArrayType := PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY
            def cc := getClassConstant(string)
            if debug
                header.writeLine("; " + StringLiteral.escape(s))
            header.writeLine(result + " = private unnamed_addr constant " + 
                    '%panda$core$String { ' + 
                    getLLVMType(ClassType.CLASS) + " bitcast(" + cc.type + 
                    "* @" + cc.name + " to " + getLLVMType(ClassType.CLASS) + 
                    "), " + getLLVMType(charPrimitiveArrayType) + " " + chars + " }," +
                    " align " + POINTER_SIZE)
            stringConstants[s] := result
        }
        return result
    }

    -- return value is nullable so void expressions (method calls) can return
    -- null
    @protected
    method createReference(v:Value):String? {
        switch v.class {
            case class(VariableAssignment): return createVariableAssignmentReference(v->(VariableAssignment))
-*            case class(Add): return createBinaryOperationReference(v->(BinaryOperation), "add", "fadd")
            case class(Subtract): return createBinaryOperationReference(v->(BinaryOperation), "sub", "fsub")
            case class(Multiply): return createBinaryOperationReference(v->(BinaryOperation), "mul", "fmul")
            case class(Divide): return createBinaryOperationReference(v->(BinaryOperation), null, "fdiv")
            case class(IntDivide): {
                var op:String
                if v.type->(IntType).signed
                    op := "sdiv"
                else
                    op := "udiv"
                return createBinaryOperationReference(v->(BinaryOperation), op, null)
            }
            case class(Remainder): return createBinaryOperationReference(v->(BinaryOperation), "srem", "urem", null)
            case class(ShiftLeft): return createBinaryOperationReference(v->(BinaryOperation), "shl", null)
            case class(ShiftRight): {
                if v.type->(IntType).signed
                    return createBinaryOperationReference(v->(BinaryOperation), "ashr", null)
                else
                    return createBinaryOperationReference(v->(BinaryOperation), "lshr", null)
            }
            case class(And): return createAndReference(v->(And))
            case class(Or): return createOrReference(v->(Or))
            case class(Xor): return createBinaryOperationReference(v->(BinaryOperation), "xor", null)
            case class(BitwiseAnd): return createBinaryOperationReference(v->(BinaryOperation), "and", null)
            case class(BitwiseOr): return createBinaryOperationReference(v->(BinaryOperation), "or", null)
            case class(BitwiseXor): return createBinaryOperationReference(v->(BinaryOperation), "xor", null)
*-
            case class(Construct): return createConstructReference(v->(Construct))
            case class(MethodCall): return createMethodCallReference(v->(MethodCall))
            case class(StringLiteral): return getStringConstantReference(v->(StringLiteral).value)
            case class(IntegerLiteral): return v->(IntegerLiteral).value->>(String)
-*
            case class(RealLiteral): return createRealLiteralReference(v->(RealLiteral))
            case class(VariableReference): return createVariableReference(v->(VariableReference))
            case class(FieldReference): return createFieldReference(v->(FieldReference))
            case class(Cast): return createCastReference(v->(Cast))
            case class(Equal): return createBinaryOperationReference(v->(BinaryOperation), "icmp eq", "fcmp oeq")
            case class(Identity): return createBinaryOperationReference(v->(BinaryOperation), "icmp eq")
            case class(LessThan): return createBinaryOperationReference(v->(BinaryOperation), "icmp slt", "icmp ult", "fcmp olt")
            case class(GreaterThan): return createBinaryOperationReference(v->(BinaryOperation), "icmp sgt", "icmp ugt", "fcmp ogt")
            case class(LessThanOrEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp sle", "icmp ule", "fcmp ole")
            case class(GreaterThanOrEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp sge", "icmp uge", "fcmp oge")
            case class(NotEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp ne", "fcmp one")
            case class(NotIdentity): return createBinaryOperationReference(v->(BinaryOperation), "icmp ne")
            case class(BitLiteral): return v->(BitLiteral).value->>(String)
            case class(IndexValue): return createIndexValueReference(v->(IndexValue))
            case class(NewPrimitiveArrayWithLength): return createNewPrimitiveArrayWithLengthReference(v->(NewPrimitiveArrayWithLength))
            case class(NewPrimitiveArrayWithValues): return createNewPrimitiveArrayWithValuesReference(v->(NewPrimitiveArrayWithValues))
            case class(NewPrimitiveArrayWithRange): return createNewPrimitiveArrayWithRangeReference(v->(NewPrimitiveArrayWithRange))
            case class(Not): return createNotReference(v->(Not))
            case class(BitwiseNot): return createBitwiseNotReference(v->(BitwiseNot))
            case class(UnaryMinus): return createUnaryMinusReference(v->(UnaryMinus))
            case class(NullLiteral): return "null"
            case class(ClassObjectLiteral): return createClassObjectLiteralReference(v->(ClassObjectLiteral))
            case class(Ternary): return createTernaryReference(v->(Ternary))
            case class(Unwrap): return createReference(v->(Unwrap).value)
            case class(AndLeft): return createReference(v->(AndLeft).value)
            case class(OrLeft): return createReference(v->(OrLeft).value)
            case class(MethodValue): return createMethodValueReference(v->(MethodValue))
            case class(DynamicCall): return createDynamicCallReference(v->(DynamicCall))
            case class(ReusedValueDefinition): return createReusedValueDefinitionReference(v->(ReusedValueDefinition))
            case class(ReusedValue): return createReusedValueReference(v->(ReusedValue)) *-
            default: {
                throw new CompilerException("unsupported value class: " + 
                        v.class.name, v.position)
            }
        }
    }

    @protected
    method getTypedReference(v:Value):String {
        def ref := createReference(v)
        assert ref != null : "expected non-null ref in getTypedReference"
        return getLLVMType(v.type) + " " + ref
    }
    
    @protected
    method generateValueStatementCode(v:ValueStatement) {
        createReference(v.value)
    }

    @protected
    method generateStatementCode(s:Statement) {
        if debug
            body.writeLine("; " + s)
        switch s.class {
-*            case class(IndexedAssignment): 
                    generateIndexedAssignmentCode(s->(IndexedAssignment))
            case class(FieldAssignment): 
                    generateFieldAssignmentCode(s->(FieldAssignment)) *-
            case class(ValueStatement):
                    generateValueStatementCode(s->(ValueStatement))
-*            case class(If): generateIfCode(s->(If))
            case class(While): generateWhileCode(s->(While))
            case class(Do): generateDoCode(s->(Do))
            case class(Loop): generateLoopCode(s->(Loop))
            case class(LoopWithContinueBlock): 
                    generateLoopWithContinueBlockCode(s->(LoopWithContinueBlock))
            case class(Block): generateBlockCode(s->(Block))
            case class(Return): generateReturnCode(s->(Return))
            case class(Break): generateBreakCode(s->(Break))
            case class(Continue): generateContinueCode(s->(Continue))
            case class(Assert): generateAssertCode(s->(Assert))
            case class(Throw): generateThrowCode(s->(Throw))
            case class(Try): generateTryCode(s->(Try))
            case class(CatchExit): { }
            case class(Unreachable): generateUnreachableCode(s->(Unreachable)) *-
            default: 
                throw new InternalCompilerException("unsupported statement: " + 
                        s, s.position)
        }
    }

    @protected
    method generateBlockCode(b:Block) {
        for s in b.statements
            generateStatementCode(s)
    }

    @protected
    method writeMethodDeclaration(m:TypedMethodStub) {
        if m.annotations.isAbstract
            return
        def private := m.annotations.isPrivate
        def external := m.annotations.isExternal
        body.writeLine()
        if debug
            body.writeLine("; " + m)
        body.write("declare ")
        if !external
            body.write("fastcc ")
        body.write(getLLVMType(m.returnType) + " @\{getName(m)}(")
        for i, p in m.parameters {
            if i > 0
                body.write(", ")
            body.write(getLLVMType(p.type))
        }
        body.write(")")
        if m.methodType = MethodNodeType.FUNCTION & isImmutable(m.returnType)
            body.write(" readonly")
        body.writeLine()
    }

    @protected
    method generateMethodCode(m:MethodNode) {
        if m.annotations.isAbstract
            return
        tempVariable := 1
        def private := m.annotations.isPrivate
        def external := m.annotations.isExternal
        body.writeLine()
        if debug
            body.writeLine("; " + m)
        if external
            body.write("declare ")
        else
            body.write("define ")
        if !external
            body.write("fastcc ")
        body.write(getLLVMType(m.returnType) + " @\{getName(m)}(")
        for i, p in m.parameters {
            if i > 0
                body.write(", ")
            body.write(getLLVMType(p.type))
            if !external {
                body.write(" %") 
                body.write(getName(p))
            }
        }
        body.write(")")
        if m.methodType = MethodNodeType.FUNCTION & isImmutable(m.returnType)
            body.write(" readonly")
        if external
            body.writeLine()
        else {
            body.writeLine(" {")
            body.level += 1
            currentBlockLabel := "0"
            for v in m.localVariables
                body.writeLine("%\{getName(v)} = alloca \{getLLVMType(v.type)}")
-*            for (source, promoted) in promotedParameters {
                body.writeLine("%" + getName(promoted) + " = alloca " + 
                        getLLVMType(promoted.type))
                body.writeLine("store " + getLLVMType(promoted.type) +
                        " %" + getName(source) + ", " + 
                        getLLVMType(promoted.type) + "* %" + getName(promoted))
            } *-
            
            def block := m.block
            assert block != null
            generateBlockCode(block)
            if !block.endsInBranch {
                if m.returnType = VoidType.VOID
                    body.writeLine("ret void")
                else
                    body.writeLine("unreachable")
            }
            body.level -= 1
            body.writeLine("}")
        }
    }

    method generateClassCode(cl:ClassNode) {
        for m in cl.methods
            generateMethodCode(m)
    }

    @override
    method generateCode(target:File) {
        if debug
            Console.writeLine("llvm debug output is enabled")
        header.writeLine('target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"')
        header.writeLine('target triple = "' + StaticSettings.TARGET_TRIPLE + 
                '"')
        header.writeLine('%$itable = type { %panda$core$Class*, %$itable*, ' +
                "[0 x i8*] }")
        for (_, cl) in stubs {
            if cl.genericParameters = null
                writeTypeDescriptor(cl)
        }
        for (_, cl) in stubs {
            if classes[cl.name] = null & cl.genericParameters = null {
                for m in cl.methods
                    writeMethodDeclaration(m)
            }
        }
-*        for (_, cl) in stubs {
            if cl.live & !cl.annotations.isUnspecified()
                getClassConstant(cl)
        }*-
        for (_, cl) in classes
            generateClassCode(cl)

        body.writeLine("declare void @pandaInit()")
        body.writeLine("declare void @pandaCheckLibVersion(i32)")
        body.writeLine("declare void @pandaCheckOverflow(i1)")
        body.writeLine("declare {i8, i1}  @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.sadd.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.uadd.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.uadd.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.uadd.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.ssub.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.ssub.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.ssub.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.usub.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.usub.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.usub.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.usub.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.smul.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.smul.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.smul.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.smul.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.umul.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.umul.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.umul.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.umul.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare void @llvm.trap() noreturn nounwind")
        body.writeLine("declare void @pandaCheckSignCasti8(i8)")
        body.writeLine("declare void @pandaCheckSignCasti16(i16)")
        body.writeLine("declare void @pandaCheckSignCasti32(i32)")
        body.writeLine("declare void @pandaCheckSignCasti64(i64)")

        body.writeLine("declare i8* @_pandaNew(%panda$core$Class*, " +
                getLLVMType(IntType.INT32) + ")")

        def parent := target.parent()
        if parent = null {
            throw new CompilerException("could not determine parent " +
                    "directory of " + target.path)
        }
        def unoptTarget := parent.resolve(target.name + ".unopt")
        def out := new BufferedOutputStream(unoptTarget.openOutputStream())
        out.write(headerBuffer->>(String))
        out.write(bodyBuffer->>(String))
        out.close()

        def opt := PandaCompiler.getLLVMHome().resolve("opt")
        System.exec(opt, unoptTarget.path, "-o", target.path, "-O3",
                "-q", "-f", "-S", "-std-compile-opts")
        if !compilerSettings.preserveTempArtifacts
            unoptTarget.delete()
    }
}