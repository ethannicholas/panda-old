package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.compiler.CompilerSettings
uses org.pandalanguage.pandac.compiler.Dummy
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.And
uses org.pandalanguage.pandac.tree.AndLeft
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.BitwiseAnd
uses org.pandalanguage.pandac.tree.BitwiseNot
uses org.pandalanguage.pandac.tree.BitwiseOr
uses org.pandalanguage.pandac.tree.BitwiseXor
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Divide
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.Equal
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.FieldStub
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodStub
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewArrayWithLength
uses org.pandalanguage.pandac.tree.NewArrayWithRange
uses org.pandalanguage.pandac.tree.NewArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryMinus
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedType
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

@private 
class ClassConstant {
    var name:String
    var type:String
    var methods:Array<MethodNode>
    
    constructor(name:String, type:String, methods:Array<MethodNode>) {
        self.name := name
        self.type := type
        self.methods := methods
    }
}

class LLVMCodeGenerator (CodeGenerator) {
    @private
    constant NAME := "NAME"

    @private
    constant CONSTANT := "CONSTANT"
    
    @private
    constant NEXT_LABEL := "NEXT_LABEL"
    
    @private
    constant END_LABEL := "END_LABEL"

    @private
    constant LANDING_PAD_LABEL := "LANDING_PAD_LABEL"

    @private
    constant CATCH_LABEL := "CATCH_LABEL"

    @private
    constant CATCH_TEST_LABEL := "CATCH_TEST_LABEL"

    @private
    constant REFERENCE := "REFERENCE"

    @private
    constant CLASS_CONSTANT := "CLASS_CONSTANT"
    
    @private
    constant METHOD_VALUE := "METHOD_VALUE"
    
    @private
    constant SHARED_LINKAGE := "weak_odr"
    
    @private 
    constant CLASS_POINTER_INDEX := 0
    
    @private 
    constant ARRAY_CONTENTS_INDEX := 3

    -- index of the vtable within the class structure. Note that Class is 
    -- special and this information is spread between more locations than I
    -- would like; the vtable (and itable) are "special" fields programmatically
    -- added to the Class class here. The information shows up in a couple spots
    -- here in the LLVM output, and *also* shows up in the panda$core$Class.h 
    -- file generated by HeaderCodeGenerator (where the same extra fields are 
    -- added). All of these sources must agree with each other or nothing will 
    -- work.
    @private 
    constant VTABLE_INDEX := 6

    @private
    constant ITABLE_INDEX := 5

    @private
    constant FAIL_ASSERT_NAME := "@panda$core$Panda$failAssert"

    @private
    var tempVariable := 1
    
    @protected
    var headerBuffer := new MemoryOutputStream()

    @protected
    var header := new IndentedOutputStream(headerBuffer)
    
    @protected
    var bodyBuffer := new MemoryOutputStream()

    @protected
    var body := new IndentedOutputStream(bodyBuffer)
    
    @private
    var cStringCount:Int
    
    @private
    var byteArrayCount:Int
    
    @private
    var stringConstants := new HashMap()
    
    @private
    var currentBlockLabel := "<undefined>"
    
    @private
    var currentBlock:Block?
    
    @private
    var labelIndex:Int
    
    @private
    var nameCount:Int
    
    @private
    var promotedParameters := new HashMap()
    
    @private
    var currentMethod:MethodNode?

    @private
    var debug := false

    @override
    function defaultExtension():String {
        return ".ll"
    }
    
    @protected
    method getName(n:Node):String {
        var name := n.getProperty(NAME)->(String?)
        if name = null {
            switch n.class {
                case class(LocalVariable): name := n->(Variable).name
                case class(Parameter): name := n->(Parameter).name
                case class(FieldNode): {
                    if n->(FieldNode).annotations.isClass |
                            n->(FieldNode).annotations.isThread {
                        var type := n.parent->(ClassNode).type()
                        return "class_" + getName(type) + "$" + 
                                n->(FieldNode).name
                    }
                    else
                        name := n->(FieldNode).name
                }
                case class(MethodNode): return getName(n->(MethodNode)) 
                default: throw new AssertionError("unreachable")
            }
            name += nameCount
            nameCount += 1
            n.setProperty(NAME, name)
        }
        return name
    }
    
    @protected
    method getDefaultValue(f:FieldNode):String {
        if f.initialValue != null {
            var v := f.initialValue
            if v-?>(IntegerLiteral) {
                if f.annotations.isStatic
                    f.setProperty(CONSTANT, true)
                return v->>(String)
            }
        }
        var type := f.type
        if type.isInteger | type = CharType.CHAR
            return "0"
        else if type.isReal
            return createRealLiteralReference(new RealLiteral(0, type))
        else if type = BitType.BIT
            return "false"
        else
            return "null"
    }
    ============================================================================
    Returns an internal identifier for this type, used in mangling method names.
    
    @param t a type
    @returns an internal identifier for the type
    ============================================================================
    @class
    method getName(var t:Type):String {
        t := t.unwrapGenerics()
        if t = CharType.CHAR
            return "char"
        else if t = NativePointerType.NATIVE_POINTER
            return "ptr"
        else if t.isPrimitive
            return getLLVMType(t)
        else if t.isArray {
            var e := t.elementType
            var suffix:String
            if t.isImmutable
                suffix := "$ImmutableArray"
            else
                suffix := "$Array"
            var elementName:String
            if e.isPrimitive {
                assert e.name.startsWith(ClassNode.CORE)
                elementName := e.name[ClassNode.CORE.length..]
            }
            else
                elementName := getName(e)
            if e.isNullable
                return elementName + "$Z" + suffix
            else
                return elementName + suffix
        }
        else {
            def c := t.classNode
            def result := new MutableString()
            for i in 0 ... c.name.length - 1 {
                def ch := c.name[i]
                if ".<,>+?()=&".contains(ch)
                    result.append("$")
                else if ch != " "
                    result.append(ch)
            }
            return result->>(String)
        }
    }

    @protected
    function getMethodIndex(cl:ClassConstant, m:MethodNode):Int {
        -- FIXME use indexOf when that's available
        def methods := cl.methods
        for i in 0 ... methods.length - 1 {
            if methods[i] = m
                return i
        }
        throw new InternalCompilerException(m + 
                " not found in class constant", m.position)
    }

    @class
    function getName(m:MethodNode):String {
        if m.getProperty(MethodNamer.NAME) = null
            throw new Error(m + " has no name")
        return m.getProperty(MethodNamer.NAME)->(String)
    }

    ============================================================================
    Returns the LLVM name for a type. Note that method types are a bit 
    complicated: sometimes we want a method type identified as an instance of 
    class Method, and sometimes we want a method type identified as an actual
    function pointer. This method always returns the Method class, and the
    getLLVMMethodType() method may be used to get the function pointer type
    corresponding to a method.
    ============================================================================
    @class
    method getLLVMType(var t:Type):String {
        t := t.unwrapGenerics()
        if t-?>(MethodType) {
            if t.isImmutable
                return getLLVMType(ClassType.METHOD())
            else
                return getLLVMType(ClassType.MUTABLE_METHOD())
        }
        switch t {
            case IntType.INT8,  IntType.UINT8:  return "i8"
            case IntType.INT16, IntType.UINT16: return "i16"
            case IntType.INT32, IntType.UINT32: return "i32"
            case IntType.INT64, IntType.UINT64: return "i64"
            case RealType.REAL32: return "float"
            case RealType.REAL64: return "double"
            case CharType.CHAR:   return "i16"
            case BitType.BIT:     return "i1"
            case VoidType.VOID:   return "void"
            case NativePointerType.NATIVE_POINTER: return "i8*"
            default: {
                if t.isPrimitive
                    return "<error:" + t.name + ">"
                else if t.classNode.live
                        return "%" + getName(t) + "*"
                else {
                    -- type isn't live, return stubbed out type
                    return "i8*"
                }
            }
        }
    }

    @class
    method getLLVMMethodType(t:MethodType):String {
            var result := new MutableString()
            var returnType := t.returnType
            result.append(getLLVMType(returnType))
            result.append(" (")
            var parameters := t.methodParameters
            for i in 0 ... parameters.length - 1 {
                if i > 0
                    result.append(", ")
                result.append(getLLVMType(parameters[i]))
            }
            result.append(")*")
            return result->>(String)    
    }

    -- we could of course just call getLLVMMethodType(m.type), but that is much 
    -- less efficient
    @class
    method getLLVMMethodType(m:MethodNode):String {
        var result := new MutableString()
        var returnType := m.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        var parameters := m.parameters
        for i in 0 ... parameters.length - 1 {
            if i > 0
                result.append(", ")
            result.append(getLLVMType(parameters[i].type))
        }
        result.append(")*")
        return result->>(String)
    }

    @protected
    method writeBody(text:String, comment:String) {
        body.write(text)
        if debug {
            body.write("; ")
            body.write(comment)
        }
        body.writeLine()
    }
    
    @protected
    method createBlock(label:String, comment:String) {
        currentBlockLabel := label
        if debug
            body.writeLine("; " + comment)
        body.writeLine(label + ":")
    }
    
    @protected
    method createLabel():String {
        nameCount += 1
        return "$label" + nameCount
    }
    
    @protected
    method writeTypeDescriptor(c:ClassNode) {
        if debug
            header.writeLine("; " + c.name)
        header.write("%" + getName(c.type()) + " = type { ")
        var fields := c.unifiedFields
        for i, rawF in fields {
            def f := rawF.unwrap()
            if i != 0
                header.write(", ")
            if f.name = FieldNode.ELEMENTS_NAME
                header.write(getLLVMType(f.type) + "*")
            else
                header.write(getLLVMType(f.type))
        }
        if c.name = ClassNode.CLASS_NAME {
            -- Class is special, write out the VTABLE entry at the end of its fields
            header.write(", %$itable*, [0 x i8*]")
        }
        header.writeLine(" }")
    }

    @private
    method getVirtualMethodReference(target:Value, index:Int, 
            type:MethodType):String {
        -- load class constant entry
        var cl := target.type.classNode
        var getep := "getelementptr inbounds " + 
                getTypedReference(target) + 
                ", i32 0, i32 " + CLASS_POINTER_INDEX
        if debug
            getep += "; get pointer to pointer to " + cl
        var ep := getTempVariable()
        body.writeLine(ep + " = " + getep)
        var load := getTempVariable()
        var classType := getLLVMType(ClassType.CLASS())
        writeBody("\{load} = load \{classType}* \{ep}", "get pointer to " + 
                cl)
        ep := getTempVariable()
        writeBody("\{ep} = getelementptr inbounds \{classType} \{load}, " +
                "i32 0, i32 \{VTABLE_INDEX}, i32 \{index}", 
                "get pointer to pointer to \{cl}.vtable[\{index}]")
        var cast := getTempVariable()
        writeBody("\{cast} = bitcast i8** \{ep} to \{getLLVMMethodType(type)}*", 
                "convert pointer to method pointer to correct type")
        var methodRef := getTempVariable()
        writeBody("\{methodRef} = load \{getLLVMMethodType(type)}* \{cast}", 
                "get \{cl}.vtable[\{index}]")
        return methodRef
    }

    @private
    method getVirtualMethodReference(mc:MethodCall):String {
        def m := mc.methodNode
        def cc := getClassConstant(m.owner)
        return getVirtualMethodReference(mc.parameters[0], 
                getMethodIndex(cc, m), m.type())
    }

    @private
    method getInterfaceMethodReference(mc:MethodCall):String {
        if debug
            body.writeLine("; get pointer to first itable entry")
        var m := mc.methodNode
        var methodType := getLLVMMethodType(m)
        -- load class constant entry
        var target := mc.parameters[0]
        var cl := target.type.classNode
        var enter := createLabel()
        body.writeLine("br label %" + enter)
        createBlock(enter, "itable search entrance")
        var targetRef := getTypedReference(target)
        var classPointer := getTempVariable()
        writeBody(classPointer + " = getelementptr inbounds " + 
                targetRef + ", i32 0, i32 " + CLASS_POINTER_INDEX, 
                "get pointer to pointer to " + cl)
        var loadedClass := getTempVariable()
        var classType := getLLVMType(ClassType.CLASS())
        writeBody(loadedClass + " = load " + classType + "* " + 
                classPointer, "get pointer to " + cl)
        var itableFirst := getTempVariable()
        writeBody(itableFirst + " = getelementptr inbounds " + 
                classType + " " + loadedClass + ", i32 0, i32 " + ITABLE_INDEX, 
                "get pointer to first itable")
        var next := createLabel()
        body.writeLine("br label %" + next)
        var leavingEnterLabel := currentBlockLabel
        createBlock(next, "itable next")
        var itableNext := "%itableNext" + nameCount
        nameCount += 1
        var itablePtrPtr := getTempVariable()
        var fail := createLabel()
        body.writeLine(itablePtrPtr + " = phi %$itable** [ " + itableFirst +
                ", %" + leavingEnterLabel + "], [ " + itableNext + ", %" + 
                fail + " ]")
        var itablePtr := getTempVariable()
        body.writeLine(itablePtr + " = load %$itable** " + itablePtrPtr)
        var itableClassPtr := getTempVariable()
        body.writeLine(itableClassPtr + " = getelementptr inbounds %$itable* " + 
                itablePtr + ", i32 0, i32 0")
        var itableClass := getTempVariable()
        body.writeLine(itableClass + " = load " + classType + "* " + 
                itableClassPtr)
        var test := getTempVariable()
        var intfCC := getClassConstant(m.owner)
        writeBody(test + " = icmp eq " + classType + " bitcast(" + 
                intfCC.type + "* @" + 
                intfCC.name + " to " + classType + "), " + itableClass,
                "check for correct interface class")
        var success := createLabel()
        body.writeLine("br i1 " + test + ", label %" + success + ", label %" +
                fail)

        createBlock(fail, "itable test fail")
        writeBody(itableNext + " = getelementptr inbounds " + 
                "%$itable* " + itablePtr + ", i32 0, i32 1",
                "get pointer to next itable")
        body.writeLine("br label %" + next)

        createBlock(success, "itable test success")
        var methodIndex := getMethodIndex(intfCC, m)
        var methodPtrPtr := getTempVariable()
        writeBody(methodPtrPtr + " = getelementptr inbounds " +
                "%$itable* " + itablePtr + ", i32 0, i32 2, i32 " + 
                methodIndex, "get pointer to pointer to " + m.owner + "." + 
                m.name + ":" + m.returnType.name)
        var cast := getTempVariable()
        body.writeLine(cast + " = bitcast i8** " + methodPtrPtr +
                " to " + methodType + "*; convert pointer to method " +
                "pointer to correct type")
        var methodPtr := getTempVariable()
        writeBody(methodPtr + " = load " + methodType + "* " + cast, "get " + m)
        return methodPtr
    }
    
    @protected
    method createMethodCallReference(mc:MethodCall):String? {
        var m := mc.methodNode
        var methodRef:String
        if m.isEffectivelyVirtual & mc.isVirtual {
            assert !m.annotations.isClass
            assert mc.parameters.length >= 1 -- requires self
            var target := mc.parameters[0]
            var classNode := target.type.classNode
            if classNode.isInterface
                methodRef := getInterfaceMethodReference(mc)
            else
                methodRef := getVirtualMethodReference(mc)
        }
        else
            methodRef := "@" + getName(m)
        var text := ("fastcc " + getLLVMMethodType(m) + " " + methodRef + 
                "(")->>(MutableString)
        var parameterPrototypes := m.parameters
        var parameters := mc.parameters
        for i in 0 ... parameters.length - 1 {
            if i != 0
                text.append(", ")
            text.append(getTypedReference(parameters[i]))
        }
        text.append(")")
        if mc.type = VoidType.VOID {
            call(text->>(String))
            return null
        }
        else
            return createCallReference(text->>(String), mc->>(String))
    }

    @protected
    method createConstructReference(construct:Construct):String {
        var targetType := construct.methodNode.parameters[0].type
        var target := targetType.classNode
        var cc := getClassConstant(target)
        var cast := getTempVariable()
        var classType := getLLVMType(ClassType.CLASS())
        writeBody(cast + " = bitcast " + cc.type + "* @" + cc.name +
                " to " + classType, "convert class pointer")
        var alloc := createCallReference("i8* @_pandaNew(" + classType + " " + 
                cast + ", " + getLLVMType(Type.INDEX_TYPE) + " " + 
                target.size + ")", "allocate " + targetType.name)
    
        var result := createCommandReference("bitcast i8* " + alloc + " to " + 
                getLLVMType(targetType), "convert pointer to " + 
                targetType.name)

        var params := construct.parameters
        var finalParams := new Array<Value>()
        -- create a dummy value and force its reference to be what we want
        var dummyReference := new Dummy(targetType)
        dummyReference.setProperty(REFERENCE, result)
        finalParams.append(dummyReference)
        for i in 0 ... params.length - 1 {
            dummyReference := new Dummy(params[i].type)
            var ref := getReference(params[i])
            assert ref != null
            dummyReference.setProperty(REFERENCE, ref)
            finalParams.append(dummyReference)
        }
        var call := new MethodCall(construct.methodNode, false, finalParams)
        getReference(call) -- this inserts a call to the constructor
        return result
    }

    @protected
    method getTempVariable():String {
        var result := "%" + tempVariable
        tempVariable += 1
        return result
    }
    
    @private
    function isConstant(expr:String):Bit {
        return expr.startsWith("%") | expr.matches(#/\d+/#)
    }

    @protected
    method call(invocation:String, result:String?, comment:String?) {
        if result != null
            body.write(result + " = ")
        var currentTry:Try? := null
        var block:Node? := currentBlock
        while block != null {
            if block-?>(Catch) | block-?>(Finally) {
                -- if we're in a catch or finally, we don't want to be 
                -- considered a part of the corresponding Try
                block := block.parent
                assert block != null
            }
            else if block-?>(Try) {
                currentTry := block->(Try)
                break
            }
            block := block.parent
        }
        if currentTry != null {
            var success := createLabel()
            var fail := currentTry.getProperty(LANDING_PAD_LABEL)->(String?)
            if fail = null {
                fail := createLabel()
                currentTry.setProperty(LANDING_PAD_LABEL, fail)
            }
            body.writeLine("invoke " + invocation + " to label %" + success + 
                    " unwind label %" + fail)
            createBlock(success, "invoke success")
        }
        else
            body.write("call " + invocation)
        if debug & comment != null
            body.writeLine("; " + comment)
        else
            body.writeLine()
    }
    
    @protected 
    method call(invocation:String) {
        call(invocation, null, null)
    }
    
    @protected
    method createCallReference(codeString:String, comment:String):String {
        var result := getTempVariable()
        call(codeString, result, comment)
        return result
    }

    @protected
    method createCommandReference(codeString:String, comment:String):String {
        if isConstant(codeString)
            return codeString
        var result := getTempVariable()
        writeBody(result + " = " + codeString, comment)
        return result
    }
    
    @protected
    method createOverflowCheckedBinaryOperationReference(value:BinaryOperation, 
            op:String):String {
        var typeString := getLLVMType(value.type)
        var left := getTypedReference(value.left)
        var right := getTypedReference(value.right)
        var result := createCommandReference("call { " + typeString + 
                ", i1 } @llvm." + op + ".with.overflow." + typeString + "(" + 
                left + ", " + right + ")", value->>(String))
                var flag := getTempVariable()
        writeBody(flag + " = extractvalue { " + typeString + 
                ", i1 } " + result + ", 1", "extract overflow flag")
        var p := value.position
        call("void @pandaCheckOverflow(i1 " + flag + ")")
        return createCommandReference("extractvalue { " + typeString + 
                ", i1 } " + result + ", 0", "load results of '" + op + "'")
    }
    
    @protected
    method createBinaryOperationReference(b:BinaryOperation,
            var op:String):String {
        var cm := currentMethod
        assert cm != null
        if (op = "add" | op = "sub" | op = "mul") & 
                !cm.annotations.isOverflow &
                CompilerSettings.overflowChecking &
                (b-!>(Add) | !b->(Add).permitOverflow) &
                (b-!>(Subtract) | !b->(Subtract).permitOverflow) {
            if b.type.isInteger & b.type->(IntType).signed
                op := "s" + op
            else
                op := "u" + op
            return createOverflowCheckedBinaryOperationReference(b, op)
        }
        var left := getReference(b.left)
        var right := getReference(b.right)
        assert left != null & right != null
        return createCommandReference(op + " " + getLLVMType(b.operandType) + 
                " " + left + ", " + right, b->>(String))
    }
    
    @protected
    method createBinaryOperationReference(b:BinaryOperation, sop:String?, 
            uop:String?, fop:String?):String {
        var operandType := b.operandType
        var op:String?
        if operandType.isReal
            op := fop
        else if operandType = CharType.CHAR | (operandType.isInteger & 
                !operandType->(IntType).signed)
            op := uop
        else
            op := sop
        if op = null {
            throw new CompilerException("cannot compile '" + b + 
                    "', invalid types", b.position)
        }
        return createBinaryOperationReference(b, op)
    }
    
    @protected
    method createBinaryOperationReference(b:BinaryOperation, iop:String?, 
            fop:String?):String {
        return createBinaryOperationReference(b, iop, iop, fop)
    }
    
    @protected
    method createFieldReference(fr:FieldReference):String {
        if fr.field.annotations.isThread {
            var owner := fr.field.parent->(ClassNode)
            callClassInit(owner)
            var type := fr.type
            var suffix:String
            if type.isPrimitive
                suffix := fr.type.name[ClassNode.CORE.length..]
            else {
                suffix := "Object"
                type := ClassType.OBJECT()
            }
            var threadLocalId := getTempVariable()
            var indexField := owner.symbolTable.getVariable(fr.field.name + 
                    ASTGenerator.INDEX_SUFFIX)
            assert indexField != null
            body.writeLine("load i32* @" + getName(indexField))
            var callString := ("fastcc " + getLLVMType(type) + 
                    " @panda$core$Panda$getThreadLocal" + suffix + 
                    "(i32 " + threadLocalId + ", ")->>(MutableString)
            var initializer := owner.symbolTable.getMethod(fr.position,
                        ASTGenerator.getThreadLocalInitializerName(fr.field),
                        new Array<Value>(), true)
            if initializer != null {
                callString.append(
                        getLLVMType(NativePointerType.NATIVE_POINTER) + 
                        " bitcast(" + getLLVMType(fr.type) + "()* @" + 
                        getName(initializer->(MethodNode)) + " to " + 
                        getLLVMType(NativePointerType.NATIVE_POINTER) + "))")
            }
            else
                callString.append("i8* null)") -- no initializer function
            var ref := createCallReference(callString->>(String), fr->>(String))
            if !fr.type.isPrimitive & fr.type != ClassType.OBJECT() {
                var cast := getTempVariable()
                writeBody(cast + " = bitcast " + 
                    getLLVMType(type) + " " + ref + " to " + 
                    getLLVMType(fr.type), "cast Object to threadlocal")
                ref := cast
            }
            return ref
        }
        var value := getDefaultValue(fr.field)
        if fr.field.getProperty(CONSTANT) = true
            return value
        var ep := getFieldPointer(fr.object, fr.field)
        if fr.field-?>(FieldStub) {
            var rawType := getLLVMType(fr.field->(FieldStub).baseField.type)
            var load := createCommandReference("load " + 
                    rawType + "* " + ep, fr->>(String))
            return createCommandReference("bitcast " + rawType + " " + load + 
                    " to " + getLLVMType(fr.field.type), "generics cast")
        }
        else {
            return createCommandReference("load " + getLLVMType(fr.field.type) + 
                    "* " + ep, fr->>(String))
        }
    }
    
    @protected
    method createCastReference(c:Cast):String? {
        var tempResult := getReference(c.value)
        assert tempResult != null
        var actualType := c.value.type
        var destType := c.type
        if actualType = destType
            return tempResult
        var actualSize := actualType.size
        var destSize := destType.size
        var command:String? := null
        if actualSize = destSize & 
                (actualType.isInteger | actualType = CharType.CHAR) & 
                (destType.isInteger | destType = CharType.CHAR) {
            -- actual bits aren't changing, just the logical type
            return tempResult
        }
        if actualType.isInteger & (destType.isInteger | 
                destType = CharType.CHAR) {
            if actualSize > destSize
                -- int narrowing
                command := "trunc"
            else if actualType->(IntType).signed
                -- signed int widening
                command := "sext"
            else
                -- unsigned int widening
                command := "zext"
        }
        else if actualType.isReal & destType.isReal {
            if actualSize > destSize
                -- real64 ->> real32
                command := "fptrunc"
            else
                -- real32 ->> real64
                command := "fpext"
        }
        else if actualType.isReal & destType.isInteger {
            -- real to signed int
            command := "fptosi"
        }
        else if actualType.isInteger & destType.isReal {
            if actualType->(IntType).signed {
                -- signed int to real
                command := "sitofp"
            }
            else {
                -- unsigned int to real
                command := "uitofp"
            }
        }
        else if actualType = CharType.CHAR & destType.isInteger {
            if actualSize > destSize
                -- char narrowing
                command := "trunc"
            else
                -- char widening
                command := "zext"
        }
        else if actualType.isReal & destType = CharType.CHAR {
            -- real to char
            command := "fptoui"
        }
        else if actualType = CharType.CHAR & destType.isReal {
            -- char to real
            command := "uitofp"
        }
     
        if command != null {
            var result := getTempVariable()
            body.writeLine(result + " = " + command + " " + 
                    getLLVMType(actualType) + " " + tempResult + 
                    " to " + getLLVMType(destType), c.value + " -> " + 
                    destType.name)
            return result
        }
        else {
            -- casting one type of object to another, can simply bitcast the
            -- pointer
            assert !actualType.isPrimitive
            assert !destType.isPrimitive
            def checkCast := !c.safe & CompilerSettings.checkCasts
            if checkCast {
                -- verify the cast. Use a dummy for the first 
                -- parameter just to get the type right.
                var params := new Array<Value>(new Dummy(actualType), 
                        new ClassObjectLiteral(destType), 
                        new BitLiteral(destType.isNullable))
                var panda := ClassType.PANDA().classNode
                var check := panda.symbolTable.getMethod(c.position,
                        "checkCast", params, true)
                assert check != null
                for i in 1 ... params.length - 1
                    getTypedReference(params[i])
                var intermediate := tempResult
                if actualType != ClassType.OBJECT() {
                    intermediate := getTempVariable()
                    writeBody(intermediate + " = bitcast " + 
                            getLLVMType(actualType) + " " + tempResult + 
                            " to " + getLLVMType(ClassType.OBJECT()),
                            c.value + " -> " + ClassType.OBJECT().name)
                }
                var callString := ("fastcc void @" + getName(check) + 
                        "(")->>(MutableString)
                callString.append(getLLVMType(ClassType.OBJECT()) + " " + 
                        intermediate)
                for i in 1 ... params.length - 1 {
                    callString.append(", ")
                    callString.append(getTypedReference(params[i]))
                }
                callString.append(")")
                call(callString->>(String), null, "check cast " + c + ":" + 
                        c.position)
            }
            if destType = actualType.unwrapNullable
                return tempResult
            else if !actualType.isPrimitive & 
                    destType = actualType.getNullableVersion()
                return tempResult
            var result := getTempVariable()
            writeBody(result + " = bitcast " + 
                    getLLVMType(actualType) + " " + tempResult + " to " + 
                    getLLVMType(destType), 
                    c.value + " -> " + destType.name)
            return result
        }
    }
    
    @protected
    method createVariableReference(vr:VariableReference):String {
        var variable := promotedParameters[vr.variable]->(Variable?)
        if variable = null
            variable := vr.variable
        if variable-?>(Parameter)
            return "%" + getName(variable)
        return createCommandReference("load " + getLLVMType(vr.type) + "* %" + 
                getName(variable), vr->>(String))
    }
    
    @pre(array.type.isArray)
    @pre(index.type = Type.INDEX_TYPE)
    method getArrayElementPointer(array:Value, index:Value):String {
        var arrayRef := getTypedReference(array)
        var indexRef := getTypedReference(index)
        if CompilerSettings.boundsChecking {
            var cast := getTempVariable()
            var arrayType := getLLVMType(ClassType.ARRAY())
            body.writeLine(cast + " = bitcast " + arrayRef + 
                    " to " + arrayType)
            call("void @pandaCheckBounds(" + arrayType + " " + cast + 
                    ", " + indexRef + ")")
        }
        var arrayContentsPointer := createCommandReference("getelementptr " +
                "inbounds " + arrayRef + ", i32 0, i32 " + ARRAY_CONTENTS_INDEX, 
                "get pointer to pointer to array contents")
        var elementType := array.type.elementType
        var arrayContents := createCommandReference("load " + 
                getLLVMType(elementType) + 
                "** " + arrayContentsPointer, 
                "get pointer to array contents")
        return createCommandReference("getelementptr inbounds " + 
                getLLVMType(elementType) + "* " + 
                arrayContents + ", " + indexRef, 
                "get pointer to " + array + "[" + index + "]")
    }
    
    @private
    method callClassInit(cl:ClassNode) {
        var classInit := cl.symbolTable.getMethod(cl.position,
                MethodNode.CLASS_INIT_NAME, new Array<Value>(), true)
        if classInit = null {
            throw new InternalCompilerException("classInit method not found " +
                    " in " + cl.name, cl.position)
        }
        else                            
            call("fastcc void @" + getName(classInit) + "()")
    }
    
    @protected
    @pre(!object.type.isPrimitive)
    @pre(!field.annotations.isThread)
    method getFieldPointer(object:Value, field:FieldNode):String {
        if field.annotations.isClass {
            if field.name != FieldNode.CLASS_INITED_NAME
                callClassInit(field.parent->(ClassNode))
            return "@" + getName(field)
        }
        else {
            var cl := object.type.classNode
            var fields := cl.unifiedFields
            for i in 0 .. fields.length {
                if fields[i] = field {
                    return createCommandReference("getelementptr inbounds " + 
                        getTypedReference(object) + 
                        ", i32 0, i32 " + i, "field pointer: " + object + "." +
                        field.name)
                }
            }
            error("failed to find field \{field} (\{field.owner}) in \{object} " +
                    "(\{object.type.name}), \{currentMethod->(MethodNode)}", 
                    object.position)
            return "error"
        } 
    }

    @protected
    method createReusedValueDefinitionReference(rvd:ReusedValueDefinition):String {
        def result := createReference(rvd.value)->(String)
        rvd.setProperty(REFERENCE, result)
        return result
    }

    @protected
    method createReusedValueReference(rv:ReusedValue):String {
        def result := rv.owner.getProperty(REFERENCE)->(String?)
        assert result != null: "ReusedValueDefinition (" + rv.owner + ", " +
                rv.owner.position + ") has not had a REFERENCE defined"
        return result
    }

    @protected
    method createVariableAssignmentReference(va:VariableAssignment):String {
        var variable := promotedParameters[va.variable]->(Variable?)
        if variable = null
            variable := va.variable
        var lref := getLLVMType(variable.type) + "* %" + getName(variable)
        var result := getReference(va.value)
        assert result != null
        writeBody("store " + getLLVMType(variable.type) + " " + result + ", " + 
                lref, va->>(String))
        return result
    }
    
    method createIndexValueReference(iv:IndexValue):String {
        var ep := getArrayElementPointer(iv.array, iv.index)
        return createCommandReference("load " + getLLVMType(iv.type) + "* " + 
                ep + "; " + iv, iv->>(String))
    }
    
    method createAndReference(and:And):String {
        var left := getReference(and.left)
        assert left != null
        var leftFromLabel := currentBlockLabel
        var rightLabel := createLabel()
        var endLabel := createLabel()
        writeBody("br i1 " + left + ", label %" + rightLabel + 
                ", label %" + endLabel,
                "and test: " + and)
        body.writeLine()
        createBlock(rightLabel, "right: " + and)
        var right := getReference(and.right)
        assert right != null
        var rightFromLabel := currentBlockLabel
        body.writeLine("br label %" + endLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + and)
        var result := getTempVariable()
        body.writeLine(result + " = phi i1 [false, %" + leftFromLabel + 
                "], [" + right + ", %" + rightFromLabel + "]")
        return result
    }
    
    method createOrReference(or:Or):String {
        var left := getReference(or.left)
        assert left != null
        var leftFromLabel := currentBlockLabel
        var rightLabel := createLabel()
        var endLabel := createLabel()
        writeBody("br i1 " + left + ", label %" + endLabel + 
                ", label %" + rightLabel, "or test: " + or)
        body.writeLine()
        createBlock(rightLabel, "right: " + or)
        var right := getReference(or.right)
        assert right != null
        var rightFromLabel := currentBlockLabel
        body.writeLine("br label %" + endLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + or)
        var result := getTempVariable()
        body.writeLine(result + " = phi i1 [true, %" + leftFromLabel + 
                "], [" + right + ", %" + rightFromLabel + "]")
        return result
    }

    method createTernaryReference(t:Ternary):String {
        var test := getReference(t.test)
        assert test != null
        var leftLabel := createLabel()
        var rightLabel := createLabel()
        var endLabel := createLabel()
        writeBody("br i1 " + test + ", label %" + leftLabel + 
                ", label %" + rightLabel, "ternary test: " + t)
        body.writeLine()

        createBlock(leftLabel, "left: " + t)
        var left := getReference(t.left)
        assert left != null
        var leftFromLabel := currentBlockLabel
        body.writeLine("br label %" + endLabel)
        
        createBlock(rightLabel, "right: " + t)
        var right := getReference(t.right)
        assert right != null
        var rightFromLabel := currentBlockLabel
        body.writeLine("br label %" + endLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + t)
        var result := getTempVariable()
        body.writeLine(result + " = phi " + getLLVMType(t.type) + 
                " [" + left + ", %" + leftFromLabel + 
                "], [" + right + ", %" + rightFromLabel + "]")
        return result
    }

    method createNewArrayWithLengthReference(na:NewArrayWithLength):String {
        var arrayClass := na.type.classNode
        var cc := getClassConstant(arrayClass)
        var cast := getTempVariable()
        var elementType := na.type.elementType
        var classType := getLLVMType(ClassType.CLASS())
        writeBody(cast + " = bitcast " + cc.type + "* @" + 
                cc.name + " to " + classType,
                "convert class pointer")
        var ref := getReference(na.arrayLength)
        assert ref != null
        var alloc := createCallReference("i8* " +
                "@pandaNewArrayWithLength(" + classType + " " + cast + 
                ", i32 " + ref + ", i32 " + elementType.size + ", i1 " + 
                !elementType.isPrimitive + ")", "allocate " + na.type.name)
        var result := createCommandReference("bitcast i8* " + alloc + " to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }
    
    method createNewArrayWithRangeReference(na:NewArrayWithRange):String {
        var arrayClass := na.type.classNode
        var cc := getClassConstant(arrayClass)
        var cast := getTempVariable()
        var elementType := na.type.elementType
        var classType := getLLVMType(ClassType.CLASS())
        writeBody(cast + " = bitcast " + cc.type + "* @" + 
                cc.name + " to " + classType, "convert class pointer")
        var rawArray := getTypedReference(na.source)
        var arrayCast := getTempVariable()
        -- this cast isn't necessary legal but it doesn't matter
        writeBody(arrayCast + " = bitcast " + rawArray + " to " + 
                getLLVMType(ClassType.ARRAY()), "cast array pointer to Array")
        var alloc := createCallReference("i8* " +
                "@pandaNewArrayWithRange(" + classType + " " + cast + ", " + 
                getLLVMType(ClassType.ARRAY()) + " " + arrayCast + ", " +
                getTypedReference(na.offset) + ", " +
                getTypedReference(na.arrayLength) + ", i32 " + 
                elementType.size + ", i1 " + !elementType.isPrimitive +
                 ")", "allocate " + na.type.name)
        var result := createCommandReference("bitcast i8* " + alloc + " to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }
    
    method createNewArrayWithValuesReference(na:NewArrayWithValues):String {
        var elementType := na.type.elementType
        var arrayClass := na.type.classNode
        var cc := getClassConstant(arrayClass)
        var cast := getTempVariable()
        var classType := getLLVMType(ClassType.CLASS())
        writeBody(cast + " = bitcast " + cc.type + "* @" + cc.name +
                " to " + classType, "convert class pointer")
        var type:Int
        constant ARRAY_INT8   := 0
        constant ARRAY_INT16  := 1
        constant ARRAY_INT32  := 2
        constant ARRAY_INT64  := 3
        constant ARRAY_REAL32 := 4
        constant ARRAY_REAL64 := 5
        constant ARRAY_PTR    := 6
        switch elementType {
            case IntType.INT8, IntType.UINT8, BitType.BIT: 
                type := ARRAY_INT8

            case IntType.INT16, IntType.UINT16, CharType.CHAR: 
                type := ARRAY_INT16

            case IntType.INT32, IntType.UINT32: 
                type := ARRAY_INT32

            case IntType.INT64, IntType.UINT64: 
                type := ARRAY_INT64

            case RealType.REAL32: 
                type := ARRAY_REAL32

            case RealType.REAL64: 
                type := ARRAY_REAL64

            default:
                type := ARRAY_PTR
        }
        var references:Array<String> := []
        for v in na.values {
            var raw := getTypedReference(v)
            if type = ARRAY_REAL32 {
                -- varargs requires promotion of float to double, and evidently
                -- we have to do it ourselves
                references.append("double " + createCommandReference("fpext " + 
                        raw + " to double", "varargs promotion"))
            }
            else
                references.append(raw)
        }
        var code := ("i8* (" + classType + ", " + 
                getLLVMType(Type.INDEX_TYPE) + ", i32, ...)* " +
                "@pandaNewArrayWithValues(" + classType + " " + cast + ", i32 " + 
                na.values.length + ", i32 " + type)->>(MutableString)
        for r in references {
            code.append(", ")
            code.append(r)
        }
        code.append(")")
        var alloc := createCallReference(code->>(String), 
                "allocate " + na.type.name)
        var result := createCommandReference("bitcast i8* " + alloc + " to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }
    
    -- FIXME use standard conversion function when it's available
    function hexString(var i:UInt64):String {
        var digits := "0123456789ABCDEF"
        var result := new MutableString()
        while i != 0 {
            var digit := (i && 15)->(Int8)
            result.append(digits[digit])
            i >>= 4
        }
        return result->>(String).reverse
    }
    
    @protected
    @math(overflow)
    method createRealLiteralReference(r:RealLiteral):String {
        var bits := Panda.real64Bits(r.value)->>(UInt64)
        -- LLVM's float representation is completely insane -- it's not a float,
        -- it's a double with the 29 low-order bits zeroed
        if r.type = RealType.REAL32
            bits := bits && ((-1)->(UInt64) << 29->(UInt64))
        var hex := hexString(bits)
        return "0x" + "0" * (16 - hex.length) + hex
    }
    
    @protected
    method createUnaryMinusReference(u:UnaryMinus):String {
        var op:String
        var zero:Value
        if u.type.isReal {
            op := "fsub"
            zero := new RealLiteral(0)
        }
        else {
            op := "sub"
            zero := new IntegerLiteral(0)
        }
        var zeroRef := getReference(zero)
        assert zeroRef != null
        var valueRef := getReference(u.value)
        assert valueRef != null
        return createCommandReference(op + " " + getLLVMType(u.type) + 
                " " + zeroRef + ", " + valueRef, u->>(String))
    }
    
    @protected
    method createNotReference(n:Not):String {
        return createCommandReference("xor " + getTypedReference(n.value) + 
                ", 1", n->>(String))
    }
    
    @protected
    method createBitwiseNotReference(n:BitwiseNot):String {
        return createCommandReference("xor " + getTypedReference(n.value) + 
                ", -1", n->>(String))
    }
    
    @protected
    method createClassObjectLiteralReference(type:ClassObjectLiteral):String {
        var cl := type.value.classNode
        var cc := getClassConstant(cl)
        var classType := getLLVMType(ClassType.CLASS())
        return "bitcast(" + cc.type + "* @" + 
                cc.name + " to " + classType + ")"
    }

    @protected
    method createMethodValueReference(m:MethodValue):String {
        var raw := m.rawMethodNode
        var methodValue := raw.getProperty(METHOD_VALUE)->(String?)
        if methodValue = null {
            var shimmed := m.shimmedMethodNode
            methodValue := "@" + getName(raw) + "_value"
            var methodClass:ClassNode
            if m.type.isImmutable
                methodClass := ClassType.METHOD().classNode
            else
                methodClass := ClassType.MUTABLE_METHOD().classNode
            var cc := getClassConstant(methodClass)
            header.writeLine(methodValue + " = private unnamed_addr " +
                    "constant %" + getName(methodClass.type()) + " { " + 
                    getLLVMType(ClassType.CLASS()) + " bitcast(" + cc.type + 
                    "* @" + cc.name + " to " + getLLVMType(ClassType.CLASS()) + 
                    "), i8* bitcast(" + getLLVMMethodType(raw) + " @" + 
                    getName(raw) + " to i8*), i8* bitcast(" + 
                    getLLVMMethodType(shimmed) + " @" + 
                    getName(shimmed) + " to i8*) }, align " + 
                    NativePointerType.NATIVE_POINTER.size)
            raw.setProperty(METHOD_VALUE, methodValue)
        }
        return methodValue
    }

    @protected
    method createDynamicCallReference(d:DynamicCall):String? {
        def methodValue := getTypedReference(d.methodValue)
        def object := getClassConstant(ClassType.METHOD().classNode)
        var offset := object.methods.length
        -- FIXME uncomment this when shimming works
        if !d.type.isPrimitive
            offset += 1 -- shimmed
        def typeName := new MutableString(d.methodValue.type.unwrapNullable->(MethodType).name)
        assert typeName[0] = "("
        if typeName[1] = ")"
            typeName[1 .. 1] := d.methodValue.type.name
        else
            typeName[1 .. 1] := d.methodValue.type.name + ","
        def realType := SymbolTable.master.getType(Position.INTERNAL,
                typeName->>(String))->(MethodType)
        def methodPtr := getVirtualMethodReference(d.methodValue, offset,
                realType)
        def c := "fastcc "->>(MutableString)
        c.append(getLLVMMethodType(realType))
        c.append(" ")
        c.append(methodPtr)
        c.append("(")
        c.append(getTypedReference(d.methodValue))
        for i, p in d.parameters {
            c.append(", ")
            c.append(getTypedReference(p))
        }
        c.append(")")
        def result:String?
        if d.type = VoidType.VOID
            result := null
        else
            result := getTempVariable()
        call(c->>(String), result, d->>(String))
        return result
    }

-*    @protected
    method createDynamicCallReference(d:DynamicCall):String? {
        var methodValue := getTypedReference(d.methodValue)
        var offset:Int
        if d.type.isPrimitive
            offset := 1 -- raw
        else
            offset := 2 -- shimmed
        var methodPtrPtr:= createCommandReference(
                "getelementptr inbounds " + methodValue + ", i32 0, i32 " + 
                    offset, 
                "get pointer to actual method")
        var methodType := getLLVMMethodType(d.methodValue.type->(MethodType))
        var methodPtrRaw := createCommandReference("load i8** " + methodPtrPtr,
                "load method pointer")
        var methodPtr := createCommandReference("bitcast i8* " + 
                methodPtrRaw + " to " + methodType, 
                "cast method pointer to the correct type")
        var c := "fastcc "->>(MutableString)
        c.append(methodType)
        c.append(" ")
        c.append(methodPtr)
        c.append("(")
        for i, p in d.parameters {
            if i != 0
                c.append(", ")
            c.append(getTypedReference(p))
        }
        c.append(")")
        var result:String?
        if d.type = VoidType.VOID
            result := null
        else
            result := getTempVariable()
        call(c->>(String), result, d->>(String))
        return result
    }*-

    -- return value is nullable so void expressions (method calls) can return
    -- null
    @protected
    method createReference(v:Value):String? {
        switch v.class {
            case class(VariableAssignment): return createVariableAssignmentReference(v->(VariableAssignment))
            case class(Add): return createBinaryOperationReference(v->(BinaryOperation), "add", "fadd")
            case class(Subtract): return createBinaryOperationReference(v->(BinaryOperation), "sub", "fsub")
            case class(Multiply): return createBinaryOperationReference(v->(BinaryOperation), "mul", "fmul")
            case class(Divide): return createBinaryOperationReference(v->(BinaryOperation), null, "fdiv")
            case class(IntDivide): {
                var op:String
                if v.type->(IntType).signed
                    op := "sdiv"
                else
                    op := "udiv"
                return createBinaryOperationReference(v->(BinaryOperation), op, null)
            }
            case class(Remainder): return createBinaryOperationReference(v->(BinaryOperation), "srem", "urem", null)
            case class(ShiftLeft): return createBinaryOperationReference(v->(BinaryOperation), "shl", null)
            case class(ShiftRight): {
                if v.type->(IntType).signed
                    return createBinaryOperationReference(v->(BinaryOperation), "ashr", null)
                else
                    return createBinaryOperationReference(v->(BinaryOperation), "lshr", null)
            }
            case class(And): return createAndReference(v->(And))
            case class(Or): return createOrReference(v->(Or))
            case class(Xor): return createBinaryOperationReference(v->(BinaryOperation), "xor", null)
            case class(BitwiseAnd): return createBinaryOperationReference(v->(BinaryOperation), "and", null)
            case class(BitwiseOr): return createBinaryOperationReference(v->(BinaryOperation), "or", null)
            case class(BitwiseXor): return createBinaryOperationReference(v->(BinaryOperation), "xor", null)
            case class(Construct): return createConstructReference(v->(Construct))
            case class(MethodCall): return createMethodCallReference(v->(MethodCall))
            case class(StringLiteral): return getStringConstantReference(v->(StringLiteral).value)
            case class(IntegerLiteral): return v->(IntegerLiteral).value->>(String)
            case class(RealLiteral): return createRealLiteralReference(v->(RealLiteral))
            case class(VariableReference): return createVariableReference(v->(VariableReference))
            case class(FieldReference): return createFieldReference(v->(FieldReference))
            case class(Cast): return createCastReference(v->(Cast))
            case class(Equal): return createBinaryOperationReference(v->(BinaryOperation), "icmp eq", "fcmp oeq")
            case class(Identity): return createBinaryOperationReference(v->(BinaryOperation), "icmp eq")
            case class(LessThan): return createBinaryOperationReference(v->(BinaryOperation), "icmp slt", "icmp ult", "fcmp olt")
            case class(GreaterThan): return createBinaryOperationReference(v->(BinaryOperation), "icmp sgt", "icmp ugt", "fcmp ogt")
            case class(LessThanOrEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp sle", "icmp ule", "fcmp ole")
            case class(GreaterThanOrEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp sge", "icmp uge", "fcmp oge")
            case class(NotEqual): return createBinaryOperationReference(v->(BinaryOperation), "icmp ne", "fcmp one")
            case class(NotIdentity): return createBinaryOperationReference(v->(BinaryOperation), "icmp ne")
            case class(BitLiteral): return v->(BitLiteral).value->>(String)
            case class(IndexValue): return createIndexValueReference(v->(IndexValue))
            case class(NewArrayWithLength): return createNewArrayWithLengthReference(v->(NewArrayWithLength))
            case class(NewArrayWithValues): return createNewArrayWithValuesReference(v->(NewArrayWithValues))
            case class(NewArrayWithRange): return createNewArrayWithRangeReference(v->(NewArrayWithRange))
            case class(Not): return createNotReference(v->(Not))
            case class(BitwiseNot): return createBitwiseNotReference(v->(BitwiseNot))
            case class(UnaryMinus): return createUnaryMinusReference(v->(UnaryMinus))
            case class(NullLiteral): return "null"
            case class(ClassObjectLiteral): return createClassObjectLiteralReference(v->(ClassObjectLiteral))
            case class(Ternary): return createTernaryReference(v->(Ternary))
            case class(Unwrap): return createReference(v->(Unwrap).value)
            case class(AndLeft): return createReference(v->(AndLeft).value)
            case class(OrLeft): return createReference(v->(OrLeft).value)
            case class(MethodValue): return createMethodValueReference(v->(MethodValue))
            case class(DynamicCall): return createDynamicCallReference(v->(DynamicCall))
            case class(ReusedValueDefinition): return createReusedValueDefinitionReference(v->(ReusedValueDefinition))
            case class(ReusedValue): return createReusedValueReference(v->(ReusedValue))
            default: {
                throw new CompilerException("unsupported value class: " + 
                        v.class.name, v.position)
            }
        }
    }
    
    -- return value is nullable so void expressions (method calls) can return
    -- null
    @protected
    method getReference(v:Value):String? {
        var result := v.getProperty(REFERENCE)->(String?)
        if result = null {
            result := createReference(v)
            if result != null
                v.setProperty(REFERENCE, result)
        }
        return result
    }
    
    @protected
    method getTypedReference(v:Value):String {
        var ref := getReference(v)
        assert ref != null
        return getLLVMType(v.type) + " " + ref
    }
    
    @protected
    method generateValueStatementCode(v:ValueStatement) {
        getReference(v.value)
    }
    
    @protected
    method generateIndexedAssignmentCode(ia:IndexedAssignment) {
        var ep := getArrayElementPointer(ia.array, ia.index)
        var elementType := ia.array.type.elementType
        var lref := getLLVMType(elementType) + "* " + ep
        var ref := getReference(ia.value) 
        assert ref != null
        writeBody("store " + getLLVMType(elementType) + " " + ref + ", " + lref, 
                ia->>(String))
    }
    
    @protected
    method generateFieldAssignmentCode(fa:FieldAssignment) {
        if !fa.fieldNode.annotations.isThread {
            var ep := getFieldPointer(fa.object, fa.fieldNode)
            var lref := getLLVMType(fa.fieldNode.type) + "* " + ep
            var vref := getReference(fa.value)
            assert vref != null
            writeBody("store " + getLLVMType(fa.fieldNode.type) + " " + 
                    vref + ", " + lref, fa->>(String))
        }
        else {
            var owner := fa.fieldNode.parent->(ClassNode)
            callClassInit(owner)
            var threadLocalId := getTempVariable()
            var indexField := owner.symbolTable.getVariable(fa.fieldNode.name + 
                    ASTGenerator.INDEX_SUFFIX)
            assert indexField != null
            body.writeLine("load i32* @" + getName(indexField))
            var ref := getReference(fa.value)
            assert ref != null
            if !fa.value.type.isPrimitive & 
                    fa.value.type != ClassType.OBJECT() {
                var cast := getTempVariable()
                writeBody(cast + " = bitcast " + 
                        getLLVMType(fa.value.type) + " " + ref + " to " + 
                        getLLVMType(ClassType.OBJECT()), 
                        "cast threadlocal to Object")
                ref := getLLVMType(ClassType.OBJECT()) + " " + cast
            }
            else
                ref := getLLVMType(fa.value.type) + " " + ref
            var suffix:String
            if fa.value.type.isPrimitive
                suffix := fa.value.type.name[ClassNode.CORE.length..]
            else
                suffix := "Object"
            call("void @panda$core$Panda$setThreadLocal" + 
                    suffix + "(i32 " + threadLocalId + ", " + ref + ")")
        }
    }
    
    @protected
    method generateIfCode(i:If) {
        if debug
            body.writeLine("; " + i)
        var ifLabel := createLabel()
        var elseLabel := createLabel()
        var endLabel:String
        if i.elseBlock != null
            endLabel := createLabel()
        else
            endLabel := elseLabel
        writeBody("br " + getTypedReference(i.test) + 
                ", label %" + ifLabel + ", label %" + elseLabel, 
                "if test: " + i.test)
        body.writeLine()
        createBlock(ifLabel, "then: " + i)
        generateBlockCode(i.ifBlock)
        if !i.ifBlock.endsInBranch
            writeBody("br label %" + endLabel, "then -> end")
        body.writeLine()
        var elseBlock := i.elseBlock
        if elseBlock != null {
            createBlock(elseLabel, "else: " + i)
            generateBlockCode(elseBlock)
            if !elseBlock.endsInBranch
                writeBody("br label %" + endLabel, "else -> end")
            body.writeLine()
        }
        createBlock(endLabel, "end: " + i)
    }
    
    @protected
    method getStatementReference(statement:String):String {
        var result := getTempVariable()
        body.writeLine(result + " = " + statement)
        return result
    }

    @protected
    method generateWhileCode(w:While) {
        var bodyLabel := createLabel()
        var nextLabel := createLabel()
        var endLabel := createLabel()
        w.setProperty(NEXT_LABEL, nextLabel)
        w.setProperty(END_LABEL, endLabel)
        body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + w)
        writeBody("br " + getTypedReference(w.test) + 
                ", label %" + bodyLabel + ", label %" + endLabel,
                "while test: " + w.test)
        body.writeLine()
        createBlock(bodyLabel, "body: " + w)
        generateBlockCode(w.block())
        if !w.block.endsInBranch
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + w)
    }

    @protected
    method generateDoCode(d:Do) {
        var bodyLabel := createLabel()
        var nextLabel := createLabel()
        var endLabel := createLabel()
        d.setProperty(NEXT_LABEL, nextLabel)
        d.setProperty(END_LABEL, endLabel)
        body.writeLine("br label %" + bodyLabel)
        body.writeLine()
        createBlock(bodyLabel, "body: " + d)
        generateBlockCode(d.block)
        if !d.block.endsInBranch
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + d)
        writeBody("br " + getTypedReference(d.test) + 
                ", label %" + bodyLabel + ", label %" + endLabel,
                "do test: " + d.test)
        body.writeLine()
        createBlock(endLabel, "end: " + d)
    }

    @protected
    method generateLoopCode(l:Loop) {
        def nextLabel := createLabel()
        def endLabel := createLabel()
        l.setProperty(NEXT_LABEL, nextLabel)
        l.setProperty(END_LABEL, endLabel)
        body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + l)
        generateBlockCode(l.block)
        if !l.block.endsInBranch
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + l)
    }

    @protected
    method generateLoopWithContinueBlockCode(l:LoopWithContinueBlock) {
        def startLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        l.setProperty(NEXT_LABEL, nextLabel)
        l.setProperty(END_LABEL, endLabel)
        body.writeLine("br label %" + startLabel)
        body.writeLine()
        createBlock(startLabel, "start: " + l)
        generateBlockCode(l.block)
        if !l.block.endsInBranch
            body.writeLine("br label %" + nextLabel)
        createBlock(nextLabel, "next: " + l)
        generateBlockCode(l.continueBlock)
        assert !l.continueBlock.endsInBranch
        body.writeLine("br label %" + startLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + l)
    }

    @class
    function findLoop(o:Node, label:String?):AbstractLoop? {
        var ancestor := o.parent
        while ancestor != null {
            if ancestor-?>(AbstractLoop) {
                var loopLabel := ancestor->(AbstractLoop).label
                if label = null
                    break
                else if label = loopLabel
                    break
            }
            ancestor := ancestor.parent
        }
        if ancestor-?>(AbstractLoop)
            return ancestor->(AbstractLoop)
        else
            throw new CompilerException("no matching loop found", o.position)
    }

    @protected
    method generateReturnCode(ret:Return) {
        var value := ret.value
        if value = null
            body.writeLine("ret void ; " + ret)
        else
            writeBody("ret " + getTypedReference(value), ret->>(String))
    }
    
    @protected
    method generateBreakCode(br:Break) {
        var loopNode := findLoop(br, br.label)
        var endLabel := loopNode.getProperty(END_LABEL)->(String?)
        assert endLabel != null
        writeBody("br label %" + endLabel, br->>(String))
    }

    @protected
    method generateContinueCode(c:Continue) {
        var loopNode := findLoop(c, c.label)
        var nextLabel := loopNode.getProperty(NEXT_LABEL)->(String?)
        assert nextLabel != null
        writeBody("br label %" + nextLabel, c->>(String))
    }

    ============================================================================
    Returns a snippet of LLVM code (with type i8*) which refers to a 
    null-terminated string.
    ============================================================================
    method getCString(s:String):String {
        var type := "[" + (s.length + 1) + " x i8]"
        var result := "cs" + cStringCount
        cStringCount += 1
        header.write("@" + result + 
                " = private constant " + type + " [ ")
        for i in 0 ... s.length - 1 {
            if i > 0
                header.write(", ")
            header.write("i8 " + s[i]->(Int))
        }
        if s.length > 0
            header.write(", ")
        header.write("i8 0")
        header.writeLine(" ], align 1")
        return "bitcast(" + type + "* @" + result + " to i8*)"
    }

    @protected
    method generateAssertCode(a:Assert) {
        var succeedLabel := createLabel()
        var failLabel := createLabel()
        writeBody("br " + getTypedReference(a.test) + 
                ", label %" + succeedLabel + ", label %" + failLabel,
                "assert test: " + a)
        body.writeLine()
        createBlock(failLabel, "fail: " + a)
        var msg := a.message
        if msg != null {
            if msg.type = ClassType.STRING() {
                call("void " + FAIL_ASSERT_NAME + "(" + getTypedReference(msg) + 
                        ")")
            }
            else {
                assert msg.type = ClassType.ERROR()
                call("void @pandaThrow(" + getTypedReference(msg) + ")")
            }
        }
        else {
            call("void " + FAIL_ASSERT_NAME + "(" +
                    getLLVMType(ClassType.STRING()) + " null)")
        }
        body.writeLine("unreachable")
        body.writeLine()
        createBlock(succeedLabel, "succeed: " + a)
    }
    
    @protected
    method generateUnreachableCode(u:Unreachable) {
        call("void " + FAIL_ASSERT_NAME + "(" +
                getLLVMType(ClassType.STRING()) + " null)")
    }

    @protected
    method generateThrowCode(t:Throw) {
        call("void @pandaThrow(" + getTypedReference(t.error) + ")")
    }
    
    @protected
    method generateTryCode(t:Try) {
        var exitLabel := createLabel()
        generateBlockCode(t.block)
        if !t.block.endsInBranch
            body.writeLine("br label %" + exitLabel)
        var classType := getLLVMType(ClassType.CLASS())
        var objectType := getLLVMType(ClassType.OBJECT())
        var errorType := getLLVMType(ClassType.ERROR())
        var lpLabel := t.getProperty(LANDING_PAD_LABEL)->(String?)
        if lpLabel != null {
            -- set up landing pad
            createBlock(lpLabel, "landing pad")
            var landingPad := getTempVariable()
            body.writeLine(landingPad + 
                    " = landingpad { i8*, i32 } personality i8* bitcast " +
                    "(i32 (...)* @pandaPersonality to i8*)")
            body.level += 1
            for i in 0 ... t.length - 1 {
                if t[i]-?>(Catch) {
                    var c := t[i]->(Catch)
                    c.setProperty(CATCH_TEST_LABEL, createLabel())
                    var catchClass := c.exception.type.classNode
                    var cc := getClassConstant(catchClass)
                    body.writeLine("catch i8* bitcast (" + cc.type + 
                            "* @" + cc.name + " to i8*)")
                }
            }
            body.level -= 1
            
            -- get exception
            var nativeException := getTempVariable()
            body.writeLine(nativeException + 
                    " = extractvalue { i8*, i32 } " + landingPad + 
                    ", 0")
            var error := getTempVariable()
            body.writeLine(error + 
                    " = call " + errorType + " @pandaCatch(i8* " + 
                    nativeException + ")")
            var errorObject := getTempVariable()
            body.writeLine(errorObject + " = bitcast " + errorType + 
                    " " + error + " to " + objectType)

            -- run through each catch type, checking to see if we have the right
            -- kind of variable
            var resumeLabel := createLabel()
            var first := true
            for i in 0 ... t.length - 1 {
                if t[i]-?>(Catch) {
                    var c := t[i]->(Catch)
                    if first {
                        if debug {
                            body.writeLine("; catch test for " + 
                                    c.exception.type.name)
                        }
                    }
                    else
                        createBlock(c.getProperty(CATCH_TEST_LABEL)->(String),
                                "catch test for " + c.exception.type.name)
                    first := false
                    var catchLabel := createLabel()
                    c.setProperty(CATCH_LABEL, catchLabel)
                    var catchClass := c.exception.type.classNode
                    var catchClassConstant := getClassConstant(catchClass)
                    var test := getTempVariable()
                    body.writeLine(test + 
                            " = call i1 " +
                            "@panda$core$Panda$instanceOf(" + 
                            objectType + " " + errorObject + ", " + classType + 
                            " bitcast(" + catchClassConstant.type + "* @" + 
                            catchClassConstant.name + " to " + classType + 
                            "), i1 0)")
                    var nextLabel := resumeLabel
                    for j in i + 1 ... t.length - 1 {
                        if t[j]-?>(Catch) {
                            nextLabel := 
                                    t[j].getProperty(CATCH_TEST_LABEL)->(String)
                            break
                        }
                    }
                    -- either branch to the catch for this type or to the next
                    -- test
                    body.writeLine("br i1 " + test + ", label %" + 
                            catchLabel + ", label %" + nextLabel)
                }
            }
            -- handle no match case
            createBlock(resumeLabel, "no match, re-throw")
            body.writeLine("resume { i8*, i32 } " + landingPad)
            
            -- write actual catch blocks
            for i in 0 ... t.length - 1 {
                if t[i]-?>(Catch) {
                    var c := t[i]->(Catch)
                    createBlock(c.getProperty(CATCH_LABEL)->(String), "catch " + 
                            c.exception.type.name)
                    -- cast error to the right type and store it in its
                    -- respective variable
                    var cast := getTempVariable()
                    body.writeLine(cast + " = bitcast " + errorType +
                            " " + error + " to " + 
                            getLLVMType(c.exception.type))
                    body.writeLine("store " + getLLVMType(c.exception.type) + 
                            " " + cast + ", " + getLLVMType(c.exception.type) + 
                            "* %" + getName(c.exception))
                    generateBlockCode(c)
                    if !c.endsInBranch
                        body.writeLine("br label %" + exitLabel)
                }
            }
        }
        createBlock(exitLabel, "after try")
    }

    @protected
    method generateStatementCode(s:Statement) {
        if debug
            body.writeLine("; " + s)
        switch s.class {
            case class(IndexedAssignment): 
                    generateIndexedAssignmentCode(s->(IndexedAssignment))
            case class(FieldAssignment): 
                    generateFieldAssignmentCode(s->(FieldAssignment))
            case class(ValueStatement):
                    generateValueStatementCode(s->(ValueStatement))
            case class(If): generateIfCode(s->(If))
            case class(While): generateWhileCode(s->(While))
            case class(Do): generateDoCode(s->(Do))
            case class(Loop): generateLoopCode(s->(Loop))
            case class(LoopWithContinueBlock): 
                    generateLoopWithContinueBlockCode(s->(LoopWithContinueBlock))
            case class(Block): generateBlockCode(s->(Block))
            case class(Return): generateReturnCode(s->(Return))
            case class(Break): generateBreakCode(s->(Break))
            case class(Continue): generateContinueCode(s->(Continue))
            case class(Assert): generateAssertCode(s->(Assert))
            case class(Throw): generateThrowCode(s->(Throw))
            case class(Try): generateTryCode(s->(Try))
            case class(CatchExit): { }
            case class(Unreachable): generateUnreachableCode(s->(Unreachable))
            default: error("unsupported statement: " + s, s.position)
        }
    }

    @private
    method clearReferences(n:Node) {
        n.clearProperty(REFERENCE)
        for i in 0 ... n.length - 1
            clearReferences(n[i])
    }
    
    @protected
    method generateBlockCode(b:Block) {
        var insertPoint:Int? := null
        if b.parent-?>(MethodNode) & 
                b.parent->(MethodNode).methodType = MethodNodeType.CONSTRUCTOR {
            var m := b.parent->(MethodNode)
            if !ASTGenerator.callsOtherSelfConstructor(m) {
                if ASTGenerator.callsSuperConstructor(m)
                    insertPoint := 1
                else
                    insertPoint := 0
            }
        }
        for i in 0 ... b.length {
            if i = insertPoint {
                -- insert field initializers
                var m := b.parent->(MethodNode)
                var cl := m.owner
                var selfParam := b.parent->(MethodNode).parameters[0]
                for j in 0 ... cl.length - 1 {
                    if cl[j]-?>(FieldNode) {
                        var f := cl[j]->(FieldNode)
                        getDefaultValue(f)
                        if f.getProperty(CONSTANT) = true
                            continue
                        if f.annotations.isClass | 
                                f.annotations.isThread |
                                f.initialValue = null
                            continue
                        -- it's an instance field with an initializer
                        var value := f.initialValue
                        assert value != null
                        value.removeFromParent()
                        if value-?>(FieldReference) & value->(FieldReference).object-?>(ReusedValue) {
                            -- tuple multi-assignment, need to capture tuple value
                            def rvd := value->(FieldReference).object->(ReusedValue).owner
                            if rvd.getProperty(REFERENCE) = null {
                                ASTGenerator.replaceSelf(rvd, selfParam)
                                generateStatementCode(new ValueStatement(rvd))
                            }
                        }
                        ASTGenerator.replaceSelf(value, selfParam)
                        var assignment := new FieldAssignment(f.position,
                                new VariableReference(selfParam), f, value)
                        clearReferences(assignment)
                        generateStatementCode(assignment)
                        value.removeFromParent()
                        f.initialValue := value
                    }
                }
            }
            if i < b.length {
                currentBlock := b
                generateStatementCode(b[i]->(Statement))
            }
        }
    }
    
    ============================================================================
    Recursively scan the tree, looking for parameters which have been assigned
    to and therefore need to be promoted to actual variables.
    
    @param node the node to scan
    ============================================================================
    @protected
    @pre(node-!>(MethodNode))
    method findPromotedParameters(node:Node) {
        if node-?>(MethodNode)
            throw new AssertionError("FIXME")
        if node-?>(VariableAssignment) {
            var variable := node->(VariableAssignment).variable
            if variable-?>(Parameter) {
                if promotedParameters[variable] = null {
                    promotedParameters[variable] := new LocalVariable(
                            variable.name, variable.type)
                }
            }
        }
        else {
            for i in 0 ... node.length - 1
                findPromotedParameters(node[i])
        }
    }
    
    @private
    method compilingCoreLibrary():Bit {
        -- not a great test for this, but works for now
        return ClassType.OBJECT().classNode.state = ClassNodeState.DEFINED
    }
 
    @protected
    method generateMethodCode(m:MethodNode) {
        if m.annotations.isAbstract | m-?>(MethodStub)
            return
        currentMethod := m
        tempVariable := 1
        var owner := m.parent->(ClassNode)
        var private := m.annotations.isPrivate
        var externalMethod := m.annotations.isExternal
        var external := externalMethod | 
                owner.state = ClassNodeState.EXTERNALLY_DEFINED
        promotedParameters := new HashMap()
        if !external
            findPromotedParameters(m.block)
        body.writeLine()
        if debug
            body.writeLine("; " + m)
        if external {
            body.write("declare ")
        }
        else {
            body.write("define ")
            if owner.isArray()
                body.write(SHARED_LINKAGE + " ")
        }
        if !externalMethod
            body.write("fastcc ")
        var name := getName(m)
        body.write(getLLVMType(m.returnType) + " @" + name + "(")
        for i, p in m.parameters {
            if i > 0
                body.write(", ")
            body.write(getLLVMType(p.type))
            if !external {
                body.write(" %") 
                body.write(getName(p))
            }
        }
        body.write(")")
        if m.methodType = MethodNodeType.FUNCTION & m.returnType.isImmutable
                body.write(" readonly")
        if external
            body.writeLine()
        else {
            body.writeLine(" {")
            body.level += 1
            currentBlockLabel := "0"
            for i in 0 ... m.localVariables.length - 1 {
                def v := m.localVariables[i]
                body.writeLine("%" + getName(v) + " = alloca " + 
                        getLLVMType(v.type))
            }
            for (key, value) in promotedParameters.entries {
                def variable := value->(Variable)
                -- FIXME this check shouldn't be necessary
                body.writeLine("%" + getName(variable) + " = alloca " + 
                        getLLVMType(variable.type))
                body.writeLine("store " + getLLVMType(variable.type) +
                        " %" + getName(key->(Variable)) + ", " + 
                        getLLVMType(variable.type) + "* %" + getName(variable))
            }
            
            generateBlockCode(m.block)
            if !(m.block.endsInBranch) {
                if m.returnType = VoidType.VOID
                    body.writeLine("ret void")
                else
                    body.writeLine("unreachable")
            }
            body.level -= 1
            body.writeLine("}")
        }
    }
    
    @private
    method getCharArrayConstantReference(chars:Array<Char>):String {
        var charArrayType := SymbolTable.master.getType(Position.INTERNAL,
                ClassNode.IMMUTABLE_ARRAY_NAME + "<panda.core.Char>")
        var charArrayClass := charArrayType.classNode
        var cc := getClassConstant(charArrayClass)
        var charsType := "[" + chars.length + " x " + 
                getLLVMType(CharType.CHAR) + "]"
        var type := "{ " + cc.type + "*, " +
                getLLVMType(Type.INDEX_TYPE) + ", " + 
                getLLVMType(Type.INDEX_TYPE) + ", " + 
                charsType + "* }"
        var result := "ca" + byteArrayCount
        byteArrayCount += 1
        var charsName := "@" + result + "_chars"
        header.write(charsName + " = private unnamed_addr constant " + 
                charsType + " [")
        for i in 0 ... chars.length - 1 {
            if i != 0
                header.write(", ")
            header.write(getLLVMType(CharType.CHAR) + " " + chars[i]->(Int))
        }
        header.writeLine("]")

        header.writeLine("@" + result + " = private unnamed_addr constant " + 
                type + " { " + cc.type + "* @" + cc.name + ", " + 
                getLLVMType(Type.INDEX_TYPE) + " " + chars.length + ", " +
                getLLVMType(Type.INDEX_TYPE) + " " + chars.length + ", " + 
                charsType + "* " + charsName + " }, align " +
                NativePointerType.NATIVE_POINTER.size)
        return "bitcast(" + type + "* @" + result + " to " + 
                getLLVMType(charArrayType) + ")"
    }

    @private
    method getStringConstantReference(s:String):String {
        var result := stringConstants[s]->(String?)
        if result = null {
            var string := SymbolTable.master.getClass(ClassNode.STRING_NAME)
            assert string != null
            var chars := getCharArrayConstantReference(s->>(Array<Char>))
            result := "@s" + stringConstants.length
            stringConstants[s] := result
            var charArrayType := SymbolTable.master.getType(Position.INTERNAL,
                    ClassNode.IMMUTABLE_ARRAY_NAME + "<panda.core.Char>")
            var cc := getClassConstant(string)
            if debug
                header.writeLine("; " + StringLiteral.escape(s))
            header.writeLine(result + " = private unnamed_addr constant " + 
                    "%" + getName(string.type()) + " { " + 
                    getLLVMType(ClassType.CLASS()) + " bitcast(" + cc.type + 
                    "* @" + cc.name + " to " + getLLVMType(ClassType.CLASS()) + 
                    "), " + getLLVMType(charArrayType) + " " + chars + " }," +
                    " align " + NativePointerType.NATIVE_POINTER.size)
            stringConstants[s] := result
        }
        return result
    }

    @protected
    method getClassConstant(name:String):ClassConstant {
        var cl := SymbolTable.master.getClass(name)
        assert cl != null
        return getClassConstant(cl)
    }
    
    @private
    method getITable(cl:ClassNode):String {
        -- FIXME use a set
        var visited := new HashMap()
        var interfaces := cl.allInterfaces()
        var previous := "%$itable* null"
        for intf in interfaces {
            if visited.contains(intf)
                continue
            visited[intf] := intf
            var intfCC := getClassConstant(intf)
            var methods := cl.interfaceMethods(intf)
            var name := "@" + getName(cl.type()) + "$." + getName(intf.type())
            var type := "{ " + getLLVMType(ClassType.CLASS()) + 
                    ", %$itable*, [" + methods.length + " x i8*] }"
            header.write(name + " = " + SHARED_LINKAGE + " constant ")
            header.write(type + " { " + 
                    getLLVMType(ClassType.CLASS()) + " bitcast(" + intfCC.type + 
                    "* @" + intfCC.name + " to " + 
                    getLLVMType(ClassType.CLASS()) + "), " + previous + ", [" + 
                    methods.length + " x i8*][")
            for i, rawM in methods {
                def m := rawM.unwrap()
                if i > 0
                    header.write(", ")
                if m.annotations.isAbstract
                    header.write("i8* null")
                else {
                    header.write("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            header.writeLine("] }")
            previous := "%$itable* bitcast(" + type + "* " + name + 
                    " to %$itable*)" 
        }
        return previous
    }

    @protected
    method getClassConstant(cl:ClassNode):ClassConstant {
        var cc := cl.getProperty(CLASS_CONSTANT)->(ClassConstant?)
        if cc = null {
            def methods := cl.virtualMethods
            cc := new ClassConstant(
                    getName(cl.type()) + "_class",
                    "{ " + getLLVMType(ClassType.CLASS()) + ", " + 
                    getLLVMType(ClassType.STRING()) +  ", " + 
                    getLLVMType(ClassType.CLASS()) + ", i1, i1, %$itable*, [" + 
                    methods.length + " x i8*] }", methods)
            cl.setProperty(CLASS_CONSTANT, cc)
            var name := cl.name
            if cl.type().isWrapper {
                assert name.endsWith("Wrapper")
                name := name[0 .. name.length - "Wrapper".length]
            }
            -- go ahead and get other class constants here, before we've written
            -- anything -- this could cause other class definitions to be
            -- printed, and we don't want to be in the middle of output when
            -- that happens
            var nameRef := "<error>"
            if cl.state != ClassNodeState.EXTERNALLY_DEFINED
                nameRef := getStringConstantReference(name)
            getClassConstant(ClassNode.CLASS_NAME)

            for m in methods {
                -- create declarations for dead methods so we can include them 
                -- in the vtable
                if !m.live & m.owner = cl {
                    var oldBody := body
                    var oldTemp := tempVariable
                    body := header
                    generateMethodCode(m)
                    body := oldBody
                    tempVariable := oldTemp
                }
            }

            var superclassConstant:ClassConstant?
            def superclass := cl.superclass
            if superclass != null
                superclassConstant := getClassConstant(superclass)
            else
                superclassConstant := null
            if cl.state = ClassNodeState.EXTERNALLY_DEFINED {
                header.write("@" + cc.name + " = ")
                header.writeLine("external global " + cc.type)
                return cc
            }
            var intf := getITable(cl)
            header.write("@" + cc.name + " = ")
            header.write(SHARED_LINKAGE + " ")
            var superclassRef:String
            if superclassConstant != null
                superclassRef := "bitcast(" + superclassConstant.type + "* @" + 
                        superclassConstant.name + " to " + 
                        getLLVMType(ClassType.CLASS()) + ")"
            else
                superclassRef := "null"
            -- class constant includes vtable. Doesn't include statics, as 
            -- those are just globals.
            var overridesFinalize := false
            for child in cl.children {
                if child-?>(MethodNode) {
                    var m := child->(MethodNode)
                    if m.name = MethodNode.FINALIZE_NAME & 
                            !m.annotations.isClass & 
                            m.parameters.length = 1
                        overridesFinalize := true
                }
            }
            def classClass := SymbolTable.master.getClass(ClassNode.CLASS_NAME)
            assert classClass != null
            def classClassConstant := getClassConstant(classClass)
            header.write("constant " + cc.type + 
                    " { " + getLLVMType(ClassType.CLASS()) + " bitcast(" + 
                    classClassConstant.type + "* @" + classClassConstant.name + 
                    " to " + getLLVMType(ClassType.CLASS()) + "), " + 
                    getLLVMType(ClassType.STRING()) + " " + nameRef + ", " + 
                    getLLVMType(ClassType.CLASS()) + " " + superclassRef + 
                    ", i1 1, i1 " + overridesFinalize + ", " + intf + ", [" + 
                    methods.length + " x i8*] [ ")
            for i, rawM in methods {
                def m := rawM.unwrap()
                if i > 0
                    header.write(", ")
                if m.annotations.isAbstract
                    header.write("i8* null")
                else {
                    header.write("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            header.writeLine(" ] }")
        }
        return cc
    }
    
    @protected
    method generateClassCode(cl:ClassNode) {
        MethodNamer.nameMethods(cl, new CMethodNamingStrategy())
        for child in cl.children {
            switch child.class {
                case class(MethodStub), class(FieldStub): { }
                case class(MethodNode):  {
                    if child.live
                        generateMethodCode(child->(MethodNode))
                }
                case class(FieldNode): {
                    var f := child->(FieldNode).unwrap()
                    if f.annotations.isClass & f.live {
                        -- write class field
                        body.write("@" + getName(f) + " = ")
                        if cl.state != ClassNodeState.DEFINED
                            body.write("external ")
                        else if cl.type().isArray
                            body.write(SHARED_LINKAGE + " ")
                        body.write("global " + getLLVMType(f.type))
                        if cl.state = ClassNodeState.DEFINED
                            body.writeLine(" " + getDefaultValue(f))
                        else
                            body.writeLine()
                    }
                    else if f.annotations.isThread {
                        -- write thread field
                        body.write("@" + getName(f) + " = ")
                        if cl.state != ClassNodeState.DEFINED
                            body.write("external ")
                        body.write("global i32")
                        if cl.state = ClassNodeState.DEFINED
                            body.writeLine(" 0")
                        else
                            body.writeLine()
                    }
                }
                default: unreachable
            }
        }
    }
    
    @protected
    method error(msg:String, n:Node) {
        error(msg, n.position)
    }
    
    @protected
    method error(msg:String, position:Position) {
        throw new CompilerException(msg, position)
    }

    @override
    method generateCode(target:File) {
        if debug
            Console.writeLine("llvm debug output is enabled")
        MethodNamer.nameMethods(new CMethodNamingStrategy())
        header.writeLine('target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"')
        header.writeLine('target triple = "' + StaticSettings.TARGET_TRIPLE + 
                '"')
        header.writeLine("%$itable = type { %panda$core$Class*, %$itable*, " +
                "[0 x i8*] }")
        var classes := SymbolTable.master.classes
        for cl in classes {
            if cl.live
                writeTypeDescriptor(cl)
        }
        for cl in classes {
            if cl.live
                getClassConstant(cl)
        }
        for cl in classes {
            if cl.live
                generateClassCode(cl)
        }

        var array := getLLVMType(ClassType.ARRAY())
        var classType := getLLVMType(ClassType.CLASS())
        var errorType := getLLVMType(ClassType.ERROR())
        body.writeLine("declare void @pandaInit()")
        body.writeLine("declare void @pandaCheckLibVersion(i32)")
        body.writeLine("declare void @pandaThrow(" + errorType + ")")
        body.writeLine("declare " + errorType + " @pandaCatch(i8*)")
        body.writeLine("declare void @pandaCheckOverflow(i1)")
        body.writeLine("declare {i8, i1}  @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.sadd.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.uadd.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.uadd.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.uadd.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.ssub.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.ssub.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.ssub.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.usub.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.usub.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.usub.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.usub.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.smul.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.smul.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.smul.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.smul.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.umul.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.umul.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.umul.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.umul.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare void @llvm.trap() noreturn nounwind")
        body.writeLine("declare void @pandaCheckSignCasti8(i8)")
        body.writeLine("declare void @pandaCheckSignCasti16(i16)")
        body.writeLine("declare void @pandaCheckSignCasti32(i32)")
        body.writeLine("declare void @pandaCheckSignCasti64(i64)")
        body.writeLine("declare void @pandaCheckBounds(" + array + ", " + 
                getLLVMType(Type.INDEX_TYPE) + ")")

        body.writeLine("declare i8* @pandaNewArrayWithLength(" + 
                classType + ", " + 
                getLLVMType(Type.INDEX_TYPE) + ", " +
                getLLVMType(Type.INDEX_TYPE) + ", " +
                getLLVMType(BitType.BIT) + ")")
        body.writeLine("declare i8* @pandaNewArrayWithRange(" + 
                classType + ", " + 
                array + ", " + 
                getLLVMType(Type.INDEX_TYPE) + ", " + 
                getLLVMType(Type.INDEX_TYPE) + ", " + 
                getLLVMType(Type.INDEX_TYPE) + ", " +
                getLLVMType(BitType.BIT) + ")")
        body.writeLine("declare i8* @pandaNewArrayWithValues(" + 
                classType + ", " + 
                getLLVMType(Type.INDEX_TYPE) + ", " + 
                getLLVMType(IntType.INT32) + ", ...)")
        body.writeLine("declare i8* @_pandaNew(" +
                classType + ", " +
                getLLVMType(Type.INDEX_TYPE) + ")")
        
        body.writeLine("declare i32 @pandaPersonality(...)")

        var parent := target.parent()
        if parent = null {
            throw new CompilerException("could not determine parent " +
                    "directory of " + target.path)
        }
        var unoptTarget := parent.resolve(target.name + ".unopt")
        var out := new BufferedOutputStream(unoptTarget.openOutputStream())
        out.write(headerBuffer->>(String))
        out.write(bodyBuffer->>(String))
        out.close()

        var opt := PandaCompiler.getLLVMHome().resolve("opt")
        System.exec(opt, unoptTarget.path, "-o", target.path, "-O3",
                "-q", "-f", "-S", "-std-compile-opts")
        if !CompilerSettings.preserveTempArtifacts
            unoptTarget.delete()
    }
}