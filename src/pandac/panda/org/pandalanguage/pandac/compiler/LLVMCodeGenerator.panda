package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.compiler.IRGenerator
uses org.pandalanguage.pandac.compiler.CompilerSettings
uses org.pandalanguage.pandac.compiler.Dummy
uses org.pandalanguage.pandac.compiler.StubGenerator
uses org.pandalanguage.pandac.stubs.ClassStub 
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.MethodStub 
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodReference
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

@private 
class ClassConstant : Immutable {
    def name:String
    def type:String
    def methods:ImmutableArray<MethodStub>
    
    constructor(name:String, type:String, methods:ListView<MethodStub>) {
        self.name := name
        self.type := type
        self.methods := new ImmutableArray<MethodStub>(methods)
    }
}

class LLVMCodeGenerator (CodeGenerator) {
    constant POINTER_SIZE := 8

    @private
    constant SHARED_LINKAGE := "weak_odr"
    
    @private 
    constant CLASS_POINTER_INDEX := 0
    
    @private 
    constant ARRAY_CONTENTS_INDEX := 3

    -- index of the vtable within the class structure. Note that Class is 
    -- special and this information is spread between more locations than I
    -- would like; the vtable (and itable) are "special" fields programmatically
    -- added to the Class class here. The information shows up in a couple spots
    -- here in the LLVM output, and *also* shows up in the panda$core$Class.h 
    -- file generated by HeaderCodeGenerator (where the same extra fields are 
    -- added). All of these sources must agree with each other or nothing will 
    -- work.
    @private 
    constant VTABLE_INDEX := 6

    @private
    constant ITABLE_INDEX := 5

    @private
    constant FAIL_ASSERT_NAME := "@panda$core$Panda$failAssert"

    def program:Program

    def debug := false

    var tempVariable := 0

    def variableNames := new HashMap<Variable, String>()

    var currentBlockLabel:String := "0"

    def classes:MapView<String, ClassNode>

    def classConstants := new HashMap<String, ClassConstant>()

    var nameCount:Int
    
    var charArrayCount := 0

    def stringConstants := new HashMap<String, String>()

    def references := new HashMap<Value, String>()

    def methodReferences := new HashMap<MethodStub, String>()

    def loops := new Stack<AbstractLoop>()

    def nextLabels := new HashMap<AbstractLoop, String>()

    def endLabels := new HashMap<AbstractLoop, String>()

    def headerBuffer := new MemoryOutputStream()

    def header := new IndentedOutputStream(headerBuffer)

    def bodyBuffer := new MemoryOutputStream()

    def body := new IndentedOutputStream(bodyBuffer)

    def methodNamer:MethodNamer

    var currentMethod:MethodNode?

    var context:Context

    def writtenStubs := new HashSet<String>()

    def writtenTypes := new HashSet<String>()

    constructor(p:Program, compilerSettings:CompilerSettings) {
        self.program := p
        def errors := new FatalErrorReporter()
        self.context := new Context(p.stubGenerator, p.root, p.stubs, 
                errors, compilerSettings)
        self.classes := p.classes
        self.methodNamer := new MethodNamer(context, 
                new CMethodNamingStrategy())
    }

    @protected
    method writeBody(text:String, comment:String) {
        body.write(text)
        if debug {
            body.write("; ")
            body.write(comment)
        }
        body.writeLine()
    }
    
    @override
    function defaultExtension():String {
        return ".ll"
    }

    method getStub(name:String):ClassStub {
        def stub := context.getStub(name)
        if !writtenStubs.contains(name) {
            writtenStubs.add(name)
            if !stub.annotations.isUnspecified
                writeTypeDescriptor(stub)
            if stub.isExternal {
                -- write external stubs
                for m in stub.methods {
                    if !stub.annotations.isUnspecified | m.annotations.isClass
                        writeMethodDeclaration(m)
                }
                for f in stub.fields {
                    if (!stub.annotations.isUnspecified | 
                            f.annotations.isClass | f.annotations.isThread) & 
                            f.owner.name = stub.name {
                        writeFieldDeclaration(f)
                    }
                }
            }
        }
        return stub
    }

    @private
    def typeCache := new HashMap<Type, String>()
    ============================================================================
    Returns the LLVM name for a type. Note that method types are a bit 
    complicated: sometimes we want a method type identified as an instance of 
    class Method, and sometimes we want a method type identified as an actual
    function pointer. This method always returns the Method class, and the
    getLLVMMethodType() method may be used to get the function pointer type
    corresponding to a method.
    ============================================================================
    method getLLVMType(t:Type):String {
        var result := typeCache[t]
        if result = null {
            if t.isNullable
                result := getLLVMType(t.unwrapNullable)
            else {
                switch t {
                    case IntType.INT8:  result := "i8"
                    case IntType.INT16: result := "i16"
                    case IntType.INT32: result := "i32"
                    case IntType.INT64: result := "i64"
                    case IntType.UINT8:  result := "i8"
                    case IntType.UINT16: result := "i16"
                    case IntType.UINT32: result := "i32"
                    case IntType.UINT64: result := "i64"
                    case RealType.REAL32: result := "float"
                    case RealType.REAL64: result := "double"
                    case BitType.BIT: result := "i1"
                    case CharType.CHAR: result := "i16"
                    case VoidType.VOID: result := "void"
                    case NativePointerType.NATIVE_POINTER: result := "i8*"
                    default: {
                        var cl := t->>ClassType
                        if cl-?>MethodType {
                            if cl->MethodType.immutableMethod
                                cl := ClassType.METHOD
                            else
                                cl := ClassType.MUTABLE_METHOD
                        }
                        def stub := context.classes[cl.name]
                        if stub != null
                            result := "%" + getName(stub) + "*"
                        else {
                            -- stub hasn't been created, just use a dummy type
                            result := "%panda$core$Object*"
                        }
                    }
                }
            }
            typeCache[t] := result
        }
        return result
    }

    method getLLVMMethodType(m:MethodStub):String {
        def result := new MutableString()
        def returnType := m.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        def parameters := m.parameters
        var first := true
        if !m.annotations.isClass {
            first := false
            result.append(getSelfType(m))
        }
        for i, p in parameters {
            if first
                first := false
            else
                result.append(", ")
            result.append(getLLVMType(p.type))
        }
        result.append(")*")
        return result->>String
    }

    method getLLVMMethodType(t:MethodType):String {
        def result := new MutableString()
        def returnType := t.returnType
        result.append(getLLVMType(returnType))
        result.append(" (")
        def parameters := t.methodParameters
        for i, p in parameters {
            if i > 0
                result.append(", ")
            result.append(getLLVMType(p))
        }
        result.append(")*")
        return result->>String
    }

    method getSelfType(m:MethodStub):String {
        if m.annotations.isWrapperMethod
            return getLLVMType(m.owner->>PrimitiveType)
        return getLLVMType(m.owner)
    }

    @protected
    method getTempVariable():String {
        def result := "%" + tempVariable
        tempVariable += 1
        return result
    }

    @private
    def nameCache := new HashMap<ClassStub, String>()
    @private
    function getName(cl:ClassStub):String {
        var result := nameCache[cl]
        if result = null {
            result := MethodNamer.escapeTypeName(cl.name)
            nameCache[cl] := result
        }
        return result
    }

    @private
    method getName(m:MethodNode):String {
        return getName(m.stub)
    }

    @private
    method getName(m:MethodStub):String {
        return methodNamer.getName(m)
    }

    @private
    method getName(v:Variable):String {
        var result := variableNames[v]
        if result = null {
            if v-?>FieldNode {
                def field := v->FieldNode
                def name := getName(getStub(field.owner)) + "$" + v.name
                if field.annotations.isClass
                    result := "class_" + name
                else
                    result := name
            }
            else
                result := v.name
            if v-?>LocalVariable
                result += variableNames.length
            variableNames[v] := result
        }
        return result
    }

    @private
    function getClass(cl:ClassType):ClassNode {
        return classes[cl.name]->ClassNode
    }

    @private
    method getStub(cl:ClassType):ClassStub {
        return getStub(cl.name)
    }

    @private
    method size(t:Type):Int {
        if t.isPrimitive
            return t->>PrimitiveType.size
        def stub := getStub(t->>ClassType)
        var total := 0
        def sc := stub.superclass
        if sc != null
            total += size(sc)
        for field in stub.fields.filter(f => !f.annotations.isClass &
                !f.annotations.isThread) {
            def fieldSize:Int
            if field.type.isPrimitive
                fieldSize := size(field.type)
            else
                fieldSize := POINTER_SIZE
            def align := total % fieldSize
            if align != 0
                total += fieldSize - align
            assert total % fieldSize = 0
            total += fieldSize
        }
        return total
    }

    @protected
    method createBlock(label:String, comment:String) {
        currentBlockLabel := label
        if debug
            body.writeLine("; block: " + comment.replace("\n", "\n; (block cont) "))
        body.writeLine(label + ":")
    }

    @protected
    function endsInBranch(s:Statement):Bit {
        if s-?>Return | s-?>Break | s-?>Continue
            return true
        if s-?>Block
            return s->Block.endsInBranch
        return false
    }
    
    @protected
    method createLabel():String {
        nameCount += 1
        return "$label" + nameCount
    }

    @protected
    method writeTypeDescriptor(var t:Type) {
        t := t.unwrapNullable
        if !t.isPrimitive & t-!>MethodType & 
                t != NativePointerType.NATIVE_POINTER
            writeTypeDescriptor(getStub(t->>ClassType))
    }
    
    @protected
    method writeTypeDescriptor(cl:ClassStub) {
        if writtenTypes.contains(cl.name)
            return
        writtenTypes.add(cl.name)
        if debug
            header.writeLine("; " + cl.name)
        header.write("%" + getName(cl) + " = type { ")
        def fields := cl.instanceFields(context)
        for i, f in fields {
            if i != 0
                header.write(", ")
            if f.name = FieldNode.ELEMENTS_NAME
                header.write(getLLVMType(f.type) + "*")
            else
                header.write(getLLVMType(f.type))
        }
        if cl.name = ClassType.CLASS.name {
            -- Class is special, write out the VTABLE entry at the end of its fields
            header.write(", %$itable*, [0 x i8*]")
        }
        header.writeLine(" }")
    }

    @protected
    method createCallReference(codeString:String, comment:String):String {
        def result := getTempVariable()
        call(codeString, result, comment)
        return result
    }

    @protected
    method call(invocation:String, result:String?, comment:String?) {
        if result != null
            body.write(result + " = ")
        body.write("call " + invocation)
        if debug & comment != null
            body.writeLine("; call: " + comment.replace("\n", "\n; (call cont) "))
        else
            body.writeLine()
    }

    @protected
    method call(invocation:String) {
        call(invocation, null, null)
    }

    @private
    def digits := /\d+/
    @private
    function isConstant(expr:String):Bit {
        return expr.startsWith("%") | expr.matches(digits)
    }

    @protected
    method createCommandReference(codeString:String, comment:String):String {
        if isConstant(codeString)
            return codeString
        def result := getTempVariable()
        writeBody(result + " = " + codeString, comment)
        return result
    }

    @protected
    method createConstructReference(construct:Construct):String {
        def targetType := construct.type
        def target := getStub(targetType->>ClassType)
        def cc := getClassConstant(target)
        def cast := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody(cast + " = bitcast " + cc.type + "* @" + cc.name +
                " to " + classType, "convert class pointer")
        def alloc := createCallReference("i8* @_pandaNew(" + classType + " " + 
                cast + ", i32 " + size(targetType) + ")", 
                "allocate " + targetType.name)
    
        def result := createCommandReference("bitcast i8* " + alloc + " to " + 
                getLLVMType(targetType), "convert pointer to " + 
                targetType.name)

        def parameters := construct.constructorCall.parameters
        def m := construct.constructorCall.methodStub
        def methodRef := "@" + getName(m)
        def text := new MutableString("fastcc void \{methodRef}(")
        text.append(getLLVMType(targetType) + " " + result)
        for i, p in parameters {
            text.append(", ")
            text.append(getTypedReference(p))
        }
        text.append(")")
        call(text->>String)
        return result
    }

    @private
    @pre(target-!>ClassLiteral)
    method getVirtualMethodReference(target:Value, index:Int, 
            type:String):String {
        -- load class constant entry
        def cl := target.type.name
        var getep := "getelementptr inbounds " + 
                getTypedReference(target) + 
                ", i32 0, i32 " + CLASS_POINTER_INDEX
        if debug
            getep += "; get pointer to pointer to " + cl
        var ep := getTempVariable()
        body.writeLine(ep + " = " + getep)
        def load := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody("\{load} = load \{classType}* \{ep}", "get pointer to " + 
                cl)
        ep := getTempVariable()
        writeBody("\{ep} = getelementptr inbounds \{classType} \{load}, " +
                "i32 0, i32 \{VTABLE_INDEX}, i32 \{index}", 
                "get pointer to pointer to \{cl}.vtable[\{index}]")
        def cast := getTempVariable()
        writeBody("\{cast} = bitcast i8** \{ep} to \{type}*", 
                "convert pointer to method pointer to correct type")
        def methodRef := getTempVariable()
        writeBody("\{methodRef} = load \{type}* \{cast}", 
                "get \{cl}.vtable[\{index}]")
        return methodRef
    }

    @private
    method getVirtualMethodReference(mc:MethodCall):String {
        def m := mc.methodStub
        def cc := getClassConstant(getStub(m.owner))
        return getVirtualMethodReference(mc.target, 
                getMethodIndex(cc, m), getLLVMMethodType(m))
    }

    @private
    method getInterfaceMethodReference(mc:MethodCall):String {
        if debug
            body.writeLine("; get pointer to first itable entry")
        def m := mc.methodStub
        def methodType := getLLVMMethodType(m)
        -- load class constant entry
        def cl := getStub(mc.target.type->>ClassType)
        def enter := createLabel()
        body.writeLine("br label %" + enter)
        createBlock(enter, "itable search entrance")
        def targetRef := getTypedReference(mc.target)
        def classPointer := getTempVariable()
        writeBody(classPointer + " = getelementptr inbounds " + 
                targetRef + ", i32 0, i32 " + CLASS_POINTER_INDEX, 
                "get pointer to pointer to " + cl)
        def loadedClass := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody(loadedClass + " = load " + classType + "* " + 
                classPointer, "get pointer to " + cl.name)
        def itableFirst := getTempVariable()
        writeBody(itableFirst + " = getelementptr inbounds " + 
                classType + " " + loadedClass + ", i32 0, i32 " + ITABLE_INDEX, 
                "get pointer to first itable")
        def next := createLabel()
        body.writeLine("br label %" + next)
        def leavingEnterLabel := currentBlockLabel
        createBlock(next, "itable next")
        def itableNext := "%itableNext" + nameCount
        nameCount += 1
        def itablePtrPtr := getTempVariable()
        def fail := createLabel()
        body.writeLine(itablePtrPtr + " = phi %$itable** [ " + itableFirst +
                ", %" + leavingEnterLabel + "], [ " + itableNext + ", %" + 
                fail + " ]")
        def itablePtr := getTempVariable()
        body.writeLine(itablePtr + " = load %$itable** " + itablePtrPtr)
        def itableClassPtr := getTempVariable()
        body.writeLine(itableClassPtr + " = getelementptr inbounds %$itable* " + 
                itablePtr + ", i32 0, i32 0")
        def itableClass := getTempVariable()
        body.writeLine(itableClass + " = load " + classType + "* " + 
                itableClassPtr)
        def test := getTempVariable()
        def intfCC := getClassConstant(getStub(m.owner))
        writeBody(test + " = icmp eq " + classType + " bitcast(" + 
                intfCC.type + "* @" + 
                intfCC.name + " to " + classType + "), " + itableClass,
                "check for correct interface class")
        def success := createLabel()
        body.writeLine("br i1 " + test + ", label %" + success + ", label %" +
                fail)

        createBlock(fail, "itable test fail")
        writeBody(itableNext + " = getelementptr inbounds " + 
                "%$itable* " + itablePtr + ", i32 0, i32 1",
                "get pointer to next itable")
        body.writeLine("br label %" + next)

        createBlock(success, "itable test success")
        def methodIndex := getMethodIndex(intfCC, m)
        def methodPtrPtr := getTempVariable()
        writeBody(methodPtrPtr + " = getelementptr inbounds " +
                "%$itable* " + itablePtr + ", i32 0, i32 2, i32 " + 
                methodIndex, "get pointer to pointer to " + m.owner.name + "." + 
                m.name + ":" + m.returnType.name)
        def cast := getTempVariable()
        body.writeLine(cast + " = bitcast i8** " + methodPtrPtr +
                " to " + methodType + "*; convert pointer to method " +
                "pointer to correct type")
        def methodPtr := getTempVariable()
        writeBody(methodPtr + " = load " + methodType + "* " + cast, "get " + m)
        return methodPtr
    }

    @protected
    function getMethodIndex(cl:ClassConstant, m:MethodStub):Int {
        -- FIXME use indexOf when that's available
        def result := cl.methods.indexOf(m)
        assert result != null : m + " not found in class constant"
        return result
    }

    @protected
    method createMethodCallReference(mc:MethodCall):String? {
        def m := mc.methodStub
        def methodRef:String
        if program.isEffectivelyVirtual(m) & IRGenerator.unwrapCast(mc.target)-!>Super {
            assert !m.annotations.isClass : "expected method not to be @class"
            def target := mc.target->Value
            def classStub := getStub(target.type->>ClassType)
            if classStub.isInterface
                methodRef := getInterfaceMethodReference(mc)
            else
                methodRef := getVirtualMethodReference(mc)
        }
        else
            methodRef := "@" + getName(m)

        def text := new MutableString("fastcc \{getLLVMMethodType(m)} \{methodRef}(")
        def parameters := mc.parameters
        if !m.annotations.isClass {
            text.append(getTypedReference(mc.target->Value))
            if parameters.length > 0
                text.append(", ")
        }
        for i, p in parameters {
            if i > 0
                text.append(", ")
            text.append(getTypedReference(p))
        }
        text.append(")")
        if mc.type = VoidType.VOID {
            call(text->>String)
            return null
        }
        else
            return createCallReference(text->>String, mc->>String)
    }

    @protected
    method createVariableAssignmentReference(va:VariableAssignment):String {
        var variable := va.variable
        def lref := getLLVMType(variable.type) + "* %" + getName(variable)
        def result := getReference(va.value)
        assert result != null : 
                "expected non-null result in createVariableAssignmentReference"
        writeBody("store " + getLLVMType(variable.type) + " " + result + ", " + 
                lref, va->>String)
        return result
    }
    
    @private
    method getITable(cl:ClassStub):String {
        def visited := new HashSet<ClassStub>()
        def interfaces := cl.allInterfaces(context)
        var previous := "%$itable* null"
        for intf in interfaces {
            if visited.contains(intf)
                continue
            visited.add(intf)
            def intfCC := getClassConstant(intf)
            def methods := cl.interfaceMethods(intf, context)
            def name := "@" + getName(cl) + "$." + getName(intf)
            def type := "{ " + getLLVMType(ClassType.CLASS) + 
                    ", %$itable*, [" + methods.length + " x i8*] }"
            header.write(name + " = " + SHARED_LINKAGE + " constant ")
            header.write(type + " { " + 
                    getLLVMType(ClassType.CLASS) + " bitcast(" + intfCC.type + 
                    "* @" + intfCC.name + " to " + 
                    getLLVMType(ClassType.CLASS) + "), " + previous + ", [" + 
                    methods.length + " x i8*][")
            for i, m in methods {
                if i > 0
                    header.write(", ")
                if m.annotations.isAbstract
                    header.write("i8* null")
                else {
                    header.write("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            header.writeLine("] }")
            previous := "%$itable* bitcast(" + type + "* " + name + 
                    " to %$itable*)" 
        }
        return previous
    }

    @protected
    method getClassConstant(cl:ClassStub):ClassConstant {
        var name := cl.name
        var cc := classConstants[name]
        if cc = null {
            def methods := cl.virtualMethods(context)
            def className := getName(cl)
            cc := new ClassConstant(
                    className + "_class",
                    "{ " + getLLVMType(ClassType.CLASS) + ", " + 
                    getLLVMType(ClassType.STRING) +  ", " + 
                    getLLVMType(ClassType.CLASS) + ", i1, i1, %$itable*, [" + 
                    methods.length + " x i8*] }", methods)
            classConstants[name] := cc
            if name.startsWith("panda.core.") & name.endsWith("Wrapper")
                name := name[0 .. name.length - "Wrapper".length]
            -- go ahead and get other class constants here, before we've written
            -- anything -- this could cause other class definitions to be
            -- printed, and we don't want to be in the middle of output when
            -- that happens
            var nameRef := "<error>"
            if !cl.isExternal
                nameRef := getStringConstantReference(name)
            getClassConstant(getStub(ClassType.CLASS.name))

            def superclassConstant:ClassConstant?
            def superclass := cl.superclass
            if superclass != null
                superclassConstant := getClassConstant(getStub(superclass))
            else
                superclassConstant := null
            if cl.isExternal {
                header.write("@" + cc.name + " = ")
                header.writeLine("external global " + cc.type)
                return cc
            }
            def intf := getITable(cl)
            header.write("@" + cc.name + " = ")
            header.write(SHARED_LINKAGE + " ")
            def superclassRef:String
            if superclassConstant != null
                superclassRef := "bitcast(" + superclassConstant.type + "* @" + 
                        superclassConstant.name + " to " + 
                        getLLVMType(ClassType.CLASS) + ")"
            else
                superclassRef := "null"
            -- class constant includes vtable. Doesn't include statics, as 
            -- those are just globals.
            var overridesFinalize := false
            for m in cl.methods {
                if m.name = MethodNode.FINALIZE_NAME & 
                        !m.annotations.isClass & 
                        m.parameters.length = 1
                    overridesFinalize := true
            }
            def classClass := getStub(ClassType.CLASS)
            def classClassConstant := getClassConstant(classClass)
            header.write("constant " + cc.type + 
                    " { " + getLLVMType(ClassType.CLASS) + " bitcast(" + 
                    classClassConstant.type + "* @" + classClassConstant.name + 
                    " to " + getLLVMType(ClassType.CLASS) + "), " + 
                    getLLVMType(ClassType.STRING) + " " + nameRef + ", " + 
                    getLLVMType(ClassType.CLASS) + " " + superclassRef + 
                    ", i1 1, i1 " + overridesFinalize + ", " + intf + ", [" + 
                    methods.length + " x i8*] [ ")
            for i, m in methods {
                if i > 0
                    header.write(", ")
                if m.annotations.isAbstract
                    header.write("i8* null")
                else {
                    header.write("i8* bitcast(" + getLLVMMethodType(m) + 
                            " @" + getName(m) + " to i8*)")
                }
            }
            header.writeLine(" ] }")
        }
        return cc
    }

    @private
    method getCharPrimitiveArrayConstantReference(chars:ListView<Char>):String {
        def charPrimitiveArrayClass := getStub(
                PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
        def cc := getClassConstant(charPrimitiveArrayClass)
        def charsType := "[\{chars.length} x \{getLLVMType(CharType.CHAR)}]"
        def type := "{ " + cc.type + "*, " +
                getLLVMType(IntType.INT32) + ", " + 
                getLLVMType(IntType.INT32) + ", " + 
                charsType + "* }"
        def result := "ca" + charArrayCount
        charArrayCount += 1
        def charsName := "@\{result}_chars"
        header.write(charsName + " = private unnamed_addr constant " + 
                charsType + " [")
        for i, c in chars {
            if i != 0
                header.write(", ")
            header.write(getLLVMType(CharType.CHAR) + " " + c->Int)
        }
        header.writeLine("]")

        header.writeLine("@" + result + " = private unnamed_addr constant " + 
                type + " { " + cc.type + "* @" + cc.name + ", " + 
                getLLVMType(IntType.INT32) + " " + chars.length + ", " +
                getLLVMType(IntType.INT32) + " " + chars.length + ", " + 
                charsType + "* " + charsName + " }, align " +
                POINTER_SIZE)
        return "bitcast(" + type + "* @" + result + " to " + 
                getLLVMType(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY) + ")"
    }

    @private
    method getStringConstantReference(s:String):String {
        var result := stringConstants[s]
        if result = null {
            def string := getStub(ClassType.STRING)
            def primitiveChars := new Array<Char>()
            for c in s
                primitiveChars.add(c)
            def chars := getCharPrimitiveArrayConstantReference(primitiveChars)
            result := "@s" + stringConstants.length
            stringConstants[s] := result
            def charPrimitiveArrayType := PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY
            def cc := getClassConstant(string)
            if debug
                header.writeLine("; " + StringLiteral.escape(s))
            header.writeLine(result + " = private unnamed_addr constant " + 
                    '%panda$core$String { ' + 
                    getLLVMType(ClassType.CLASS) + " bitcast(" + cc.type + 
                    "* @" + cc.name + " to " + getLLVMType(ClassType.CLASS) + 
                    "), " + getLLVMType(charPrimitiveArrayType) + " " + chars + " }," +
                    " align " + POINTER_SIZE)
            stringConstants[s] := result
        }
        return result
    }

    @private
    method createOverflowCheckedBinaryOperationReference(value:BinaryOperation, 
            op:String):String {
        def typeString := getLLVMType(value.type)
        def left := getTypedReference(value.left)
        def right := getTypedReference(value.right)
        def result := createCommandReference("call { " + typeString + 
                ", i1 } @llvm." + op + ".with.overflow." + typeString + "(" + 
                left + ", " + right + ")", value->>String)
                var flag := getTempVariable()
        writeBody(flag + " = extractvalue { " + typeString + 
                ", i1 } " + result + ", 1", "extract overflow flag")
        def p := value.position
        call("void @pandaCheckOverflow(i1 " + flag + ")")
        return createCommandReference("extractvalue { " + typeString + 
                ", i1 } " + result + ", 0", "load results of '" + op + "'")
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation,
            var op:String):String {
        def cm := currentMethod
        assert cm != null : 
                "currentMethod unexpectedly null in createBinaryOperationReference"
        if (op = "add" | op = "sub" | op = "mul") & 
                !cm.stub.annotations.isOverflow &
                context.compilerSettings.overflowChecking &
                !b.permitOverflow {
            if b.type.isInteger & b.type->IntType.signed
                op := "s" + op
            else
                op := "u" + op
            return createOverflowCheckedBinaryOperationReference(b, op)
        }
        def left := getReference(b.left)
        def right := getReference(b.right)
        assert left != null & right != null : 
                "expected left and right to be non-null in createBinaryOperationReference"
        return createCommandReference(op + " " + getLLVMType(b.left.type) + 
                " " + left + ", " + right, b->>String)
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation, sop:String?, 
            uop:String?, fop:String?):String {
        def operandType := b.left.type
        def op:String?
        if operandType.isReal
            op := fop
        else if operandType = CharType.CHAR | (operandType.isInteger & 
                !operandType->IntType.signed)
            op := uop
        else
            op := sop
        if op = null {
            throw new CompilerException("cannot compile '" + b + 
                    "' at \{b.position}", b.position)
        }
        return createBinaryOperationReference(b, op)
    }
    
    @private
    method createBinaryOperationReference(b:BinaryOperation, iop:String?, 
            fop:String?):String {
        return createBinaryOperationReference(b, iop, iop, fop)
    }

    method createPrimitiveArrayIndexValueReference(iv:PrimitiveArrayIndexValue):String {
        def ep := getPrimitiveArrayElementPointer(iv.array, iv.index)
        return createCommandReference("load \{getLLVMType(iv.type)}* \{ep}", 
                iv->>String)
    }
    
    @pre(and.operation = BinaryOperationType.AND)
    method createAndReference(and:BinaryOperation):String {
        def left := getReference(and.left)
        assert left != null : "expected non-null left in createAndReference"
        def leftFromLabel := currentBlockLabel
        def rightLabel := createLabel()
        def endLabel := createLabel()
        writeBody("br i1 \{left}, label %\{rightLabel}, label %\{endLabel}",
                "and test: \{and}")
        body.writeLine()
        createBlock(rightLabel, "right: \{and}")
        def right := getReference(and.right)
        assert right != null : "expected non-null right in createAndReference"
        def rightFromLabel := currentBlockLabel
        body.writeLine("br label %\{endLabel}")
        body.writeLine()
        createBlock(endLabel, "end: \{and}")
        def result := getTempVariable()
        body.writeLine("\{result} = phi i1 [false, %\{leftFromLabel}], " +
                "[\{right}, %\{rightFromLabel}]")
        return result
    }
    
    @pre(or.operation = BinaryOperationType.OR)
    method createOrReference(or:BinaryOperation):String {
        def left := getReference(or.left)
        assert left != null : "expected non-null left in createOrReference"
        def leftFromLabel := currentBlockLabel
        def rightLabel := createLabel()
        def endLabel := createLabel()
        writeBody("br i1 \{left}, label %\{endLabel}, label %\{rightLabel}", 
                "or test: \{or}")
        body.writeLine()
        createBlock(rightLabel, "right: \{or}")
        def right := getReference(or.right)
        assert right != null : "expected non-null right in createOrReference"
        def rightFromLabel := currentBlockLabel
        body.writeLine("br label %\{endLabel}")
        body.writeLine()
        createBlock(endLabel, "end: \{or}")
        def result := getTempVariable()
        body.writeLine("\{result} = phi i1 [true, %\{leftFromLabel}], " +
                "[\{right}, %\{rightFromLabel}]")
        return result
    }

    method createUnaryOperationReference(u:UnaryOperation):String {
        switch u.operation {
            case UnaryOperationType.MINUS: {
                var op:String
                var zero:Value
                if u.type.isReal {
                    op := "fsub"
                    zero := new RealLiteral(Position.INTERNAL, 0)
                }
                else {
                    op := "sub"
                    zero := new IntegerLiteral(Position.INTERNAL, 0)
                }
                var zeroRef := getReference(zero)
                assert zeroRef != null : "expected non-null zeroRef"
                var valueRef := getReference(u.operand)
                assert valueRef != null : "expected non-null valueRef"
                return createCommandReference(op + " " + getLLVMType(u.type) + 
                        " " + zeroRef + ", " + valueRef, u->>String)
            }
            case UnaryOperationType.NOT: {
                return createCommandReference("xor " + 
                        getTypedReference(u.operand) + ", 1", u->>String)
            }
            case UnaryOperationType.BITWISE_NOT: {
                return createCommandReference("xor " + 
                        getTypedReference(u.operand) + ", -1", u->>String)
            }
            default: unreachable
        }
    }

    method createNewPrimitiveArrayWithLengthReference(na:NewPrimitiveArrayWithLength):String {
        def arrayClass := getStub(na.type->>ClassType)
        def cc := getClassConstant(arrayClass)
        def cast := getTempVariable()
        def elementType := na.type->>PrimitiveArrayType.elementType
        def classType := getLLVMType(ClassType.CLASS)
        writeBody("\{cast} = bitcast \{cc.type}* @\{cc.name} to \{classType}",
                "convert class pointer")
        def ref := getReference(na.arrayLength)
        assert ref != null : "expected non-null ref in createNewPrimitiveArrayWithLengthReference"
        def alloc := createCallReference(
                "i8* @pandaNewPrimitiveArrayWithLength(\{classType} \{cast}, " + 
                "i32 \{ref}, i32 \{size(elementType)}, i1 " +
                !elementType.isPrimitive + ")", "allocate " + na.type.name)
        def result := createCommandReference("bitcast i8* \{alloc} to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }
    
    method createPrimitiveArrayCopyReference(na:PrimitiveArrayCopy):String {
        def arrayClass := getStub(na.type->PrimitiveArrayType)
        def cc := getClassConstant(arrayClass)
        def cast := getTempVariable()
        def elementType := na.type->PrimitiveArrayType.elementType
        def classType := getLLVMType(ClassType.CLASS)
        writeBody("\{cast} = bitcast \{cc.type}* @\{cc.name} to \{classType}", 
                "convert class pointer")
        def rawPrimitiveArray := getTypedReference(na.array)
        def arrayCast := getTempVariable()
        writeBody("\{arrayCast} = bitcast \{rawPrimitiveArray} to " + 
                getLLVMType(ClassType.PRIMITIVE_ARRAY), 
                "cast array pointer to PrimitiveArray")
        def alloc := createCallReference("i8* " +
                "@pandaNewPrimitiveArrayCopy(\{classType} \{cast}, " + 
                "\{getLLVMType(ClassType.PRIMITIVE_ARRAY)} \{arrayCast}, " +
                "i32 \{size(elementType)}, i1 \{!elementType.isPrimitive})", 
                "allocate \{na.type.name}")
        var result := createCommandReference("bitcast i8* \{alloc} to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }
       
    method createNewPrimitiveArrayWithValuesReference(na:NewPrimitiveArrayWithValues):String {
        def elementType := na.type->PrimitiveArrayType.elementType
        def arrayClass := getStub(na.type->PrimitiveArrayType)
        def cc := getClassConstant(arrayClass)
        def cast := getTempVariable()
        def classType := getLLVMType(ClassType.CLASS)
        writeBody(cast + " = bitcast " + cc.type + "* @" + cc.name +
                " to " + classType, "convert class pointer")
        def type:Int
        constant ARRAY_INT8   := 0
        constant ARRAY_INT16  := 1
        constant ARRAY_INT32  := 2
        constant ARRAY_INT64  := 3
        constant ARRAY_REAL32 := 4
        constant ARRAY_REAL64 := 5
        constant ARRAY_PTR    := 6
        switch elementType {
            case IntType.INT8, IntType.UINT8, BitType.BIT: 
                type := ARRAY_INT8

            case IntType.INT16, IntType.UINT16, CharType.CHAR: 
                type := ARRAY_INT16

            case IntType.INT32, IntType.UINT32: 
                type := ARRAY_INT32

            case IntType.INT64, IntType.UINT64: 
                type := ARRAY_INT64

            case RealType.REAL32: 
                type := ARRAY_REAL32

            case RealType.REAL64: 
                type := ARRAY_REAL64

            default:
                type := ARRAY_PTR
        }
        def references := new Array<String>()
        for v in na.values {
            var raw := getTypedReference(v)
            if type = ARRAY_REAL32 {
                -- varargs requires promotion of float to double, and evidently
                -- we have to do it ourselves
                references.add("double " + createCommandReference("fpext " + 
                        raw + " to double", "varargs promotion"))
            }
            else
                references.add(raw)
        }
        def code := ("i8* (\{classType}, i32, i32, ...)* " +
                "@pandaNewPrimitiveArrayWithValues(\{classType} \{cast}, i32 " + 
                "\{na.values.length}, i32 \{type}")->>MutableString
        for r in references {
            code.append(", ")
            code.append(r)
        }
        code.append(")")
        def alloc := createCallReference(code->>String, "allocate " + 
                na.type.name)
        def result := createCommandReference("bitcast i8* \{alloc} to " + 
                getLLVMType(na.type), "cast array to final type")
        return result
    }

    @protected
    method createBinaryOperationReference(b:BinaryOperation):String {
        switch b.operation {
            case BinaryOperationType.ADD: 
                return createBinaryOperationReference(b, "add", "fadd")
            case BinaryOperationType.SUBTRACT:
                return createBinaryOperationReference(b, "sub", "fsub")
            case BinaryOperationType.MULTIPLY: 
                return createBinaryOperationReference(b, "mul", "fmul")
            case BinaryOperationType.DIVIDE: 
                return createBinaryOperationReference(b, null, "fdiv")
            case BinaryOperationType.INT_DIVIDE: {
                var op:String
                if b.type->IntType.signed
                    op := "sdiv"
                else
                    op := "udiv"
                return createBinaryOperationReference(b, op, null)
            }
            case BinaryOperationType.REMAINDER: 
                return createBinaryOperationReference(b, "srem", "urem", null)
            case BinaryOperationType.SHIFT_LEFT: 
                return createBinaryOperationReference(b, "shl", null)
            case BinaryOperationType.SHIFT_RIGHT: {
                if b.type->IntType.signed
                    return createBinaryOperationReference(b, "ashr", null)
                else
                    return createBinaryOperationReference(b, "lshr", null)
            }
            case BinaryOperationType.AND: 
                return createAndReference(b)
            case BinaryOperationType.OR:
                return createOrReference(b)
            case BinaryOperationType.XOR: 
                return createBinaryOperationReference(b, "xor", null)
            case BinaryOperationType.BITWISE_AND: 
                return createBinaryOperationReference(b, "and", null)
            case BinaryOperationType.BITWISE_OR: 
                return createBinaryOperationReference(b, "or", null)
            case BinaryOperationType.BITWISE_XOR: 
                return createBinaryOperationReference(b, "xor", null)
            case BinaryOperationType.EQUAL: 
                return createBinaryOperationReference(b, "icmp eq", "fcmp oeq")
            case BinaryOperationType.IDENTITY: 
                return createBinaryOperationReference(b, "icmp eq")
            case BinaryOperationType.LESS_THAN: {
                return createBinaryOperationReference(b, "icmp slt", "icmp ult", 
                        "fcmp olt")
            }
            case BinaryOperationType.GREATER_THAN: {
                return createBinaryOperationReference(b, "icmp sgt", "icmp ugt",
                        "fcmp ogt")
            }
            case BinaryOperationType.LESS_THAN_OR_EQUAL: {
                return createBinaryOperationReference(b, "icmp sle", "icmp ule",
                        "fcmp ole")
            }
            case BinaryOperationType.GREATER_THAN_OR_EQUAL: {
                return createBinaryOperationReference(b, "icmp sge", "icmp uge",
                        "fcmp oge")
            }
            case BinaryOperationType.NOT_EQUAL:
                return createBinaryOperationReference(b, "icmp ne", "fcmp one")
            case BinaryOperationType.NOT_IDENTITY:
                return createBinaryOperationReference(b, "icmp ne")
            default: {
                Console.writeLine("no support for binary operation \{b.operation}")
                unreachable
            }
        }
    }

    @private
    method callClassInit(cl:ClassStub) {
        if currentMethod->MethodNode.stub.name = MethodNode.CLASS_INIT_NAME &
                currentMethod->MethodNode.stub.owner = cl.type
            return
        def classInit := cl.methods.filter(
                m => m.name = MethodNode.CLASS_INIT_NAME)
        assert classInit.length = 1 : "expected exactly one method named " +
                "'\{MethodNode.CLASS_INIT_NAME} in \{cl}, found " +
                classInit.length
        call("fastcc void @\{getName(classInit.iterator.next())}()")
    }
    
    @protected
    @pre(!object.type.isPrimitive)
    @pre(!field.annotations.isThread)
    method getFieldPointer(object:Value, field:FieldNode):String {
        if field.annotations.isClass {
            if field.name != FieldNode.CLASS_INITED_NAME
                callClassInit(getStub(field.owner))
            return "@" + getName(field)
        }
        else {
            def cl := getStub(object.type->>ClassType)
            def fields := cl.instanceFields(context)
            for i, f in fields {
                if f = field {
                    return createCommandReference("getelementptr inbounds " + 
                        getTypedReference(object) + 
                        ", i32 0, i32 " + i, "field pointer: " + object + "." +
                        field.name)
                }
            }
            unreachable
        } 
    }

    @protected
    method createFieldReference(fr:FieldReference):String {
        if fr.field.annotations.isThread {
            def owner := fr.field.owner
            callClassInit(context.getStub(owner))
            var type := fr.type
            def suffix:String
            if type.isPrimitive
                suffix := fr.type.name["panda.core.".length..]
            else {
                suffix := "Object"
                type := ClassType.OBJECT
            }

            def threadLocalId := getTempVariable()
            def symbolTable := context.getSymbolTable(context.getStub(owner))
            def indexField := symbolTable[fr.field.name + 
                    StubGenerator.INDEX_SUFFIX]->FieldNode
            body.writeLine("load i32* @" + getName(indexField))
            def callString := new MutableString("fastcc " + getLLVMType(type) + 
                    " @panda$core$Panda$getThreadLocal" + suffix + 
                    "(i32 " + threadLocalId + ", ")
            def initializer := symbolTable[
                        IRGenerator.getThreadLocalInitializerName(fr.field)
                    ]->Methods?
            if initializer != null {
                callString.append(
                        getLLVMType(NativePointerType.NATIVE_POINTER) + 
                        " bitcast(" + getLLVMType(fr.type) + "()* @" + 
                        getName(initializer.methods[0]) + " to " + 
                        getLLVMType(NativePointerType.NATIVE_POINTER) + "))")
            }
            else
                callString.append("i8* null)") -- no initializer function
            var ref := createCallReference(callString->>String, fr->>String)
            if !fr.type.isPrimitive & fr.type != ClassType.OBJECT {
                def cast := getTempVariable()
                writeBody(cast + " = bitcast " + 
                        getLLVMType(type) + " " + ref + " to " + 
                        getLLVMType(fr.type), "cast Object to threadlocal")
                ref := cast
            }
            return ref
        }
        def ep := getFieldPointer(fr.object, fr.field)
        return createCommandReference(
                "load \{getLLVMType(fr.field.type)}* \{ep}", fr->>String)
    }

    @protected
    method createCastReference(c:Cast):String? {
        def tempResult := getReference(c.value)
        assert tempResult != null : 
                "expected non-null tempResult in createCastReference"
        def actualType := c.value.type
        def destType := c.type
        if actualType = destType
            return tempResult
        def actualSize := size(actualType)
        def destSize := size(destType)
        var command:String? := null
        if actualSize = destSize & 
                (actualType.isInteger | actualType = CharType.CHAR) & 
                (destType.isInteger | destType = CharType.CHAR) {
            -- actual bits aren't changing, just the logical type
            return tempResult
        }
        if actualType.isInteger & (destType.isInteger | 
                destType = CharType.CHAR) {
            if actualSize > destSize
                -- int narrowing
                command := "trunc"
            else if actualType->IntType.signed
                -- signed int widening
                command := "sext"
            else
                -- unsigned int widening
                command := "zext"
        }
        else if actualType.isReal & destType.isReal {
            if actualSize > destSize
                -- real64 ->> real32
                command := "fptrunc"
            else
                -- real32 ->> real64
                command := "fpext"
        }
        else if actualType.isReal & destType.isInteger {
            -- real to signed int
            command := "fptosi"
        }
        else if actualType.isInteger & destType.isReal {
            if actualType->IntType.signed {
                -- signed int to real
                command := "sitofp"
            }
            else {
                -- unsigned int to real
                command := "uitofp"
            }
        }
        else if actualType = CharType.CHAR & destType.isInteger {
            if actualSize > destSize
                -- char narrowing
                command := "trunc"
            else
                -- char widening
                command := "zext"
        }
        else if actualType.isReal & destType = CharType.CHAR {
            -- real to char
            command := "fptoui"
        }
        else if actualType = CharType.CHAR & destType.isReal {
            -- char to real
            command := "uitofp"
        }
     
        if command != null {
            def result := getTempVariable()
            body.writeLine(result + " = " + command + " " + 
                    getLLVMType(actualType) + " " + tempResult + 
                    " to " + getLLVMType(destType), c.value + " -> " + 
                    destType.name)
            return result
        }
        else {
            -- casting one type of object to another, can simply bitcast the
            -- pointer
            assert !actualType.isPrimitive : 
                    "expected actualType to not be primitive"
            assert !destType.isPrimitive :
                    "expected destType to not be primitive"
            def checkCast := !c.safe & context.compilerSettings.checkCasts
            if checkCast {
-*                -- verify the cast. Use a dummy for the first 
                -- parameter just to get the type right.
                def params := new PrimitiveArray<Value>(new Dummy(actualType), 
                        new ClassLiteral(destType.unwrapNullable()), 
                        new BitLiteral(destType.isNullable))
                def panda := ClassType.PANDA().classNode
                def check := panda.symbolTable.getMethod(c.position,
                        "checkCast", params, true)
                assert check != null : "expected check to be non-null"
                for i in 1 .. params.length
                    getTypedReference(params[i])
                var intermediate := tempResult
                if actualType != ClassType.OBJECT() {
                    intermediate := getTempVariable()
                    writeBody(intermediate + " = bitcast " + 
                            getLLVMType(actualType) + " " + tempResult + 
                            " to " + getLLVMType(ClassType.OBJECT()),
                            c.value + " -> " + ClassType.OBJECT().name)
                }
                var callString := ("fastcc void @" + getName(check) + 
                        "(")->>MutableString
                callString.append(getLLVMType(ClassType.OBJECT()) + " " + 
                        intermediate)
                for i in 1 ... params.length - 1 {
                    callString.append(", ")
                    callString.append(getTypedReference(params[i]))
                }
                callString.append(")")
                call(callString->>String, null, "check cast " + c + ":" + 
                        c.position)*-
            }
            def actualLLVMType := getLLVMType(actualType)
            def destLLVMType := getLLVMType(destType)
            if actualLLVMType = destLLVMType
                return tempResult
            def result := getTempVariable()
            writeBody("\{result} = bitcast \{actualLLVMType} \{tempResult} " +
                    " to \{destLLVMType}", "\{c.value} -> \{destType.name}")
            return result
        }
    }
    
    @protected
    method createVariableReference(vr:VariableReference):String {
        var variable := vr.variable
        if variable-?>Parameter & variable.varType = VariableType.DEF
            return "%" + getName(variable)
        return createCommandReference("load " + getLLVMType(vr.type) + "* %" + 
                getName(variable), vr->>String)
    }
        
    @protected
    method createSuperReference(s:Super):String {
        return "%self"
    }

    @protected
    method createReusedValueDefinitionReference(rvd:ReusedValueDefinition):String {
        def result := getReference(rvd.value)
        assert result != null : "null reference for ReusedValueDefinition " + rvd
        references[rvd] := result
        return result
    }

    @protected
    method createReusedValueReference(rv:ReusedValue):String {
        def result := references[rv.owner]
        assert result != null : "null reference for ReusedValue owner " + rv
        return result
    }

    @protected
    @math(overflow)
    method createRealLiteralReference(r:RealLiteral):String {
        var bits := Panda.real64Bits(r.value)->>UInt64
        -- LLVM's float representation is completely insane -- it's not a float,
        -- it's a double with the 29 low-order bits zeroed
        if r.type = RealType.REAL32
            bits := bits && ((-1)->UInt64 << 29->UInt64)
--        return "0x\{bits,0>16:h}"
        return "0x0000000000000000"
    }
    
    @protected
    method createMethodReference(m:MethodReference):String? {
        def stub := m.methodStub
        var methodValue := methodReferences[stub]
        if methodValue = null {
            methodValue := "@" + getName(stub) + "_value"
            def methodClass := m.type->>ClassType
            def cc := getClassConstant(getStub(methodClass))
            header.writeLine("\{methodValue} = private unnamed_addr " +
                    "constant %\{getName(getStub(methodClass))} { " + 
                    "\{getLLVMType(ClassType.CLASS)} bitcast(\{cc.type}" + 
                    "* @\{cc.name} to \{getLLVMType(ClassType.CLASS)}" + 
                    "), i8* bitcast(\{getLLVMMethodType(stub)} @" + 
                    "\{getName(stub)} to i8*) }, " +
                    "align \{POINTER_SIZE}")
            methodReferences[stub] := methodValue
        }
        return methodValue
    }

    @protected
    method createDynamicCallReference(d:DynamicCall):String? {
        def methodValue := getTypedReference(d.methodValue)
        def object := getClassConstant(getStub(ClassType.METHOD))
        var offset := object.methods.length
        if !d.type.isPrimitive
            offset += 1 -- shimmed
        -- the "real" type of the method includes a reference to the method 
        -- object before the formal parameters
        def baseType := d.methodValue.type->>MethodType
        def realParameters := new Array<Type>()
        realParameters.add(baseType)
        realParameters.addAll(baseType.methodParameters)
        def realType := new MethodType(realParameters, baseType.returnType, 
                baseType.isMethod, baseType.immutableMethod)
        def methodPtr := getVirtualMethodReference(d.methodValue, offset,
                getLLVMMethodType(realType))
        def c := "fastcc "->>MutableString
        c.append(getLLVMMethodType(realType))
        c.append(" ")
        c.append(methodPtr)
        c.append("(")
        c.append(getTypedReference(d.methodValue))
        for i, p in d.parameters {
            c.append(", ")
            c.append(getTypedReference(p))
        }
        c.append(")")
        def result:String?
        if d.type = VoidType.VOID
            result := null
        else
            result := getTempVariable()
        call(c->>String, result, d->>String)
        return result
    }

    @protected
    method createClassLiteralReference(cl:ClassLiteral):String {
        def stub := getStub(cl.value)
        def cc := getClassConstant(stub)
        def classType := getLLVMType(ClassType.CLASS)
        return "bitcast(\{cc.type}* @\{cc.name} to \{classType})"
    }

    -- return value is nullable so void expressions (method calls) can return
    -- null
    @protected
    method createReference(v:Value):String? {
        switch v.class {
            case class(VariableAssignment): return createVariableAssignmentReference(v->VariableAssignment)
            case class(UnaryOperation): return createUnaryOperationReference(v->UnaryOperation)
            case class(BinaryOperation): return createBinaryOperationReference(v->BinaryOperation)
            case class(Construct): return createConstructReference(v->Construct)
            case class(MethodCall): return createMethodCallReference(v->MethodCall)
            case class(StringLiteral): return getStringConstantReference(v->StringLiteral.value)
            case class(IntegerLiteral): return v->IntegerLiteral.value->>String
            case class(RealLiteral): return createRealLiteralReference(v->RealLiteral)
            case class(VariableReference): return createVariableReference(v->VariableReference)
            case class(FieldReference): return createFieldReference(v->FieldReference)
            case class(Cast): return createCastReference(v->Cast)
            case class(BitLiteral): return v->BitLiteral.value->>String
            case class(NewPrimitiveArrayWithLength): return createNewPrimitiveArrayWithLengthReference(v->NewPrimitiveArrayWithLength)
            case class(PrimitiveArrayCopy): return createPrimitiveArrayCopyReference(v->PrimitiveArrayCopy)
            case class(NewPrimitiveArrayWithValues): return createNewPrimitiveArrayWithValuesReference(v->NewPrimitiveArrayWithValues)
            case class(PrimitiveArrayIndexValue): return createPrimitiveArrayIndexValueReference(v->PrimitiveArrayIndexValue)
            case class(NullLiteral): return "null"
            case class(ClassLiteral): return createClassLiteralReference(v->ClassLiteral)
            case class(Unwrap): return createReference(v->Unwrap.value)
            case class(MethodReference): return createMethodReference(v->MethodReference)
            case class(DynamicCall): return createDynamicCallReference(v->DynamicCall)
            case class(ReusedValueDefinition): return createReusedValueDefinitionReference(v->ReusedValueDefinition)
            case class(ReusedValue): return createReusedValueReference(v->ReusedValue) 
            case class(Super): return createSuperReference(v->Super)
            default: {
                throw new CompilerException("unsupported value class: " + 
                        "\{v.class.name}: \{v}", v.position)
            }
        }
    }

    @protected
    method getTypedReference(v:Value):String {
        def ref := getReference(v)
        assert ref != null : "expected non-null ref in getTypedReference"
        return getLLVMType(v.type) + " " + ref
    }

    @protected
    method getReference(v:Value):String? {
        var result := references[v]
        if result = null {
            result := createReference(v)
            if result != null
                references[v] := result
        }
        return result
    }
    
    @protected
    method generateValueStatementCode(v:ValueStatement) {
        getReference(v.value)
    }

    @pre(array.type.isPrimitiveArray)
    @pre(index.type = IntType.INT32)
     method getPrimitiveArrayElementPointer(array:Value, index:Value):String {
        def arrayRef := getTypedReference(array)
        def indexRef := getTypedReference(index)
        if context.compilerSettings.boundsChecking {
            def cast := getTempVariable()
            def arrayType := getLLVMType(ClassType.PRIMITIVE_ARRAY)
            body.writeLine("\{cast} = bitcast \{arrayRef} to \{arrayType}")
            call("void @pandaCheckBounds(\{arrayType} \{cast}, \{indexRef})")
        }
        def arrayContentsPointer := createCommandReference("getelementptr " +
                "inbounds \{arrayRef}, i32 0, i32 \{ARRAY_CONTENTS_INDEX}", 
                "get pointer to pointer to array contents")
        def elementType := array.type->>PrimitiveArrayType.elementType
        def arrayContents := createCommandReference("load " + 
                getLLVMType(elementType) + 
                "** " + arrayContentsPointer, 
                "get pointer to array contents")
        return createCommandReference("getelementptr inbounds " + 
                "\{getLLVMType(elementType)}* \{arrayContents}, \{indexRef}", 
                "get pointer to " + array + "[" + index + "]")
    }

    @protected
    method generatePrimitiveArrayIndexAssignmentCode(ia:PrimitiveArrayIndexAssignment) {
        def ep := getPrimitiveArrayElementPointer(ia.array, ia.index)
        def elementType := ia.array.type->>PrimitiveArrayType.elementType
        def lref := getLLVMType(elementType) + "* " + ep
        def ref := getReference(ia.value) 
        assert ref != null : "expected non-null ref in generateIndexAssignmentCode"
        writeBody("store \{getLLVMType(elementType)} \{ref}, \{lref}", 
                ia->>String)
    }
    
    @protected
    method generateFieldAssignmentCode(fa:FieldAssignment) {
        if !fa.fieldNode.annotations.isThread {
            def ep := getFieldPointer(fa.object, fa.fieldNode)
            def lref := getLLVMType(fa.fieldNode.type) + "* " + ep
            def vref := getReference(fa.value)
            assert vref != null : "expected non-null vref in generateFieldAssignmentCode"
            writeBody("store \{getLLVMType(fa.fieldNode.type)} \{vref}, " + 
                    lref, fa->>String)
        }
        else {
            def owner := context.getStub(fa.fieldNode.owner)
            callClassInit(owner)
            def threadLocalId := getTempVariable()
            def indexField := owner.symbols[fa.fieldNode.name + 
                    StubGenerator.INDEX_SUFFIX]->Variable
            body.writeLine("load i32* @" + getName(indexField))
            var ref := getReference(fa.value)
            assert ref != null : "expected non-null ref in generateFieldAssignmentCode"
            if !fa.value.type.isPrimitive & 
                    fa.value.type != ClassType.OBJECT {
                var cast := getTempVariable()
                writeBody(cast + " = bitcast " + 
                        getLLVMType(fa.value.type) + " " + ref + " to " + 
                        getLLVMType(ClassType.OBJECT), 
                        "cast threadlocal to Object")
                ref := getLLVMType(ClassType.OBJECT) + " " + cast
            }
            else
                ref := getLLVMType(fa.value.type) + " " + ref
            var suffix:String
            if fa.value.type.isPrimitive
                suffix := fa.value.type.name["panda.core.".length..]
            else
                suffix := "Object"
            call("fastcc void @panda$core$Panda$setThreadLocal" + 
                    suffix + "(i32 " + threadLocalId + ", " + ref + ")")
        }
    }

    @protected
    method generateIfCode(i:If) {
        def ifLabel := createLabel()
        def elseLabel := createLabel()
        def endLabel:String
        if i.elseStatement != null
            endLabel := createLabel()
        else
            endLabel := elseLabel
        writeBody("br " + getTypedReference(i.test) + 
                ", label %" + ifLabel + ", label %" + elseLabel, 
                "if test")
        body.writeLine()
        createBlock(ifLabel, "then")
        generateStatementCode(i.thenStatement)
        if !endsInBranch(i.thenStatement)
            writeBody("br label %" + endLabel, "then -> end")
        body.writeLine()
        def elseStatement := i.elseStatement
        if elseStatement != null {
            createBlock(elseLabel, "else")
            generateStatementCode(elseStatement)
            if !endsInBranch(elseStatement)
                writeBody("br label %" + endLabel, "else -> end")
            body.writeLine()
        }
        createBlock(endLabel, "end if")
    }

    @protected
    method generateReturnCode(ret:Return) {
        def value := ret.value
        if value = null
            body.writeLine("ret void ; " + ret)
        else
            writeBody("ret " + getTypedReference(value), ret->>String)
    }
    
    @protected
    method generateWhileCode(w:While) {
        loops.push(w)
        def bodyLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[w] := nextLabel
        endLabels[w] := endLabel
        body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + w)
        writeBody("br " + getTypedReference(w.test) + 
                ", label %" + bodyLabel + ", label %" + endLabel,
                "while test: " + w.test)
        body.writeLine()
        createBlock(bodyLabel, "body: " + w)
        generateStatementCode(w.statement)
        if !endsInBranch(w.statement)
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + w)
        loops.pop()
    }
    @post(loops.length = @pre(loops.length))

    @protected
    method generateDoCode(d:Do) {
        loops.push(d)
        def bodyLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[d] := nextLabel
        endLabels[d] := endLabel
        body.writeLine("br label %" + bodyLabel)
        body.writeLine()
        createBlock(bodyLabel, "body: " + d)
        generateStatementCode(d.statement)
        if !endsInBranch(d.statement)
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + d)
        writeBody("br " + getTypedReference(d.test) + 
                ", label %" + bodyLabel + ", label %" + endLabel,
                "do test: " + d.test)
        body.writeLine()
        createBlock(endLabel, "end: " + d)
        loops.pop()
    }
    @post(loops.length = @pre(loops.length))

    @protected
    method generateLoopCode(l:Loop) {
        loops.push(l)
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[l] := nextLabel
        endLabels[l] := endLabel
        body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(nextLabel, "next: " + l)
        generateStatementCode(l.statement)
        if !endsInBranch(l.statement)
            body.writeLine("br label %" + nextLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + l)
        loops.pop()
    }
    @post(loops.length = @pre(loops.length))

    @protected
    method generateLoopWithContinueBlockCode(l:LoopWithContinueBlock) {
        loops.push(l)
        def startLabel := createLabel()
        def nextLabel := createLabel()
        def endLabel := createLabel()
        nextLabels[l] := nextLabel
        endLabels[l] := endLabel
        body.writeLine("br label %" + startLabel)
        body.writeLine()
        createBlock(startLabel, "start: " + l)
        generateStatementCode(l.statement)
        if !endsInBranch(l.statement)
            body.writeLine("br label %" + nextLabel)
        createBlock(nextLabel, "next: " + l)
        generateBlockCode(l.continueBlock)
        assert !endsInBranch(l.continueBlock) : "expected loop to not end in " +
                "branch in generateLoopWithContinueBlockCode"
        body.writeLine("br label %" + startLabel)
        body.writeLine()
        createBlock(endLabel, "end: " + l)
        loops.pop()
    }
    @post(loops.length = @pre(loops.length))

    function findLoop(label:String?):AbstractLoop {
        if label = null
            return loops.peek
        for i in 0 .. loops.length {
            if loops.peek(i).label = label
                return loops.peek(i)
        }
        unreachable
    }

    @protected
    method generateBreakCode(br:Break) {
        def loopNode := findLoop(br.label)
        def endLabel := endLabels[loopNode]
        assert endLabel != null : "expected non-null endLabel in generateBreakCode"
        writeBody("br label %" + endLabel, br->>String)
    }

    @protected
    method generateContinueCode(c:Continue) {
        def loopNode := findLoop(c.label)
        def nextLabel := nextLabels[loopNode]
        assert nextLabel != null : "expected non-null nextLabel in generateContinueCode"
        writeBody("br label %" + nextLabel, c->>String)
    }

    @protected
    method generateAssertCode(a:Assert) {
        def succeedLabel := createLabel()
        def failLabel := createLabel()
        writeBody("br \{getTypedReference(a.test)}, label %\{succeedLabel}, " +
                "label %\{failLabel}", "assert test: \{a}")
        body.writeLine()
        createBlock(failLabel, "fail: \{a}")
        var error := a.error
        if error != null {
            if error.type = ClassType.STRING
                call("void \{FAIL_ASSERT_NAME}(\{getTypedReference(error)})")
            else {
                assert error.type = ClassType.ERROR : 
                        "expected msg.type = ERROR but found \{error.type}"
                call("void @pandaThrow(\{getTypedReference(error)})")
            }
        }
        else {
            call("void \{FAIL_ASSERT_NAME}(\{getLLVMType(ClassType.STRING)}" +
                    " null)")
        }
        body.writeLine("unreachable")
        body.writeLine()
        createBlock(succeedLabel, "succeed: \{a}")
    }
    
    @protected
    method generateUnreachableCode(u:Unreachable) {
        call("void \{FAIL_ASSERT_NAME}(\{getLLVMType(ClassType.STRING)} null)")
    }

    @protected
    method generateTryCode(t:Try) {
        generateStatementCode(t.statement)
    }

    @protected
    method generateThrowCode(t:Throw) {
        call("void @pandaThrow(" + getTypedReference(t.error) + ")")
    }

    @protected
    method generateStatementCode(s:Statement) {
        if debug
            body.writeLine("; statement:" + s->>String.replace("\n", "\n; (statement cont) "))
        switch s.class {
            case class(PrimitiveArrayIndexAssignment): 
                    generatePrimitiveArrayIndexAssignmentCode(s->PrimitiveArrayIndexAssignment)
            case class(FieldAssignment): 
                    generateFieldAssignmentCode(s->FieldAssignment)
            case class(ValueStatement):
                    generateValueStatementCode(s->ValueStatement)
            case class(If): generateIfCode(s->If)
            case class(While): generateWhileCode(s->While)
            case class(Do): generateDoCode(s->Do)
            case class(Loop): generateLoopCode(s->Loop)
            case class(LoopWithContinueBlock): 
                    generateLoopWithContinueBlockCode(
                        s->LoopWithContinueBlock)
            case class(Block): generateBlockCode(s->Block)
            case class(Return): generateReturnCode(s->Return)
            case class(Break): generateBreakCode(s->Break)
            case class(Continue): generateContinueCode(s->Continue)
            case class(Assert): generateAssertCode(s->Assert)
            case class(Throw): generateThrowCode(s->Throw)
            case class(Try): generateTryCode(s->Try)
            case class(Unreachable): generateUnreachableCode(s->Unreachable)
            default: 
                throw new InternalCompilerException("unsupported statement: " + 
                        s, s.position)
        }
    }

    @protected
    method generateBlockCode(b:Block) {
        for s in b.statements
            generateStatementCode(s)
    }

    @protected
    method getDefaultValue(f:FieldNode):String {
        def type := f.type
        if type.isInteger | type = CharType.CHAR
            return "0"
        else if type.isReal 
            return createRealLiteralReference(new RealLiteral(Position.INTERNAL,
                    0, type))
        else if type = BitType.BIT
            return "false"
        else
            return "null"
    }

    @protected
    method writeFieldDeclaration(f:FieldNode) {
        if f.annotations.isClass {
            -- write class field
            body.write("@" + getName(f) + " = ")
            def cl := getStub(f.owner)
            if cl.isExternal
                body.write("external ")
            else if f.owner.isPrimitiveArray
                body.write(SHARED_LINKAGE + " ")
            body.write("global " + getLLVMType(f.type))
            if !cl.isExternal
                body.writeLine(" " + getDefaultValue(f))
            else
                body.writeLine()
        }
        else if f.annotations.isThread {
            -- write thread field
            body.write("@" + getName(f) + " = ")
            def cl := getStub(f.owner)
            if cl.isExternal
                body.write("external ")
            body.write("global i32")
            if !cl.isExternal
                body.writeLine(" 0")
            else
                body.writeLine()
        }
    }

    @private
    method isKnownToBeImmutable(type:Type):Bit {
        if type.isPrimitive
            return true
        def stub := context.classes[type.name]
        if stub = null
            return false
        return type.isImmutable(context)
    }

    @protected
    method writeMethodDeclaration(m:MethodStub) {
        assert currentMethod = null : "generating stub for \{m.owner} while in the middle of a method"
        if m.annotations.isAbstract & !m.annotations.isExternal
            return
        def private := m.annotations.isPrivate
        def external := m.annotations.isExternal
        def immutableReturn := m.returnType != VoidType.VOID & 
                isKnownToBeImmutable(m.returnType)
        for p in m.parameters {
            if context.classes[p.type.name] != null
                writeTypeDescriptor(p.type)
        }
        body.writeLine()
        if debug
            body.writeLine("; method: " + m->>String.replace("\n", "\n; (method cont) "))
        body.write("declare ")
        if !external
            body.write("fastcc ")
        body.write(getLLVMType(m.returnType) + " @\{getName(m)}(")
        var first := true
        if !m.annotations.isClass {
            body.write("\{getSelfType(m)} %self")
            first := false
        }
        for i, p in m.parameters {
            if first
                first := false
            else
                body.write(", ")
            body.write(getLLVMType(p.type))
        }
        body.write(")")
        if m.methodType = MethodNodeType.FUNCTION & immutableReturn
            body.write(" readonly")
        body.writeLine()
    }

    @protected
    method generateMethodCode(m:MethodNode) {
        assert currentMethod = null
        if m.stub.annotations.isAbstract
            return
        references.clear()
        nextLabels.clear()
        endLabels.clear()
        def immutableReturn := m.stub.returnType != VoidType.VOID & 
                isKnownToBeImmutable(m.stub.returnType)
        for p in m.stub.parameters
            writeTypeDescriptor(p.type)
        currentMethod := m
        tempVariable := 1
        def private := m.stub.annotations.isPrivate
        def external := m.stub.annotations.isExternal
        body.writeLine()
        if debug
            body.writeLine("; method: " + m->>String.replace("\n", "\n; (method cont) "))
        if external
            body.write("declare ")
        else
            body.write("define ")
        if !external
            body.write("fastcc ")
        body.write(getLLVMType(m.stub.returnType) + " @\{getName(m.stub)}(")
        var first := true
        if !m.stub.annotations.isClass {
            body.write("\{getSelfType(m.stub)} %self")
            first := false
        }
        for i, p in m.parameters {
            if first
                first := false
            else
                body.write(", ")
            body.write(getLLVMType(p.type))
            if !external {
                body.write(" %") 
                body.write(getName(p))
                if p.varType = VariableType.VAR
                    body.write("$PARAM")
            }
        }
        body.write(")")
        if m.stub.methodType = MethodNodeType.FUNCTION & immutableReturn
            body.write(" readonly")
        if external {
            body.writeLine()
        }
        else {
            body.writeLine(" {")
            body.level += 1
            currentBlockLabel := "0"
            for v in m.localVariables
                body.writeLine("%\{getName(v)} = alloca \{getLLVMType(v.type)}")
            for p in m.parameters.filter(p => p.varType = VariableType.VAR) {
                body.writeLine("%" + getName(p) + " = alloca " + 
                        getLLVMType(p.type))
                body.writeLine("store " + getLLVMType(p.type) + " %" + 
                        getName(p) + "$PARAM, " + getLLVMType(p.type) + "* %" + 
                        getName(p))
            }

            def block := m.body
            generateBlockCode(block)
            if !endsInBranch(block) {
                if m.stub.returnType = VoidType.VOID
                    body.writeLine("ret void")
                else
                    body.writeLine("unreachable")
            }
            body.level -= 1
            body.writeLine("}")
        }
        currentMethod := null
    }

    method generateClassCode(cl:ClassNode) {
        for f in cl.stub.fields {
            if f.owner.name = cl.stub.name
                writeFieldDeclaration(f)
        }
        for m in cl.stub.methods {
            if m.annotations.isExternal
                writeMethodDeclaration(m)
        }
        for m in cl.methods
            generateMethodCode(m)
    }

    @override
    method generateCode(target:File) {
        if debug
            Console.writeLine("llvm debug output is enabled")
        header.writeLine('target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"')
        header.writeLine('target triple = "' + StaticSettings.TARGET_TRIPLE + 
                '"')
        header.writeLine('%$itable = type { %panda$core$Class*, %$itable*, ' +
                "[0 x i8*] }")
        for (_, cl) in context.classes {
            if !cl.annotations.isUnspecified
                writeTypeDescriptor(cl)
        }
        getStub(ClassType.METHOD)
        getStub(ClassType.MUTABLE_METHOD)
        for (_, cl) in context.classes {
            if !cl.annotations.isUnspecified
                getClassConstant(cl)
            getStub(cl.type)
        }
        for (_, cl) in classes
            generateClassCode(cl)

        body.writeLine("declare void @pandaInit()")
        body.writeLine("declare void @pandaCheckLibVersion(i32)")
        body.writeLine("declare void @pandaCheckOverflow(i1)")
        body.writeLine("declare {i8, i1}  @llvm.sadd.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.sadd.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.sadd.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.uadd.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.uadd.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.uadd.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.uadd.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.ssub.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.ssub.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.ssub.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.ssub.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.usub.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.usub.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.usub.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.usub.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.smul.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.smul.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.smul.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.smul.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare {i8, i1}  @llvm.umul.with.overflow.i8(i8 %a, i8 %b)")
        body.writeLine("declare {i16, i1} @llvm.umul.with.overflow.i16(i16 %a, i16 %b)")
        body.writeLine("declare {i32, i1} @llvm.umul.with.overflow.i32(i32 %a, i32 %b)")
        body.writeLine("declare {i64, i1} @llvm.umul.with.overflow.i64(i64 %a, i64 %b)")

        body.writeLine("declare void @pandaThrow(\{getLLVMType(ClassType.ERROR)})")
        body.writeLine("declare void @llvm.trap() noreturn nounwind")
        body.writeLine("declare void @pandaCheckSignCasti8(i8)")
        body.writeLine("declare void @pandaCheckSignCasti16(i16)")
        body.writeLine("declare void @pandaCheckSignCasti32(i32)")
        body.writeLine("declare void @pandaCheckSignCasti64(i64)")

        body.writeLine("declare i8* @_pandaNew(%panda$core$Class*, i32)")

        body.writeLine("declare i8* @pandaNewPrimitiveArrayWithLength(" + 
                getLLVMType(ClassType.CLASS) + ", " + 
                getLLVMType(IntType.INT32) + ", " +
                getLLVMType(IntType.INT32) + ", " +
                getLLVMType(BitType.BIT) + ")")
        body.writeLine("declare i8* @pandaNewPrimitiveArrayWithValues(" + 
                getLLVMType(ClassType.CLASS) + ", " + 
                getLLVMType(IntType.INT32) + ", " + 
                getLLVMType(IntType.INT32) + ", ...)")
        body.writeLine("declare i8* @pandaNewPrimitiveArrayCopy(" + 
                getLLVMType(ClassType.CLASS) + ", " + 
                getLLVMType(ClassType.PRIMITIVE_ARRAY) + ", " + 
                getLLVMType(IntType.INT32) + ", " +
                getLLVMType(BitType.BIT) + ")")
        def array := getLLVMType(ClassType.PRIMITIVE_ARRAY)
        body.writeLine("declare void @pandaCheckBounds(\{array}, i32)")

        def parent := target.parent()
        if parent = null {
            throw new CompilerException("could not determine parent " +
                    "directory of " + target.path)
        }
        def unoptTarget := parent.resolve(target.name + ".unopt")
        def out := new BufferedOutputStream(unoptTarget.openOutputStream())
        headerBuffer.sendTo(out)
        bodyBuffer.sendTo(out)
        out.close()

        def opt := PandaCompiler.getLLVMHome().resolve("opt")
        System.exec(opt, unoptTarget.path, "-o", target.path, "-O3",
                "-q", "-f", "-S")
        if !context.compilerSettings.preserveTempArtifacts
            unoptTarget.delete()
    }
}