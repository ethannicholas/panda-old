package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.VoidType

class Context {
    def typeResolver:TypeResolver

    var classes:Map<String, ClassStub>

    def errors:ErrorReporter

    def compilerSettings:CompilerSettings

    var currentClass:ClassStub

    var currentMethod:MethodStub

    var symbolTable:SymbolTable

    def localVariables := new Array<LocalVariable>()

    constructor(typeResolver:TypeResolver, classes:MapView<String, ClassStub>, 
            errors:ErrorReporter, compilerSettings:CompilerSettings) {
        self.typeResolver := typeResolver
        self.classes := new HashMap<String, ClassStub>(classes)
        self.errors := errors
        self.compilerSettings := compilerSettings
        self.currentClass := new ClassStub(Position.INTERNAL, 
                new ClassType("ContextDummy"), false, new Annotations(
                    Position.INTERNAL, new Array<AnnotationType>()), 
                new LookupContext(new Array<String>(), 
                    new HashMap<String, String>()), 
                null, new Array<ClassType>(),
                new Array<MethodStub>(), new Array<FieldNode>(), 
                new Array<ASTInvariant>(), null, true)
        def classAnnotation := new Array<AnnotationType>()
        classAnnotation.add(AnnotationType.CLASS)
        self.currentMethod := new MethodStub(Position.INTERNAL, "<dummy>",
                new Annotations(Position.INTERNAL, classAnnotation),
                MethodNodeType.METHOD, new Array<FormalParameter>(), 
                VoidType.VOID, null, ClassType.OBJECT)
        self.symbolTable := new SymbolTable()
        -- force IMMUTABLE_CHAR_ARRAY to have a stub so that String constants
        -- work
        getStub(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
    }

    method pushSymbolTable() {
        def newSymbolTable := new SymbolTable(symbolTable)
        symbolTable := newSymbolTable
    }

    method popSymbolTable() {
        def newSymbolTable := symbolTable.parent
        assert newSymbolTable != null : "empty SymbolTable stack"
        symbolTable := newSymbolTable
    }

    @private
    method createStub(name:String):ClassStub? {
        def type := typeResolver.resolve(new PandaParser(errors).parseType(name,
                Position.INTERNAL), new LookupContext(new Array<String>(),
                    new HashMap<String, String>()))
        if type = null
            return null
        if type-?>(PrimitiveArrayType) {
            def array := type->(PrimitiveArrayType)
            if array.elementType-?>(GenericParameterType)
                return null
            def elementStub:ClassStub?
            if array.elementType.isPrimitive
                elementStub := null
            else
                elementStub := getStub(array.elementType.name)
            return array.createStub(elementStub)
        }
        else if type-?>(GenericType) {
            def generic := type->(GenericType)
            def baseStub := getStub(generic.base.name)
            def parameterStubs := new Array<ClassStub?>()
            for p in generic.parameters {
                if p-!>(PrimitiveType) & p-!>(GenericParameterType)
                    parameterStubs.add(getStub(p.name))
                else
                    parameterStubs.add(null)
            }
            return type->(GenericType).createStub(self, baseStub,
                    parameterStubs)
        }
        return null
    }

    @private
    @unsafeFunction
    function getStub(name:String):ClassStub {
        if name.endsWith("?")
            return getStub(name[0 .. name.length - 1])
        var result := classes[name]
        if result = null {
            result := createStub(name)
            assert result != null : "failed to create stub for \{name}"
            classes[name] := result
        }
        return result
    }

    function getStub(cl:ClassType):ClassStub {
        if cl.isMethod
            return getStub(ClassType.METHOD)
        return getStub(cl.name)
    }

    function isInstance():Bit {
        return !currentMethod.annotations.isClass
    }

    @pre(isInstance)
    function getSelf(position:Position):Value {
        def v := symbolTable[Parameter.SELF_NAME]
        assert v != null
        return new VariableReference(position, v)
    }

    @private
    constant VARARG_COST := 1

    constant CONVERT_COST := 10

    function matchCost(m:MethodStub, params:ListView<Value>):Int? {
        if m.methodType = MethodNodeType.CONSTRUCTOR & params.length > 0 &
                m.parameters[0].type != params[0].type {
            -- constructor called on mismatched type means we're in a subclass,
            -- and since constructors are not inherited we need to ignore it
            return null
        }
        var result := 0
        var methodParams:ListView<FormalParameter> := m.parameters
        var isVarArg := methodParams.length > 0 & 
                methodParams[methodParams.length - 1].isVarArg
        if isVarArg
            result += VARARG_COST
        if params.length > 0 & params[params.length - 1]-?>(Unwrap) {
            -- we handle unwrap parameters (such as the call foo(bar, baz...))
            -- by simply turning off varargs; the last parameter is already an
            -- array and we just let it be treated as such
            isVarArg := false
        }
        if isVarArg {
            -- strip off vararg parameter, it's not required
            methodParams := m.parameters[..m.parameters.length - 1]
        }
        -- do we have the right number of parameters?
        if !isVarArg & params.length != methodParams.length | 
                isVarArg & params.length < methodParams.length
            return null

        for i, param in methodParams {
            if i = 0 & !m.annotations.isClass
                continue
            def targetType := param.type
            def cost := params[i].implicitCastCost(self, targetType)
            if cost = null {
                if methodParams[i].isConvert & 
                        params[i].canConvertTo(self, targetType)
                    result += CONVERT_COST
                else
                    return null
            }
            else
                result += cost
        }
        
        if isVarArg {
            -- verify that all remaining parameters match the vararg
            def varArg := m.parameters[m.parameters.length - 1]
            def varArgType := varArg.type->>(PrimitiveArrayType).elementType
            for i in methodParams.length .. params.length {
                def cost := params[i].implicitCastCost(self, varArgType)
                if cost = null {
                    if varArg.isConvert & 
                            params[i].canConvertTo(self, varArgType)
                        result += CONVERT_COST
                    else
                        return null
                }
                else
                    result += cost
            }
        }
        return result
    }

    function getMethodsNamed(name:String, searchClass:ClassStub):
            CollectionView<MethodStub> {
        def result := new Array<MethodStub>()
        def superclass := searchClass.superclass
        if superclass != null
            result.addAll(getMethodsNamed(name, getStub(superclass)))
        for intf in searchClass.interfaces
            result.addAll(getMethodsNamed(name, getStub(intf)))
        result.addAll(searchClass.methods.filter(m => m.name = name))
        return result
    }

    ============================================================================
    Finds the best match for the given method.

    @param contextValue the object the method is being called on, or `null` if
            it is a bare method name
    @param name the name of the method
    @param params the method parameters
    ============================================================================
    function getMethod(contextValue:Value?, name:String, 
            params:ListView<Value>):MethodStub? {
        def searchClass:ClassStub
        def classMethod:Bit?
        if contextValue != null {
            if contextValue-?>(ClassLiteral) {
                searchClass := getStub(contextValue->(ClassLiteral).value)
                classMethod := true
            }
            else if contextValue-?>(Super) {
                def cc := currentClass
                searchClass := getStub(cc.superclass->(ClassType))
                classMethod := false
            }
            else {
                classMethod := false
                searchClass := getStub(contextValue.type->>(ClassType))
            }
        }
        else {
            searchClass := currentClass->(ClassStub)
            classMethod := null
        }
        def methods:CollectionView<MethodStub>
        if classMethod = true {
            methods := getMethodsNamed(name, searchClass).filter
                    (m => m.annotations.isClass | 
                    m.methodType = MethodNodeType.CONSTRUCTOR)
        }
        else if classMethod = false {
            methods := getMethodsNamed(name, searchClass).filter
                    (m => !m.annotations.isClass)
        }
        else
            methods := getMethodsNamed(name, searchClass)
        var maxCost := Int.MAX
        var max:MethodStub? := null
        for m in methods {
            def cost := matchCost(m, params)
            if cost != null & cost < maxCost {
                maxCost := cost
                max := m
            }
        }
        return max
    }
}