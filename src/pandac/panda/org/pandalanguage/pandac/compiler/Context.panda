package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Package
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.stubs.TypeSymbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.ArrayLiteral
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.InstanceContext
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

================================================================================
Refactoring badly needed!

Originally this was just a collection of useful information that the IRGenerator
maintained, passing it into things that needed access to it without having to 
pass around the entire IRGenerator. It was originally intended that the Context
be sharable between multiple IRGenerators (e.g. when doing multithreaded
compilation).

After a long series of it-seemed-like-a-good-idea-at-the-time changes (e.g. it
turned out one spot that had access to the Context but not the IRGenerator 
needed to resolve a method call -- so is it better to just move the (very simple 
at the time) method call resolution into Context vs. refactor the whole damned
compiler?), the original vision has morphed into the current monstrosity, where 
the Context does way too much shit and is tightly coupled to the IRGenerator 
anyway, so I'm not even clear on what the distinction between the two of them is
supposed to be in the first place. I will be taking a flamethrower to this 
design once I have the language stabilized.
================================================================================
class Context {
    def stubGenerator:StubGenerator

    def irGenerator:IRGenerator

    var root:Package

    var errors:ErrorReporter

    def compilerSettings:CompilerSettings

    var currentClass:ClassStub

    var currentMethod:MethodStub

    var inClosure:Bit

    def liveMethods := HashSet<MethodStub>()

    ============================================================================
    Methods to be added to the current class.
    ============================================================================
    def methods := Array<MethodNode>()

    ============================================================================
    Captures we have run into while compiling closures. The topmost entry of the
    stack is for the current (innermost) closure.
    ============================================================================
    def captures := Stack<(MethodStub, Set<Variable>)>()

    var symbolTableStack := Stack<SymbolTable>()

    def localVariables := Array<LocalVariable>()

    init(irGenerator:IRGenerator, stubGenerator:StubGenerator, 
            root:Package, errors:ErrorReporter, 
            compilerSettings:CompilerSettings) {
        self.irGenerator := irGenerator
        self.stubGenerator := stubGenerator
        self.root := root
        self.errors := errors
        self.compilerSettings := compilerSettings
        self.currentClass := ClassStub(Position.INTERNAL, 
                ClassType("ContextDummy"), ClassStub.Kind.CLASS, Annotations(
                    Position.INTERNAL, []), 
                null, [], OrderedMap<String, Symbol>(),
                LookupContext(), [], null, true,
                null)
        def classAnnotation := Array<Annotations.Kind>()
        classAnnotation.add(Annotations.Kind.CLASS)
        self.currentMethod := MethodStub(Position.INTERNAL, "<dummy>",
                Annotations(Position.INTERNAL, classAnnotation),
                MethodStub.Kind.METHOD, Array<FormalParameter>(), null,
                VoidType.VOID, null, ClassType.OBJECT)
        symbolTableStack.push(stubGenerator.masterSymbolTable)
        -- force IMMUTABLE_CHAR_ARRAY to have a stub so that String constants
        -- work
        getStub(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
    }

    property symbolTable:SymbolTable

    @private
    function get_symbolTable():SymbolTable {
        return symbolTableStack.peek()
    }

    method pushSymbolTable() {
        symbolTableStack.push(SymbolTable([symbolTable]))
    }

    method pushSymbolTable(symbolTable:SymbolTable) {
        symbolTableStack.push(symbolTable)
    }

    method popSymbolTable() {
        symbolTableStack.pop()
    }

    method resolveType(type:ASTType):Type? {
        return stubGenerator.resolveType(type, symbolTable)
    }

    ============================================================================
    Given something that appears to be a type name (such as a dot-separated list
    of identifiers), attempt to resolve it as a type. If we find a valid type
    name before reaching the end, return the remaining tokens as a list of
    `String`s. For instance, given the expression:

        def a := foo -> Int.abs

    this will parse as `foo -> (Int.abs)`, since `Int.abs` is a valid type 
    name. During evaluation, we note that `Int` is a valid type name, but 
    `Int.abs` is not, so we return `(Int, ["abs"])`.
    ============================================================================
    method resolveTypeWithExtras(type:ASTType):(Type, ListView<String>)? {
        return stubGenerator.resolveTypeWithExtras(type, symbolTable)
    }

    method resolveType(name:String):Type? {
        return stubGenerator.resolveType(
                PandaParser(errors).parseType(name, Position.INTERNAL), 
                symbolTable)
    }

    method isUnspecified(t:Type):Bit {
        return stubGenerator.isUnspecified(t)
    }

    function getStub(name:String):ClassStub {
        return stubGenerator.getStub(name)
    }

    function getStub(cl:ClassType):ClassStub {
        if cl.isMethod {
            return stubGenerator.getStub(ClassType.METHOD)
        }
        return stubGenerator.getStub(cl.name)
    }
    
    property isInstance:Bit

    @private
    function get_isInstance():Bit {
        return symbolTable[Parameter.SELF_NAME] != null
    }

    @private
    constant VARARG_COST := 1

    function matchCost(m:MethodType, var isVarArg:Bit,
            var params:ListView<Value>, returnType:Type?):Int? {
        var result := 0
        if isVarArg {
            result += VARARG_COST
        }
        if params.count > 0 & params[params.count - 1]-?>Unwrap {
            -- we handle unwrap parameters (such as the call foo(bar, baz...))
            -- by simply turning off varargs; the last parameter is already an
            -- array and we just let it be treated as such
            isVarArg := false
            -- ...but we do need to handle primitive arrays for legacy code
            -- right now
            def lastType := m.methodParameters[m.methodParameters.count - 1]
            if lastType-?>PrimitiveArrayType {
                def newParams := Array<Value>()
                newParams.addAll(params[0 .. params.count - 1])
                newParams.add(Dummy(params[params.count - 1].position,
                        lastType))
                params := newParams
            }
        }
        def methodParams:ListView<Type>
        if isVarArg {
            -- strip off vararg parameter, it's not required
            methodParams := m.methodParameters[..m.methodParameters.count - 1]
        }
        else {
            methodParams := m.methodParameters
        }
        -- do we have the right number of parameters?
        if !isVarArg & params.count != methodParams.count | 
                isVarArg & params.count < methodParams.count {
            return null
        }

        for (i, param) in methodParams.enumeration {
            def cost := params[i].implicitCastCost(self, param)
            if cost = null {
                return null
            }
            else {
                result += cost
            }
        }
        
        if isVarArg {
            -- verify that all remaining parameters match the vararg
            def varArg := m.methodParameters[m.methodParameters.count - 1]
            def varArgType := varArg->GenericType.parameters[0]
            for i in methodParams.count .. params.count {
                def cost := params[i].implicitCastCost(self, varArgType)
                if cost = null {
                    return null
                }
                else {
                    result += cost
                }
            }
        }

        if returnType != null {
            def cost := m.returnType.implicitCastCost(self, returnType)
            if cost = null {
                return null
            }
            else {
                result += cost
            }
        }
        return result
    }

    function matchCost(target:Value, m:MethodStub, var params:ListView<Value>, 
            returnType:Type?):Int? {
        var methodParams:ListView<FormalParameter> := m.parameters
        var isVarArg := methodParams.count > 0 & 
                methodParams[methodParams.count - 1].isVarArg
        def type:MethodType
        if m.genericParameters != null {
            def generics := getGenericTypes(target, m, params, returnType)
            if generics = null {
                return null
            }
            type := m.typeWithGenerics(generics)
        }
        else {
            type := m.type
        }
        return matchCost(type, isVarArg, params, returnType)
    }

    function matchCost(target:Value, m:MethodStub, var params:ListView<Value>, 
            returnType:Type?):Int? {
        var methodParams:ListView<FormalParameter> := m.parameters
        var isVarArg := methodParams.count > 0 & 
                methodParams[methodParams.count - 1].isVarArg
        return matchCost(m.type, isVarArg, params, returnType)
    }

    method getSymbolTable(cl:ClassType):SymbolTable {
        return stubGenerator.getSymbolTable(cl)
    }

    method getMethodsNamed(name:String, searchClass:ClassStub):
            CollectionView<MethodStub> {
        def symbol := getSymbolTable(searchClass.type)[name]
        if symbol-?>Methods {
            def result := Array<MethodStub>()
            for m in symbol->Methods.entries {
                result.add(m)
            }
            return result
        }
        return Array<MethodStub>()
    }

    ============================================================================
    Finds the best match for the given method.

    @param target the object the method is being called on, or `null` if
            it is a bare method name
    @param name the name of the method
    @param params the method parameters
    ============================================================================
    method getMethod(target:Value, name:String, 
            params:ListView<Value>, returnType:Type?):MethodStub? {
        def searchClass:ClassStub
        def classMethod:Bit
        if target-?>ClassLiteral {
            searchClass := getStub(target->ClassLiteral.value)
            classMethod := true
        }
        else if target-?>Super {
            def cc := currentClass
            searchClass := getStub(cc.superclass->ClassType)
            classMethod := false
        }
        else {
            classMethod := false
            searchClass := getStub(target.type.convert()->ClassType)
        }
        def methods:CollectionView<MethodStub>
        if classMethod = true {
            methods := getMethodsNamed(name, searchClass).filter
                    (m => m.annotations.isClass | 
                    m.kind = MethodStub.Kind.INIT)
        }
        else if classMethod = false {
            methods := getMethodsNamed(name, searchClass).filter
                    (m => !m.annotations.isClass)
        }
        else {
            methods := getMethodsNamed(name, searchClass)
        }
        var maxCost := Int.MAX
        var max:MethodStub? := null
        for m in methods {
            def cost := matchCost(target, m, params, returnType)
            if cost != null & cost < maxCost {
                maxCost := cost
                max := m
            }
        }
        return max
    }

    method testCall(position:Position, var target:Value, 
            methodName:String, var params:ListView<Value>):Value? {
        return call(position, target, methodName, params, null, false)
    }

    function isNumber(type:Type):Bit {
        if type.isNumber {
            return true
        }
        if type.isWrapper {
            return type.convert()->PrimitiveType.isNumber
        }
        return false
    }

    ============================================================================
    Looks for an overloaded version of `name` (which could be `"="`, `"+"`, 
    etc.) and returns a call to it, or `null` if no such overloaded operator was
    found.
    
    @param position the position of the call in the source code
    @param name the name of the method to call
    @param left the left argument
    @param right the right argument
    @returns a method call, or `null`
    ============================================================================
    method callOverloadedOperator(position:Position, var name:String, 
            left:Value, right:Value):Value? {
        -- avoid calling the various "fake" operators we define in the wrapper
        -- classes
        function isChar(v:Value):Bit {
            return v.type = CharType.CHAR | 
                    v.type = StringOrCharType.STRING_OR_CHAR
        }
        if isChar(left) & isChar(right) {
            return null
        }
        if (name = "=" | name = "!=") & left.type.isPrimitive & 
                right.type.isPrimitive {
            return null
        }
        else if !name.startsWith("[") & isNumber(left.type) & 
                isNumber(right.type) {
            return null
        }
        if left.type = NullType.NULL | right.type = NullType.NULL {
            return null -- force this to be compiled as ==, which is quicker 
                        -- than calling nullableEquals.
        }
        if name != "=" {
            if left.type = StringOrCharType.STRING_OR_CHAR {
                def charCast := left.implicitCast(self, 
                        WrapperType.CHAR_WRAPPER)
                var result := callOverloadedOperator(position, name, charCast, 
                        right)
                if result = null {
                    def stringCast := left.implicitCast(self, ClassType.STRING)
                    result := callOverloadedOperator(position, name, stringCast, 
                            right)
                }
                return result
            }
            if right.type = StringOrCharType.STRING_OR_CHAR {
                def charCast := right.implicitCast(self, 
                        WrapperType.CHAR_WRAPPER)
                var result := callOverloadedOperator(position, name, left, 
                        charCast)
                if result = null {
                    def stringCast := right.implicitCast(self, ClassType.STRING)
                    result := callOverloadedOperator(position, name, left,
                            stringCast)
                }
                return result
            }
        }

        def rawName := name
        -- map != and !== to = and ==. We'll invert the answer on return.
        if name.startsWith("!") {
            name := name[1..]
        }
        var result:Value? := null
        if name = "=" & (left.type.isNullable | right.type.isNullable) {
            -- for equality, if one or both parameters are null, we need to
            -- funnel this through Panda.nullableEquals
            result := testCall(position, ClassLiteral(
                    position, ClassType.PANDA), "nullableEquals", [left, right])
            assert result != null : "failed to call nullableEquals"
        }
        if result = null {
            -- check for overload on left (both instance & class)
            result := testCall(position, left, name, [right])
            if result = null {
                result := testCall(position, ClassLiteral(
                        position, left.type.convert()->ClassType), name, [left, right])
            }
        }
        if result = null & right.isValid {
            def resolved := irGenerator.resolve(right)
            -- check for overload on right (class only)
            result := testCall(position, ClassLiteral(position, 
                    resolved.type.convert()->ClassType), name, [left, resolved])
        }
        if rawName.startsWith("!") & result != null {
            result := UnaryOperation(position, UnaryOperation.Kind.NOT,
                    result)
        }
        return result
    }

    @private
    class Constraint {
        def atLeast:Type?
        def atMost:Type?

        @override
        function convert():String {
            function format(t:Type?):String {
                if t = null {
                    return "<null>"
                }
                return t.convert()
            }
            return "Constraint<\{format(atLeast)}, \{format(atMost)}>"
        }        
    }

    @private
    method updateConstraints(parameterType:Type, var valueType:Type,
            constraints:Map<String, Constraint>):Bit {
        valueType := valueType.unwrapNullable
        if parameterType-?>GenericParameterType {
            def g := parameterType->GenericParameterType
            var result := constraints[g.name]
            if result = null {
                result := Constraint()
                constraints[g.name] := result
            }
            if result.atMost != null {
                result.atMost := Type.union(stubGenerator, result.atMost, 
                        valueType)
            }
            else {
                result.atMost := valueType
            }
        }
        else if parameterType-?>MethodType {
            def m1 := parameterType->MethodType
            if valueType-!>MethodType {
                return false
            }
            def m2 := valueType->MethodType
            if m1.methodParameters.count != m2.methodParameters.count {
                return false
            }
            for (i, t) in m1.methodParameters.enumeration {
                updateConstraints(t, m2.methodParameters[i], constraints)
            }
            updateConstraints(m1.returnType, m2.returnType, constraints)
        }
        return true
    }

    @private
    method updateConstraints(var type:Type, value:Value, 
            constraints:Map<String, Constraint>):Bit {
        if !value.isValid {
            return false
        }
        def resolved := irGenerator.resolve(value)
        if resolved = null {
            return false
        }
        return updateConstraints(type.unwrapNullable, resolved.type, 
                constraints)
    }

    @private
    @pre(m.genericParameters != null)
    method getGenericConstraints(owner:Type, m:MethodStub, 
            params:ListView<Value>,
            expectedReturn:Type?):Map<String, Constraint> {
        def constraints := HashMap<String, Constraint>()
        if owner-?>GenericType {
            def stub := getStub(owner->GenericType.base)
            def raw := stub.genericParameters
            for (i, p) in owner->GenericType.parameters.enumeration {
                def c := Constraint()
                c.atLeast := p
                c.atMost := p
                constraints[m.owner.name + "." + raw[i][0]] := c
            }
        }
        else if getStub(owner.convert()->ClassType).genericParameters != null {
            def stub := getStub(owner.convert()->ClassType)
            for p in stub.genericParameters {
                def c := Constraint()
                def key := m.owner.name + "." + p[0]
                def bound := p[1]
                if bound = null {
                    bound := NullableType.ANY
                }
                c.atLeast := GenericParameterType(key, bound)
                c.atMost := c.atLeast
                constraints[key] := c
            }
        }
        for (i, p) in m.parameters.enumeration {
            updateConstraints(p.type, params[i], constraints)
        }
        return constraints
    }

    @private
    function removeGenerics(cl:ClassType):ClassType {
        if cl-?>GenericType {
            return cl->GenericType.base
        }
        return cl
    }

    @private
    function findOwner(start:ClassType, m:MethodStub):ClassType? {
        if removeGenerics(start) = removeGenerics(m.owner) {
            return start
        }
        def stub := getStub(start)
        if stub.superclass != null {
            def parent := findOwner(stubGenerator.effectiveType(start, 
                    stub.superclass)->ClassType, m)
            if parent != null {
                return parent
            }
        }
        for intf in stub.interfaces {
            def intfOwner := findOwner(stubGenerator.effectiveType(start, 
                    intf)->ClassType, m)
            if intfOwner != null {
                return intfOwner
            }
        }
        return null
    }

    @private
    @pre(m.genericParameters != null)
    method getGenericTypes(target:Value, m:MethodStub, params:ListView<Value>,
            expectedReturn:Type?):ListView<Type>? {
        if params.count != m.parameters.count {
            return null
        }
        def finalTarget := getEffectiveTarget(m, target)
        if finalTarget = null {
            return null
        }
        def owner:ClassType
        if finalTarget-?>ClassLiteral {
            owner := findOwner(finalTarget->ClassLiteral.value, m)
        }
        else {
            owner := findOwner(finalTarget.type.convert()->ClassType, m)
        }
        def constraints := getGenericConstraints(owner, m, params, 
                expectedReturn)
        def result := Array<Type>()
        for g in m.genericParameters {
            def key := m.owner.name + "." + g[0]
            def constraint := constraints[key]
            if constraint != null {
                result.add(constraint.atLeast)
            }
            else {
                errors.error("no constraints on \{key} in \{target.type.displayName}.\{m}(\{params})", target.position)
                result.add(NullableType.ANY)
            }
        }
        return result
    }

    @private
    method getMethodNotFoundMessage(target:Value, methodName:String, 
            params:ListView<Value>):String {
        def msg := MutableString("no match found for method ")
        msg.append(methodName)
        msg.append("(")
        var first := true
        for (i, p) in params.enumeration {
            if p-?>Dummy {
                continue
            }
            if first {
                first := false
            }
            else {
                msg.append(", ")
            }
            msg.append(p.type.displayName)
        }
        msg.append(")")
        if target-?>Super {
            msg.append(" in \{currentClass->ClassStub.superclass->Type.displayName}")
        }
        else if target-?>ClassLiteral {
            msg.append(" in \{target}")
        }
        else {
            msg.append(" in \{target.type.displayName}")
        }
        for p in params {
-*            if p-?>UnresolvedLambda {
                def lambda := p->UnresolvedLambda
                if lambda.errors.count > 0 {
                    msg.append("\n    possible error in lambda at " +
                            "\{lambda.position}:")
                    def entries := PrimitiveArray<Object>()
                    for e in lambda.errors
                        entries.append(e)
                    Panda.sort(entries, function(eo1:Object, eo2:Object):Bit {
                        def e1 := eo1->(Object?, Object?)[0]->PrimitiveArray<Type>
                        def e2 := eo2->(Object?, Object?)[0]->PrimitiveArray<Type>
                        assert e1.count = e2.count
                        for i in 0 .. e1.count {
                            def n1 := e1[i].name
                            def n2 := e2[i].name
                            if n1 > n2
                                return true
                            if n2 > n1
                                return false
                        }
                        return false
                    })
                    for raw in entries {
                        def e := raw->(Object?, Object?)
                        def types := e[0]->PrimitiveArray<Type>
                        def typeString := MutableString()
                        typeString.append("(")
                        for (i, type) in types.enumeration {
                            if i > 0
                                typeString.append(",")
                            typeString.append(type.displayName)
                        }
                        typeString.append(")=>(...)")
                        var error, errorPos := e[1]->(String, Position?)
                        if errorPos = null
                            errorPos := Position.INTERNAL
                        msg.append("\n        when interpreted as \{typeString}:\n")
                        msg.append("            \{error}")
                        if errorPos != lambda.position
                            msg.append(" at \{errorPos}")
                    }
                }
            }*-
        }
        return msg.convert()
    }

    method call(position:Position, var target:Value, m:MethodStub,
            var params:ListView<Value>):Value? {
        if target.type.isPrimitive & m.name = "hash" & params.count = 0 {
            -- simple optimization, avoid calling non-wrapper function in this
            -- common case (can't be a wrapper function because it is an
            -- override)
            return Cast(position, target, m.returnType, Cast.Kind.CONVERT)
        }
        def type:MethodType
        if m.genericParameters != null {
            def generics := getGenericTypes(target, m, params, null)
            if generics = null {
                errors.error("invalid method call", position)
            }
            type := m.typeWithGenerics(generics)
        }
        else {
            type := m.type
        }
        def finalTarget := getEffectiveTarget(m, target)
        if finalTarget != null  {
            target := finalTarget
        }
        else {
            if m.annotations.isClass {
                errors.error("cannot call @class method on an instance",
                        position)
            }
            else {
                errors.error("cannot call instance method from a class context",
                        position)
            }
            return null
        }
        if !m.annotations.isClass & m.kind != MethodStub.Kind.INIT &
                !target.canImplicitCastTo(self, m.owner) {
            errors.error("cannot call instance method '\{m.name}' belonging " +
                    "to class '\{m.owner.displayName}' on an instance of " +
                    "'\{target.type.displayName}'", 
                    position)
            return null
        }
        def rawParams := m.parameters
        var isVarArg := rawParams.count > 0 & 
                rawParams[rawParams.count - 1].isVarArg
        if params.count > 0 {
            def last := params[params.count - 1]
            if last-?>UnresolvedRange {
                def range := last->UnresolvedRange
                def left := range.left
                if isListView(left) & range.right = null {
                    assert left != null
                    def newParams := Array<Value>()
                    newParams.addAll(params[0 .. params.count - 1])
                    newParams.add(Unwrap(left))
                    params := newParams
                }
            }
        }
        for (i, p) in params.enumeration {
            if p-?>Unwrap {
                if !isVarArg {
                    errors.error("'...' may not be used with " +
                            "non-variadic \{m}", position)
                    return null
                }
                if i < params.count - 1 {
                    errors.error("'...' may only be used " +
                            "with the last parameter of a call", position)
                    return null
                }
            }
        }
        if isVarArg & params.count > 0 & params[params.count - 1]-?>Unwrap {
            isVarArg := false
        }
        def count:Int
        if isVarArg {
            count := rawParams.count - 1
        }
        else {
            count := rawParams.count
        }
        def finalParams := Array<Value>()
        if params.count < count | (params.count > count & !isVarArg) {
            errors.error("\{m} requires \{count} parameters, but found " +
                    params.count, position)
            return null
        }
        def actualParams := m.unwrapped.type.methodParameters
        def effectiveParams := type.methodParameters
        for i in 0 .. count {
            def targetType := effectiveParams[i]
            if params[i].canImplicitCastTo(self, targetType) {
                def cast := params[i].implicitCast(self, targetType)
                finalParams.add(cast.explicitCast(self, 
                        actualParams[i].unwrapGenerics, true))
            }
            else {
                params[i].reportCastError(self, targetType)
                return null
            }
        }
        if isVarArg {
            def values := Array<Value>()
            def actualArrayType := actualParams[actualParams.count - 
                    1]->GenericType
            def effectiveArrayType := actualParams[actualParams.count - 
                    1]->GenericType
            def actualElementType := 
                    actualArrayType.parameters[0].unwrapGenerics
            def effectiveElementType := effectiveArrayType.parameters[0]
            for i in count .. params.count {
                def cast := params[i].implicitCast(self, 
                        effectiveElementType).implicitCast(self, 
                            actualElementType)
                values.add(cast)
            }
            def varParams := createArrayLiteral(position, actualArrayType, 
                    values)
            finalParams.add(varParams)
        }
        if target-!>ClassLiteral {
            def selfType:Type
            if m.annotations.isWrapperMethod {
                selfType := m.owner.convert()->PrimitiveType
            }
            else {
                selfType := m.unwrapped.owner
            }
            target := target.implicitCast(self, selfType)
        }
        if m.name = "convert" & target.type.isWrapper & 
                target.type.convert()->PrimitiveType.isNumeric & 
                m.returnType.isNumeric {
            -- handle conversions between primitive types directly
            return Cast(position, target.unwrap(self), m.returnType, 
                    Cast.Kind.CONVERT)
        }
        liveMethods.add(m.unwrapped)
        var result:Value := MethodCall(position, target, m.unwrapped, 
                                       finalParams)
        if result.type != type.returnType {
            result := result.explicitCast(self, type.returnType, true)
        }
        return result
    }

    @private
    function isListView(value:Value?):Bit {
        if value = null {
            return false
        }
        for intf in value.type.convert()->ClassType.allInterfaces(
                stubGenerator) {
            if intf.name.startsWith("panda.collections.ListView<") {
                return true
            }
        }
        return false
    }

    @private
    function getEffectiveTarget(m:MethodStub, target:Value):Value? {
        if target-?>InstanceContext {
            if m.annotations.isClass {
                return ClassLiteral(target.position, m.owner)
            }
            else {
                return target->InstanceContext.selfParam
            }
        }
        else {
            def isInit := m.kind = MethodStub.Kind.INIT
            if !isInit & 
                    (m.annotations.isClass != target-?>ClassLiteral) {
                return null
            }
            return target
        }
    }

    method call(position:Position, target:Value, 
            methodName:String, var params:ListView<Value>):Value? {
        return call(position, target, methodName, params, null, true)
    }

    method call(position:Position, target:Value, 
            methodName:String, var params:ListView<Value>, returnType:Type?,
            reportErrors:Bit):Value? {
        def type:ClassType
        if target-?>ClassLiteral {
            type := target->ClassLiteral.value
        }
        else if target-?>Super {
            def sub := getStub(target.type.convert()->ClassType)
            type := stubGenerator.effectiveType(
                    target.type.convert()->ClassType, 
                    sub.superclass->ClassType)->ClassType
        }
        else {
            type := target.type.convert()->ClassType
        }
        def symbolTable := getSymbolTable(type)
        def methods := symbolTable[methodName]
        if methods-?>Methods {
            def stubs := Array<MethodStub>()
            for m in methods->Methods.entries {
                stubs.add(m)
            }
            return call(position, target, stubs, params, returnType, 
                    reportErrors)
        }
        if reportErrors {
            if methods != null {
                errors.error("'\{target.type.displayName}.\{methodName}' is " +
                        "not a method", position)
            }
            else {
                errors.error("'\{target.type.displayName}' has no member " +
                        "named '\{methodName}'", position)
            }
        }
        return null
    }

    method call(position:Position, target:Value, methods:ListView<MethodStub>, 
            var params:ListView<Value>):Value? {
        return call(position, target, methods, params, null)
    }

    method call(position:Position, target:Value, methods:ListView<MethodStub>, 
            var params:ListView<Value>, returnType:Type?):Value? {
        return call(position, target, methods, params, returnType, true)
    }

    method call(position:Position, target:Value, 
            methods:ListView<MethodStub>, var params:ListView<Value>,
            returnType:Type?, reportErrors:Bit):Value? {
        if params.count > 0 {
            def last := params[params.count - 1]
            if last-?>UnresolvedRange {
                def range := last->UnresolvedRange
                def left := range.left
                if isListView(left) & range.right = null {
                    assert left != null
                    def newParams := Array<Value>()
                    newParams.addAll(params[0 .. params.count - 1])
                    newParams.add(Unwrap(left))
                    params := newParams
                }
            }
        }
        var bestCost := Int.MAX
        var best:Array<MethodStub> := []
        for m in methods {
            def finalTarget := getEffectiveTarget(m, target)
            if finalTarget = null {
                continue
            }
            def cost := matchCost(finalTarget, m, params, returnType)
            if cost != null & cost < bestCost {
                bestCost := cost
                best := [m]
            }
            else if cost != null & cost = bestCost {
                best.add(m)
            }
        }
        if best.count > 1 {
            best.filterInPlace(m => !m.annotations.isShim)
        }
        if best.count = 1 {
            def finalTarget := getEffectiveTarget(best[0], target)
            if finalTarget = null {
                errors.error("internal error: null target in " +
                        "\{target}:\{best[0]}", position)
                return null
            }
            if reportErrors & inClosure & target-?>InstanceContext & 
                    !best[0].annotations.isClass {
                errors.error("cannot implicitly reference 'self' within a " + 
                        "closure. Use an explicit 'self.' to make the " +
                        "capture semantics explicit.", position)
            }
            return call(position, finalTarget, best[0], params)
        }
        else if best.count = 0 {
            if reportErrors {
                def types := Array<String>()
                for p in params {
                    types.add(p.type.displayName)
                }
                var msg := "no match for \{methods[0].owner.name}." +
                        "\{methods[0].name}(\{types.join(', ')})"
                if returnType != null {
                    msg += ":\{returnType.name}"
                }
                errors.error(msg, position)
            }
            return null
        }
        else {
            if reportErrors {
                reportAmbiguous(position, methods, params, returnType)
            }
            return null
        }
    }

    method reportAmbiguous(position:Position, 
            methods:CollectionView<MethodStub>, params:ListView<Value>, 
            returnType:Type?) {
        def result := MutableString()
        result.append("call to '\{methods.iterator.next().name}' with " +
                "parameters (")
        for (i, p) in params.enumeration {
            if i > 0 {
                result.append(", ")
            }
            result.append(p.type.displayName)
        }
        result.append(")")
        if returnType != null {
            result.append(" and expected return type " +
                    "'\{returnType.displayName}'")
        }
        result.append(" is ambiguous. The following methods are " +
                "equally good matches:")
        for m in methods {
            result.append("\n    \{m} (\{m.position})")
        }
        errors.error(result.convert(), position)
    }

    method createArrayLiteral(position:Position, type:GenericType, 
            values:ListView<Value>):Value {
        def params := Array<Value>()
        def typeParameters := Array<ASTType>()
        typeParameters.add(IRGenerator.toASTType(position,
                type.parameters[0]))
        def primName:String
        def arrayName:String
        if type.isImmutable(stubGenerator) {
            primName := ClassType.IMMUTABLE_PRIMITIVE_ARRAY.name
            arrayName := ClassType.IMMUTABLE_ARRAY.name
        }
        else {
            primName := ClassType.PRIMITIVE_ARRAY.name
            arrayName := ClassType.ARRAY.name
        }
        def primType := resolveType(ASTClassType(position, 
                primName, typeParameters, false))
        assert primType != null
        def arrayType := resolveType(ASTClassType(position, 
                arrayName, typeParameters, false))
        assert arrayType != null
        params.add(NewPrimitiveArrayWithValues(position, 
                primType->PrimitiveArrayType, values))
        def c := call(position, ClassLiteral(position, arrayType),
                MethodNode.INIT_NAME, params)
        assert c != null
        return Construct(c->MethodCall).implicitCast(self, type)
    }
}