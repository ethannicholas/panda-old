package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Package
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.InstanceContext
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayCopy
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.VoidType

class Context {
    def stubGenerator:StubGenerator

    var root:Package

    def classes:Map<String, ClassStub>

    def errors:ErrorReporter

    def compilerSettings:CompilerSettings

    var currentClass:ClassStub

    var currentMethod:MethodStub

    var symbolTableStack := new Stack<SymbolTable>()

    def localVariables := new Array<LocalVariable>()

    def symbolTables := new HashMap<ClassStub, SymbolTable>()

    constructor(stubGenerator:StubGenerator, root:Package, 
            classes:MapView<String, ClassStub>, errors:ErrorReporter, 
            compilerSettings:CompilerSettings) {
        self.stubGenerator := stubGenerator
        self.root := root
        self.classes := new HashMap<String, ClassStub>(classes)
        self.errors := errors
        self.compilerSettings := compilerSettings
        self.currentClass := new ClassStub(Position.INTERNAL, 
                new ClassType("ContextDummy"), false, new Annotations(
                    Position.INTERNAL, new Array<AnnotationType>()), 
                null, new Array<ClassType>(), stubGenerator.masterSymbolTable,
                new LookupContext(), new Array<ASTInvariant>(), null, true)
        def classAnnotation := new Array<AnnotationType>()
        classAnnotation.add(AnnotationType.CLASS)
        self.currentMethod := new MethodStub(Position.INTERNAL, "<dummy>",
                new Annotations(Position.INTERNAL, classAnnotation),
                MethodNodeType.METHOD, new Array<FormalParameter>(), 
                VoidType.VOID, null, ClassType.OBJECT)
        symbolTableStack.push(stubGenerator.masterSymbolTable)
        -- force IMMUTABLE_CHAR_ARRAY to have a stub so that String constants
        -- work
        getStub(PrimitiveArrayType.IMMUTABLE_CHAR_ARRAY)
    }

    function symbolTable():SymbolTable {
        return symbolTableStack.peek()
    }

    method pushSymbolTable() {
        symbolTableStack.push(new SymbolTable(symbolTable))
    }

    method popSymbolTable() {
        symbolTableStack.pop()
    }

    method resolveType(type:ASTType):Type? {
        return stubGenerator.resolveType(type, symbolTable)
    }

    method resolveType(name:String):Type? {
        return stubGenerator.resolveType(
                new PandaParser(errors).parseType(name, Position.INTERNAL), 
                symbolTable)
    }

    @private
    method createStub(name:String):ClassStub? {
        def type := stubGenerator.resolveType(
                new PandaParser(errors).parseType(name, Position.INTERNAL), 
                symbolTable)
        if type = null
            return null
        if type-?>(PrimitiveArrayType) {
            def array := type->(PrimitiveArrayType)
            def elementStub:ClassStub?
            if array.elementType.isPrimitive
                elementStub := null
            else
                elementStub := getStub(array.elementType.name)
            return array.createStub(elementStub, self)
        }
        else if type-?>(GenericType) {
            def generic := type->(GenericType)
            def baseStub := getStub(generic.base.name)
            def parameterStubs := new Array<ClassStub?>()
            for p in generic.parameters {
                if p-!>(PrimitiveType) & p-!>(GenericParameterType)
                    parameterStubs.add(getStub(p.name))
                else
                    parameterStubs.add(null)
            }
            return generic.createStub(self, baseStub,
                    parameterStubs)
        }
        else if type-?>(GenericParameterType) {
            return getStub(type->(GenericParameterType).bound.name)
        }
        else if type-?>(TupleType) {
            def tuple := type->(TupleType)
            def stubs := new Array<ClassStub?>()
            for t in tuple.types {
                if t.isPrimitive | t-?>(GenericParameterType)
                    stubs.add(null)
                else
                    stubs.add(getStub(t.name))
            }
            return tuple.createStub(stubs, self)
        }
        else
            throw new InternalCompilerException("cannot create stub for \{type}")
    }

    @private
    @unsafeFunction
    function getStub(name:String):ClassStub {
        if name.endsWith("?")
            return getStub(name[0 .. name.length - 1])
        var result := classes[name]
        if result = null {
            result := createStub(name)
            assert result != null : "failed to create stub for \{name}"
            classes[name] := result
        }
        return result
    }

    function getStub(cl:ClassType):ClassStub {
        if cl.isMethod
            return getStub(ClassType.METHOD)
        return getStub(cl.name)
    }

    function isInstance():Bit {
        return !currentMethod.annotations.isClass
    }

    @pre(isInstance)
    function getSelf(position:Position):Value {
        def v := symbolTable[Parameter.SELF_NAME]
        return new VariableReference(position, v->(Variable))
    }

    @private
    constant VARARG_COST := 1

    constant CONVERT_COST := 10

    function matchCost(target:Value, m:MethodStub, 
            var params:ListView<Value>):Int? {
        var result := 0
        var methodParams:ListView<FormalParameter> := m.parameters
        var isVarArg := methodParams.length > 0 & 
                methodParams[methodParams.length - 1].isVarArg
        if isVarArg
            result += VARARG_COST
        if params.length > 0 & params[params.length - 1]-?>(Unwrap) {
            -- we handle unwrap parameters (such as the call foo(bar, baz...))
            -- by simply turning off varargs; the last parameter is already an
            -- array and we just let it be treated as such
            isVarArg := false
            -- ...but we do need to handle primitive arrays for legacy code
            -- right now
            def lastType := m.parameters[m.parameters.length - 1].type
            if lastType-?>(PrimitiveArrayType) {
                def newParams := new Array<Value>()
                newParams.addAll(params[0 .. params.length - 1])
                newParams.add(new Dummy(params[params.length - 1].position,
                        lastType))
                params := newParams
            }
        }
        if isVarArg {
            -- strip off vararg parameter, it's not required
            methodParams := m.parameters[..m.parameters.length - 1]
        }
        -- do we have the right number of parameters?
        if !isVarArg & params.length != methodParams.length | 
                isVarArg & params.length < methodParams.length
            return null

        for i, param in methodParams {
            def targetType := param.type
            def cost := params[i].implicitCastCost(self, targetType)
            if cost = null {
                if methodParams[i].isConvert & 
                        params[i].canConvertTo(self, targetType)
                    result += CONVERT_COST
                else
                    return null
            }
            else
                result += cost
        }
        
        if isVarArg {
            -- verify that all remaining parameters match the vararg
            def varArg := m.parameters[m.parameters.length - 1]
            def varArgType := varArg.type->>(PrimitiveArrayType).elementType
            for i in methodParams.length .. params.length {
                def cost := params[i].implicitCastCost(self, varArgType)
                if cost = null {
                    if varArg.isConvert & 
                            params[i].canConvertTo(self, varArgType)
                        result += CONVERT_COST
                    else
                        return null
                }
                else
                    result += cost
            }
        }
        return result
    }

    method getSymbolTable(cl:ClassStub):SymbolTable {
        var result := symbolTables[cl]
        if result = null {
            result := new SymbolTable(stubGenerator.masterSymbolTable)
            for p in cl.lookupContext.packageUses
                stubGenerator.usePackage(p, result, cl.position)
            for (alias, target) in cl.lookupContext.classAliases {
                def resolved := resolveType(new ASTClassType(
                        cl.position, target, null, false))
                assert resolved != null
                stubGenerator.aliasType(alias, resolved, result)
            }
            def superclass := cl.superclass
            if superclass != null
                result.addAll(getSymbolTable(getStub(superclass)))
            for intf in cl.interfaces
                result.addAll(getSymbolTable(getStub(intf)))
            result.addAll(cl.symbols)
            symbolTables[cl] := result
        }
        return result
    }

    method getMethodsNamed(name:String, searchClass:ClassStub):
            CollectionView<MethodStub> {
        def symbol := getSymbolTable(searchClass)[name]
        if symbol-?>(Methods)
            return symbol->(Methods).methods
        def result := new Array<MethodStub>()
        if symbol-?>(MethodStub)
            result.add(symbol->(MethodStub))
        return result
    }

    ============================================================================
    Finds the best match for the given method.

    @param target the object the method is being called on, or `null` if
            it is a bare method name
    @param name the name of the method
    @param params the method parameters
    ============================================================================
    method getMethod(target:Value, name:String, 
            params:ListView<Value>):MethodStub? {
        def searchClass:ClassStub
        def classMethod:Bit
        if target-?>(ClassLiteral) {
            searchClass := getStub(target->(ClassLiteral).value)
            classMethod := true
        }
        else if target-?>(Super) {
            def cc := currentClass
            searchClass := getStub(cc.superclass->(ClassType))
            classMethod := false
        }
        else {
            classMethod := false
            searchClass := getStub(target.type->>(ClassType))
        }
        def methods:CollectionView<MethodStub>
        if classMethod = true {
            methods := getMethodsNamed(name, searchClass).filter
                    (m => m.annotations.isClass | 
                    m.methodType = MethodNodeType.CONSTRUCTOR)
        }
        else if classMethod = false {
            methods := getMethodsNamed(name, searchClass).filter
                    (m => !m.annotations.isClass)
        }
        else
            methods := getMethodsNamed(name, searchClass)
        var maxCost := Int.MAX
        var max:MethodStub? := null
        for m in methods {
            def cost := matchCost(target, m, params)
            if cost != null & cost < maxCost {
                maxCost := cost
                max := m
            }
        }
        return max
    }

    method testCall(position:Position, var target:Value, 
            methodName:String, var params:ListView<Value>):Value? {
        def methodStub := getMethod(target, methodName, params)
        if methodStub != null
            return call(position, target, methodStub, params)
        else
            return null
    }

    ============================================================================
    Looks for an overloaded version of `name` (which could be `"="`, `"+"`, 
    etc.) and returns a call to it, or `null` if no such overloaded operator was
    found.
    
    @param position the position of the call in the source code
    @param name the name of the method to call
    @param left the left argument
    @param right the right argument
    @returns a method call, or `null`
    ============================================================================
    method callOverloadedOperator(position:Position, var name:String, 
            left:Value, right:Value):Value? {
        -- avoid calling the various "fake" operators we define in the wrapper
        -- classes
        if name = "=" | name = "!=" {
            if left.type.isPrimitive & right.type.isPrimitive
                return null
        }
        else if !name.startsWith("[") & (left.type.isNumber | 
                left.type.isWrapper) & (right.type.isNumber | 
                right.type.isWrapper)
            return null
        if left.type = NullType.NULL | right.type = NullType.NULL
            return null -- force this to be compiled as ==, which is quicker 
                        -- than calling nullableEquals.
        if name != "=" {
            if left.type = StringOrCharType.STRING_OR_CHAR {
                def cast:Value?
                cast := left.implicitCast(self, ClassType.STRING)
                return callOverloadedOperator(position, name, cast, right)
            }
            if right.type = StringOrCharType.STRING_OR_CHAR {
                def cast:Value?
                cast := right.implicitCast(self, ClassType.STRING)
                return callOverloadedOperator(position, name, left, cast)
            }
        }

        def rawName := name
        -- map != and !== to = and ==. We'll invert the answer on return.
        if name.startsWith("!")
            name := name[1..]
        var result:Value? := null
        def parameters := new Array<Value>()
        parameters.add(left)
        parameters.add(right)
        if name = "=" & (left.type.isNullable | right.type.isNullable) {
            -- for equality, if one or both parameters are null, we need to
            -- funnel this through Panda.nullableEquals
            result := testCall(position, new ClassLiteral(
                    position, ClassType.PANDA), "nullableEquals", parameters)
            assert result != null : "failed to call nullableEquals"
        }
        if result = null {
            -- check for overload on left (both instance & class)
            def rightParam := new Array<Value>()
            rightParam.add(right)
            result := testCall(position, left, name, rightParam)
            if result = null {
                result := testCall(position, new ClassLiteral(
                        position, left.type->>(ClassType)), name, parameters)
            }
        }
        if result = null {
            -- check for overload on right (class only)
            parameters.clear()
            parameters.add(right)
            parameters.add(left)
            result := testCall(position, new ClassLiteral(position, 
                    right.type->>(ClassType)), name, parameters)
        }
        if rawName.startsWith("!") & result != null {
            result := new UnaryOperation(position, UnaryOperationType.NOT,
                    result)
        }
        return result
    }

    @private
    method getMethodNotFoundMessage(target:Value, methodName:String, 
            params:ListView<Value>):String {
        def msg := "no match found for method "->>(MutableString)
        msg.append(methodName)
        msg.append("(")
        var first := true
        for i, p in params {
            if p-?>(Dummy)
                continue
            if first
                first := false
            else
                msg.append(", ")
            msg.append(p.type.displayName)
        }
        msg.append(")")
        if target-?>(Super)
            msg.append(" in \{currentClass->(ClassStub).superclass->(Type).displayName}")
        else if target-?>(ClassLiteral)
            msg.append(" in \{target}")
        else
            msg.append(" in \{target.type.displayName}")
        for p in params {
-*            if p-?>(UnresolvedLambda) {
                def lambda := p->(UnresolvedLambda)
                if lambda.errors.length > 0 {
                    msg.append("\n    possible error in lambda at " +
                            "\{lambda.position}:")
                    def entries := new PrimitiveArray<Object>()
                    for e in lambda.errors
                        entries.append(e)
                    Panda.sort(entries, function(eo1:Object, eo2:Object):Bit {
                        def e1 := eo1->((Object?, Object?))[0]->(PrimitiveArray<Type>)
                        def e2 := eo2->((Object?, Object?))[0]->(PrimitiveArray<Type>)
                        assert e1.length = e2.length
                        for i in 0 .. e1.length {
                            def n1 := e1[i].name
                            def n2 := e2[i].name
                            if n1 > n2
                                return true
                            if n2 > n1
                                return false
                        }
                        return false
                    })
                    for raw in entries {
                        def e := raw->((Object?, Object?))
                        def types := e[0]->(PrimitiveArray<Type>)
                        def typeString := new MutableString()
                        typeString.append("(")
                        for i, type in types {
                            if i > 0
                                typeString.append(",")
                            typeString.append(type.displayName)
                        }
                        typeString.append(")=>(...)")
                        var error, errorPos := e[1]->((String, Position?))
                        if errorPos = null
                            errorPos := Position.INTERNAL
                        msg.append("\n        when interpreted as \{typeString}:\n")
                        msg.append("            \{error}")
                        if errorPos != lambda.position
                            msg.append(" at \{errorPos}")
                    }
                }
            }*-
        }
        return msg->>(String)
    }

    method call(position:Position, target:Value, m:MethodStub,
            params:ListView<Value>):Value? {
        def methodParams := m.parameters
        var isVarArg := methodParams.length > 0 &
                methodParams[methodParams.length - 1].isVarArg
        for i, p in params {
            if p-?>(Unwrap) {
                if !isVarArg {
                    errors.error("'...' may not be used with " +
                            "non-variadic \{m}", position)
                    return null
                }
                if i < params.length - 1 {
                    errors.error("'...' may only be used " +
                            "with the last parameter of a call", position)
                    return null
                }
            }
        }
        if isVarArg & params.length > 0 & params[params.length - 1]-?>(Unwrap)
            isVarArg := false
        def count:Int
        if isVarArg
            count := methodParams.length - 1
        else
            count := methodParams.length
        def finalParams := new Array<Value>()
        for i in 0 .. count {
            def targetType := m.parameters[i].type
            if params[i].canImplicitCastTo(self, targetType) {
                def cast := params[i].implicitCast(self, targetType)
                finalParams.add(cast)
            }
            else if m.parameters[i].isConvert & 
                    params[i].canConvertTo(self, targetType) {
                def converted := params[i].convert(self, targetType)
                finalParams.add(converted)
            }
            else if params[i]-?>(Unwrap) & targetType-?>(PrimitiveArrayType) {
                -- temporary, until new compiler is done and we stop using
                -- PrimitiveArrays outside of Array. FIXME remove this case.
                finalParams.add(params[i].convert(self, targetType))
            }
            else {
                Console.writeLine("calling \{m} with \{params}")
                errors.error("expected value of type " +
                        "'\{targetType.displayName}', but found " +
                        "'\{params[i].type.displayName}'", params[i].position)
                return null
            }
        }
        if isVarArg {
            def values := new Array<Value>()
            def isConvert := methodParams[methodParams.length - 1].isConvert
            def arrayType := methodParams[methodParams.length - 1].type->(PrimitiveArrayType)
            def elementType := arrayType.elementType
            for i in count .. params.length {
                if isConvert {
                    def convert := params[i].convert(self, elementType)
                    values.add(convert)
                }
                else {
                    def cast := params[i].implicitCast(self, elementType)
                    values.add(cast)
                }
            }
            def varParams := new NewPrimitiveArrayWithValues(position,
                    arrayType, values)
            finalParams.add(varParams)
        }
        return new MethodCall(position, target, m, finalParams)
    }

    @private
    function isListView(value:Value?):Bit {
        if value = null
            return false
        def cl := getStub(value.type->>(ClassType))
        for intf in cl.allInterfaces(self) {
            if intf.name.startsWith("panda.collections.ListView<")
                return true
        }
        return false
    }

    method call(position:Position, target:Value, methodName:String, 
            var params:ListView<Value>):Value? {
        if params.length > 0 {
            def last := params[params.length - 1]
            if last-?>(UnresolvedRange) {
                def range := last->(UnresolvedRange)
                def left := range.left
                if isListView(left) & range.right = null {
                    assert left != null
                    def newParams := new Array<Value>()
                    newParams.addAll(params[0 .. params.length - 1])
                    newParams.add(new Unwrap(left))
                    params := newParams
                }
            }
        }
        for p in params {
            if !p.checkValid(self)
                return null
        }
        def result := testCall(position, target, methodName, 
                params)
        if result = null {
            errors.error(getMethodNotFoundMessage(target, methodName, 
                    params), position)
        }
        return result
    }

    @private
    function getEffectiveTarget(m:MethodStub, target:Value):Value {
        if target-?>(InstanceContext) {
            if m.annotations.isClass
                return new ClassLiteral(target.position, m.owner)
            else
                return target->(InstanceContext).selfParam
        }
        else
            return target
    }

    method call(position:Position, target:Value, 
            methods:ListView<MethodStub>, var params:ListView<Value>):Value? {
        if params.length > 0 {
            def last := params[params.length - 1]
            if last-?>(UnresolvedRange) {
                def range := last->(UnresolvedRange)
                def left := range.left
                if isListView(left) & range.right = null {
                    assert left != null
                    def newParams := new Array<Value>()
                    newParams.addAll(params[0 .. params.length - 1])
                    newParams.add(new Unwrap(left))
                    params := newParams
                }
            }
        }
        var maxCost := Int.MAX
        var max:MethodStub? := null
        for m in methods {
            def cost := matchCost(getEffectiveTarget(m, target), m, params)
            if cost != null & cost < maxCost {
                maxCost := cost
                max := m
            }
        }
        if max != null
            return call(position, getEffectiveTarget(max, target), max, params)
        else {
            def types := new Array<String>()
            for p in params
                types.add(p.type.displayName)
            errors.error("no match for \{methods[0].owner.name}." +
                    "\{methods[0].name}(\{types.join(', ')})", position)
            return null
        }
   }
}