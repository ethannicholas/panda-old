package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.stubs.UntypedClassStub
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

class StubMap : Immutable (MessageProcessor) {
    @private
    constant ALL_STUBS := "allStubs"

    @private
    constant GET := "get"

    @private
    def queue := new MessageQueue()

    @private
    def typeMap:TypeMap

    @private
    @thread
    var masterMap:Map<String, TypedClassStub>?

    constructor(typeMap:TypeMap) {
        self.typeMap := typeMap
        Thread.start(method() {
            def map := new HashMap<String, TypedClassStub>()
            StubMap.masterMap := map
            loop {
                def message := queue.getMessage()
                if message-?>(TypedClassStub) {
                    def stub := message->(TypedClassStub)
                    map[stub.name] := stub
                }
                else if message-?>((String, MessageQueue)) {
                    def command, replyTo := message->((String, MessageQueue))
                    assert command = ALL_STUBS
                    replyTo.post(new ImmutableHashMap<String, TypedClassStub>(
                            map))
                }
                else {
                    def command, parameter, replyTo := 
                            message->((String, String, MessageQueue))
                    assert command = GET
                    replyTo.post(getOrCreateStub(parameter, map))
                }
            }
        }, false)
    }

    @private
    method getOrCreateStub(name:String, rawStubs:Map<String, TypedClassStub>):
            TypedClassStub? {
        var stub := rawStubs[name]
        if stub = null {
            stub := createStub(typeMap, name, rawStubs)
            if stub != null {
                assert stub.name = name
                rawStubs[stub.name] := stub
            }
        }
        return stub
    }

    @private
    method inferFieldTypes(cl:TypedClassStub):TypedClassStub {
        if cl.fullyResolved
            return cl
        def result:TypedClassStub
        def remaining:Bit
        var messages:ListView<Message>?
        def progress:Bit
        result, progress, remaining, messages := new TypeResolver(typeMap, 
                self).inferFieldTypes(cl)
        if remaining {
            def fields := new MutableString()
            def filter := f:FieldNode => f.type-?>(UnresolvedType)
            for f in result.fields.filter(filter) {
                fields.append("\n    ")
                fields.append("\{f.name}:\{f.position}")
            }
            messages := addMessage(messages, "unable to infer field " +
                    "types in '\{cl.name}', possibly due to a circular " +
                    "dependency involving:\{fields}", result.position)
            assert messages != null
            -- this shouldn't actually happen; we should be detecting
            -- circular dependencies in the base generic class prior to
            -- handling particular instances of it, but let's play it safe
            throw new CompilerException(messages)
        }
        assert result.fullyResolved
        return result

    }

    @private
    method createStub(typeMap:TypeMap, name:String, 
            rawStubs:Map<String, TypedClassStub>):TypedClassStub? {
        -- we have to be careful here; the createStub methods can't end up 
        -- calling getStub, or we'll hang
        def type, _ := typeMap.getType(new PandaParser().parseType(name,
                Position.INTERNAL), null)
        if type = null
            return null
        if type-?>(PrimitiveArrayType) {
            def array := type->(PrimitiveArrayType)
            if array.elementType-?>(GenericParameterType)
                return null
            def elementStub := getOrCreateStub(array.elementType.name, rawStubs)
            return array.createStub(elementStub)
        }
        else if type-?>(GenericType) {
            def generic := type->(GenericType)
            def baseStub := getOrCreateStub(generic.base.name, rawStubs)
            assert baseStub != null : "no stub for \{generic.base}"
            def parameterStubs := new Array<TypedClassStub?>()
            for p in generic.parameters
                parameterStubs.add(getOrCreateStub(p.name, rawStubs))
            def stub, _ := type->(GenericType).createStub(typeMap, baseStub,
                    parameterStubs)
            return stub
        }
        return null
    }

    @self
    @pre(!name.startsWith("<"))
    method getStub(name:String):TypedClassStub? {
        def map := masterMap
        if map != null
            return getOrCreateStub(name, map)
        def replyTo := Thread.currentThread().queue
        queue.post((GET, name, replyTo))
        return replyTo.getMessage()->(TypedClassStub?)
    }

    method allStubs():ImmutableHashMap<String, TypedClassStub> {
        def replyTo := Thread.currentThread().queue
        queue.post((ALL_STUBS, replyTo))
        return replyTo.getMessage()->(ImmutableHashMap<String, TypedClassStub>)
    }

    @self
    method putStub(stub:TypedClassStub) {
        queue.post(stub)
    }
 }
