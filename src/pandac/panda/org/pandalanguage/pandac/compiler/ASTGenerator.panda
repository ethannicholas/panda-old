package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.TypeMap
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.parser.ParseNodeType
uses org.pandalanguage.pandac.parser.Token
uses org.pandalanguage.pandac.parser.TokenNode
uses org.pandalanguage.pandac.parser.TokenType
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.stubs.TypedFormalParameter
uses org.pandalanguage.pandac.stubs.TypedMethodStub
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Divide
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.Equal
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.ForEach
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodCallStatement
uses org.pandalanguage.pandac.tree.MethodCallValue
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewPrimitiveArray
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexValue
uses org.pandalanguage.pandac.tree.PrimitiveArrayIndexAssignment
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedIndex
uses org.pandalanguage.pandac.tree.UnresolvedLambda
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedSlice
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.RealLiteralType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.UnresolvedTypeException
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class Context : Immutable {
    def currentClass:TypedClassStub?

    def currentMethod:TypedMethodStub?

    def lookupContext:LookupContext

    def typeMap:TypeMap

    def stubs:StubMap

    def localVariables:ImmutableArray<LocalVariable>

    def visibleVariables:ImmutableHashMap<String, Variable>

    constructor(currentClass:TypedClassStub?, currentMethod:TypedMethodStub?,
            lookupContext:LookupContext, typeMap:TypeMap, stubs:StubMap,
            localVariables:ImmutableArray<LocalVariable>,
            visibleVariables:ImmutableHashMap<String, Variable>) {
        self.currentClass := currentClass
        self.currentMethod := currentMethod
        self.lookupContext := lookupContext
        self.typeMap := typeMap
        self.stubs := stubs
        self.localVariables := localVariables
        self.visibleVariables := visibleVariables
    }

    function isInstance():Bit {
        return currentMethod != null & !currentMethod.annotations.isClass
    }

    function getVariable(name:String):Variable? {
        var result := visibleVariables[name]
        if result != null
            return result
        if currentClass != null 
            return currentClass.getField(self, name)
        return null
    }

    @private
    constant VARARG_COST := 1

    constant CONVERT_COST := 10

    function matchCost(m:TypedMethodStub, params:ListView<Value>):Int? {
        if m.methodType = MethodNodeType.CONSTRUCTOR & params.length > 0 &
                m.parameters[0].type != params[0].type {
            -- constructor called on mismatched type means we're in a subclass,
            -- and since constructors are not inherited we need to ignore it
            return null
        }
        var result := 0
        var methodParams:ListView<TypedFormalParameter> := m.parameters
        var isVarArg := methodParams.length > 0 & 
                methodParams[methodParams.length - 1].isVarArg
        if isVarArg
            result += VARARG_COST
        if params.length > 0 & params[params.length - 1]-?>(Unwrap) {
            -- we handle unwrap parameters (such as the call foo(bar, baz...))
            -- by simply turning off varargs; the last parameter is already an
            -- array and we just let it be treated as such
            isVarArg := false
        }
        if isVarArg {
            -- strip off vararg parameter, it's not required
            methodParams := m.parameters[..m.parameters.length - 1]
        }
        -- do we have the right number of parameters?
        if !isVarArg & params.length != methodParams.length | 
                isVarArg & params.length < methodParams.length
            return null

        for i, param in methodParams {
            if i = 0 & !m.annotations.isClass
                continue
            def targetType := param.type
            def cost := params[i].implicitCastCost(self, targetType)
            if cost = null {
                if methodParams[i].isConvert & 
                        params[i].canConvertTo(self, targetType)
                    result += CONVERT_COST
                else
                    return null
            }
            else
                result += cost
        }
        
        if isVarArg {
            -- verify that all remaining parameters match the vararg
            def varArg := m.parameters[m.parameters.length - 1]
            def varArgType := varArg.type->>(PrimitiveArrayType).elementType
            for i in methodParams.length .. params.length {
                def cost := params[i].implicitCastCost(self, varArgType)
                if cost = null {
                    if varArg.isConvert & 
                            params[i].canConvertTo(self, varArgType)
                        result += CONVERT_COST
                    else
                        return null
                }
                else
                    result += cost
            }
        }
        return result
    }

    function getMethodsNamed(name:String, searchClass:TypedClassStub):
            CollectionView<TypedMethodStub> {
        def result := new Array<TypedMethodStub>()
        def superclass := searchClass.superclass
        if superclass != null
            result.addAll(getMethodsNamed(name, getStub(superclass)))
        for intf in searchClass.interfaces
            result.addAll(getMethodsNamed(name, getStub(intf)))
        result.addAll(searchClass.methods.filter(m => m.name = name))
        return result
    }

    ============================================================================
    Finds the best match for the given method.

    @param contextValue the object the method is being called on, or `null` if
            it is a bare method name
    @param name the name of the method
    @param params the method parameters
    ============================================================================
    function getMethod(contextValue:Value?, name:String, 
            params:ListView<Value>):TypedMethodStub? {
        def searchClass:TypedClassStub
        def classMethod:Bit?
        if contextValue != null {
            if contextValue-?>(ClassLiteral) {
                searchClass := getStub(contextValue->(ClassLiteral).value)
                classMethod := true
            }
            else if contextValue-?>(Super) {
                def cc := currentClass
                if cc = null
                    return null
                searchClass := getStub(cc.superclass->(ClassType))
                classMethod := false
            }
            else {
                classMethod := false
                searchClass := getStub(contextValue.type->>(ClassType))
            }
        }
        else {
            searchClass := currentClass->(TypedClassStub)
            classMethod := null
        }
        def methods:CollectionView<TypedMethodStub>
        if classMethod = true {
            methods := getMethodsNamed(name, searchClass).filter
                    (m => m.annotations.isClass | 
                    m.methodType = MethodNodeType.CONSTRUCTOR)
        }
        else if classMethod = false {
            methods := getMethodsNamed(name, searchClass).filter
                    (m => !m.annotations.isClass)
        }
        else
            methods := getMethodsNamed(name, searchClass)
        var maxCost := Int.MAX
        var max:TypedMethodStub? := null
        for m in methods {
            def cost := matchCost(m, params)
            if cost != null & cost < maxCost {
                maxCost := cost
                max := m
            }
        }
        return max
    }

    @pre(currentClass != null)
    method currentClassType():ClassType {
        return getType(currentClass->(TypedClassStub))
    }

    @pre(isInstance)
    function getSelf(position:Position):Value {
        def selfVar := visibleVariables[Parameter.SELF_NAME]
        assert selfVar != null : "no self at \{position}"
        return new VariableReference(position, selfVar)
    }

    method getWrapper(t:PrimitiveType):WrapperType {
        return getRequiredType(t.name + "Wrapper")->(WrapperType)
    }

    @unsafeFunction
    function getStub(t:ClassType):TypedClassStub {
        var result := stubs.getStub(t.name)
        if result = null {
            Panda.log("no stub for \{t.name}")
            result := getStub(ClassType.OBJECT)
        }
        return result
    }

    @pre(currentClass != null)
    method getType(cl:TypedClassStub):ClassType {
        return getRequiredType(cl.name)->(ClassType)
    }

    @pre(t.type = ParseNodeType.TYPE)
    method getType(t:ParseNode):(Type?, ListView<Message>?) {
        return typeMap.getType(t, lookupContext)
    }

    method getType(name:String, position:Position):
            (Type?, ListView<Message>?) {
        try {
            def node := new PandaParser().parseType(name, position)
            return typeMap.getType(node, lookupContext)
        }
        catch e:CompilerException {
            def messages := new Array<Message>()
            messages.add(new Message(e.message, position))
            return (null, messages)
        }
    }

    method getRequiredType(name:String):Type {
        def node := new PandaParser().parseType(name, Position.INTERNAL)
        def result, messages := typeMap.getType(node, lookupContext)
        if result = null {
            assert messages != null
            throw new InternalCompilerException(messages.join("\n"))
        }
        return result
    }

    function +(v:Variable):Context {
        def newVisibleVariables := new HashMap<String, Variable>(
                visibleVariables)
        newVisibleVariables[v.name] := v
        def newLocalVariables:ImmutableArray<LocalVariable>
        if v-?>(LocalVariable) {
            def temp := new Array<LocalVariable>(localVariables)
            temp.add(v->(LocalVariable))
            newLocalVariables := new ImmutableArray<LocalVariable>(temp)
        }
        else
            newLocalVariables := localVariables
        return new Context(currentClass, currentMethod, lookupContext, typeMap,
                stubs, newLocalVariables, 
                new ImmutableHashMap<String, Variable>(newVisibleVariables))
    }

    function +(variables:ListView<Variable>):Context {
        def newVisibleVariables := new HashMap<String, Variable>(
                visibleVariables)
        for v in variables
            newVisibleVariables[v.name] := v
        def newLocalVariables := new Array<LocalVariable>(localVariables)
        for v in variables {
            if v-?>(LocalVariable)
                newLocalVariables.add(v->(LocalVariable))
        }
        return new Context(currentClass, currentMethod, lookupContext, typeMap,
                stubs, new ImmutableArray<LocalVariable>(newLocalVariables), 
                new ImmutableHashMap<String, Variable>(newVisibleVariables))
    }

    function addLocalsFrom(other:Context):Context {
        def newLocals := new Array<LocalVariable>(localVariables)
        newLocals.addAll(other.localVariables)
        return new Context(currentClass, currentMethod, lookupContext, typeMap,
                stubs, new ImmutableArray<LocalVariable>(newLocals), 
                visibleVariables)
    }
}

================================================================================
A placeholder object which stands in for a `Value`, generally so we can perform
method lookup without having to have actual correct `Value`s.
================================================================================
class Dummy : Value {
    constructor(position:Position, type:Type) {
        super.constructor(position, type)
    }

    @override
    function format(fmt:String):String {
        return "Dummy<\{type.displayName}>"
    }
}

================================================================================
A reference to a field which could, depending on context, also refer to a no-arg
function of the same name.
================================================================================
@private
class AmbiguousReference : Value {
    def contextValue:Value
    def field:FieldNode

    constructor(position:Position, contextValue:Value, field:FieldNode) {
        super.constructor(position, new UnresolvedType(field.name, position))
        self.contextValue := contextValue
        self.field := field
    }
}

================================================================================
Represents an element of a shared tuple, for initializing several fields from 
the same value.
================================================================================
@private
class TupleReference {
    var tuple:ParseNode
    var element:Int

    constructor(tuple:ParseNode, element:Int) {
        self.tuple := tuple
        self.element := element
    }
}

================================================================================
Used to represent something that looks like an array index (foo[bar]) but can't
actually be resolved into something meaningful. We do this because if the next
token we run into is a ":=", the expression could still resolve into an indexed
assignment.
================================================================================
@private
class PossibleIndexedAssignment : Value {
    def contextValue:Value
    def index:Value

    constructor(position:Position, contextValue:Value, index:Value) {
        super.constructor(position, new UnresolvedType("<index>", position))
        self.contextValue := contextValue
        self.index := index
    }
}

================================================================================
Used to represent something that looks like an slice (foo[bar .. baz]) but can't
actually be resolved into something meaningful. We do this because if the next
token we run into is a ":=", the expression could still resolve into a slice
assignment.
================================================================================
@private
class PossibleSliceAssignment : Value {
    def contextValue:Value
    def left:Value
    def right:Value
    def step:Value
    def endInclusive:Bit

    constructor(position:Position, contextValue:Value, left:Value, right:Value,
            step:Value, endInclusive:Bit) {
        super.constructor(position, new UnresolvedType("<slice>", position))
        self.contextValue := contextValue
        self.left := left
        self.right := right
        self.step := step
        self.endInclusive := endInclusive
    }
}

================================================================================
Converts typed stubs into AST nodes.
================================================================================
class ASTGenerator : Immutable (MessageProcessor) {
    constant INDEX_SUFFIX := "$index"

    constant AUTO_PREFIX := "$auto_"

    constant SHIM_PREFIX := "$shim_"

    constant STRING_GROUP := #/(?<!\\)\\\{.*?(?<!\\)\}/#

    constant UNESCAPED_BRACE := #/(?<!\\)\{/#

    constructor() {
    }

    -- FIXME switch to built-in string parser when it exists
    @pre(base >= 2 & base <= 36)
    function parseInt(s:String, base:UInt):UInt64? {
        var result:UInt64 := 0
        constant DIGITS := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        constant DIGITS_LOWER := "0123456789abcdefghijklmnopqrstuvwxyz"
        for i in 0 .. s.length {
            var digit := DIGITS.indexOf(s[i])->(UInt?)
            if digit = null
                digit := DIGITS_LOWER.indexOf(s[i])->(UInt?)
            if digit = null | digit >= base
                return null
            result := result * base + digit
        }
        return result
    }
    
    @pre(t.type = TokenType.NUMBER)
    method parseNumericLiteral(context:Context, t:Token):
            (Value, ListView<Message>?) {
        def value:UInt64?
        if t.text.startsWith("0x") | t.text.startsWith("0X")
            value := parseInt(t.text[2..], 16)
        else if t.text.startsWith("0b") | t.text.startsWith("0B")
            value := parseInt(t.text[2..], 2)
        else
            value := t.text->>(UInt64?)
        if value != null
            return (new IntegerLiteral(t.position, value), null)
        else {
            def real := t.text->>(Real64?)
            if real != null
                return (new RealLiteral(t.position, real), null)
            else {
                return (new IntegerLiteral(t.position, 0), 
                        wrap(new Message("invalid numeric literal", t.position)))
            }
        }
    }

    ============================================================================
    Given a sequence of chars from a string literal (e.g. "Hello\n!"), returns a
    string representing the contents of the literal (e.g. "Hello<newline>!")

    If `interpolating` is true, permits the additional escape sequences `\:`,
    `\{`, and `\}`, passing them through unmodified.
    ============================================================================
    method convertStringChars(position:Position, s:String, 
            interpolating:Bit):(String?, ListView<Message>?) {
        var result := new MutableString()
        var i := 0
        loop {
            var next := s.indexOf("\\", i)
            if next = null {
                result.append(s[i..])
                break
            }
            result.append(s[i .. next])
            var c := s[next + 1]
            switch c {
                case "n":  result.append("\n")
                case "r":  result.append("\r")
                case "t":  result.append("\t")
                case '"':  result.append('"')
                case "\\": {
                    result.append("\\")
                    if interpolating
                        result.append("\\")
                }
                case "'":  result.append("'")
                case ":", "{", "}": {
                    if interpolating {
                        result.append("\\")
                        result.append(c)
                    }
                    else {
                        return (null, wrap(new Message("invalid string escape " +
                                "'\\" + c + "'", 
                                new Position(position.compilationUnit, 
                                    position.line, position.column + i))))
                    }
                }
                default: 
                    return (null, wrap(new Message("invalid string escape '\\" + c + 
                            "'", new Position(position.compilationUnit, 
                                position.line, position.column + i))))
            }
            i := next + 2
        }
        return (result->>(String), null)
    }

    @pre(t.type = TokenType.STRING)
    method parseStringLiteral(context:Context, t:Token):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var s := t.text[1 .. t.text.length - 1]
        def result := new MutableString()
        def matcher := STRING_GROUP.matcher(s)
        def values := new Array<Value>()
        var lastEnd := 0
        while matcher.find() {
            var chars, submessages := convertStringChars(t.position,
                    s[lastEnd .. matcher.start], false)
            messages := addMessages(messages, submessages)
            if chars != null {
                result.append(chars.replace(UNESCAPED_BRACE, 
                        "\\{"))
            }
            def text := s[matcher.start + 2 .. matcher.end - 1]
            var expr, remaining := new PandaParser().parseExpressionWithExtraText(
                    text, t.position)
            def value:Value?
            value, submessages := convertExpression(context, expr)
            messages := addMessages(messages, submessages)
            if value = null
                return (null, messages)
            values.add(value)
            def token:String?
            token, submessages := convertStringChars(t.position, remaining, 
                    true)
            messages := addMessages(messages, submessages)
            if token != null
                result.append("{\{token}}")
            lastEnd := matcher.end()
        }
        if lastEnd > 0 {
            def chars, submessages := convertStringChars(t.position,
                    s[lastEnd..], false)
            messages := addMessages(messages, submessages)
            if chars != null
                result.append(chars.replace(UNESCAPED_BRACE, "\\{"))
            s := result->>(String)
            values.insert(0, new StringLiteral(t.position, s))
            return call(context, t.position, new ClassLiteral(t.position, 
                    ClassType.STRING), "format", values)
        }
        else {
            def chars, submessages := convertStringChars(t.position, s, false)
            messages := addMessages(messages, submessages)
            if chars = null
                return (null, messages)
            return (new StringLiteral(t.position, chars), messages)
        }
    }

    method isAccessible(context:Context, f:FieldNode):Bit {
        return true
    -*
        var cl := currentClass
        assert cl != null
        if cl.type()-?>(GenericType) {
            -- we've already performed access checks for the unspecified version
            -- of this class, and the specified version could be (legally) 
            -- accessing private members of the unspecified version
            return true
        }
        def a := f.annotations
        if a.isPrivate {
            while cl.containingClass != null
                cl := cl.containingClass->(ClassNode)
            def targetClass := f.owner
            def c1 := cl.parent
            def c2 := targetClass.parent
            return c1 = c2
        }
        else if a.isProtected {
            def cm := currentMethod
            assert cm != null
            var caller := cm.parent->(ClassNode?)
            while caller != null & caller.containingClass != null
                caller := caller.containingClass
            var callee := f.parent->(ClassNode)
            while caller != null {
                if caller = callee
                    return true
                caller := caller.superclass
            }
            return false
        }
        return true*-
    }

    @private
    method createFieldReference(context:Context, position:Position, 
            var contextValue:Value, f:FieldNode, 
            allowNoArgFunctions:Bit):Value {
        def annotations := f.annotations
        if allowNoArgFunctions {
            def name := f.name
            def unresolved := new Unresolved(position, contextValue, name)
            def noArg := resolveNoArgFunction(context, unresolved)
            if noArg != null
                return new AmbiguousReference(position, contextValue, f)
        }
        def result := new FieldReference(position, contextValue, f)
        return result
    }

    method getField(context:Context, position:Position, var contextValue:Value,
            var name:String):(Value?, ListView<Message>?) {
        return getField(context, position, contextValue, name, true)
    }

    method getField(context:Context, position:Position, var contextValue:Value,
            var name:String, allowNoArgFunctions:Bit):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        if name = "class"
            name := "$class"
        var cl:TypedClassStub
        if contextValue.type = StringOrCharType.STRING_OR_CHAR {
            def submessages:ListView<Message>?
            contextValue, submessages := contextValue.implicitCast(position, 
                    context, CharType.CHAR)
        }
        if contextValue-!>(Super) {
            var submessages:ListView<Message>?
            def nextValue:Value?
            nextValue, submessages := resolveUnresolvedConstructs(context, 
                    contextValue)
            messages := addMessages(messages, submessages)
            if nextValue = null
                return (null, messages)
            contextValue := nextValue
            if contextValue.type.isPrimitive {
                def casted:Value?
                casted, submessages := contextValue.implicitCast(position, 
                            context,
                            context.getWrapper(contextValue.type->>(PrimitiveType)))
                messages := addMessages(messages, submessages)
                if casted = null
                    return (null, messages)
                return getField(context, position, casted, name, 
                        allowNoArgFunctions)
            }
            else {
                var contextValueClass := context.getStub(
                        contextValue.type->>(ClassType))
                cl := contextValueClass
            }
            if contextValue-!>(ClassLiteral) {
                def fields := cl.instanceFields(context.stubs)
                -- need to search backwards since ancestor classes are at the
                -- beginning of the array, and we may be shadowing fields
                for i in fields.length - 1  ... 0 by -1 {
                    def f := fields[i]
                    if f.name = name & !f.annotations.isClass &
                            !f.annotations.isThread & isAccessible(context, f) {
                        if contextValue-?>(UnresolvedClassLiteral) {
                            contextValue := new ClassObjectLiteral(
                                    contextValue.position,
                                    contextValue->(UnresolvedClassLiteral).value)
                        }
                        return (createFieldReference(context, position, 
                                contextValue, f, allowNoArgFunctions), messages)
                    }
                }
            }
            if contextValue-?>(UnresolvedClassLiteral) {
                contextValue := new ClassLiteral(contextValue.position,
                        contextValue->(UnresolvedClassLiteral).value)
            }
            if contextValue-?>(ClassLiteral) {
                var type := contextValue->(ClassLiteral).value
                if type.isPrimitive
                    type := context.getWrapper(type->>(PrimitiveType))
                cl := context.getStub(type->>(ClassType))
                for f in cl.fields {
                    if f.name = name & (f.annotations.isClass |
                            f.annotations.isThread) &
                            isAccessible(context, f) {
                        return (createFieldReference(context, position, 
                                contextValue, f, allowNoArgFunctions), messages)
                    }
                }
            }
        }
        return (new Unresolved(position, contextValue, name), messages)
    }

    @pre(e.type = ParseNodeType.TERM)
    method convertTerm(context:Context, e:ParseNode):(Value?, ListView<Message>?) {
        switch e[0].type {
            case ParseNodeType.TOKEN: {
                switch e[0]->(TokenNode).token.type {
                    case TokenType.STRING: {
                        return parseStringLiteral(context, 
                                e[0]->(TokenNode).token)
                    }
                    case TokenType.NUMBER: {
                        def value, messages := parseNumericLiteral(context, 
                                e[0]->(TokenNode).token)
                        return (value, messages)
                    }
                    case TokenType.TRUE:
                        return (new BitLiteral(e[0].position, 
                                e[0]->(TokenNode).token->>(String)->>(Bit)), 
                                null)
                    case TokenType.FALSE:
                        return (new BitLiteral(e[0].position, 
                                e[0]->(TokenNode).token->>(String)->>(Bit)),
                                null)
                    case TokenType.NULL:
                        return (new NullLiteral(e[0].position), null)
                    case TokenType.IDENTIFIER, TokenType.SELF:
                        if e.length = 1
                            return parseBareIdentifier(context, e[0])
                        else
--                            return convertLambda(context, e)
                            throw new NotSupportedException("lambda")
                    case TokenType.CLASS:
                        return parseBareIdentifier(context, e[0])
                    case TokenType.LPAREN: {
                        if e[2]->(TokenNode).token.type = TokenType.COMMA
                            return convertTuple(context, e)
                        assert e[2]->(TokenNode).token.type = TokenType.RPAREN
                        return convertExpression(context, e[1])
                    }
                    case TokenType.PLUGIN: 
                        --return convertPlugin(context, e[0].position, e[0]->>(String))
                        throw new NotSupportedException("plugin")
                    case TokenType.SUPER: 
                        return (new Super(e[0].position), null)
                    case TokenType.ATRETURN: {
-*                        def returnValue := self.returnValue
                        if returnValue != null
                            return returnValue.createReference()
                        else {
                            return (null, wrap(new Message("@return may only " +
                                    "appear within @post(...) in methods " +
                                    "which return a value", e[0].position)))
                        } *-
                        throw new NotSupportedException("@return")
                    }
                    case TokenType.PRE: {
-*                        if !inPostcondition {
                            return (null, wrap(new Message("@pre(...) " +
                                    "expressions may only appear " +
                                    "within @post(...)", e.position)))
                        }
                        assert e[1]->(TokenNode).token.type = TokenType.LPAREN
                        var expr := convertExpression(context, e[2])
                        var cm := currentMethod
                        assert cm != null
                        var mainBlock := cm.block
                        -- add a dummy object, will replace it as we slide other
                        -- nodes down
                        mainBlock.children.append(new Dummy(VoidType.VOID))
                        for i in mainBlock.length - 1 ... 1 by -1
                            mainBlock[i] := mainBlock[i - 1]
                        var statement := new ValueStatement(e.position, expr)
                        mainBlock[0] := statement
                        statement.parent := mainBlock
                        assert e[3]->(TokenNode).token.type = TokenType.RPAREN
                        def reused := makeReusable(expr)
                        return reused.createReference() *-
                        throw new NotSupportedException("@pre")
                    }
                    default: throw new CompilerException(
                                "unsupported term: '\{e[0]->(TokenNode).token}'", 
                                e[0].position)
                }
            }
            case ParseNodeType.CLASS_LITERAL: {
                def literal := e[0]
                assert literal[0]->(TokenNode).token.type = TokenType.CLASS
                assert literal[1]->(TokenNode).token.type = TokenType.LPAREN
                assert literal[2].type = ParseNodeType.TYPE
                assert literal[3]->(TokenNode).token.type = TokenType.RPAREN
                def type, messages := context.getType(literal[2])
                if type != null {
                    return (new ClassObjectLiteral(literal.position, type), 
                            messages)
                }
                else
                    return (null, messages)
            }
            case ParseNodeType.CONSTRUCT:
                return convertConstruct(context, e[0])
--            case ParseNodeType.ARRAY_LITERAL:
--                return convertPrimitiveArrayLiteral(context, e[0])
--            case ParseNodeType.METHOD_VALUE:
--                return convertMethodValue(context, e[0])
-*            case ParseNodeType.TYPE: {
                var typeName := e[0]->>(String).replace(#/\s+/#, "")
                var type := getType(e[0].position, typeName)
                return new UnresolvedClassLiteral(e[0].position, type)
            }*-
--            case ParseNodeType.LAMBDA:
--                return convertLambda(context, e[0])
            default: throw new CompilerException(
                    "unsupported term: '\{e[0].type}'", 
                    e.position)
        }
    }

    @pre(e.type = ParseNodeType.CALL_EXPRESSION)
    method convertCallExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var value, submessages := convertTerm(context, e[0])
        messages := addMessages(messages, submessages)
        if value = null
            return (null, messages)
        if e.length > 1 {
            def statement:Statement?
            value, statement, submessages := processCallOrAssignment(context, 
                    value, e)
            assert statement = null
            messages := addMessages(messages, submessages)
            if value = null
                return (null, submessages)
        }
        return resolve(context, value)
    }

    @pre(e.type = ParseNodeType.EXPONENT_EXPRESSION)
    method convertExponentExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var left, leftMessages := convertCallExpression(context, e[0])
        messages := addMessages(messages, leftMessages)
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i]->(TokenNode).token.type = TokenType.POW
            def right, rightMessages := convertCallExpression(context, e[i + 1])
            messages := addMessages(messages, rightMessages)
            if right = null
                return (null, messages)
            left, leftMessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, leftMessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }

    @pre(e.type = ParseNodeType.UNARY_EXPRESSION)
    method convertUnaryExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var exp, submessages := convertExponentExpression(context, 
                e[e.length - 1])
        messages := addMessages(messages, submessages)
        if exp = null
            return (null, messages)
        if e[0].type = ParseNodeType.UNARY_OPERATOR {
            def op := e[0][0]->(TokenNode).token.type
            switch op {
                case TokenType.SUB: {
                    if exp-?>(RealLiteral) {
                        exp := new RealLiteral(exp.position, 
                                -(exp->(RealLiteral).value))
                    }
                    else {
                        if exp.type.isWrapper {
                            exp, submessages := exp.implicitCast(
                                    context, exp.type->>(PrimitiveType))
                            messages := addMessages(messages, submessages)
                        }
                        if exp.type.isNumber {
                            exp := new UnaryOperation(e.position, 
                                    UnaryOperationType.MINUS, exp)
                        }
                        else {
                            return (null, wrap(new Message("expected a number, " +
                                    "but found '\{exp.type.displayName}'", e.position)))
                        }
                    }
                }
                case TokenType.NOT: {
                    exp, submessages := exp.implicitCast(context, BitType.BIT)
                    messages := addMessages(messages, submessages)
                    exp := new UnaryOperation(e.position, UnaryOperationType.NOT,
                            exp)
                }
                case TokenType.BITWISENOT: {
                    if exp.type.isWrapper {
                        exp, submessages := exp.implicitCast(context,
                                exp.type->>(PrimitiveType))
                        messages := addMessages(messages, submessages)
                    }
                    if exp.type.isInteger {
                        if exp.type->>(PrimitiveType).size < 4 {
                            if exp.type->(IntType).signed {
                                exp, submessages := 
                                        exp.implicitCast(context,
                                                IntType.INT32)
                            }
                            else {
                                exp, submessages := 
                                        exp.implicitCast(context, 
                                            IntType.UINT32)
                            }
                            messages := addMessages(messages, submessages)
                        }
                        exp := new UnaryOperation(e.position, 
                                UnaryOperationType.BITWISE_NOT, exp)
                    }
                    else {
                        return (null, wrap(new Message("expected an integer, " +
                                "but found '\{exp.type.displayName}'", 
                                e.position)))
                    }
                }
                default: {
                    throw new InternalCompilerException("unknown unary " +
                            "operator: '\{op}'", e.position)
                }
            }
        }
        return (exp, messages)
    }

    ============================================================================
    As implicitCast, but with the ability to toggle whether we care about 
    signedness. If `signMatters` is false, the signedness is not considered
    important and will not stop a cast that would normally not be allowed.

    Note that the source and destination types are not necessarily integers; if
    not, we ignore the signMatters flag altogether and just perform a normal
    implicitCast.
    ============================================================================
    @private
    method signMattersCast(context:Context, position:Position, v:Value, t:Type, 
            signMatters:Bit):(Value, ListView<Message>?) {
        if !signMatters {
            def srcType := v.type->>(PrimitiveType)
            if srcType.isInteger & t.isInteger & 
                    srcType->(IntType).signed != t->(IntType).signed & 
                    srcType->>(PrimitiveType).size <= t->>(PrimitiveType).size {
                return v.explicitCast(context, t)
            }
        }
        return v.implicitCast(context, t)
    }
    
    ============================================================================
    Looks for an overloaded version of `name` (which could be `"="`, `"+"`, 
    etc.) and returns a call to it, or `null` if no such overloaded operator was
    found.
    
    @param position the position of the call in the source code
    @param name the name of the method to call
    @param left the left argument
    @param right the right argument
    @returns a method call, or `null`
    ============================================================================
    method callOverloadedOperator(context:Context, position:Position, 
            var name:String, var left:Value, var right:Value):Value? {
        var messages:ListView<Message>? := null
        def newLeft:Value?
        newLeft, messages := resolveUnresolvedConstructs(context, left)
        if newLeft = null
            return null
        left := newLeft
        def newRight:Value?
        newRight, messages := resolveUnresolvedConstructs(context, right)
        if newRight = null
            return null
        right := newRight
        -- avoid calling the various "fake" operators we define in the wrapper
        -- classes
        if name = "=" | name = "!=" {
            if left.type.isPrimitive & right.type.isPrimitive
                return null
        }
        else if !name.startsWith("[") & (left.type.isNumber | 
                left.type.isWrapper) & (right.type.isNumber | 
                right.type.isWrapper)
            return null
        if left.type = NullType.NULL | right.type = NullType.NULL
            return null -- force this to be compiled as ==, which is quicker 
                        -- than calling nullableEquals.
        if name != "=" {
            if left.type = StringOrCharType.STRING_OR_CHAR {
                def cast:Value?
                cast, messages := left.implicitCast(context, 
                        ClassType.STRING)
                assert messages = null : messages->>(String)
                return callOverloadedOperator(context, position, name, cast, 
                        right)
            }
            if right.type = StringOrCharType.STRING_OR_CHAR {
                def cast:Value?
                cast, messages := right.implicitCast(context, 
                        ClassType.STRING)
                assert messages = null : messages->>(String)
                return callOverloadedOperator(context, position, name, left, 
                        cast)
            }
        }

        def rawName := name
        -- map != and !== to = and ==. We'll invert the answer on return.
        if name.startsWith("!")
            name := name[1..]
        var result:Value? := null
        def parameters := new Array<Value>()
        parameters.add(left)
        parameters.add(right)
        if name = "=" & (left.type.isNullable | right.type.isNullable) {
            -- for equality, if one or both parameters are null, we need to
            -- funnel this through Panda.nullableEquals
            result, messages := call(context, position, new ClassLiteral(
                    position, ClassType.PANDA), "nullableEquals", parameters)
            assert result != null : "failed to call nullableEquals: \{messages}"
        }
        -- we can safely ignore the error messages, as it is ok to not find an
        -- overload
        if result = null {
            -- check for overload on left (both instance & class)
            def rightParam := new Array<Value>()
            rightParam.add(right)
            var ignored:ListView<Message>?
            result, ignored := call(context, position, left, name, rightParam)
            if result = null {
                result, ignored := call(context, position, new ClassLiteral(
                        position, left.type->>(ClassType)), name, parameters)
            }
        }
        if result = null {
            -- check for overload on right (class only)
            parameters.clear()
            parameters.add(right)
            parameters.add(left)
            def ignored:ListView<Message>?
            result, ignored := call(context, position, new ClassLiteral(
                    position, right.type->>(ClassType)), name, parameters)
        }
        if rawName.startsWith("!") & result != null {
            result := new UnaryOperation(position, UnaryOperationType.NOT, 
                    result)
        }
        return result
    }

    ============================================================================
    Returns `<left> <op> <right>`, where `op` is the type of a token 
    representing a binary operator.
    
    @param node the position, for error reporting purposes
    @param left the left operand
    @param op the token type of a binary operator
    @param right the right operand
    ============================================================================
    method getBinaryValue(context:Context, position:Position, var left:Value, 
            op:TokenType, var right:Value):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var methodName:String
        switch op {
            case TokenType.ADD:                  methodName := "+"
            case TokenType.SUB:                  methodName := "-"
            case TokenType.MUL:                  methodName := "*"
            case TokenType.DIV:                  methodName := "/"
            case TokenType.INTDIV:               methodName := "//"
            case TokenType.REM:                  methodName := "%"
            case TokenType.SHIFTLEFT:            methodName := "<<"
            case TokenType.SHIFTRIGHT:           methodName := ">>"
            case TokenType.AND:                  methodName := "&"
            case TokenType.OR:                   methodName := "|"
            case TokenType.XOR:                  methodName := "~"
            case TokenType.BITWISEAND:           methodName := "&&"
            case TokenType.BITWISEOR:            methodName := "||"
            case TokenType.BITWISEXOR:           methodName := "~~"
            case TokenType.POW:                  methodName := "^"
            case TokenType.EQ:                   methodName := "="
            case TokenType.NEQ:                  methodName := "!="
            case TokenType.IDENTITY:             methodName := "=="
            case TokenType.NIDENTITY:            methodName := "!=="
            case TokenType.LT:                   methodName := "<"
            case TokenType.GT:                   methodName := ">"
            case TokenType.LTEQ:                 methodName := "<="
            case TokenType.GTEQ:                 methodName := ">="
            default: throw new CompilerException(
                    "unsupported binary operator '\{op}'",
                    position)
        }
        var submessages:ListView<Message>?
        def newLeft:Value?
        newLeft, submessages := resolveUnresolvedConstructs(context, left)
        messages := addMessages(messages, submessages)
        if newLeft = null
            return (null, messages)
        def newRight:Value?
        newRight, submessages := resolveUnresolvedConstructs(context, right)
        if newRight = null
            return (null, messages)
        right := newRight
        messages := addMessages(messages, submessages)
        var value := callOverloadedOperator(context, position, methodName, left,
                right)
        if value = null {
            def opType:BinaryOperationType
            switch op {
                case TokenType.ADD:        opType := BinaryOperationType.ADD
                case TokenType.SUB:        opType := BinaryOperationType.SUBTRACT
                case TokenType.MUL:        opType := BinaryOperationType.MULTIPLY
                case TokenType.DIV:        opType := BinaryOperationType.DIVIDE
                case TokenType.INTDIV:     opType := BinaryOperationType.INT_DIVIDE
                case TokenType.REM:        opType := BinaryOperationType.REMAINDER
                case TokenType.AND:        opType := BinaryOperationType.AND
                case TokenType.OR:         opType := BinaryOperationType.OR
                case TokenType.XOR:        opType := BinaryOperationType.XOR
                case TokenType.BITWISEAND: opType := BinaryOperationType.BITWISE_AND
                case TokenType.BITWISEOR:  opType := BinaryOperationType.BITWISE_OR
                case TokenType.BITWISEXOR: opType := BinaryOperationType.BITWISE_XOR
                case TokenType.EQ:         opType := BinaryOperationType.EQUAL
                case TokenType.NEQ:        opType := BinaryOperationType.NOT_EQUAL
                case TokenType.IDENTITY:   opType := BinaryOperationType.IDENTITY
                case TokenType.NIDENTITY:  opType := BinaryOperationType.NOT_IDENTITY
                case TokenType.LT:         opType := BinaryOperationType.LESS_THAN
                case TokenType.GT:         opType := BinaryOperationType.GREATER_THAN
                case TokenType.LTEQ:       opType := BinaryOperationType.LESS_THAN_OR_EQUAL
                case TokenType.GTEQ:       opType := BinaryOperationType.GREATER_THAN_OR_EQUAL
                case TokenType.SHIFTLEFT:  opType := BinaryOperationType.SHIFT_LEFT
                case TokenType.SHIFTRIGHT: opType := BinaryOperationType.SHIFT_RIGHT
-*                case TokenType.POW: {
                    def panda := ClassType.PANDA().classNode
                    def params := new PrimitiveArray<Value>(left, right)
                    def exp := panda.symbolTable.getMethod(position, "pow", 
                            params, true)
                    if exp = null {
                        throw new CompilerException(
                                "'^' cannot operate on '\{left.type.displayName}', " +
                                "'\{right.type.displayName}'", position)
                    }
                    return call(position, exp, true, params)
                }*-
                default: throw new InternalCompilerException(position)
            }
            def operandType := BinaryOperation.operandType(context,
                    opType, left, right)
            if operandType = null {
                return (null, wrap(new Message("'\{methodName}' cannot operate on " +
                        "'\{left.type.displayName}', " +
                        "'\{right.type.displayName}'", position)))
            }
            left, submessages := signMattersCast(context, position, left, 
                    operandType, BinaryOperation.signMatters(opType))
            messages := addMessages(messages, submessages)
            right, submessages := signMattersCast(context, position, right, 
                    operandType, BinaryOperation.signMatters(opType))
            messages := addMessages(messages, submessages)
            value := new BinaryOperation(position, opType, left, right)
        }
        return (value, null)
    }

    @pre(e.type = ParseNodeType.MULTIPLICATIVE_EXPRESSION)
    method convertMultiplicativeExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var left, submessages := convertUnaryExpression(context, e[0])
        messages := addMessages(messages, submessages)
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right:Value?
            right, submessages := convertUnaryExpression(context, e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }

    @pre(e.type = ParseNodeType.ADDITIVE_EXPRESSION)
    method convertAdditiveExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var left, submessages := convertMultiplicativeExpression(context, e[0])
        messages := addMessages(messages, submessages)
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            def right:Value?
            right, submessages := convertMultiplicativeExpression(context, 
                    e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }

    @pre(e.type = ParseNodeType.RANGE_EXPRESSION)
    method convertRangeExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var result, submessages := convertAdditiveExpression(context, e[0])
        messages := addMessages(messages, submessages)
        if e.length > 1 {
            def type := e[1]->(TokenNode).token.type
            var right:Value? := null
            var step:Value?  := null
            if e.length > 2 {
                var i := 2
                if e[i].type = ParseNodeType.ADDITIVE_EXPRESSION {
                    right, submessages := convertAdditiveExpression(context, 
                            e[2])
                    messages := addMessages(messages, submessages)
                    if right = null
                        return (null, messages)
                    i += 1
                }
                if e.length > i {
                    assert e[i]->(TokenNode).token.type = TokenType.BY
                    i += 1
                    step, submessages := convertAdditiveExpression(context, 
                            e[i])
                    messages := addMessages(messages, submessages)
                    if right = null
                        return (null, messages)
                }
            }
            result := new UnresolvedRange(e.position, result, right, step, 
                    type = TokenType.ELLIPSIS)
        }
        return (result, messages)
    }

    @pre(e.type = ParseNodeType.COMPARISON_EXPRESSION)
    method convertComparisonExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var left, messages := convertRangeExpression(context, e[0])
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right, submessages := convertRangeExpression(context, e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }

    @pre(e.type = ParseNodeType.AND_EXPRESSION)
    method convertAndExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var left, messages := convertComparisonExpression(context, e[0])
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right, submessages := convertComparisonExpression(context, 
                    e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }
    
    @pre(e.type = ParseNodeType.OR_EXPRESSION)
    method convertOrExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var left, messages := convertAndExpression(context, e[0])
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right, submessages := convertAndExpression(context, e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }
    
    method convertExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        assert e.type = ParseNodeType.EXPRESSION: 
                "expected expression, but found \{e} (\{e.type}): \{e.position}"
        return convertOrExpression(context, e[0])
    }

    method resolveUnresolvedConstructs(context:Context, v:Value):
            (Value?, ListView<Message>?) {
        def error := v.checkValid()
        if error != null {
            -- FIXME simplify this when new array syntax is working
            def result := new Array<Message>()
            result.add(error)
            return (null, result)
        }
        if v-?>(UnresolvedIndex) | v-?>(UnresolvedSlice) {
            def result, messages := v.implicitCast(context, v.type)
            return (result, messages)
        }
        if !v.isResolved {
            def result, messages := v.implicitCast(context, 
                    v.preferredVariableType)
            return (result, messages)
        }
        return (v, null)
    }
    @post(@return[0].isResolved)

    method call(context:Context, position:Position, var m:TypedMethodStub, 
            isSuper:Bit, params:ListView<Value>):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def methodParams := m.parameters
        var isVarArg := methodParams.length > 0 &
                methodParams[methodParams.length - 1].isVarArg
        for i, p in params {
            if p-?>(Unwrap) {
                if !isVarArg {
                    return (null, wrap(new Message("'...' may not be used " +
                            "with non-variadic \{m}", position)))
                }
                if i < params.length - 1 {
                    return (null, wrap(new Message("'...' may only be used " +
                            "with the last parameter of a call", position)))
                }
            }
        }
        if isVarArg & params.length > 0 & params[params.length - 1]-?>(Unwrap)
            isVarArg := false
        def count:Int
        if isVarArg
            count := methodParams.length - 1
        else
            count := methodParams.length
        def finalParams := new Array<Value>()
        for i in 0 .. count {
            def target := m.parameters[i].type
            if params[i].canImplicitCastTo(context, target) {
                def cast, submessages := params[i].implicitCast(context, target)
                messages := addMessages(messages, submessages)
                finalParams.add(cast)
            }
            else if m.parameters[i].isConvert & 
                    params[i].canConvertTo(context, target) {
                def converted, submessages := params[i].convert(context, target)
                messages := addMessages(messages, submessages)
                finalParams.add(converted)
            }
            else {
                messages := addMessage(messages, "expected value of type " +
                        "'\{target.displayName}', but found " +
                        "'\{params[i].type.displayName}'", params[i].position)
            }
        }
        if isVarArg {
            def values := new Array<Value>()
            def isConvert := methodParams[methodParams.length - 1].isConvert
            def arrayType := methodParams[methodParams.length - 1].type->(PrimitiveArrayType)
            def elementType := arrayType.elementType
            for i in count .. params.length {
                if isConvert {
                    def convert, submessages := params[i].convert(context, 
                            elementType)
                    messages := addMessages(messages, submessages)
                    values.add(convert)
                }
                else {
                    def cast, submessages := params[i].implicitCast(context, 
                            elementType)
                    messages := addMessages(messages, submessages)
                    values.add(cast)
                }
            }
            finalParams.add(new NewPrimitiveArrayWithValues(position,
                    arrayType, values))
        }
        return (new MethodCall(position, m, isSuper, finalParams), messages)
    }

    method call(context:Context, position:Position, var contextValue:Value?, 
            methodName:String, var params:ListView<Value>):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null            
        for p in params {
            def message := p.checkValid
            messages := addMessage(messages, message)
        }
        if messages != null
            return (null, messages)
        if contextValue = null {
            if context.isInstance {
                -- bare identifier, could be either instance or class
                var result := context.getMethod(null, methodName, params)
                if result != null {
                    if result.annotations.isClass {
                        -- class method, update the contextValue
                        contextValue := new ClassLiteral(position, 
                                context.currentClassType())
                    }
                }
                if contextValue = null
                    contextValue := context.getSelf(position)
            }
            else {
                -- in a class context
                contextValue := new ClassLiteral(position,
                        context.currentClassType())
            }
        }
        var classMethod:Bit
        var supercall:Bit
        if contextValue-?>(UnresolvedClassLiteral) {
            contextValue := new ClassLiteral(position, 
                    contextValue->(UnresolvedClassLiteral).value)
        }
        if contextValue-?>(ClassLiteral) {
            classMethod := true
            supercall := false
        }
        else if contextValue-?>(ClassObjectLiteral) {
            classMethod := false
            supercall := false
        }
        else {
            classMethod := false
            var newParams := new Array<Value>()
            if contextValue-?>(Super) {
                def cl := context.currentClass
                assert cl != null
                def superclass := cl.superclass
                if superclass = null {
                    return (null, wrap(new Message("class '\{cl}' has no " +
                            "superclass", contextValue.position)))
                }
                def cast, submessages := context.getSelf(position).implicitCast(
                        context, superclass)
                assert messages = null : "failed to cast to superclass: \{messages}"
                newParams.add(cast)
                supercall := true
            }
            else {
                newParams.add(contextValue)
                supercall := false
            }
            newParams.addAll(params)
            params := newParams
        }
        var methodStub := context.getMethod(contextValue, methodName, params)
        if methodStub = null {
            if classMethod & methodName = MethodNode.CONSTRUCTOR_NAME {
                -- check for a constructor, which is called like a class method
                -- but implemented as an instance method
                def type:Type
                if contextValue-?>(ClassLiteral)
                    type := contextValue->(ClassLiteral).value
                else {
                    assert contextValue-?>(Super)
                    def sc := context.currentClass->(TypedClassStub).superclass
                    assert sc != null
                    type := sc
                }
                if type.isPrimitiveArray {
                    if params.length = 1 &
                            params[0].canImplicitCastTo(context, IntType.INT32) {
                        def cast, _ := params[0].implicitCast(context,
                                IntType.INT32)
                        return (new NewPrimitiveArray(position, 
                                type->>(PrimitiveArrayType), cast), messages)
                    }
                    else {
                        return (null, wrap(new Message(
                                "invalid arguments to PrimitiveArray constructor", 
                                position)))
                    }
                }
                if params.length = 0 | params[0]-!>(Dummy) {
                    def newParams := new Array<Value>()
                    newParams.add(new Dummy(contextValue.position, type))
                    newParams.addAll(params)
                    params := newParams
                    def construct, submessages := call(context, position, 
                            contextValue, methodName, params)
                    if construct != null {
                        def stub := construct->(Construct).constructorCall.methodStub
                        if stub.methodType != 
                                MethodNodeType.CONSTRUCTOR {
                            return (null, wrap(new Message(
                                    "instance method '\{stub.name}' cannot " +
                                    "be accessed from a class context", 
                                    position)))
                        }
                        messages := addMessages(messages, submessages)
                        return (construct, messages)
                    }
                }
            }
        }
        if methodStub != null {
            def result := call(context, position, methodStub, supercall, params)
            if methodStub.methodType = MethodNodeType.CONSTRUCTOR & !supercall {
                def type:Type?
                if contextValue-?>(ClassLiteral)
                    type := contextValue->(ClassLiteral).value
                else
                    type := context.currentClass->(TypedClassStub).superclass
                return (new Construct(type->(ClassType),
                        result[0]->(MethodCall)), result[1])
            }
            else
                return result
        }
        else {
            return (null, wrap(getMethodNotFoundMessage(context, position, 
                    contextValue, methodName, params)))
        }
    }
    
    @private
    method getMethodNotFoundMessage(context:Context, position:Position, 
            contextValue:Value?, methodName:String, 
            params:ListView<Value>):Message {
        def msg := "no match found for method "->>(MutableString)
        msg.append(methodName)
        msg.append("(")
        var first := true
        for i, p in params {
            if p-?>(Dummy)
                continue
            if i = 0 & contextValue != null & contextValue-!>(ClassLiteral) {
                assert p = contextValue
                continue
            }
            if first
                first := false
            else
                msg.append(", ")
            msg.append(p.type.displayName)
        }
        msg.append(")")
        if contextValue != null {
            if contextValue-?>(Super)
                msg.append(" in \{context.currentClass->(TypedClassStub).superclass->(Type).displayName}")
            else if contextValue-?>(ClassLiteral)
                msg.append(" in \{contextValue}")
            else
                msg.append(" in \{contextValue.type.displayName}")
        }
        for p in params {
-*            if p-?>(UnresolvedLambda) {
                def lambda := p->(UnresolvedLambda)
                if lambda.errors.length > 0 {
                    msg.append("\n    possible error in lambda at " +
                            "\{lambda.position}:")
                    def entries := new PrimitiveArray<Object>()
                    for e in lambda.errors
                        entries.append(e)
                    Panda.sort(entries, function(eo1:Object, eo2:Object):Bit {
                        def e1 := eo1->((Object?, Object?))[0]->(PrimitiveArray<Type>)
                        def e2 := eo2->((Object?, Object?))[0]->(PrimitiveArray<Type>)
                        assert e1.length = e2.length
                        for i in 0 .. e1.length {
                            def n1 := e1[i].name
                            def n2 := e2[i].name
                            if n1 > n2
                                return true
                            if n2 > n1
                                return false
                        }
                        return false
                    })
                    for raw in entries {
                        def e := raw->((Object?, Object?))
                        def types := e[0]->(PrimitiveArray<Type>)
                        def typeString := new MutableString()
                        typeString.append("(")
                        for i, type in types {
                            if i > 0
                                typeString.append(",")
                            typeString.append(type.displayName)
                        }
                        typeString.append(")=>(...)")
                        var error, errorPos := e[1]->((String, Position?))
                        if errorPos = null
                            errorPos := Position.INTERNAL
                        msg.append("\n        when interpreted as \{typeString}:\n")
                        msg.append("            \{error}")
                        if errorPos != lambda.position
                            msg.append(" at \{errorPos}")
                    }
                }
            }*-
        }
        return new Message(msg->>(String), position)
    }

    method resolveNoArgFunction(context:Context, u:Unresolved):Value? {
        def result, messages := call(context, u.position, u.contextValue, 
                u.name, new Array<Value>())
        if result-?>(MethodCall) & 
                result->(MethodCall).methodStub.methodType = 
                    MethodNodeType.FUNCTION
            return result
        return null
    }
    
    ============================================================================
    Resolves a possibly-unresolved value. During the code analysis phase, we
    often end up with partial sequences of tokens: for instance, the sequence
    `panda.core.String` could potentially represent a type name (`panda`) having
    a class function (`core`) called upon it, resulting in an object which we 
    are going to extract a field (`String`) from. Or it could (as it obviously
    does in this case) represent the name of a class (`panda.core.String`). But
    as we are parsing it, and have so far just seen the "panda.core" part, we
    don't yet know we have a type name until we reach the "String", and the
    partial value will be represented by objects that are not fully resolved.

    This method means "we have all the information about this value we are ever
    going to get, so either give me the value it's describing or raise an 
    error". Note that a resolved construct may still have an unresolved type,
    such as `UnresolvedArray` or `UnresolvedRange`; those are legal returns from
    this method. See `resolveUnresolvedConstructs` for how to resolve those.
    ============================================================================
    method resolve(context:Context, raw:Value):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var result:Value? := raw
        if result.type = RealType.REAL64 {
            def submessages:ListView<Message>?
            result, submessages := result.implicitCast(context, RealType.REAL64)
            messages := addMessages(messages, submessages)
        }
        else if result-?>(Unresolved) {
            def type, submessages := context.getType(raw->>(String), 
                    raw.position)
            if type != null {
                messages := addMessages(messages, submessages)
                return (new ClassLiteral(raw.position, type), messages)
            }
            if !result->(Unresolved).name.contains(".")
                result := resolveNoArgFunction(context, result->(Unresolved))
            else
                result := null
            if result = null {
                messages := addMessage(messages, new Message(
                        "unknown identifier", raw.position))
            }
        }
        else if result-?>(AmbiguousReference) {
            def a := result->(AmbiguousReference)
            def name := a.field.name
            throw new CompilerException("reference to '\{name}' is " +
                    "ambiguous, both field '\{name}' and function " +
                    "\{name}() match", a.position)
        }
        else if result-?>(PossibleIndexedAssignment) {
            def pia := result->(PossibleIndexedAssignment)
            messages := addMessage(messages, 
                    pia.contextValue.type.displayName +
                    "does not define the index ([]) operator for " +
                    "'\{pia.index.type.displayName}'", pia.position)
        }
        else if result-?>(PossibleSliceAssignment) {
            def psa := result->(PossibleSliceAssignment)
            var name:String
            if psa.endInclusive
                name := "inclusive slice ([...])"
            else
                name := "exclusive slice ([..])"
            messages := addMessage(messages, 
                    psa.contextValue.type.displayName +
                    "does not define the \{name} operator for these types", 
                    psa.position)
        }
        return (result, messages)
    }

    @class
    function makeExplicit(v:Value):Value {
        if v-?>(Cast)
            return new Cast(v->(Cast).value, v.type, CastType.EXPLICIT)
        return v
    }

    method convertInstanceOf(context:Context, position:Position, 
            var object:Value, var type:Type):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        if object.type = StringOrCharType.STRING_OR_CHAR {
            -- hardcode STRING_OR_CHAR-?>(Char) and STRING_OR_CHAR-?>(String)
            -- as true
            if type = CharType.CHAR | ClassType.STRING.implicitCastCost(
                    context, type) != null
                return (new BitLiteral(position, true), null)
        }
        var primitiveTarget := type.isPrimitive | type.isWrapper
        if primitiveTarget {
            var submessages:ListView<Message>?
            if object.type = StringOrCharType.STRING_OR_CHAR {
                object, submessages := object.implicitCast(context, 
                        CharType.CHAR)
                messages := addMessages(messages, submessages)
            }
            if object.type = CharType.CHAR & type.isNumber {
                object, submessages  := object.explicitCast(context, 
                        IntType.INT32)
                messages := addMessages(messages, submessages)
            }
        }
        var primitiveSource := object.type.isPrimitive | 
                object.type.isWrapper

        if object.type.isNumber & type.isReal
            return (new BitLiteral(position, true), null)

        if !primitiveSource & type.isPrimitive
            type := type->>(WrapperType)

        if !object.canExplicitCastTo(context, type) {
            messages := addMessage(messages, "'\{object}' " +
                    "(\{object.type.displayName}) cannot possibly be an " +
                    "instance of '\{type.displayName}'", position)
            return (null, messages)
        }

        def panda := context.getStub(ClassType.PANDA)
        def parameters := new Array<Value>()
        parameters.add(object)
        if !primitiveTarget {
            parameters.add(new ClassObjectLiteral(position, 
                    type.unwrapNullable))
        }
        
        var methodName := "instanceOf"
        if primitiveTarget {
            def target := type.unwrapNullable
            var name := target.name
            assert name.startsWith("panda.core.")
            name := name["panda.core.".length..]
            if target.isWrapper
                name := name.replace("Wrapper", "")
            methodName += name
        }
        def contextValue := new ClassLiteral(position, ClassType.PANDA)
        var instanceOf:TypedMethodStub? := null
        if !object.type.isNullable {
            instanceOf := context.getMethod(contextValue, methodName, 
                    parameters)
        }
        if instanceOf = null {
            parameters.add(new BitLiteral(position, type.isNullable))
            instanceOf := context.getMethod(contextValue, methodName, 
                    parameters)
        }
        assert instanceOf != null
        return call(context, position, instanceOf, false, parameters)
    }

    @pre(c.type = ParseNodeType.CONSTRUCT)
    method convertConstruct(context:Context, c:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        assert c[0]->(TokenNode).token.type = TokenType.NEW
        var type, submessages := context.getType(c[1])
        messages := addMessages(messages, submessages)
        if type = null
            return (null, messages)
        def params:ListView<Value>?
        params, submessages := convertParameters(context, c[2])
        messages := addMessages(messages, submessages)
        if params = null
            return (null, messages)
        def classLiteral := new ClassLiteral(c[1].position, type)
        def result:Value?
        result, submessages := call(context, c.position, classLiteral, 
                MethodNode.CONSTRUCTOR_NAME, params)
        messages := addMessages(messages, submessages)
        return (result, messages)
    }

    method parseBareIdentifier(context:Context, id:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var name := id->>(String)
        if name = "class"
            name := "$class"
        def variable := context.getVariable(name)
        if variable != null {
            if variable-?>(FieldNode) {
                def classField := variable->(FieldNode).annotations.isClass | 
                        variable->(FieldNode).annotations.isThread
                if !context.isInstance & !classField {
                    messages := addMessage(messages, 
                            "instance field '\{name}' cannot be accessed " +
                            "from a class context", id.position)
                }
                def contextValue:Value
                if classField {
                    def cc := context.currentClass
                    assert cc != null
                    def type, submessages := context.getType(cc.name, 
                            id.position)
                    messages := addMessages(messages, submessages)
                    if type = null
                        return (null, messages)
                    contextValue := new ClassLiteral(id.position, type)
                }
                else
                    contextValue := context.getSelf(id.position)
                if isAccessible(context, variable->(FieldNode)) {
                    return (createFieldReference(context, id.position, 
                            contextValue, variable->(FieldNode), true), 
                            messages)
                }
            }
            else {
                def result := new VariableReference(id.position, variable)
                return (result, messages)
            }
        }
        if id->(TokenNode).token.type = TokenType.IDENTIFIER {
            def type, _ := context.getType(name, id.position)
            if type != null {
                return (new UnresolvedClassLiteral(id.position, type), null)
            }
        }
        return (new Unresolved(id.position, null, name), null)
    }

    @pre(params.type = ParseNodeType.PARAMETERS)
    method convertParameters(context:Context, 
            params:ParseNode):(ListView<Value>?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        assert params[0]->(TokenNode).token.type = TokenType.LPAREN
        def result := new Array<Value>()
        for i in 1 .. params.length - 1 by 2 {
            var expr, submessages := convertExpression(context, params[i])
            messages := addMessages(messages, submessages)
            if expr = null
                return (null, messages)
            if i = params.length - 2 & expr-?>(UnresolvedRange) {
                def r := expr->(UnresolvedRange)
                def left := r.left
                if left != null & left.preferredVariableType.isPrimitiveArray & 
                        r.right = null & r.step = null & r.endInclusive
                    expr := new Unwrap(left)
            }
            result.add(expr)
        }
        return (result, messages)
    }

    -- FIXME remove this when array syntax is wired up to generic arrays
    @class
    function wrap(message:Message):ListView<Message> {
        def result := new Array<Message>()
        result.add(message)
        return result
    }

    @private
    @class
    function unwrapCast(v:Value):Value {
        if v-?>(Cast)
            return unwrapCast(v->(Cast).value)
        return v
    }

    -- FIXME refactoring required! I did this all wrong and dumb. When I first
    -- started working on Panda, all lvalues were also rvalues. Then one
    -- situation crept in where the two weren't exactly the same, so I hacked it
    -- a bit to get it working. Then another cropped up, and another, and slowly
    -- this nice simple method turned into this hellish monstrosity. It needs to
    -- be killed with extreme prejudice, and I apologize to anyone reading this
    -- code. It just built up a bit at a time until it was completely out of
    -- control.
    --
    -- The basic idea is that (due to the original simplicity) the processing
    -- originally just figured out the rvalue on the left side of the assignment
    -- operator, ran into an assignment operator, made sure the rvalue worked as
    -- an lvalue, and continued on its merry way. Since then, this has gotten so 
    -- hellishly complicated that it absolutely needs to be rewritten so as to 
    -- know up front to be looking for an lvalue, so we can eliminate all of 
    -- these special cases and cut this at least in half.
    --
    -- UPDATE:
    -- Oh god I made it even worse. It's so awful. Please don't judge me by this
    -- method, I'm better than this, I swear :-(
    --
    -- FURTHER UPDATE:
    -- Actually, I don't think the refactoring is as simple as I outlined. I 
    -- hadn't considered the complexities introduced by compound assignment. We
    -- can't just process the assignment target twice (once in "lvalue mode" and
    -- once in "rvalue mode"), because that would involve duplicate evaluations
    -- of things that are only supposed to be evaluated once. It can certainly
    -- be done simpler than it's being done, but I don't think it's possible to
    -- eliminate quite as much complexity as I had hoped.
    method processSingleAssignment(context:Context, var left:Value, 
            assignmentOp:ParseNode, right:Value, reuse:Bit):
            (ListView<Statement>?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def resolved, resolveMessages := resolve(context, left)
        if resolved != null
            left := resolved
        messages := addMessages(messages, resolveMessages)
        if left-?>(Unresolved) {
            -- could be an assignment method
            var contextValue := left->(Unresolved).contextValue
            def name := left->(Unresolved).name
            if contextValue = null {
                if context.isInstance
                    contextValue := context.getSelf(assignmentOp.position)
                else {
                    -- we're in a class context, so there can't possibly be an
                    -- assignment method. Go ahead and report the error.
                    return (null, resolveMessages)
                }
            }
            assert contextValue != null
-*            def call := callAssignmentMethod(contextValue, name, 
                    new PrimitiveArray<Value>(right))
            if call != null
                currentNode.add(call)
            else {
                -- no assignment method, trigger the exception
                resolve(left)
            }*-
            throw new NotSupportedException("assignment method")
        }
-*        else if left-?>(AmbiguousReference) {
            var a := left->(AmbiguousReference)
            var object := a.context
            if reuse {
                def reusable := makeReusable(object)
                reusable.replace(reusable.createReference())
                currentNode.add(new ValueStatement(reusable))
                object := reusable.createReference()
            }
            checkAssignment(a.field, a.position)
            open(new FieldAssignment(assignmentOp.position, object, a.field))
            currentNode.add(implicitCast(right.position, right, a.type))
            close(class(FieldAssignment))
        } *-
        else if left-?>(VariableReference) {
            def variable := left->(VariableReference).variable
            def cast, submessages := right.implicitCast(context, variable.type)
            messages := addMessages(messages, submessages)
            def assignment := new VariableAssignment(assignmentOp.position,
                    variable, cast)
            def result := new Array<Statement>()
            result.add(new ValueStatement(assignment))
            return (result, messages)
        }
        else if left-?>(FieldReference) {
            def fv := left->(FieldReference)
            def object:Value
            def finalRight:Value
            if reuse {
                def old := unwrapCast(right)->(BinaryOperation)
                assert old.left = fv
                object := new ReusedValueDefinition(fv.object)
                def newRight := new BinaryOperation(old.position, old.operation,
                        new FieldReference(old.position, object, fv.field), 
                        old.right)
                def cast, submessages := newRight.implicitCast(context,
                        fv.field.type)
                messages := addMessages(messages, submessages)
                finalRight := cast
            }
            else {
                object := fv.object
                finalRight := right
            }
            def name := fv.field.name
            Console.writeLine("skipping field ambiguity check")
-*            var call := callAssignmentMethod(object, name, 
                    new PrimitiveArray<Value>(right))
            if call != null {
                if currentClass != fv.field.parent & 
                        !fv.field.annotations.isReadOnly &
                        !fv.field.annotations.isFinal {
                    throw new CompilerException("reference to '\{name}' is " +
                            "ambiguous, both field \{name} (of type " +
                            "\{fv.field.type.displayName}) and method " +
                            "\{name}:=() match", fv.position)
                }
                currentNode.add(call)
            }*-
            def result := new Array<Statement>()
            result.add(new FieldAssignment(fv.position, object, fv.field,
                    finalRight))
            return (result, messages)
        }
        else if left-?>(PrimitiveArrayIndexValue) {
            def iv := left->(PrimitiveArrayIndexValue)
            def result := new Array<Statement>()
            if reuse {
                def old := unwrapCast(right)->(BinaryOperation)
                assert old.left = iv
                def array := new ReusedValueDefinition(iv.array)
                def index := new ReusedValueDefinition(iv.index)
                def newRight := new BinaryOperation(old.position, old.operation,
                        new PrimitiveArrayIndexValue(array, index), old.right)
                def cast, submessages := newRight.implicitCast(context,
                        array.type->>(PrimitiveArrayType).elementType)
                messages := addMessages(messages, submessages)
                result.add(new PrimitiveArrayIndexAssignment(left.position,
                        array.createReference(), index.createReference(), cast))
            }
            else {
                def array := iv.array
                def index := iv.index
                def cast, submessages := right.implicitCast(context,
                        array.type->>(PrimitiveArrayType).elementType)
                messages := addMessages(messages, submessages)
                result.add(new PrimitiveArrayIndexAssignment(left.position, 
                        array, index, cast))
            }
           return (result, messages)
        }
        else if left-?>(UnresolvedIndex) {
            def ui := left->(UnresolvedIndex)
            def params := new Array<Value>()
            params.add(ui.index)
            params.add(right)
            def call, submessages := call(context, ui.position, ui.contextValue, 
                    "[]:=", params)
            messages := addMessages(messages, submessages)
            if call = null
                return (null, messages)
            def result := new Array<Statement>()
            result.add(new ValueStatement(call))
            return (result, messages)
        }
        else if left-?>(UnresolvedSlice) {
            def us := left->(UnresolvedSlice)
            def params := new Array<Value>()
            if us.left != null
                params.add(us.left->(Value))
            else
                params.add(new NullLiteral(us.position))
            if us.right != null
                params.add(us.right->(Value))
            else
                params.add(new NullLiteral(us.position))
            if us.step != null
                params.add(us.step->(Value))
            else
                params.add(new NullLiteral(us.position))
            params.add(right)
            def name:String
            if us.inclusive
                name := "[...]:="
            else
                name := "[..]:="
            def call, submessages := call(context, us.position, us.contextValue, 
                    name, params)
            messages := addMessages(messages, submessages)
            if call = null
                return (null, messages)
            def result := new Array<Statement>()
            result.add(new ValueStatement(call))
            return (result, messages)
        }
-*
        else if left-?>(PossibleSliceAssignment) {
            var psa := left->(PossibleSliceAssignment)
            var params := [psa.left, psa.right, psa.step, right]
            var name:String
            if psa.endInclusive
                name := "[...]"
            else
                name := "[..]"
            var call := callAssignmentMethod(psa.context, name, params)
            if call != null
                currentNode.add(call)
            else {
                var types := new PrimitiveArray<String>()
                for p in params
                    types.append(p.type.displayName)
                if psa.endInclusive
                    name := "inclusive slice assignment ([...]:=)"
                else
                    name := "exclusive slice assignment ([..]:=)"
                throw new CompilerException("\{psa.context.type.displayName} does " +
                        "not define the \{name} operator for \{types}", 
                        psa.position)
            }
        }
        else if left-?>(MethodCall) {
            -- assigning to a method call. We need to look for a corresponding
            -- assignment method / field.
            var mc := left->(MethodCall)
            var methodNode := mc.methodNode
            if !methodNode.annotations.isClass & (mc.parameters.length = 1 | 
                    methodNode.name = "[]" | methodNode.name = "[..]" |
                    methodNode.name = "[...]") {
                var cl := mc.methodNode.parent->(ClassNode)
                var oldParams := mc.parameters
                var testParams := oldParams[1..]
                -- undo implicit casts that happened as part of setting up the
                -- original method call
                for i, p in testParams {
                    testParams[i] := unwrapImplicitCast(p)
                }
                if methodNode.name = "[..]" | methodNode.name = "[...]" {
                    -- restore parameters that might have been stripped when we
                    -- matched the initial slice. Such a hack, I'm so sorry.
                    if testParams.length = 0
                        testParams.append(new NullLiteral(left.position))
                    if testParams.length = 1
                        testParams.append(new NullLiteral(left.position))
                    if testParams.length = 2
                        testParams.append(new IntegerLiteral(left.position, 1))
                }
                testParams.append(right)
                def src := unwrapImplicitCast(oldParams[0])
                def m := findAssignmentMethod(src, methodNode.name, 
                        testParams, mc.isSuper)
                if m != null {
                    -- found assignment method
                    -- promote our parameters, call it and we're done
                    var params := new PrimitiveArray<Value>()
                    if reuse
                        cm.add(right)
                    else
                        cm.add(mc)
                    for i, p in m.params {
                        if i = m.params.length - 1
                            break
                        if reuse {
                            def getMethod := left->(MethodCall).methodNode
                            var reusable := makeReusable(p)
                            reusable.replace(implicitCast(p.position,
                                    reusable.createReference(),
                                    getMethod.parameters[i].type))
                            params.append(reusable)
                        }
                        else
                            params.append(p)
                        if params[i].parent != null
                            params[i].removeFromParent()
                    }
                    if reuse
                        right.removeFromParent()
                    else
                        mc.removeFromParent()
                    params.append(right)
                    currentNode.add(new ValueStatement(call(
                            assignmentOp.position, m.methodNode, 
                            m.methodNode.isDeclaredVirtual() & !mc.isSuper, 
                            params)))
                }
                else {
                    -- no assignment method
                    if methodNode.name = "[]" {
                        var types := new PrimitiveArray<String>()
                        for p in testParams
                            types.append(p.type.displayName)
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the indexed assignment ([]:=) " +
                                "operator for \{types}", mc.position)
                    }
                    else if methodNode.name = "[..]" {
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the exclusive slice assignment ([..]:=) " +
                                "operator for these types", mc.position)
                    }
                    else if methodNode.name = "[...]" {
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the inclusive slice assignment ([...]:=) " +
                                "operator for these types", mc.position)
                    }
                    else {
                        -- check for a field by this name
                        if oldParams.length = 1 {
                            var object := oldParams[0]
                            def field := getField(left.position, 
                                    new Dummy(object.type), 
                                    mc.methodNode.name, false)
                            if field-?>(FieldReference) {
                                if reuse {
                                    cm.add(right)
                                    def reusable := makeReusable(object)
                                    reusable.replace(reusable.createReference())
                                    object := reusable
                                    right.removeFromParent()
                                }
                                else
                                    object.removeFromParent()
                                checkAssignment(field->(FieldReference).field,
                                        field.position)
                                open(new FieldAssignment(assignmentOp.position, 
                                        object, field->(FieldReference).field))
                                currentNode.add(implicitCast(right.position, 
                                        right, field.type))
                                close(class(FieldAssignment))
                                return
                            }
                        }
                        error("cannot assign to '\{left}'", assignmentOp)
                    }
                }
            }
            else
                error("cannot assign to '\{left}'", assignmentOp)
        }
        else
            error("cannot assign to '\{left}'", assignmentOp)*-
        throw new NotSupportedException("special assignment: \{left}:\{left.position}")
    }

    @pre(assignmentOp.type = ParseNodeType.ASSIGNMENT_OPERATOR)
    method processAssignment(context:Context, var left:ListView<Value?>, 
            assignmentOp:ParseNode, var right:Value):
            (ListView<Statement>?, ListView<Message>?) {
        def cm := context.currentMethod
        assert cm != null
        def reuse:Bit
        def assignmentType := assignmentOp[0]->(TokenNode).token.type
        if assignmentType = TokenType.ASSIGNMENT
            reuse := false
        else {
            reuse := true
            def op:TokenType
            switch assignmentType {
                case TokenType.ADDEQ:        op := TokenType.ADD
                case TokenType.SUBEQ:        op := TokenType.SUB
                case TokenType.MULEQ:        op := TokenType.MUL
                case TokenType.DIVEQ:        op := TokenType.DIV
                case TokenType.INTDIVEQ:     op := TokenType.INTDIV
                case TokenType.POWEQ:        op := TokenType.POW
                case TokenType.REMEQ:        op := TokenType.REM
                case TokenType.SHIFTLEFTEQ:  op := TokenType.SHIFTLEFT
                case TokenType.SHIFTRIGHTEQ: op := TokenType.SHIFTRIGHT
                case TokenType.BITWISEANDEQ: op := TokenType.BITWISEAND
                case TokenType.BITWISEOREQ:  op := TokenType.BITWISEOR
                case TokenType.BITWISEXOREQ: op := TokenType.BITWISEXOR
                case TokenType.ANDEQ:        op := TokenType.AND
                case TokenType.OREQ:         op := TokenType.OR
                case TokenType.XOREQ:        op := TokenType.XOR
                default: throw new InternalCompilerException(
                        "unsupported assignment operator: " +
                        "'\{assignmentType}'", assignmentOp.position)
            }
            if left.length > 1
                return (null, wrap(new Message("compound assignment cannot " +
                        " assign to multiple values at once", 
                        assignmentOp.position)))
            var lvalue := left[0]
            if lvalue = null {
                return (null, wrap(new Message("'_' is only permitted in " +
                        "multiple assignments from a tuple", 
                        assignmentOp.position)))
            }
            var messages:ListView<Message>?
            lvalue, messages := resolve(context, lvalue)
            if lvalue = null
                return (null, messages)
            var submessages:ListView<Message>?
            def finalRight:Value?
            finalRight, submessages := getBinaryValue(context, 
                    assignmentOp.position, lvalue, op, right)
            messages := addMessages(messages, submessages)
            if finalRight != null
                right := finalRight
            else
                return (null, messages)
            -- deal with situations like int8 += 1 (which resolves into
            -- int8 := int8 + 1, and the right side promotes to an Int32, so we
            -- need to downcast)
            if right.type.isInteger & lvalue.type.isInteger {
                right, submessages := right.explicitCast(context, lvalue.type)
                messages := addMessages(messages, submessages)
            }
            def newLeft := new Array<Value?>()
            newLeft.add(lvalue)
            left := newLeft
        }

        var result := new Array<Statement>()
        if left.length > 1 {
            def reused := new ReusedValueDefinition(right)
            result.add(new ValueStatement(reused))
            var messages:ListView<Message>? := null
            for i, lvalue in left {
                if lvalue != null {
                    var tupleValue, submessages := getField(context, 
                            right.position, reused.createReference(), 
                            "$field" + i)
                    messages := addMessages(messages, submessages)
                    assert tupleValue != null : "can't-happen tuple failure: " +
                            submessages
                    var assignments:ListView<Statement>?
                    assignments, submessages := processSingleAssignment(
                            context, lvalue, assignmentOp, tupleValue, reuse)
                    messages := addMessages(messages, submessages)
                    if assignments != null
                        result.addAll(assignments)
                }
            }
            return (result, messages)
        }
        else {
            def lvalue := left[0]
            assert lvalue != null
            return processSingleAssignment(context, lvalue, assignmentOp, right,
                    reuse)
        }
    }

    ============================================================================
    Converts a list of parameters to the types required by a method type, or
    throws an exception if a conversion is not possible. Note that this method
    is for use with dynamic calls, and thus only performs a subset of the work 
    that is done during a normal call (for instance, dynamic calls cannot be
    variadic or have convert parameters).
    ============================================================================
    @private
    @pre(v.type.isMethod)
    method prepareMethodParameters(context:Context, v:Value, 
            params:ListView<Value>):(ListView<Value>?, ListView<Message>?) {
        def parameterTypes := v.type->>(MethodType).methodParameters
        if parameterTypes.length != params.length {
            var msg := "\{v.type.displayName} requires \{parameterTypes.length}"
            if parameterTypes.length = 1
                msg += " parameter"
            else
                msg += " parameters"
            msg += ", but found " + params.length
            def messages := new Array<Message>()
            messages.add(new Message(msg, v.position))
            return (null, messages)
        }
        var messages:ListView<Message>? := null
        def result := new Array<Value>()
        for i, p in params {
            def check := p.checkValid()
            if check = null {
                def cast, submessages := p.implicitCast(context, 
                        parameterTypes[i])
                messages := addMessages(messages, submessages)
                result.add(cast)
            }
            else {
                messages := addMessage(messages, check)
                result.add(new Dummy(p.position, parameterTypes[i]))
            }
        }
        return (result, messages)
    }

    @private
    function findSliceMethod(context:Context, contextValue:Value, left:Value?,
            right:Value?, step:Value?, inclusive:Bit):TypedMethodStub? {
        def name:String
        if inclusive
            name := "[...]"
        else
            name := "[..]"
        def params := new Array<Value>()
        params.add(contextValue)
        var op:TypedMethodStub?
        if left = null & right = null & step = null {
            op := context.getMethod(contextValue, name, params)
            if op != null
                return op
        }
        assert params.length = 1
        if left != null
            params.add(left)
        else
            params.add(new NullLiteral(contextValue.position))
        if right = null & step = null {
            op := context.getMethod(contextValue, name, params)
            if op != null
                return op
        }
        assert params.length = 2
        if right != null
            params.add(right)
        else
            params.add(new NullLiteral(contextValue.position))
        if step = null {
            op := context.getMethod(contextValue, name, params)
            if op != null
                return op
        }
        assert params.length = 3
        if step != null
            params.add(step)
        else
            params.add(new IntegerLiteral(contextValue.position, 1))
        assert params.length = 4
        op := context.getMethod(contextValue, name, params)
        return op
    }

    ============================================================================
    Handles the nodes following the context in a CALL_OR_ASSIGNMENT. If it is a
    call, returns the call's value, otherwise returns null.
    ============================================================================
    -- FIXME Dear god this has gotten long and unwieldy, needs to be split apart
    method processCallOrAssignment(context:Context, var contextValue:Value?, 
            c:ParseNode):(Value?, Statement?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var i := 1
        def lvalues := new Array<Value?>()
        while i < c.length {
            if c[i].type = ParseNodeType.TOKEN {
                Console.writeLine(c[i]->(TokenNode).token + " - " + c[i]->(TokenNode).token.type)
                switch c[i]->(TokenNode).token.type {
                    case TokenType.DOT: {
                        def name := c[i + 1]->>(String)
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        Console.writeLine("resolving 1")
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        Console.writeLine("resolving 2")
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        contextValue, submessages := 
                                resolveUnresolvedConstructs(context,
                                    contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        def field:Value?
                        field, submessages := getField(context, 
                                c[i + 1].position, contextValue, name)
                        messages := addMessages(messages, submessages)
                        if field != null 
                            contextValue := field
                        else {
                            if contextValue-!>(Unresolved) {
                                return (null, null, wrap(new Message(
                                        "unknown identifier",
                                        contextValue.position)))
                            }
                            contextValue := new Unresolved(c[i + 1].position, 
                                    contextValue->(Unresolved).contextValue, 
                                    contextValue + "." + name)
                        }
                        i += 2
                    }
                    case TokenType.LBRACKET: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        contextValue, submessages := 
                                resolveUnresolvedConstructs(context, 
                                    contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        i += 1
                        var slice := false
                        var endInclusive := false
                        var left:Value?
                        var right:Value?
                        var step:Value? := null
                        if c[i]-?>(TokenNode) & 
                                c[i]->(TokenNode).token.type = TokenType.DOTDOT {
                            left := null
                            slice := true
                        }
                        else if c[i]-?>(TokenNode) & 
                                c[i]->(TokenNode).token.type = TokenType.ELLIPSIS {
                            left := null
                            slice := true
                            endInclusive := true
                        }
                        else {
                            left, submessages := convertExpression(context, c[i])
                            messages := addMessages(messages, submessages)
                            if left = null
                                return (null, null, messages)
                            i += 1
                        }
                        if c[i]-?>(TokenNode) & 
                                (c[i]->(TokenNode).token.type = TokenType.DOTDOT |
                                c[i]->(TokenNode).token.type = TokenType.ELLIPSIS) {
                            slice := true
                            endInclusive := c[i]->(TokenNode).token.type = TokenType.ELLIPSIS
                            i += 1
                            if c[i]-?>(TokenNode) & 
                                    (c[i]->(TokenNode).token.type = 
                                        TokenType.RBRACKET | 
                                    c[i]->(TokenNode).token.type = 
                                        TokenType.BY)
                                right := null
                            else {
                                right, submessages := convertExpression(context, 
                                        c[i])
                                messages := addMessages(messages, submessages)
                                if right = null
                                    return (null, null, messages)
                                i += 1
                            }
                            if c[i]->(TokenNode).token.type = TokenType.BY {
                                i += 1
                                step, submessages := convertExpression(context, 
                                        c[i])
                                messages := addMessages(messages, submessages)
                                if step = null
                                    return (null, null, messages)
                                i += 1
                            }
                        }
                        else
                            right := null
                        assert c[i]->(TokenNode).token.type = TokenType.RBRACKET
                        i += 1
                        if left != null & right = null & step = null {
                            if left-?>(UnresolvedRange) {
                                def range := left->(UnresolvedRange)
                                left := range.left
                                right := range.right
                                step := range.step
                                slice := true
                                endInclusive := range.endInclusive
                            }
                        }
                        if !slice {
                            assert left != null
                            if contextValue.type.isPrimitiveArray {
                                if contextValue.type.isNullable {
                                    contextValue, submessages := contextValue.implicitCast(
                                            context,
                                            contextValue.type.unwrapNullable)
                                    messages := addMessages(messages, 
                                            submessages)
                                    if contextValue = null
                                        return (null, null, messages)
                                }
                                def cast:Value?
                                cast, submessages := left.implicitCast(
                                        context,
                                        IntType.INT32)
                                messages := addMessages(messages, submessages)
                                contextValue := new PrimitiveArrayIndexValue(
                                        contextValue, cast)
                            }
                            else if contextValue.type.isTuple & 
                                    left-?>(IntegerLiteral) {
                                contextValue, submessages := getField(context, 
                                        contextValue.position, contextValue,
                                        "$field" + left->(IntegerLiteral).value)
                                messages := addMessages(messages, submessages)
                                if contextValue = null
                                    return (null, null, messages)
                            }
                            else {
                                def params := new Array<Value>()
                                params.add(contextValue)
                                params.add(left)
                                def op := context.getMethod(contextValue, "[]", 
                                        params)
                                contextValue := new UnresolvedIndex(
                                        contextValue, left, op)
                            }
                        }
                        else {
                            def op := findSliceMethod(context, contextValue, 
                                    left, right, step, endInclusive)
                            contextValue := new UnresolvedSlice(contextValue, 
                                    left, right, step, endInclusive, op)
                        }
                    }
                    case TokenType.MEMBER: {-*
                        assert contextValue != null
                        contextValue := resolve(contextValue)
                        contextValue := resolveUnresolvedConstructs(context,
                                contextValue)
                        if contextValue-?>(UnresolvedClassLiteral)
                            contextValue := contextValue->(UnresolvedClassLiteral)->>(ClassLiteral)
                        def type := contextValue->(ClassLiteral).value
                        i += 1
                        def name := c[i]->>(String)
                        i += 1
                        var types:Array<Type>?
                        if i < c.length & c[i].type = ParseNodeType.TYPES {
                            types := convertTypes(c[i])
                            i += 1
                        }
                        else
                            types := null
                        var found := false
                        outer: for child in type.classNode.children {
                            if child-?>(MethodNode) & 
                                    child->(MethodNode).name = name {
                                def m := child->(MethodNode)
                                if types != null {
                                    var start:Int
                                    if m.annotations.isClass
                                        start := 0
                                    else
                                        start := 1
                                    def parameters := m.parameters[start..]
                                    if parameters.length != types.length
                                        continue
                                    for j, p in parameters {
                                        if p.type != types[j]
                                            continue outer
                                    }
                                }
                                if found {
                                    throw new CompilerException(
                                            "'\{type.displayName}' has more " +
                                            "than one method named " +
                                            "'\{name}', specify parameter " +
                                            "types to disambiguate", 
                                            contextValue.position)
                                }
                                if m.annotations.isAbstract {
                                    PandaCompiler.reportError(
                                            "'\{type.displayName}.\{name}' is " +
                                            "abstract", contextValue.position)
                                }
                                found := true
                                contextValue := methodReference(contextValue.position, m)
                            }
                        }
                        if !found {
                            throw new CompilerException("method not found",
                                    contextValue.position)
                        }*-
                        throw new NotSupportedException("member")
                    }
                    case TokenType.CONVERT: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def type:Type?
                        type, submessages := context.getType(c[i])
                        messages := addMessages(messages, submessages)
                        if type != null {
                            contextValue, submessages := contextValue.convert(
                                    context, type)
                            messages := addMessages(messages, submessages)
                        }
                        else
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.CAST: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def type:Type?
                        type, submessages := context.getType(c[i])
                        messages := addMessages(messages, submessages)
                        if type != null {
                            contextValue, submessages := 
                                    contextValue.explicitCast(c[i].position, 
                                        context, type)
                            messages := addMessages(messages, submessages)
                        }
                        else
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.INSTANCEOF: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        def position := c[i].position
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def type:Type?
                        type, submessages := context.getType(c[i])
                        messages := addMessages(messages, submessages)
                        if type != null {
                            contextValue, submessages := convertInstanceOf(
                                    context, position, contextValue, type)
                            messages := addMessages(messages, submessages)
                            if contextValue = null
                                return (null, null, messages)
                        }
                        else
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.NINSTANCEOF: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        def position := c[i].position
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def type:Type?
                        type, submessages := context.getType(c[i])
                        messages := addMessages(messages, submessages)
                        if type != null {
                            def instanceof:Value?
                            instanceof, submessages := convertInstanceOf(
                                    context, position, contextValue, type)
                            messages := addMessages(messages, submessages)
                            if instanceof = null
                                return (null, null, messages)
                            contextValue := new UnaryOperation(position, 
                                    UnaryOperationType.NOT, instanceof)
                        }
                        else
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.COMMA: {
                        assert contextValue != null
                        lvalues.add(contextValue)
                        i += 1
                        def submessages:ListView<Message>?
                        if c[i].type = ParseNodeType.CONSTRUCT {
                            contextValue, submessages := convertConstruct(
                                    context, c[i])
                            messages := addMessages(messages, submessages)
                        }
                        else {
                            def id := c[i]->>(String)
                            if id = "super"
                                contextValue := new Super(c.position)
                            else {
                                contextValue, submessages := 
                                        parseBareIdentifier(context, c[i])
                                messages := addMessages(messages, submessages)
                                if contextValue = null
                                    return (null, null, messages)
                            }
                        }
                        i += 1
                    }
                    case TokenType.UNDERSCORE: {
                        lvalues.add(contextValue)
                        contextValue := null
                    }
                    default: throw new InternalCompilerException(
                            "unsupported token '\{c[i]->(TokenNode).token.type}'", 
                                c[i].position)
                }
            }
            else if c[i].type = ParseNodeType.PARAMETERS {
                var params, submessages := convertParameters(context, c[i])
                messages := addMessages(messages, submessages)
                if params = null
                    return (null, null, messages)
                i += 1
                if contextValue-?>(Unresolved) {
                    contextValue, submessages := call(context, 
                            contextValue.position, 
                            contextValue->(Unresolved).contextValue, 
                            contextValue->(Unresolved).name, params)
                    messages := addMessages(messages, submessages)
                    if contextValue = null
                        return (null, null, messages)
                }
                else if contextValue-?>(Super) {
                    return (null, null, wrap(new Message(
                            "'super' is not a method", contextValue.position)))
                }
                else if contextValue-?>(Value) {
                    def v := contextValue->(Value)
                    if v.type.isMethod {
                        -- parentheses after a value of method type, need to
                        -- call the method
                        def finalParams:ListView<Value>?
                        finalParams, submessages := prepareMethodParameters(
                                context, v, params)
                        messages := addMessages(messages, submessages)
                        if finalParams != null
                            contextValue := new DynamicCall(v, finalParams)
                        else
                            return (null, null, messages)
                    }
                    else {
                        messages := addMessage(messages, "value of type '" + 
                                v.type.displayName + "' is not a method",
                                contextValue.position)
                        return (null, null, messages)
                    }
                }
                else {
                    assert contextValue != null
                    messages := addMessage(messages, "cannot call method on " +
                            "'\{contextValue.type.displayName}'", 
                            contextValue.position)
                    return (null, null, messages)
                }
            }
            else {
                assert contextValue != null
                assert c[i].type = ParseNodeType.ASSIGNMENT_OPERATOR
                lvalues.add(contextValue)
                var expr, submessages := convertExpression(context, c[i + 1])
                messages := addMessages(messages, submessages)
                def result := new Array<Statement>()
                if expr != null {
                    def assignments:ListView<Statement>?
                    assignments, submessages := processAssignment(context, 
                            lvalues, c[i], expr)
                    if assignments != null
                        result.addAll(assignments)
                    messages := addMessages(messages, submessages)
                }
                return (null, new Block(c.position, result), messages)
            }
        }
        assert contextValue != null
        assert lvalues.length = 0
        def result, submessages := resolve(context, contextValue)
        messages := addMessages(messages, submessages)
        return (result, null, messages)
    }
    @post(@return[0] = null | @return[1] = null)

    ============================================================================
    Processes a CALL_OR_ASSIGNMENT parse node.
    ============================================================================
    @pre(c.type = ParseNodeType.CALL_OR_ASSIGNMENT)
    method convertCallOrAssignment(context:Context, c:ParseNode):
            (Statement?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var contextValue:Value? := null
        if c[0].type = ParseNodeType.CONSTRUCT
            contextValue, messages := convertConstruct(context, c[0])
        else if c[0].type = ParseNodeType.CALL_EXPRESSION {
--            contextValue := convertCallExpression(c[0])
            throw new NotSupportedException("call expression")
        }
        else {
            def id := c[0]->>(String)
            if id = "super"
                contextValue := new Super(c.position)
            else {
                def submessages:ListView<Message>?
                contextValue, submessages := parseBareIdentifier(context, c[0])
                messages := addMessages(messages, submessages)
                if contextValue = null
                    return (null, messages)
            }
        }
        def call, statement, submessages := processCallOrAssignment(context, 
                contextValue, c)
        messages := addMessages(messages, submessages)
        if call != null
            return (new ValueStatement(call), messages)
        else if statement != null
            return (statement, messages)
        else
            return (null, messages)
    }

    ============================================================================
    Processes an IF parse node.
    ============================================================================
    @pre(i.type = ParseNodeType.IF)
    method convertIf(var context:Context, i:ParseNode):
            (If, Context, ListView<Message>?) {
        assert i[0]->(TokenNode).token.type = TokenType.IF
        var messages:ListView<Message>? := null
        var test, submessages := convertExpression(context, i[1])
        messages := addMessages(messages, submessages)
        def cast:Value?
        if test != null {
            cast, submessages := test.implicitCast(context, BitType.BIT)
            messages := addMessages(messages, submessages)
        }
        else
            cast := new Dummy(i[1].position, BitType.BIT)
        assert i[2].type = ParseNodeType.STATEMENT_OR_BLOCK
        def ifBlock:Block
        ifBlock, context, submessages := convertStatementOrBlock(context, i[2])
        messages := addMessages(messages, submessages)
        def elseBlock:Block?
        if i.length > 3 {
            assert i[3]->(TokenNode).token.type = TokenType.ELSE
            elseBlock, context, submessages := convertStatementOrBlock(context, 
                    i[4])
            messages := addMessages(messages, submessages)
        }
        else
            elseBlock := null
        return (new If(i.position, cast, ifBlock, elseBlock), context, messages)
    }

    @private
    method castToIterable(context:Context, value:Value):
            (Value?, ListView<Message>?) {
        def cl := context.getStub(value.type->>(ClassType))
        for intf in cl.allInterfaces(context.stubs.allStubs()) {
            if intf.name.startsWith("panda.collections.Iterable<") {
                def result, messages := value.implicitCast(context, 
                        context.getType(intf))
                return (result, messages)
            }
        }
        def result := new Array<Message>()
        result.add(new Message("expected 'panda.collections.Iterable<T>', " +
                "but found '\{value.type.displayName}'", value.position))
        return (null, result)
    }

    @private
    @pre(t.type = ParseNodeType.FOR_TUPLE)
    method convertForTuple(context:Context, t:ParseNode):
            (ListView<(Position, String?, Type?, ParseNode?)>, 
            ListView<Message>?) {
        def result := new Array<(Position, String?, Type?, 
                ParseNode?)>()
        var messages:ListView<Message>? := null
        var i := 0
        assert t[0]->(TokenNode).token.type = TokenType.LPAREN
        i += 1
        while t[i]->(TokenNode).token.type != TokenType.RPAREN {
            def position := t[i].position
            var name:String?
            if t[i]->(TokenNode).token.type = TokenType.IDENTIFIER
                name := t[i]->>(String)
            else {
                assert t[i]->(TokenNode).token.type = TokenType.UNDERSCORE
                name := null
            }
            i += 1
            def type:Type?
            def typeNode:ParseNode?
            if t[i].type = ParseNodeType.TYPE_DECLARATION {
                typeNode := t[i][1]
                var submessages:ListView<Message>?
                type, submessages := context.getType(typeNode)
                messages := addMessages(messages, submessages)
                i += 1
            }
            else {
                typeNode := null
                type := null
            }
            if t[i]->(TokenNode).token.type = TokenType.COMMA
                i += 1
            result.add((position, name, type, typeNode))
        }
        return (result, messages)
    }

    @private
    function getElementType(value:Value):Type {
        if value.type.isPrimitiveArray
            return value.type.unwrapNullable->(PrimitiveArrayType).elementType
        else {
            assert value.type.name.startsWith("panda.collections.Iterable<")
            return value.type.unwrapNullable->(GenericType).parameters[0]
        }
    }

    ============================================================================
    Processes an ANY_LOOP parse node containing a `for` loop.
    ============================================================================
    @pre(l.type = ParseNodeType.ANY_LOOP)
    method convertForLoop(var context:Context, l:ParseNode, var i:Int, 
            label:String?):(Statement?, Context, ListView<Message>?) {
        var messages:ListView<Message>? := null
        i += 1
        var vars:ListView<(Position, String?, Type?, ParseNode?)>
        if l[i].type = ParseNodeType.FOR_TUPLE {
            var submessages:ListView<Message>?
            vars, submessages := convertForTuple(context, l[i])
            messages := addMessages(messages, submessages)
            i += 1
        }
        else {
            assert l[i]->(TokenNode).token.type = TokenType.IDENTIFIER
            def name := l[i]->>(String)
            def namePosition := l[i].position
            var type:Type? := null
            var typeNode:ParseNode? := null
            i += 1
            if l[i].type = ParseNodeType.TYPE_DECLARATION {
                typeNode := l[i][1]
                var submessages:ListView<Message>?
                type, submessages := context.getType(typeNode)
                messages := addMessages(messages, submessages)
                i += 1
            }
            def newVars := new Array<(Position, String?, Type?, ParseNode?)>()
            newVars.add((namePosition, name, type, typeNode))
            vars := newVars
        }
        var indexPosition:Position? := null
        var indexName:String? := null
        var indexType:Type? := null
        var indexTypeNode:ParseNode? := null
        if l[i]->(TokenNode).token.type = TokenType.COMMA {
            -- we have both an index and a value
            i += 1
            assert vars.length = 1
            indexPosition := vars[0][0]
            indexName := vars[0][1]
            indexType := vars[0][2]
            indexTypeNode := vars[0][3]
            if indexType = null
                indexType := IntType.INT32
            if !indexType.isInteger {
                throw new CompilerException("loop index must be an integer",
                        indexPosition)
            }
            if l[i].type = ParseNodeType.FOR_TUPLE {
                var submessages:ListView<Message>?
                vars, submessages := convertForTuple(context, l[i])
                messages := addMessages(messages, submessages)
                i += 1
            }
            else {
                def position := l[i].position
                def name := l[i]->>(String)
                def type:Type?
                def typeNode:ParseNode?
                i += 1
                if l[i].type = ParseNodeType.TYPE_DECLARATION {
                    typeNode := l[i][1]
                    var submessages:ListView<Message>?
                    type, submessages := context.getType(typeNode)
                    messages := addMessages(messages, submessages)
                    i += 1
                }
                else {
                    type := null
                    typeNode := null
                }
                def newVars := new Array<(Position, String?, Type?, 
                        ParseNode?)>()
                newVars.add((position, name, type, typeNode))
                vars := newVars
            }
        }
        assert l[i]->(TokenNode).token.type = TokenType.IN
        i += 1
        var array, submessages := convertExpression(context, l[i])
        messages := addMessages(messages, submessages)
        if array = null
            return (null, context, messages)
        i += 1
        if array-?>(UnresolvedRange) {
            Console.writeLine("hack, skipping loop")
            return (null, context, null)
        }
        array, submessages := resolveUnresolvedConstructs(context, array)
        messages := addMessages(messages, submessages)
        if array = null
            return (null, context, messages)
        array, submessages := castToIterable(context, array)
        messages := addMessages(messages, submessages)
        if array = null
            return (null, context, messages)
        if vars.length > 1 {
            if !getElementType(array).isTuple {
                throw new CompilerException("'\{array.type.displayName}' " +
                        "is not a tuple", array.position)
            }
            def count := getElementType(array).unwrapNullable->(TupleType)
                    .types.length
            if count != vars.length {
                throw new CompilerException("number of for-loop variables (" + 
                        "\{vars.length}) and tuple elements (\{count}) do " +
                        "not match", l.position)
            }
        }
        var valueName:String?
        var valuePosition := vars[0][0]
        var valueType:Type?
        var valueTypeNode:ParseNode?
        if vars.length = 1 {
            valueName := vars[0][1]
            if valueName = null
                throw new CompilerException("'_' is only permitted in " +
                            "multiple assignments from a tuple", vars[0][0])
            valueType := vars[0][2]
            valueTypeNode := vars[0][3]
            if valueType != null & 
                    !getElementType(array).canImplicitCastTo(context, 
                        valueType) {
                throw new CompilerException("elements of " + 
                        "\{array.type.displayName} cannot be converted to " +
                        valueType.displayName, valuePosition)
            }
        }
        else {
            valueName := "$tuple\{l.position.line}_\{l.position.column}"
            valueType := getElementType(array)
            valueTypeNode := null
        }
        if valueType = null
            valueType := getElementType(array)
        var indexVar:Variable?
        if indexName != null {
            assert indexPosition != null
            assert indexType != null
            indexVar := new LocalVariable(indexPosition, indexName, indexType,
                    VariableType.DEF)
            context += indexVar
        }
        else
            indexVar := null
        def valueVar := new LocalVariable(valuePosition, valueName, valueType,
                VariableType.DEF)
        context += valueVar
        var block:Block?
        block, context, submessages := convertStatementOrBlock(context, l[i])
        if block = null
            return (null, context, messages)
        if vars.length > 1 {
            var newStatements := new Array<Statement>()
            for index, t in vars {
                def position := t[0]
                def name := t[1]
                if name = null
                    continue
                var type := t[2]
                if type = null
                    type := getElementType(array).unwrapNullable->(TupleType).types[index]
                def elementVar := new LocalVariable(t[0], name, type, 
                        VariableType.DEF)
                context += elementVar
                def field:Value?
                field, submessages := getField(context, array.position,
                        new VariableReference(l.position, valueVar), "$field" + 
                        index)
                messages := addMessages(messages, submessages)
                if field = null
                    return (null, context, messages)
                def cast:Value
                cast, submessages := field.implicitCast(context, type)
                messages := addMessages(messages, submessages)
                newStatements.add(new ValueStatement(
                        new VariableAssignment(l.position, elementVar, cast)))
            }
            newStatements.addAll(block.statements)
            block := new Block(block.position, newStatements)
        }
        messages := addMessages(messages, submessages)
        return (new LoopProcessor().createLoop(self, context, l.position, label, 
                indexVar, valueVar, array, block), context, messages)
    }

    ============================================================================
    Processes an ANY_LOOP parse node.
    ============================================================================
    @pre(l.type = ParseNodeType.ANY_LOOP)
    method convertAnyLoop(var context:Context, l:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        def label:String?
        var i := 0
        if l[i]->(TokenNode).token.type = TokenType.IDENTIFIER {
            label := l[i]->>(String)
            assert l[i + 1].type = ParseNodeType.TOKEN &
                    l[i + 1]->(TokenNode).token.type = TokenType.COLON
            i += 2
        }
        else 
            label := null
        switch l[i]->(TokenNode).token.type {
            case TokenType.FOR: {
                def result:Statement?
                def messages:ListView<Message>?
                result, context, messages := convertForLoop(context, l, i, 
                        label)
                return (result, context, messages)
            }

            case TokenType.DO: {
                i += 1
                var messages:ListView<Message>? := null
                assert l[i + 1].type = ParseNodeType.TOKEN &
                        l[i + 1]->(TokenNode).token.type = TokenType.WHILE
                var test, submessages := convertExpression(context, l[i + 2])
                messages := addMessages(messages, submessages)
                def cast:Value?
                if test != null {
                    cast, submessages := test.implicitCast(context, BitType.BIT)
                    messages := addMessages(messages, submessages)
                }
                else
                    cast := new Dummy(l[i + 2].position, BitType.BIT)
                def block:Block
                block, context, submessages := convertStatementOrBlock(context, 
                        l[i])
                messages := addMessages(messages, submessages)
                return (new Do(l.position, label, cast, block), context,
                        messages)
            }
            case TokenType.LOOP: {
                i += 1
                def block:Block
                def messages:ListView<Message>?
                block, context, messages := convertStatementOrBlock(context, 
                        l[i])
                return (new Loop(l.position, label, block), context, messages)
            }
            case TokenType.WHILE: {
                i += 1
                var messages:ListView<Message>? := null
                var test, submessages := convertExpression(context, l[i])
                messages := addMessages(messages, submessages)
                def cast:Value?
                if test != null {
                    cast, submessages := test.implicitCast(context, BitType.BIT)
                    messages := addMessages(messages, submessages)
                }
                else
                    cast := new Dummy(l[i].position, BitType.BIT)
                i += 1
                def block:Block?
                block, context, submessages := convertStatementOrBlock(context, l
                        [i])
                messages := addMessages(messages, submessages)
                return (new While(l.position, label, cast, block), context, messages)
            }
            default: {
                throw new InternalCompilerException("unsupported loop type", 
                        l.position)
            }
        }
    }
    
    ============================================================================
    Processes a VAR_DECLARATION parse node. Returns a list of variables and
    statements to initialize them.
    ============================================================================
    @pre(v.type = ParseNodeType.VAR_DECLARATION)
    method convertVariableDeclaration(var context:Context, v:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def variables := new Array<Variable>()
        def statements := new Array<Statement>()
        def varType:VariableType
        switch v[0]->(TokenNode).token.type {
            case TokenType.VAR:      varType := VariableType.VAR
            case TokenType.DEF:      varType := VariableType.DEF
            case TokenType.CONSTANT: varType := VariableType.CONSTANT
            default: unreachable
        }
        def positions := new Array<Position>()
        def names := new Array<String?>()
        def types := new Array<Type?>()
        var i := 1
        loop {
            positions.add(v[i].position)
            var name:String?
            if v[i]->(TokenNode).token.type = TokenType.UNDERSCORE
                name := null
            else {
                assert v[i]->(TokenNode).token.type = TokenType.IDENTIFIER
                name := v[i]->>(String)
            }
            i += 1
            def type:Type?
            if i < v.length & v[i].type = ParseNodeType.TYPE_DECLARATION {
                def submessages:ListView<Message>?
                type, submessages := context.getType(v[i][1])
                messages := addMessages(messages, submessages)
                i += 1
            }
            else
                type := null
            names.add(name)
            types.add(type)
            if i >= v.length | v[i].type != ParseNodeType.TOKEN | 
                    v[i]->(TokenNode).token.type != TokenType.COMMA
                break
            i += 1
        }
        def value:Value?
        if i < v.length {
            assert v[i]->(TokenNode).token.type = TokenType.ASSIGNMENT
            i += 1
            def submessages:ListView<Message>?
            value, submessages := convertExpression(context, v[i])
            messages := addMessages(messages, submessages)
        }
        else
            value := null
        var reusableTuple:ReusedValueDefinition? := null
        if names.length > 1 {
            if value != null {
                def valueType := value.preferredVariableType
                if !valueType.isTuple | 
                        valueType->>(TupleType).types.length != names.length {
                    messages := addMessage(messages, "expected a tuple with " +
                                "length \{names.length} for multi-value " +
                                "assignment", value.position)
                }
                for j, type in types {
                    if type = null
                        types[j] := valueType->>(TupleType).types[j].preferredVariableType
                }
                if value-!>(UnresolvedTuple)
                    reusableTuple := new ReusedValueDefinition(value)
            }
        }
        else if value != null & types[0] = null
            types[0] := value.preferredVariableType
        if names.length = 1 & names[0] = null {
            messages := addMessage(messages, "'_' is only permitted in " +
                    "multiple assignments from a tuple", positions[0])
        }
        for j, name in names {
            if name = null
                continue
            def position := positions[j]
            var type := types[j]
            if type = null | type = NullType.NULL {
                if messages = null {
                    messages := addMessage(messages, 
                            "'\{name}' has neither an initial " +
                            "value nor an explicit type", position)
                }
                type := ClassType.OBJECT
            }
            def variable := new LocalVariable(position, name, type, varType)
            context += variable
            if value != null {
                def effectiveValue:Value
                if reusableTuple != null {
-*                    effectiveValue := getField(value.position, 
                            reusableTuple.createReference(), "$field" + j).
                                implicitCast(variable.type)*-
                    unreachable
                }
                else if value-?>(UnresolvedTuple) & names.length > 1 {
                    def element := value->(UnresolvedTuple).values[j]
                    def submessages:ListView<Message>?
                    effectiveValue, submessages := element.implicitCast(
                            context, variable.type)
                    messages := addMessages(messages, submessages)
                }
                else {
                    def submessages:ListView<Message>?
                    effectiveValue, submessages := value.implicitCast(
                            context, variable.type)
                    messages := addMessages(messages, submessages)
                }
                def va := new VariableAssignment(position, variable, 
                        effectiveValue, true)
                statements.add(new ValueStatement(va))
            }
        }
        def newContext := context + variables
        if statements.length = 0
            return (null, newContext, messages)
        if statements.length = 1
            return (statements[0], newContext, messages)
        return (new Block(v.position, statements), newContext, messages)
    }

    ============================================================================
    Processes an ASSERT parse node.
    ============================================================================
    @pre(a.type = ParseNodeType.ASSERT_STATEMENT)
    method convertAssert(context:Context, a:ParseNode):
            (Statement?, ListView<Message>?) {
        assert a[0]->(TokenNode).token.type = TokenType.ASSERT
        var test, messages := convertExpression(context, a[1])
        if test = null
            return (null, messages)
        var cast, submessages := test.implicitCast(context, BitType.BIT)
        messages := addMessages(messages, submessages)
        def error:Value?
        if a.length > 2 {
            assert a[2]->(TokenNode).token.type = TokenType.COLON
            def msg:Value?
            msg, submessages := convertExpression(context, a[3])
            messages := addMessages(messages, submessages)
            if msg = null
                return (null, messages)
            if msg.canImplicitCastTo(context, ClassType.SAFETY_ERROR) {
                -- note that we verify it's a SafetyError, but actually cast to
                -- error, since that's what throw expects
                error, submessages := msg.implicitCast(context, ClassType.ERROR) 
                messages := addMessages(messages, submessages)
            }
            else if msg.canImplicitCastTo(context, ClassType.STRING) {
                error, submessages := msg.implicitCast(context,ClassType.STRING) 
                messages := addMessages(messages, submessages)
            }
            else {
                messages := addMessage(messages, 
                        "expected either 'panda.core.String' or " +
                        "'panda.core.SafetyError', but found " +
                        "'\{msg.type.displayName}'", msg.position)
                return (null, messages)
            }
        }
        else
            error := null
        return (new Assert(a.position, cast, error), messages)
    }

    ============================================================================
    Processes a SIMPLE_STATEMENT parse node.
    ============================================================================
    @pre(s.type = ParseNodeType.SIMPLE_STATEMENT)
    method convertSimpleStatement(context:Context, s:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.VAR_DECLARATION: 
                return convertVariableDeclaration(context, s[0])
--            case ParseNodeType.CONSTANT_DECLARATION: 
--                return convertConstantDeclaration(s[0])
            case ParseNodeType.CALL_OR_ASSIGNMENT: {
                def call, messages := convertCallOrAssignment(context, s[0])
                return (call, context, messages)
            }
            case ParseNodeType.ANY_LOOP:  {
                def l, newContext, messages := convertAnyLoop(context, s[0])
                return (l, newContext, messages)
            }
            case ParseNodeType.IF: {
                 def i, newContext, messages := convertIf(context, s[0])
                return (i, newContext, messages)
            }
-*
            case ParseNodeType.SWITCH_STATEMENT: {
                def s, messages := convertSwitch(context, s[0])
                return (convertSwitch(s[0]), context, messages)
            }
*-
            case ParseNodeType.ASSERT_STATEMENT: {
                def a, messages := convertAssert(context, s[0])
                return (a, context, messages)
            }
-*
            case ParseNodeType.TRY_STATEMENT: {
                def t, messages := convertTryStatement(context, s[0])
                return (t, context, messages)
            }*-
            default: throw new InternalCompilerException(
                    "unsupported simple statement: \{s[0].type}", 
                    s.position)
        }
    }

    ============================================================================
    Processes a THROW_STATEMENT parse node.
    ============================================================================
    @pre(t.type = ParseNodeType.THROW_STATEMENT)
    method convertThrowStatement(t:ParseNode):(Throw, ListView<Message>?) {
-*        return new Throw(t.position, implicitCast(t[1].position,
                convertExpression(t[1]), ClassType.ERROR())))*-
        throw new NotSupportedException("throw")
    }

    ============================================================================
    Processes an UNREACHABLE token.
    ============================================================================
    @pre(t->(TokenNode).token.type = TokenType.UNREACHABLE)
    function convertUnreachable(t:ParseNode):Unreachable {
        return new Unreachable(t.position)
    }

    @pre(t.type = ParseNodeType.TERM)
    method convertTuple(context:Context, t:ParseNode):
            (Value?, ListView<Message>?) {
        assert t[0]->(TokenNode).token.type = TokenType.LPAREN
        assert t[t.length - 1]->(TokenNode).token.type = TokenType.RPAREN
        def params := new Array<Value>()
        var messages:ListView<Message>? := null
        var success := true
        for i in 1 ... t.length - 2 by 2 {
            def expr, submessages := convertExpression(context, t[i])
            messages := addMessages(messages, submessages)
            if expr != null
                params.add(expr)
            else
                success := false
            assert i = 1 | t[i - 1]->(TokenNode).token.type = TokenType.COMMA
        }
        if success
            return (new UnresolvedTuple(t.position, params), messages)
        else
            return (null, messages)
    }

    @pre(s.type = ParseNodeType.TERMINAL_STATEMENT)
    method convertTerminalStatement(context:Context, s:ParseNode):
            (Statement, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.BREAK_STATEMENT: {
                def b := s[0]
                if b.length > 1
                    return (new Break(b.position, b[1]->>(String)), null)
                else
                    return (new Break(b.position), null)
            }
            case ParseNodeType.CONTINUE_STATEMENT: {
                def c := s[0]
                if c.length > 1
                    return (new Continue(c.position, c[1]->>(String)), null)
                else
                    return (new Continue(c.position), null)
            }
            case ParseNodeType.RETURN_STATEMENT: {
                def r := s[0]
                if r.length > 1 {
                    def cm := context.currentMethod
                    assert cm != null
                    var value, messages := convertExpression(context, r[1])
                    if value != null {
                        def check := value.checkValid()
                        if check != null {
                            messages := addMessage(messages, check)
                            return (new Return(r.position), messages)
                        }
                        def cast, submessages := value.implicitCast(context, 
                                cm.returnType)
                        messages := addMessages(messages, submessages)
                        return (new Return(r.position, cast), messages)
                    }
                    return (new Return(r.position, new Dummy(r.position,
                            cm.returnType)), messages)
                }
                else
                    return (new Return(r.position), null)
            }
-*            case ParseNodeType.THROW_STATEMENT: {
                def t, messages := convertThrowStatement(context, s[0])
                return (t, messages)
            }*-
            case ParseNodeType.TOKEN: 
                return (convertUnreachable(s[0]), null)
            default: {
                throw new InternalCompilerException(
                        "unsupported terminal statement: \{s[0].class.name}", 
                        s[0].position)
            }
        }
    }

    ============================================================================
    Processes a STATEMENT parse node.
    ============================================================================
    @pre(s.type = ParseNodeType.STATEMENT)
    method convertStatement(context:Context, s:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.SIMPLE_STATEMENT: 
                return convertSimpleStatement(context, s[0])
            case ParseNodeType.BLOCK: {
                def b, newContext, messages := convertBlock(context, s[0])
                return (b, context.addLocalsFrom(newContext), messages)
            }
            default: throw new InternalCompilerException(
                    "unsupported statement: \{s[0].class.name}", s[0].position)
        }
    }

    ============================================================================
    Processes a STATEMENT_OR_BLOCK parse node.
    ============================================================================
    @pre(b.type = ParseNodeType.STATEMENT_OR_BLOCK)
    method convertStatementOrBlock(var context:Context, b:ParseNode):
            (Block, Context, ListView<Message>?) {
        if b[0].type = ParseNodeType.BLOCK {
            def result, newContext, messages := convertBlock(context, b[0])
            return (result, newContext, messages)
        }
        else {
            def statement:Statement?
            def messages:ListView<Message>?
            if b[0].type = ParseNodeType.SIMPLE_STATEMENT {
                statement, context, messages := convertSimpleStatement(context,
                        b[0])
            }
            else
                statement, messages := convertTerminalStatement(context, b[0])
            def statements := new Array<Statement>()
            if statement != null
                statements.add(statement)
            return (new Block(b.position, statements), context, messages)
        }
    }

    ============================================================================
    Processes a BLOCK parse node.
    ============================================================================
    @pre(b.type = ParseNodeType.BLOCK)
    method convertBlock(context:Context, b:ParseNode):
            (Block, Context, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def statements := new Array<Statement>()
        var currentContext := context
        for i in 1 ... b.length - 2 {
            switch b[i].type {
                case ParseNodeType.STATEMENT: {
                    def statement, newContext, submessages := 
                            convertStatement(currentContext, b[i])
                    if statement != null
                        statements.add(statement)
                    currentContext := newContext
                    messages := addMessages(messages, submessages)
                }
                case ParseNodeType.TERMINAL_STATEMENT: {
                    def statement, submessages := convertTerminalStatement(
                            currentContext, b[i])
                    statements.add(statement)
                    messages := addMessages(messages, submessages)
                }
                default: {
                    throw new InternalCompilerException(
                            "unsupported statement in block: \{b[i].class.name}", 
                            b[i].position)
                }
            }
        }
        return (new Block(b.position, statements), currentContext, messages)
    }

    function isConstructorCall(node:Node):Bit {
        if node-!>(ValueStatement)
            return false
        def vs := node->(ValueStatement)
        if vs.value-!>(MethodCall)
            return false
        def mc := vs.value->(MethodCall)
        return mc.methodStub.methodType = MethodNodeType.CONSTRUCTOR
    }

    function callsOtherSelfConstructor(block:Block):Bit {
        return false
    }

    method convertMethod(var context:Context, m:TypedMethodStub):
            (MethodNode, ListView<Message>?) {
        var block:Block?
        var messages:ListView<Message>? := null
        def parameters := new Array<Parameter>()
        for p in m.parameters {
            parameters.add(new Parameter(p.position, p.name, p.type, p.isFinal,
                    p.isConvert, p.isVarArg))
        }
        if m.block != null {
            def visibleVariables := new HashMap<String, Variable>(
                    context.visibleVariables)
            for p in parameters
                visibleVariables[p.name] := p
            def newContext := new Context(context.currentClass, m, 
                    context.lookupContext, context.typeMap, context.stubs,
                    new ImmutableArray<LocalVariable>(),
                    new ImmutableHashMap<String, Variable>(visibleVariables))
            block, context, messages := convertBlock(newContext, 
                    m.block->(ParseNode))
            if m.methodType = MethodNodeType.CONSTRUCTOR & (block.length = 0 | 
                    !isConstructorCall(block[0])) {
                -- add default constructor call
                def supertype := context.currentClass->(TypedClassStub).superclass
                assert supertype != null
                def superclass := context.getStub(supertype)
                def defaultConstructor := superclass.methods.filter(
                        c => c.methodType = MethodNodeType.CONSTRUCTOR &
                            c.parameters.length = 1)
                if defaultConstructor.length = 0 {
                    messages := addMessage(messages, "no explicit call to " +
                            "superclass constructor, and superclass does not " +
                            "have a no-parameter constructor", m.position)
                }
                else {
                    assert defaultConstructor.length = 1
                    def params := new Array<Value>()
                    def cast, submessages := context.getSelf(m.position).
                            implicitCast(context, supertype)
                    messages := addMessages(messages, submessages)
                    params.add(cast)
                    def supercall := new MethodCall(m.position, 
                            defaultConstructor.iterator.next(), true, params)
                    def newBlock := new Array<Statement>()
                    newBlock.add(new ValueStatement(supercall))
                    newBlock.addAll(block.statements)
                    block := new Block(m.position, newBlock)
                }
            }
        }
        else {
            block := null
            messages := null
        }
        if m.methodType = MethodNodeType.CONSTRUCTOR & block != null {
            if !callsOtherSelfConstructor(block) {
                def statements := new Array<Statement>()
                for f in context.currentClass->(TypedClassStub).fields {
                    if f.initialValue != null & !f.annotations.isClass & 
                            !f.annotations.isThread {
                        def value, submessages := convertExpression(context, 
                                f.initialValue->(ParseNode))
                        messages := addMessages(messages, submessages)
                        if value != null {
                            statements.add(new FieldAssignment(m.position,
                                    context.getSelf(m.position), f, value))
                        }
                    }
                }
                statements.addAll(block.statements)
                block := new Block(block.position, statements)
            }
        }
        return (new MethodNode(m.position, m, m.name, m.methodType, parameters, 
                m.returnType, m.annotations, block, context.localVariables), 
                messages)
    }

    method convertClass(cl:TypedClassStub, typeMap:TypeMap, stubs:StubMap):
            (ClassNode, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def methods := new Array<MethodNode>()
        def unresolved := f:FieldNode => f.type-?>(UnresolvedType)
        assert cl.fields.filter(unresolved).length = 0 :
                "\{cl} still has unresolved fields " +
                cl.fields.filter(unresolved)
        for m in cl.methods {
            def context := new Context(cl, null, cl.lookupContext, typeMap, 
                    stubs, new ImmutableArray<LocalVariable>(),
                    new ImmutableHashMap<String, Variable>(
                        new HashMap<String, Variable>()))
            def compiled, submessages := convertMethod(context, m)
            methods.add(compiled)
            messages := addMessages(messages, submessages)
        }
        def result := new ClassNode(cl.position, cl.name, cl.isInterface, 
            cl.annotations, cl.lookupContext, cl.superclass, cl.interfaces, 
            methods, cl.fields, cl.invariants,
            cl.genericParameters)
        return (result, messages)
    }

    method convertClasses(classes:CollectionView<TypedClassStub>,
            typeMap:TypeMap, stubs:StubMap):
            (CollectionView<ClassNode>, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def result := new Array<ClassNode>()
        for cl in classes
            stubs.putStub(cl)
        var previous := stubs.allStubs()
        for cl in classes {
            if cl.genericParameters = null & !cl.isExternal {
                def classNode, submessages := convertClass(cl, typeMap, 
                        stubs)
                result.add(classNode)
                messages := addMessages(messages, submessages)
            }
        }
        loop {
            def current := stubs.allStubs()
            if current.length = previous.length
                break
            for (k, v) in current {
                if previous[k] = null {
                    def cl, submessages := convertClass(v, typeMap, stubs)
                    messages := addMessages(messages, submessages)
                    result.add(cl)
                }
            }
            previous := current
        }
        return (result, messages)
    }
}