package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.parser.ParseNodeType
uses org.pandalanguage.pandac.parser.Token
uses org.pandalanguage.pandac.parser.TokenNode
uses org.pandalanguage.pandac.parser.TokenType
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.And
uses org.pandalanguage.pandac.tree.AndLeft
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.BitwiseAnd
uses org.pandalanguage.pandac.tree.BitwiseNot
uses org.pandalanguage.pandac.tree.BitwiseOr
uses org.pandalanguage.pandac.tree.BitwiseXor
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Divide
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.Equal
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.ForEach
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithRange
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.compiler.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryMinus
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedPrimitiveArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedLambda
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.RealLiteralType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.UnresolvedTypeException
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

================================================================================
Converts a Panda parse tree into an abstract syntax tree. This represents the
vast majority of the compilation effort; at the end of this process, we have
(hopefully) fully comprehended the program and have generated a ready-to-execute
syntax tree, though one which still needs safety analysis (including insertion
of precondition / postcondition checks) and optimization.
================================================================================
class ASTGenerator {
    ============================================================================
    Processes a SIMPLE_STATEMENT parse node.
    ============================================================================
    @class
    @pre(s.type = ParseNodeType.SIMPLE_STATEMENT)
    function convertSimpleStatement(context:Context, s:ParseNode):
            (Statement, Context) {
        assert s.length = 1
        switch s[0].type {
-*            case ParseNodeType.VAR_DECLARATION: 
                return convertVariableDeclaration(s[0])
            case ParseNodeType.CONSTANT_DECLARATION: 
                return convertConstantDeclaration(s[0])
            case ParseNodeType.CALL_OR_ASSIGNMENT: 
                return (convertCallOrAssignment(s[0]), context)
            case ParseNodeType.ANY_LOOP: 
                return (convertAnyLoop(s[0]), context)
            case ParseNodeType.IF: 
                return (convertIf(s[0]), context)
            case ParseNodeType.SWITCH_STATEMENT: 
                return (convertSwitch(s[0]), context)
            case ParseNodeType.ASSERT_STATEMENT: 
                return (convertAssert(s[0]), context)
            case ParseNodeType.TRY_STATEMENT: 
                return (convertTryStatement(s[0]), context)*-
            default: throw new InternalCompilerException(
                    "unsupported simple statement: \{s[0].class.name}", 
                    s.position)
        }
    }

    ============================================================================
    Processes a THROW_STATEMENT parse node.
    ============================================================================
    @class
    @pre(t.type = ParseNodeType.THROW_STATEMENT)
    function convertThrowStatement(context:Context, t:ParseNode):Throw {
-*        return new Throw(t.position, implicitCast(t[1].position,
                convertExpression(t[1]), ClassType.ERROR())))*-
        throw new NotSupportedException()
    }

    ============================================================================
    Processes an UNREACHABLE token.
    ============================================================================
    @class
    @pre(t->(TokenNode).token.type = TokenType.UNREACHABLE)
    function convertUnreachable(context:Context, t:ParseNode):Unreachable {
        return new Unreachable(t.position)
    }

    @class
    @pre(s.type = ParseNodeType.TERMINAL_STATEMENT)
    function convertTerminalStatement(context:Context, s:ParseNode):Statement {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.BREAK_STATEMENT: {
                def b := s[0]
                if b.length > 1
                    return new Break(b.position, b[1]->>(String))
                else
                    return new Break(b.position)
            }
            case ParseNodeType.CONTINUE_STATEMENT: {
                def c := s[0]
                if c.length > 1
                    return new Continue(c.position, c[1]->>(String))
                else
                    return new Continue(c.position)
            }
            case ParseNodeType.RETURN_STATEMENT: {
                def r := s[0]
                if r.length > 1 {
                    throw new NotSupportedException()
-*                    def cm := currentMethod
                    assert cm != null
                    return new Return(r.position, 
                            implicitCast(r[1].position, convertExpression(r[1]), 
                                    cm.returnType)))*-
                }
                else
                    return new Return(r.position)
            }
            case ParseNodeType.THROW_STATEMENT: 
                return convertThrowStatement(context, s[0])
            case ParseNodeType.TOKEN: 
                return convertUnreachable(context, s[0])
            default: {
                throw new InternalCompilerException(
                        "unsupported terminal statement: \{s[0].class.name}", 
                        s[0].position)
            }
        }
    }

    ============================================================================
    Processes a STATEMENT parse node.
    ============================================================================
    @class
    @pre(s.type = ParseNodeType.STATEMENT)
    function convertStatement(context:Context, s:ParseNode):
            (Statement, Context) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.SIMPLE_STATEMENT: 
                return convertSimpleStatement(context, s[0])
            case ParseNodeType.BLOCK: 
                return (convertBlock(context, s[0]), context)
            default: throw new InternalCompilerException(
                    "unsupported statement: \{s[0].class.name}", s[0].position)
        }
    }

    ============================================================================
    Processes a STATEMENT_OR_BLOCK parse node.
    ============================================================================
    @class
    @pre(b.type = ParseNodeType.STATEMENT_OR_BLOCK)
    function convertStatementOrBlock(context:Context, b:ParseNode):Block {
        if b[0].type = ParseNodeType.BLOCK
            return convertBlock(context, b[0])
        else {
            def statement:Statement
            if b[0].type = ParseNodeType.SIMPLE_STATEMENT
                statement := convertSimpleStatement(context, b[0])[0]
            else
                statement := convertTerminalStatement(context, b[0])
            return new Block(context, b.position, [statement])
        }
    }

    ============================================================================
    Processes a BLOCK parse node.
    ============================================================================
    @class
    @pre(b.type = ParseNodeType.BLOCK)
    function convertBlock(context:Context, b:ParseNode):Block {
        def statements := new Array<Statement>()
        var currentContext := context
        for i in 1 ... b.length - 2 {
            switch b[i].type {
                case ParseNodeType.STATEMENT: {
                    def statement, newContext := convertStatement(currentContext, 
                            b[i])
                    statements.add(statement)
                    currentContext := newContext
                }
                case ParseNodeType.TERMINAL_STATEMENT: {
                    statements.add(convertTerminalStatement(currentContext, 
                            b[i]))
                }
                default: {
                    throw new InternalCompilerException(
                            "unsupported statement in block: \{b[i].class.name}", 
                            b[i].position)
                }
            }
        }
        return new Block(context, b.position, statements)
    }
}