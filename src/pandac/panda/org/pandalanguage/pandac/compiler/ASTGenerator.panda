package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.TypeMap
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.parser.ParseNodeType
uses org.pandalanguage.pandac.parser.Token
uses org.pandalanguage.pandac.parser.TokenNode
uses org.pandalanguage.pandac.parser.TokenType
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.stubs.TypedCompilationUnitStub
uses org.pandalanguage.pandac.stubs.TypedFormalParameter
uses org.pandalanguage.pandac.stubs.TypedMethodStub
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Divide
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.Equal
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.ForEach
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodCallStatement
uses org.pandalanguage.pandac.tree.MethodCallValue
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithRange
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryOperation
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedLambda
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.RealLiteralType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.UnresolvedTypeException
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class Context : Immutable {
    def currentClass:TypedClassStub?

    def currentMethod:TypedMethodStub?

    def stubs:ImmutableHashMap<String, TypedClassStub>

    def lookupContext:LookupContext

    def typeMap:TypeMap

    def localVariables:ImmutableArray<LocalVariable>

    def visibleVariables:ImmutableHashMap<String, Variable>

    constructor(currentClass:TypedClassStub?, currentMethod:TypedMethodStub?,
            lookupContext:LookupContext, typeMap:TypeMap, 
            stubs:ImmutableHashMap<String, TypedClassStub>,
            localVariables:ImmutableArray<LocalVariable>,
            visibleVariables:ImmutableHashMap<String, Variable>) {
        self.currentClass := currentClass
        self.currentMethod := currentMethod
        self.lookupContext := lookupContext
        self.typeMap := typeMap
        self.stubs := stubs
        self.localVariables := localVariables
        self.visibleVariables := visibleVariables
    }

    function isInstance():Bit {
        return currentMethod != null & !currentMethod.annotations.isClass
    }

    function getVariable(name:String):Variable? {
        var result := visibleVariables[name]
        if result != null
            return result
        if currentClass != null 
            return currentClass.getField(self, name)
        return null
    }

    @private
    constant VARARG_COST := 1

    constant CONVERT_COST := 10
    
    function canConvert(v:Value, t:Type):Bit {
        return false
    }

    function matchCost(m:TypedMethodStub, params:ListView<Value>):Int? {
        if m.methodType = MethodNodeType.CONSTRUCTOR & params.length > 0 &
                m.parameters[0].type != params[0].type {
            -- constructor called on mismatched type means we're in a subclass,
            -- and since constructors are not inherited we need to ignore it
            return null
        }
        var result := 0
        var methodParams:ListView<TypedFormalParameter> := m.parameters
        var isVarArg := methodParams.length > 0 & 
                methodParams[methodParams.length - 1].isVarArg
        if isVarArg
            result += VARARG_COST
        if params.length > 0 & params[params.length - 1]-?>(Unwrap) {
            -- we handle unwrap parameters (such as the call foo(bar, baz...))
            -- by simply turning off varargs; the last parameter is already an
            -- array and we just let it be treated as such
            isVarArg := false
        }
        if isVarArg {
            -- strip off vararg parameter, it's not required
            def newParams := new Array<TypedFormalParameter>()
            for i in 0 .. m.parameters.length - 1
                newParams.add(m.parameters[i])
            methodParams := newParams
        }
        -- do we have the right number of parameters?
        if !isVarArg & params.length != methodParams.length | 
                isVarArg & params.length < methodParams.length
            return null

        for i, param in methodParams {
            if i = 0 & !m.annotations.isClass
                continue
            def targetType := param.type
            def cost := params[i].implicitCastCost(targetType)
            if cost = null {
                if methodParams[i].isConvert & 
                        canConvert(params[i], targetType)
                    result += CONVERT_COST
                else
                    return null
            }
            else
                result += cost
        }
        
        if isVarArg {
            -- verify that all remaining parameters match the vararg
            def varArg := m.parameters[m.parameters.length - 1]
            def varArgType := varArg.type->>(PrimitiveArrayType).elementType
            for i in methodParams.length .. params.length {
                def cost := params[i].implicitCastCost(varArgType)
                if cost = null {
                    if varArg.isConvert & 
                            canConvert(params[i], varArgType)
                        result += CONVERT_COST
                    else
                        return null
                }
                else
                    result += cost
            }
        }
        return result
    }

    function getMethodsNamed(name:String, searchClass:TypedClassStub):
            CollectionView<TypedMethodStub> {
        return searchClass.methods.filter(m => m.name = name)
    }

    function getMethod(contextValue:Value?, name:String, 
            params:ListView<Value>):TypedMethodStub? {
        def searchClass:TypedClassStub
        if contextValue != null {
            if contextValue-?>(ClassLiteral)
                searchClass := getStub(contextValue->(ClassLiteral).value)
            else
                searchClass := getStub(contextValue.type->>(ClassType))
        }
        else
            searchClass := currentClass->(TypedClassStub)
        def methods := getMethodsNamed(name, searchClass)
        var maxCost := Int.MAX
        var max:TypedMethodStub? := null
        for m in methods {
            def cost := matchCost(m, params)
            if cost != null & cost < maxCost {
                maxCost := cost
                max := m
            }
        }
        return max
    }

    @pre(currentClass != null)
    method currentClassType():ClassType {
        return getType(currentClass->(TypedClassStub))
    }

    @pre(isInstance)
    function getSelf(position:Position):Value {
        def selfVar := visibleVariables[Parameter.SELF_NAME]
        assert selfVar != null
        return new VariableReference(position, selfVar)
    }

    method getWrapper(t:PrimitiveType):WrapperType {
        return getRequiredType(t.name + "Wrapper")->(WrapperType)
    }

    function getStub(t:ClassType):TypedClassStub {
        def result := stubs[t.name]
        assert result != null : "missing stub for \{t}"
        return result
    }

    @pre(currentClass != null)
    method getType(cl:TypedClassStub):ClassType {
        return getRequiredType(cl.name)->(ClassType)
    }

    @pre(t.type = ParseNodeType.TYPE)
    method getType(t:ParseNode):(Type?, ListView<Message>?) {
        return typeMap.getType(t, lookupContext)
    }

    method getType(name:String, position:Position):
            (Type?, ListView<Message>?) {
        def node := new PandaParser().parseType(name, position)
        return typeMap.getType(node, lookupContext)
    }

    method getRequiredType(name:String):Type {
        def node := new PandaParser().parseType(name, Position.INTERNAL)
        def result, messages := typeMap.getType(node, lookupContext)
        if result = null {
            assert messages != null
            throw new InternalCompilerException(messages.join("\n"))
        }
        return result
    }

    function +(v:Variable):Context {
        def newVisibleVariables := new HashMap<String, Variable>(
                visibleVariables)
        newVisibleVariables[v.name] := v
        def newLocalVariables:ImmutableArray<LocalVariable>
        if v-?>(LocalVariable) {
            def temp := new Array<LocalVariable>(localVariables)
            temp.add(v->(LocalVariable))
            newLocalVariables := new ImmutableArray<LocalVariable>(temp)
        }
        else
            newLocalVariables := localVariables
        return new Context(currentClass, currentMethod, lookupContext, typeMap,
                stubs, newLocalVariables, 
                new ImmutableHashMap<String, Variable>(newVisibleVariables))
    }

    function +(variables:ListView<Variable>):Context {
        def newVisibleVariables := new HashMap<String, Variable>(
                visibleVariables)
        for v in variables
            newVisibleVariables[v.name] := v
        def newLocalVariables := new Array<LocalVariable>(localVariables)
        for v in variables {
            if v-?>(LocalVariable)
                newLocalVariables.add(v->(LocalVariable))
        }
        return new Context(currentClass, currentMethod, lookupContext, typeMap,
                stubs, new ImmutableArray<LocalVariable>(newLocalVariables), 
                new ImmutableHashMap<String, Variable>(newVisibleVariables))
    }

    function addLocalsFrom(other:Context):Context {
        def newLocals := new Array<LocalVariable>(localVariables)
        newLocals.addAll(other.localVariables)
        return new Context(currentClass, currentMethod, lookupContext, typeMap,
                stubs, new ImmutableArray<LocalVariable>(newLocals), 
                visibleVariables)
    }
}

================================================================================
A placeholder object which stands in for a `Value`, generally so we can perform
method lookup without having to have actual correct `Value`s.
================================================================================
class Dummy : Value {
    constructor(position:Position, type:Type) {
        super.constructor(position, type)
    }

    @override
    function format(fmt:String):String {
        return "Dummy<\{type.displayName}>"
    }
}

================================================================================
A reference to a field which could, depending on context, also refer to a no-arg
function of the same name.
================================================================================
@private
class AmbiguousReference : Value {
    def contextValue:Value
    def field:FieldNode

    constructor(position:Position, contextValue:Value, field:FieldNode) {
        super.constructor(position, new UnresolvedType(field.name, position))
        self.contextValue := contextValue
        self.field := field
    }
}

================================================================================
Represents an element of a shared tuple, for initializing several fields from 
the same value.
================================================================================
@private
class TupleReference {
    var tuple:ParseNode
    var element:Int

    constructor(tuple:ParseNode, element:Int) {
        self.tuple := tuple
        self.element := element
    }
}

================================================================================
Used to represent something that looks like an array index (foo[bar]) but can't
actually be resolved into something meaningful. We do this because if the next
token we run into is a ":=", the expression could still resolve into an indexed
assignment.
================================================================================
@private
class PossibleIndexedAssignment : Value {
    def contextValue:Value
    def index:Value

    constructor(position:Position, contextValue:Value, index:Value) {
        super.constructor(position, new UnresolvedType("<index>", position))
        self.contextValue := contextValue
        self.index := index
    }
}

================================================================================
Used to represent something that looks like an slice (foo[bar .. baz]) but can't
actually be resolved into something meaningful. We do this because if the next
token we run into is a ":=", the expression could still resolve into a slice
assignment.
================================================================================
@private
class PossibleSliceAssignment : Value {
    def contextValue:Value
    def left:Value
    def right:Value
    def step:Value
    def endInclusive:Bit

    constructor(position:Position, contextValue:Value, left:Value, right:Value,
            step:Value, endInclusive:Bit) {
        super.constructor(position, new UnresolvedType("<slice>", position))
        self.contextValue := contextValue
        self.left := left
        self.right := right
        self.step := step
        self.endInclusive := endInclusive
    }
}

================================================================================
Converts typed stubs into AST nodes.
================================================================================
class ASTGenerator : Immutable (MessageProcessor) {
    constant INDEX_SUFFIX := "$index"

    constant AUTO_PREFIX := "$auto_"

    constant SHIM_PREFIX := "$shim_"

    constant STRING_GROUP := #/(?<!\\)\\\{.*?(?<!\\)\}/#

    constant UNESCAPED_BRACE := #/(?<!\\)\{/#

    @private
    constructor() {
    }

    -- FIXME switch to built-in string parser when it exists
    @pre(base >= 2 & base <= 36)
    function parseInt(s:String, base:UInt):UInt64? {
        var result:UInt64 := 0
        constant DIGITS := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        constant DIGITS_LOWER := "0123456789abcdefghijklmnopqrstuvwxyz"
        for i in 0 .. s.length {
            var digit := DIGITS.indexOf(s[i])->(UInt?)
            if digit = null
                digit := DIGITS_LOWER.indexOf(s[i])->(UInt?)
            if digit = null | digit >= base
                return null
            result := result * base + digit
        }
        return result
    }
    
    @pre(t.type = TokenType.NUMBER)
    method parseNumericLiteral(context:Context, t:Token):
            (Value, ListView<Message>?) {
        def value:UInt64?
        if t.text.startsWith("0x") | t.text.startsWith("0X")
            value := parseInt(t.text[2..], 16)
        else if t.text.startsWith("0b") | t.text.startsWith("0B")
            value := parseInt(t.text[2..], 2)
        else
            value := t.text->>(UInt64?)
        if value != null
            return (new IntegerLiteral(t.position, value), null)
        else {
            def real := t.text->>(Real64?)
            if real != null
                return (new RealLiteral(t.position, real), null)
            else {
                return (new IntegerLiteral(t.position, 0), 
                        wrap(new Message("invalid numeric literal", t.position)))
            }
        }
    }

    ============================================================================
    Given a sequence of chars from a string literal (e.g. "Hello\n!"), returns a
    string representing the contents of the literal (e.g. "Hello<newline>!")

    If `interpolating` is true, permits the additional escape sequences `\:`,
    `\{`, and `\}`, passing them through unmodified.
    ============================================================================
    method convertStringChars(position:Position, s:String, 
            interpolating:Bit):(String?, ListView<Message>?) {
        var result := new MutableString()
        var i := 0
        loop {
            var next := s.indexOf("\\", i)
            if next = null {
                result.append(s[i..])
                break
            }
            result.append(s[i .. next])
            var c := s[next + 1]
            switch c {
                case "n":  result.append("\n")
                case "r":  result.append("\r")
                case "t":  result.append("\t")
                case '"':  result.append('"')
                case "\\": {
                    result.append("\\")
                    if interpolating
                        result.append("\\")
                }
                case "'":  result.append("'")
                case ":", "{", "}": {
                    if interpolating {
                        result.append("\\")
                        result.append(c)
                    }
                    else {
                        return (null, wrap(new Message("invalid string escape " +
                                "'\\" + c + "'", 
                                new Position(position.compilationUnit, 
                                    position.line, position.column + i))))
                    }
                }
                default: 
                    return (null, wrap(new Message("invalid string escape '\\" + c + 
                            "'", new Position(position.compilationUnit, 
                                position.line, position.column + i))))
            }
            i := next + 2
        }
        return (result->>(String), null)
    }

    @pre(t.type = TokenType.STRING)
    method parseStringLiteral(context:Context, t:Token):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var s := t.text[1 .. t.text.length - 1]
        def result := new MutableString()
        def matcher := STRING_GROUP.matcher(s)
        def values := new Array<Value>()
        var lastEnd := 0
        while matcher.find() {
            var chars, submessages := convertStringChars(t.position,
                    s[lastEnd .. matcher.start], false)
            messages := addMessages(messages, submessages)
            if chars != null {
                result.append(chars.replace(UNESCAPED_BRACE, 
                        "\\{"))
            }
            def text := s[matcher.start + 2 .. matcher.end - 1]
            var expr, remaining := new PandaParser().parseExpressionWithExtraText(
                    text, t.position)
            def value:Value?
            value, submessages := convertExpression(context, expr)
            messages := addMessages(messages, submessages)
            if value = null
                return (null, messages)
            values.add(value)
            result.append("{" + 
                    convertStringChars(t.position, remaining, true) + "}")
            lastEnd := matcher.end()
        }
        if lastEnd > 0 {
            def chars, submessages := convertStringChars(t.position,
                    s[lastEnd..], false)
            messages := addMessages(messages, submessages)
            if chars != null
                result.append(chars.replace(UNESCAPED_BRACE, "\\{"))
            s := result->>(String)
            values.insert(0, new StringLiteral(t.position, s))
            def string := context.getRequiredType(class(String).name)
            return call(context, t.position, new ClassLiteral(context, 
                    t.position, string->(ClassType)), "format", values)
        }
        else {
            def chars, submessages := convertStringChars(t.position, s, false)
            messages := addMessages(messages, submessages)
            if chars = null
                return (null, messages)
            return (new StringLiteral(t.position, chars), messages)
        }
    }

    method isAccessible(context:Context, f:FieldNode):Bit {
        return true
    -*
        var cl := currentClass
        assert cl != null
        if cl.type()-?>(GenericType) {
            -- we've already performed access checks for the unspecified version
            -- of this class, and the specified version could be (legally) 
            -- accessing private members of the unspecified version
            return true
        }
        def a := f.annotations
        if a.isPrivate {
            while cl.containingClass != null
                cl := cl.containingClass->(ClassNode)
            def targetClass := f.owner
            def c1 := cl.parent
            def c2 := targetClass.parent
            return c1 = c2
        }
        else if a.isProtected {
            def cm := currentMethod
            assert cm != null
            var caller := cm.parent->(ClassNode?)
            while caller != null & caller.containingClass != null
                caller := caller.containingClass
            var callee := f.parent->(ClassNode)
            while caller != null {
                if caller = callee
                    return true
                caller := caller.superclass
            }
            return false
        }
        return true*-
    }

    @private
    method createFieldReference(context:Context, position:Position, 
            var contextValue:Value, f:FieldNode, 
            allowNoArgFunctions:Bit):Value {
        def annotations := f.annotations
        if allowNoArgFunctions {
            def name := f.name
            def m := context.currentMethod
            assert m != null
            def unresolved := new Unresolved(position, contextValue, name)
            def noArg := resolveNoArgFunction(context, unresolved)
            if noArg != null
                return new AmbiguousReference(position, contextValue, f)
        }
        def result := new FieldReference(position, contextValue, f)
        return result
    }

    method getField(context:Context, position:Position, var contextValue:Value,
            var name:String):(Value?, ListView<Message>?) {
        return getField(context, position, contextValue, name, true)
    }

    method getField(context:Context, position:Position, var contextValue:Value,
            var name:String, allowNoArgFunctions:Bit):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        if name = "class"
            name := "$class"
        var cl:TypedClassStub
        if contextValue.type = StringOrCharType.STRING_OR_CHAR {
            def submessages:ListView<Message>?
            contextValue, submessages := contextValue.implicitCast(position, CharType.CHAR)
        }
        if contextValue-!>(Super) {
            var submessages:ListView<Message>?
            contextValue, submessages := resolveUnresolvedConstructs(context, 
                    contextValue)
            messages := addMessages(messages, submessages)
            if contextValue.type.isPrimitive {
                def casted:Value?
                casted, submessages := contextValue.implicitCast(position, 
                            context.getWrapper(contextValue.type->>(PrimitiveType)))
                messages := addMessages(messages, submessages)
                if casted = null
                    return (null, messages)
                return getField(context, position, casted, name, 
                        allowNoArgFunctions)
            }
            else {
                var contextValueClass := context.getStub(
                        contextValue.type->>(ClassType))
                cl := contextValueClass
            }
            if contextValue-!>(ClassLiteral) {
                def fields := cl.instanceFields(context.stubs)
                -- need to search backwards since ancestor classes are at the
                -- beginning of the array, and we may be shadowing fields
                for i in fields.length - 1  ... 0 by -1 {
                    def f := fields[i]
                    if f.name = name & !f.annotations.isClass &
                            !f.annotations.isThread & isAccessible(context, f) {
                        if contextValue-?>(UnresolvedClassLiteral) {
                            contextValue := new ClassObjectLiteral(context,
                                    contextValue.position,
                                    contextValue->(UnresolvedClassLiteral).value)
                        }
                        return (createFieldReference(context, position, 
                                contextValue, f, allowNoArgFunctions), messages)
                    }
                }
            }
            if contextValue-?>(UnresolvedClassLiteral) {
                contextValue := new ClassLiteral(context,
                        contextValue.position,
                        contextValue->(UnresolvedClassLiteral).value)
            }
            if contextValue-?>(ClassLiteral) {
                var type := contextValue->(ClassLiteral).value
                if type.isPrimitive
                    type := context.getWrapper(type->>(PrimitiveType))
                cl := context.getStub(type->>(ClassType))
                for f in cl.fields {
                    if f.name = name & (f.annotations.isClass |
                            f.annotations.isThread) &
                            isAccessible(context, f) {
                        return (createFieldReference(context, position, 
                                contextValue, f, allowNoArgFunctions), messages)
                    }
                }
            }
        }
        return (new Unresolved(position, contextValue, name), messages)
    }

    @pre(e.type = ParseNodeType.TERM)
    method convertTerm(context:Context, e:ParseNode):(Value?, ListView<Message>?) {
        switch e[0].type {
            case ParseNodeType.TOKEN: {
                switch e[0]->(TokenNode).token.type {
                    case TokenType.STRING: {
                        return parseStringLiteral(context, 
                                e[0]->(TokenNode).token)
                    }
                    case TokenType.NUMBER: {
                        def value, messages := parseNumericLiteral(context, 
                                e[0]->(TokenNode).token)
                        return (value, messages)
                    }
                    case TokenType.TRUE:
                        return (new BitLiteral(e[0].position, 
                                e[0]->(TokenNode).token->>(String)->>(Bit)), 
                                null)
                    case TokenType.FALSE:
                        return (new BitLiteral(e[0].position, 
                                e[0]->(TokenNode).token->>(String)->>(Bit)),
                                null)
                    case TokenType.NULL:
                        return (new NullLiteral(e[0].position), null)
                    case TokenType.IDENTIFIER, TokenType.SELF:
                        if e.length = 1
                            return parseBareIdentifier(context, e[0])
                        else
--                            return convertLambda(context, e)
                            throw new NotSupportedException()
                    case TokenType.CLASS:
                        return parseBareIdentifier(context, e[0])
                    case TokenType.LPAREN: {
                        if e[2]->(TokenNode).token.type = TokenType.COMMA
--                            return convertTuple(e)
                            throw new NotSupportedException()
                        assert e[2]->(TokenNode).token.type = TokenType.RPAREN
                        return convertExpression(context, e[1])
                    }
                    case TokenType.PLUGIN: 
                        --return convertPlugin(context, e[0].position, e[0]->>(String))
                        throw new NotSupportedException()
                    case TokenType.SUPER: 
                        return (new Super(e[0].position), null)
                    case TokenType.ATRETURN: {
-*                        def returnValue := self.returnValue
                        if returnValue != null
                            return returnValue.createReference()
                        else {
                            return (null, wrap(new Message("@return may only " +
                                    "appear within @post(...) in methods " +
                                    "which return a value", e[0].position)))
                        } *-
                        throw new NotSupportedException()
                    }
                    case TokenType.PRE: {
-*                        if !inPostcondition {
                            return (null, wrap(new Message("@pre(...) " +
                                    "expressions may only appear " +
                                    "within @post(...)", e.position)))
                        }
                        assert e[1]->(TokenNode).token.type = TokenType.LPAREN
                        var expr := convertExpression(context, e[2])
                        var cm := currentMethod
                        assert cm != null
                        var mainBlock := cm.block
                        -- add a dummy object, will replace it as we slide other
                        -- nodes down
                        mainBlock.children.append(new Dummy(VoidType.VOID))
                        for i in mainBlock.length - 1 ... 1 by -1
                            mainBlock[i] := mainBlock[i - 1]
                        var statement := new ValueStatement(e.position, expr)
                        mainBlock[0] := statement
                        statement.parent := mainBlock
                        assert e[3]->(TokenNode).token.type = TokenType.RPAREN
                        def reused := makeReusable(expr)
                        return reused.createReference() *-
                        throw new NotSupportedException()
                    }
                    default: throw new CompilerException(
                                "unsupported term: '\{e[0]->(TokenNode).token}'", 
                                e[0].position)
                }
            }
            case ParseNodeType.CLASS_LITERAL: {
                def literal := e[0]
                assert literal[0]->(TokenNode).token.type = TokenType.CLASS
                assert literal[1]->(TokenNode).token.type = TokenType.LPAREN
                assert literal[2].type = ParseNodeType.TYPE
                assert literal[3]->(TokenNode).token.type = TokenType.RPAREN
                def type, messages := context.getType(literal[2])
                if type != null {
                    return (new ClassObjectLiteral(context, literal.position, 
                            type), messages)
                }
                else
                    return (null, messages)
            }
            case ParseNodeType.CONSTRUCT:
                return convertConstruct(context, e[0])
--            case ParseNodeType.ARRAY_LITERAL:
--                return convertPrimitiveArrayLiteral(context, e[0])
--            case ParseNodeType.METHOD_VALUE:
--                return convertMethodValue(context, e[0])
-*            case ParseNodeType.TYPE: {
                var typeName := e[0]->>(String).replace(#/\s+/#, "")
                var type := getType(e[0].position, typeName)
                return new UnresolvedClassLiteral(e[0].position, type)
            }*-
--            case ParseNodeType.LAMBDA:
--                return convertLambda(context, e[0])
            default: throw new CompilerException(
                    "unsupported term: '\{e[0].type}'", 
                    e.position)
        }
    }

    @pre(e.type = ParseNodeType.CALL_EXPRESSION)
    method convertCallExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var value, submessages := convertTerm(context, e[0])
        messages := addMessages(messages, submessages)
        if value = null
            return (null, messages)
        if e.length > 1 {
            def statement:Statement?
            value, statement, submessages := processCallOrAssignment(context, 
                    value, e)
            assert statement = null
            messages := addMessages(messages, submessages)
            if value = null
                return (null, submessages)
        }
        return resolve(context, value)
    }

    @pre(e.type = ParseNodeType.EXPONENT_EXPRESSION)
    method convertExponentExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var left, leftMessages := convertCallExpression(context, e[0])
        messages := addMessages(messages, leftMessages)
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i]->(TokenNode).token.type = TokenType.POW
            def right, rightMessages := convertCallExpression(context, e[i + 1])
            messages := addMessages(messages, rightMessages)
            if right = null
                return (null, messages)
            left, leftMessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, leftMessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }

    @pre(e.type = ParseNodeType.UNARY_EXPRESSION)
    method convertUnaryExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var exp, submessages := convertExponentExpression(context, 
                e[e.length - 1])
        messages := addMessages(messages, submessages)
        if exp = null
            return (null, messages)
        if e[0].type = ParseNodeType.UNARY_OPERATOR {
            def op := e[0][0]->(TokenNode).token.type
            switch op {
                case TokenType.SUB: {
                    if exp-?>(RealLiteral) {
                        exp := new RealLiteral(exp.position, 
                                -(exp->(RealLiteral).value))
                    }
                    else {
                        if exp.type.isWrapper {
                            exp, submessages := exp.implicitCast(exp.type->>(PrimitiveType))
                            messages := addMessages(messages, submessages)
                        }
                        if exp.type.isNumber {
                            exp := new UnaryOperation(e.position, 
                                    UnaryOperationType.MINUS, exp)
                        }
                        else {
                            return (null, wrap(new Message("expected a number, " +
                                    "but found '\{exp.type.displayName}'", e.position)))
                        }
                    }
                }
                case TokenType.NOT: {
                    exp, submessages := exp.implicitCast(BitType.BIT)
                    messages := addMessages(messages, submessages)
                    exp := new UnaryOperation(e.position, UnaryOperationType.NOT,
                            exp)
                }
                case TokenType.BITWISENOT: {
                    if exp.type.isWrapper {
                        exp, submessages := exp.implicitCast(exp.type->>(PrimitiveType))
                        messages := addMessages(messages, submessages)
                    }
                    if exp.type.isInteger {
                        if exp.type->>(PrimitiveType).size < 4 {
                            if exp.type->(IntType).signed {
                                exp, submessages := 
                                        exp.implicitCast(IntType.INT32)
                            }
                            else {
                                exp, submessages := 
                                        exp.implicitCast(IntType.UINT32)
                            }
                            messages := addMessages(messages, submessages)
                        }
                        exp := new UnaryOperation(e.position, 
                                UnaryOperationType.BITWISE_NOT, exp)
                    }
                    else {
                        return (null, wrap(new Message("expected an integer, " +
                                "but found '\{exp.type.displayName}'", 
                                e.position)))
                    }
                }
                default: {
                    throw new InternalCompilerException("unknown unary " +
                            "operator: '\{op}'", e.position)
                }
            }
        }
        return (exp, messages)
    }

    ============================================================================
    As implicitCast, but with the ability to toggle whether we care about 
    signedness. If `signMatters` is false, the signedness is not considered
    important and will not stop a cast that would normally not be allowed.

    Note that the source and destination types are not necessarily integers; if
    not, we ignore the signMatters flag altogether and just perform a normal
    implicitCast.
    ============================================================================
    @private
    method signMattersCast(position:Position, v:Value, t:Type, 
            signMatters:Bit):(Value, ListView<Message>?) {
        if !signMatters {
            def srcType := v.type->>(PrimitiveType)
            if srcType.isInteger & t.isInteger & 
                    srcType->(IntType).signed != t->(IntType).signed & 
                    srcType->>(PrimitiveType).size <= t->>(PrimitiveType).size {
                return v.explicitCast(t)
            }
        }
        return v.implicitCast(t)
    }
    
    ============================================================================
    Looks for an overloaded version of `name` (which could be `"="`, `"+"`, 
    etc.) and returns a call to it, or `null` if no such overloaded operator was
    found.
    
    @param position the position of the call in the source code
    @param name the name of the method to call
    @param left the left argument
    @param right the right argument
    @returns a method call, or `null`
    ============================================================================
    method callOverloadedOperator(position:Position, var name:String, 
            var left:Value, var right:Value):Value? {
-*        left := resolveUnresolvedConstructs(left)
        right := resolveUnresolvedConstructs(right)
        -- avoid calling the various "fake" operators we define in the wrapper
        -- classes
        if name = "=" | name = "!=" {
            if left.type.isPrimitive & right.type.isPrimitive
                return null
        }
        else if !name.startsWith("[") & (left.type.isNumber | 
                left.type.isWrapper) & (right.type.isNumber | 
                right.type.isWrapper)
            return null
        if left.type = NullType.NULL | right.type = NullType.NULL
            return null -- force this to be compiled as ==, which is quicker 
                        -- than calling nullableEquals.
        if name != "=" {
            if left.type = StringOrCharType.STRING_OR_CHAR
                return callOverloadedOperator(position, name, 
                    implicitCast(left.position, left, ClassType.STRING()), 
                    right)
            if right.type = StringOrCharType.STRING_OR_CHAR
                return callOverloadedOperator(position, name, 
                    left, implicitCast(right.position, right, 
                    ClassType.STRING()))
        }

        var rawName := name
        -- map != and !== to = and ==. We'll invert the answer on return.
        if name.startsWith("!")
            name := name[1..]
        var result:Value? := null
        var parameters := new PrimitiveArray<Value>(left, right)
        if name = "=" & (left.type.isNullable | right.type.isNullable) {
            -- for equality, if one or both parameters are null, we need to
            -- funnel this through Panda.nullableEquals
            var panda := ClassType.PANDA().classNode
            var op := panda.symbolTable.getMethod(position, "nullableEquals", 
                    parameters, true)
            assert op != null
            result := call(position, op, false, parameters)
        }
        if result = null {
            -- check for overload on left (both instance & static)
            var c:ClassNode? := null
            if !left.type.isPrimitive
                c := left.type.classNode
            if c = null & name != "="
                c := left.type.unwrapRealLiteral.wrapperVersion().classNode
            if c != null {
                var op := c.symbolTable.getMethod(position, name, parameters, 
                        true)
                if op != null
                    result := call(position, op, false, parameters)
                op := c.symbolTable.getMethod(position, name, parameters, false)
                if op != null & !op.annotations.isClass
                    result := call(position, op, true, parameters)
            }
        }
        if result = null {
            -- check for overload on right (static only)
            var c:ClassNode? := null
            if !right.type.isPrimitive
                c := right.type.classNode
            if c = null & name != "="
                c := right.type.unwrapRealLiteral.wrapperVersion().classNode
            if c != null {
                var op := c.symbolTable.getMethod(position, name, parameters, 
                        true)
                if op != null
                    result := call(position, op, false, parameters)
            }
        }
        if rawName.startsWith("!") & result != null
            result := new Not(position, result)
        return result*-
        return null
    }

    ============================================================================
    Returns `<left> <op> <right>`, where `op` is the type of a token 
    representing a binary operator.
    
    @param node the position, for error reporting purposes
    @param left the left operand
    @param op the token type of a binary operator
    @param right the right operand
    ============================================================================
    method getBinaryValue(context:Context, position:Position, var left:Value, 
            op:TokenType, var right:Value):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var methodName:String
        switch op {
            case TokenType.ADD:                  methodName := "+"
            case TokenType.SUB:                  methodName := "-"
            case TokenType.MUL:                  methodName := "*"
            case TokenType.DIV:                  methodName := "/"
            case TokenType.INTDIV:               methodName := "//"
            case TokenType.REM:                  methodName := "%"
            case TokenType.SHIFTLEFT:            methodName := "<<"
            case TokenType.SHIFTRIGHT:           methodName := ">>"
            case TokenType.AND:                  methodName := "&"
            case TokenType.OR:                   methodName := "|"
            case TokenType.XOR:                  methodName := "~"
            case TokenType.BITWISEAND:           methodName := "&&"
            case TokenType.BITWISEOR:            methodName := "||"
            case TokenType.BITWISEXOR:           methodName := "~~"
            case TokenType.POW:                  methodName := "^"
            case TokenType.EQ:                   methodName := "="
            case TokenType.NEQ:                  methodName := "!="
            case TokenType.IDENTITY:             methodName := "=="
            case TokenType.NIDENTITY:            methodName := "!=="
            case TokenType.LT:                   methodName := "<"
            case TokenType.GT:                   methodName := ">"
            case TokenType.LTEQ:                 methodName := "<="
            case TokenType.GTEQ:                 methodName := ">="
            default: throw new CompilerException(
                    "unsupported binary operator '\{op}'",
                    position)
        }
        var submessages:ListView<Message>?
        left, submessages := resolveUnresolvedConstructs(context, left)
        messages := addMessages(messages, submessages)
        right, submessages := resolveUnresolvedConstructs(context, right)
        messages := addMessages(messages, submessages)
        var value := callOverloadedOperator(position, methodName, left, right)
        if value = null {
            def opType:BinaryOperationType
            switch op {
                case TokenType.ADD:        opType := BinaryOperationType.ADD
                case TokenType.SUB:        opType := BinaryOperationType.SUBTRACT
                case TokenType.MUL:        opType := BinaryOperationType.MULTIPLY
                case TokenType.DIV:        opType := BinaryOperationType.DIVIDE
                case TokenType.INTDIV:     opType := BinaryOperationType.INT_DIVIDE
                case TokenType.REM:        opType := BinaryOperationType.REMAINDER
                case TokenType.AND:        opType := BinaryOperationType.AND
                case TokenType.OR:         opType := BinaryOperationType.OR
                case TokenType.XOR:        opType := BinaryOperationType.XOR
                case TokenType.BITWISEAND: opType := BinaryOperationType.BITWISE_AND
                case TokenType.BITWISEOR:  opType := BinaryOperationType.BITWISE_OR
                case TokenType.BITWISEXOR: opType := BinaryOperationType.BITWISE_XOR
                case TokenType.EQ:         opType := BinaryOperationType.EQUAL
                case TokenType.NEQ:        opType := BinaryOperationType.NOT_EQUAL
                case TokenType.IDENTITY:   opType := BinaryOperationType.IDENTITY
                case TokenType.NIDENTITY:  opType := BinaryOperationType.NOT_IDENTITY
                case TokenType.LT:         opType := BinaryOperationType.LESS_THAN
                case TokenType.GT:         opType := BinaryOperationType.GREATER_THAN
                case TokenType.LTEQ:       opType := BinaryOperationType.LESS_THAN_OR_EQUAL
                case TokenType.GTEQ:       opType := BinaryOperationType.GREATER_THAN_OR_EQUAL
                case TokenType.SHIFTLEFT:  opType := BinaryOperationType.SHIFT_LEFT
                case TokenType.SHIFTRIGHT: opType := BinaryOperationType.SHIFT_RIGHT
-*                case TokenType.POW: {
                    def panda := ClassType.PANDA().classNode
                    def params := new PrimitiveArray<Value>(left, right)
                    def exp := panda.symbolTable.getMethod(position, "pow", 
                            params, true)
                    if exp = null {
                        throw new CompilerException(
                                "'^' cannot operate on '\{left.type.displayName}', " +
                                "'\{right.type.displayName}'", position)
                    }
                    return call(position, exp, true, params)
                }*-
                default: throw new InternalCompilerException(position)
            }
            def operandType := BinaryOperation.operandType(context,
                    opType, left, right)
            if operandType = null {
                return (null, wrap(new Message("'\{methodName}' cannot operate on " +
                        "'\{left.type.displayName}', " +
                        "'\{right.type.displayName}'", position)))
            }
            left, submessages := signMattersCast(position, left, operandType, 
                    BinaryOperation.signMatters(opType))
            messages := addMessages(messages, submessages)
            right, submessages := signMattersCast(position, right, operandType,
                    BinaryOperation.signMatters(opType))
            messages := addMessages(messages, submessages)
            value := new BinaryOperation(position, opType, left, right)
        }
        return (value, null)
    }

    @pre(e.type = ParseNodeType.MULTIPLICATIVE_EXPRESSION)
    method convertMultiplicativeExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var left, submessages := convertUnaryExpression(context, e[0])
        messages := addMessages(messages, submessages)
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right:Value?
            right, submessages := convertUnaryExpression(context, e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }

    @pre(e.type = ParseNodeType.ADDITIVE_EXPRESSION)
    method convertAdditiveExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var left, submessages := convertMultiplicativeExpression(context, e[0])
        messages := addMessages(messages, submessages)
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            def right:Value?
            right, submessages := convertMultiplicativeExpression(context, 
                    e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }

    @pre(e.type = ParseNodeType.RANGE_EXPRESSION)
    method convertRangeExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var result, submessages := convertAdditiveExpression(context, e[0])
        messages := addMessages(messages, submessages)
        if e.length > 1 {
            def type := e[1]->(TokenNode).token.type
            var right:Value? := null
            var step:Value?  := null
            if e.length > 2 {
                var i := 2
                if e[i].type = ParseNodeType.ADDITIVE_EXPRESSION {
                    right, submessages := convertAdditiveExpression(context, 
                            e[2])
                    messages := addMessages(messages, submessages)
                    if right = null
                        return (null, messages)
                    i += 1
                }
                if e.length > i {
                    assert e[i]->(TokenNode).token.type = TokenType.BY
                    i += 1
                    step, submessages := convertAdditiveExpression(context, 
                            e[i])
                    messages := addMessages(messages, submessages)
                    if right = null
                        return (null, messages)
                }
            }
            result := new UnresolvedRange(e.position, result, right, step, 
                    type = TokenType.ELLIPSIS)
        }
        return (result, messages)
    }

    @pre(e.type = ParseNodeType.COMPARISON_EXPRESSION)
    method convertComparisonExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var left, messages := convertRangeExpression(context, e[0])
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right, submessages := convertRangeExpression(context, e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }

    @pre(e.type = ParseNodeType.AND_EXPRESSION)
    method convertAndExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var left, messages := convertComparisonExpression(context, e[0])
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right, submessages := convertComparisonExpression(context, 
                    e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }
    
    @pre(e.type = ParseNodeType.OR_EXPRESSION)
    method convertOrExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        var left, messages := convertAndExpression(context, e[0])
        if left = null
            return (null, messages)
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right, submessages := convertAndExpression(context, e[i + 1])
            messages := addMessages(messages, submessages)
            if right = null
                return (null, messages)
            left, submessages := getBinaryValue(context, e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
            messages := addMessages(messages, submessages)
            if left = null
                return (null, messages)
        }
        return (left, messages)
    }
    
    method convertExpression(context:Context, e:ParseNode):
            (Value?, ListView<Message>?) {
        assert e.type = ParseNodeType.EXPRESSION: 
                "expected expression, but found \{e} (\{e.type}): \{e.position}"
        return convertOrExpression(context, e[0])
    }

    function resolveUnresolvedConstructs(context:Context, v:Value):
            (Value, ListView<Message>?) {
        if v-?>(UnresolvedArray) | v-?>(UnresolvedTuple)-- | v-?>(UnresolvedRange)
            return v.implicitCast(v.preferredVariableType)
        return (v, null)
    }

    method call(position:Position, var m:TypedMethodStub, isSuper:Bit,
            params:ListView<Value>):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def methodParams := m.parameters
        var isVarArg := methodParams.length > 0 &
                methodParams[methodParams.length - 1].isVarArg
        for i, p in params {
            if p-?>(Unwrap) {
                if !isVarArg {
                    return (null, wrap(new Message("'...' may not be used " +
                            "with non-variadic \{m}", position)))
                }
                if i < params.length - 1 {
                    return (null, wrap(new Message("'...' may only be used " +
                            "with the last parameter of a call", position)))
                }
            }
        }
        if isVarArg & params.length > 0 & params[params.length - 1]-?>(Unwrap)
            isVarArg := false
        def count:Int
        if isVarArg
            count := methodParams.length - 1
        else
            count := methodParams.length
        def finalParams := new Array<Value>()
        for i in 0 .. count {
            def target := m.parameters[i].type
            if params[i].canImplicitCastTo(target) {
                def cast, submessages := params[i].implicitCast(target)
                messages := addMessages(messages, submessages)
                finalParams.add(cast)
            }
-*            else if m.parameters[i].isConvert & 
                    params[i].canConvertTo(target) {
                finalParams.append(convert(params[i].position, params[i], 
                        target))
            }*-
            else {
                messages := addMessage(messages, "expected value of type " +
                        "'\{target.displayName}', but found " +
                        "'\{params[i].type.displayName}'", params[i].position)
            }
        }
        if isVarArg {
            def values := new Array<Value>()
            def isConvert := methodParams[methodParams.length - 1].isConvert
-*            def type := methodParams[methodParams.length - 1].type->(PrimitiveArrayType).elementType
            for i in count ... params.length - 1 {
                if isConvert
                    values.append(convert(params[i].position, params[i], type))
                else {
                    values.append(implicitCast(params[i].position, params[i], 
                            type))
                }
            }
            finalParams.append(new NewPrimitiveArrayWithValues(position,
                methodParams[methodParams.length - 1].type, values))*-
            throw new NotSupportedException()
        }
        return (new MethodCall(position, m, isSuper, finalParams), messages)
    }

    method call(context:Context, position:Position, var contextValue:Value?, 
            methodName:String, var params:ListView<Value>):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null            
        if contextValue = null {
            if context.isInstance {
                -- bare identifier, could be either instance or class
                var result := context.getMethod(null, methodName, params)
                if result != null {
                    if result.annotations.isClass {
                        -- class method, update the contextValue
                        contextValue := new ClassLiteral(context, position, 
                                context.currentClassType())
                    }
                }
                if contextValue = null
                    contextValue := context.getSelf(position)
            }
            else {
                -- in a class context
                contextValue := new ClassLiteral(context, position,
                        context.currentClassType())
            }
        }
        var classMethod:Bit
        var supercall:Bit
        if contextValue-?>(UnresolvedClassLiteral) {
            contextValue := new ClassLiteral(context, position, 
                    contextValue->(UnresolvedClassLiteral).value)
        }
        if contextValue-?>(ClassLiteral) {
            classMethod := true
            supercall := false
        }
        else if contextValue-?>(ClassObjectLiteral) {
            classMethod := false
            supercall := false
        }
        else {
            classMethod := false
            var newParams := new Array<Value>()
            if contextValue-?>(Super) {
                def cl := context.currentClass
                assert cl != null
                def superclass := cl.superclass
                if superclass = null {
                    return (null, wrap(new Message("class '\{cl}' has no " +
                            "superclass", contextValue.position)))
                }
                def cast, submessages := context.getSelf(position).implicitCast(
                        superclass)
                assert messages = null : "failed to cast to superclass: \{messages}"
                newParams.add(cast)
                supercall := true
            }
            else {
                newParams.add(contextValue)
                supercall := false
            }
            newParams.addAll(params)
            params := newParams
        }
        var methodStub := context.getMethod(contextValue, methodName, params)
        if methodStub = null {
            if classMethod & methodName = "constructor" {
                -- check for a constructor, which is called like a class method
                -- but implemented as an instance method
-*                if type.isPrimitiveArray {
                    -- FIXME: hardcoded yuck
                    if params.length = 1 & 
                            params[0].canImplicitCastTo(Type.INDEX_TYPE) {
                        var elementType := type->(PrimitiveArrayType).elementType
                        return new NewPrimitiveArrayWithLength(position, type, 
                                implicitCast(position, params[0], 
                                Type.INDEX_TYPE))
                    }
                    else if params.length = 3 & params[0].type.isPrimitiveArray &
                            (params[0].type.elementType = type.elementType |
                                params[0].type.elementType.canImplicitCastTo(
                                    type.elementType) & 
                                    !params[0].type.elementType.isPrimitive &
                                    !type.elementType.isPrimitive) &
                            params[1].canImplicitCastTo(Type.INDEX_TYPE) &
                            params[2].canImplicitCastTo(Type.INDEX_TYPE) {
                        if params[0].type.elementType.isNullable & 
                                !type.elementType.isNullable
                            PandaCompiler.reportError("cannot create array " +
                                    "with possibly-null values", position)
                        return new NewPrimitiveArrayWithRange(position, type, 
                                params[0], 
                                implicitCast(params[1].position, params[1], 
                                    Type.INDEX_TYPE),
                                implicitCast(params[2].position, params[2], 
                                    Type.INDEX_TYPE))
                    }
                    else {
                        var finalParams := new Array<Value>()
                        for param in params {
                            finalParams.add(param.implicitCast(
                                    type.elementType))
                        }
                        throw new NotSupportedException()
--                        return new NewPrimitiveArrayWithValues(position, type, 
--                                finalParams)
                    }
                }*-
                def newParams := new Array<Value>()
                newParams.add(new Dummy(contextValue.position,
                        contextValue->(ClassLiteral).value))
                newParams.addAll(params)
                params := newParams
                def construct, submessages := call(context, position, 
                        contextValue, methodName, params)
                if construct != null {
                    def stub := construct->(Construct).constructorCall.methodStub
                    if stub.methodType != 
                            MethodNodeType.CONSTRUCTOR {
                        return (null, wrap(new Message(
                                "instance method '\{stub.name}' cannot be " +
                                "accessed from a class context", position)))
                    }
                    messages := addMessages(messages, submessages)
                    return (construct, messages)
                }
            }
        }
        if methodStub != null {
            def isSelf := contextValue = null | 
                    (contextValue-?>(VariableReference) &
                    contextValue->(VariableReference).variable.name = 
                        Parameter.SELF_NAME)
            def result := call(position, methodStub, supercall, params)
            if methodStub.methodType = MethodNodeType.CONSTRUCTOR {
                return (new Construct(contextValue->(ClassLiteral).value,
                        result[0]->(MethodCall)), result[1])
            }
            else
                return result
        }
        else {
            return (null, wrap(getMethodNotFoundMessage(context, position, 
                    contextValue, methodName, params)))
        }
    }
    
    @private
    method getMethodNotFoundMessage(context:Context, position:Position, 
            contextValue:Value?, methodName:String, 
            params:ListView<Value>):Message {
        def msg := "no match found for method "->>(MutableString)
        msg.append(methodName)
        msg.append("(")
        for i, p in params {
            if i != 0
                 msg.append(", ")
            msg.append(p.type.displayName)
        }
        msg.append(")")
        if contextValue != null {
            if contextValue-?>(Super)
                msg.append(" in \{context.currentClass->(TypedClassStub).superclass->(Type).displayName}")
            else if contextValue-?>(ClassLiteral)
                msg.append(" in \{contextValue}")
            else
                msg.append(" in \{contextValue.type.displayName}")
        }
        for p in params {
-*            if p-?>(UnresolvedLambda) {
                def lambda := p->(UnresolvedLambda)
                if lambda.errors.length > 0 {
                    msg.append("\n    possible error in lambda at " +
                            "\{lambda.position}:")
                    def entries := new PrimitiveArray<Object>()
                    for e in lambda.errors
                        entries.append(e)
                    Panda.sort(entries, function(eo1:Object, eo2:Object):Bit {
                        def e1 := eo1->((Object?, Object?))[0]->(PrimitiveArray<Type>)
                        def e2 := eo2->((Object?, Object?))[0]->(PrimitiveArray<Type>)
                        assert e1.length = e2.length
                        for i in 0 .. e1.length {
                            def n1 := e1[i].name
                            def n2 := e2[i].name
                            if n1 > n2
                                return true
                            if n2 > n1
                                return false
                        }
                        return false
                    })
                    for raw in entries {
                        def e := raw->((Object?, Object?))
                        def types := e[0]->(PrimitiveArray<Type>)
                        def typeString := new MutableString()
                        typeString.append("(")
                        for i, type in types {
                            if i > 0
                                typeString.append(",")
                            typeString.append(type.displayName)
                        }
                        typeString.append(")=>(...)")
                        var error, errorPos := e[1]->((String, Position?))
                        if errorPos = null
                            errorPos := Position.INTERNAL
                        msg.append("\n        when interpreted as \{typeString}:\n")
                        msg.append("            \{error}")
                        if errorPos != lambda.position
                            msg.append(" at \{errorPos}")
                    }
                }
            }*-
        }
        return new Message(msg->>(String), position)
    }

    method resolveNoArgFunction(context:Context, u:Unresolved):Value? {
        def result, messages := call(context, u.position, u.contextValue, 
                u.name, new Array<Value>())
        if result-?>(MethodCall) & 
                result->(MethodCall).methodStub.methodType = 
                    MethodNodeType.FUNCTION
            return result
        return null
    }
    
    ============================================================================
    Resolves a possibly-unresolved value. During the code analysis phase, we
    often end up with partial sequences of tokens: for instance, the sequence
    `panda.core.String` could potentially represent a type name (`panda`) having
    a class function (`core`) called upon it, resulting in an object which we 
    are going to extract a field (`String`) from. Or it could (as it obviously
    does in this case) represent the name of a class (`panda.core.String`). But
    as we are parsing it, and have so far just seen the "panda.core" part, we
    don't yet know we have a type name until we reach the "String", and the
    partial value will be represented by objects that are not fully resolved.

    This method means "we have all the information about this value we are ever
    going to get, so either give me the value it's describing or raise an 
    error". Note that a resolved construct may still have an unresolved type,
    such as `UnresolvedArray` or `UnresolvedRange`; those are legal returns from
    this method.
    ============================================================================
    method resolve(context:Context, raw:Value):(Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var result:Value? := raw
        if result.type = RealType.REAL64 {
            def submessages:ListView<Message>?
            result, submessages := result.implicitCast(RealType.REAL64)
            messages := addMessages(messages, submessages)
        }
        else if result-?>(Unresolved) {
            def type, submessages := context.getType(raw->>(String), 
                    raw.position)
            if type != null {
                messages := addMessages(messages, submessages)
                return (new ClassLiteral(context, raw.position, type), messages)
            }
            if !result->(Unresolved).name.contains(".")
                result := resolveNoArgFunction(context, result->(Unresolved))
            else
                result := null
            messages := addMessage(messages, new Message("unknown identifier",
                    raw.position))
        }
        else if result-?>(AmbiguousReference) {
            def a := result->(AmbiguousReference)
            def name := a.field.name
            throw new CompilerException("reference to '\{name}' is " +
                    "ambiguous, both field '\{name}' and function " +
                    "\{name}() match", a.position)
        }
        else if result-?>(PossibleIndexedAssignment) {
            def pia := result->(PossibleIndexedAssignment)
            messages := addMessage(messages, 
                    pia.contextValue.type.displayName +
                    "does not define the index ([]) operator for " +
                    "'\{pia.index.type.displayName}'", pia.position)
        }
        else if result-?>(PossibleSliceAssignment) {
            def psa := result->(PossibleSliceAssignment)
            var name:String
            if psa.endInclusive
                name := "inclusive slice ([...])"
            else
                name := "exclusive slice ([..])"
            messages := addMessage(messages, 
                    psa.contextValue.type.displayName +
                    "does not define the \{name} operator for these types", 
                    psa.position)
        }
        return (result, messages)
    }

    method convert(context:Context, position:Position, var v:Value, 
            var t:Type):Value {
        throw new NotSupportedException()
    }

    method convertInstanceOf(position:Position, var object:Value, 
            var type:Type):Value {
-*        if object.type = StringOrCharType.STRING_OR_CHAR {
            -- hardcode STRING_OR_CHAR-?>(Char) and STRING_OR_CHAR-?>(String)
            -- as true
            if type = CharType.CHAR | ClassType.STRING().canImplicitCastTo(type)
                return new BitLiteral(position, true)
        }
        var primitiveTarget := type.isPrimitive | type.isWrapper
        if primitiveTarget {
            if object.type = StringOrCharType.STRING_OR_CHAR
                object := implicitCast(position, object, CharType.CHAR)
            if object.type = CharType.CHAR & type.isNumber
                object := explicitCast(position, object, IntType.INT32)
        }
        var primitiveSource := object.type.isPrimitive | 
                object.type.isWrapper

        if object.type.isNumber & type.isReal
            return new BitLiteral(position, true)

        if !primitiveSource & type.isPrimitive
            type := type.unwrapRealLiteral.wrapperVersion()

        if !object.canExplicitCastTo(type) {
            error("'\{object}' (\{object.type.displayName}) cannot possibly " +
                    "be an instance of '\{type.displayName}'", position)
        }

        def panda := ClassType.PANDA().classNode
        var parameters := new PrimitiveArray<Value>(object)
        if !primitiveTarget
            parameters.append(new ClassObjectLiteral(position, type.unwrapNullable))
        
        var methodName := "instanceOf"
        if primitiveTarget {
            var target := type.unwrapNullable
            var name := target.name
            assert name.startsWith(ClassNode.CORE)
            name := name[ClassNode.CORE.length..]
            if target.isWrapper {
                name := name.replace("Wrapper", "")
            }
            methodName += name
        }
        var instanceOf:MethodNode? := null
        if !object.type.isNullable {
            instanceOf := panda.symbolTable.getMethod(position, methodName, 
                    parameters, true)
        }
        if instanceOf = null {
            parameters.append(new BitLiteral(position, type.isNullable))
            instanceOf := panda.symbolTable.getMethod(position, methodName, 
                    parameters, true)
        }
        assert instanceOf != null
        return call(position, instanceOf, false, parameters)*-
        throw new NotSupportedException()
    }

    @pre(c.type = ParseNodeType.CONSTRUCT)
    method convertConstruct(context:Context, c:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        assert c[0]->(TokenNode).token.type = TokenType.NEW
        var type, submessages := context.getType(c[1])
        messages := addMessages(messages, submessages)
        if type = null
            return (null, messages)
        def params:ListView<Value>?
        params, submessages := convertParameters(context, c[2])
        messages := addMessages(messages, submessages)
        if params = null
            return (null, messages)
        def classLiteral := new ClassLiteral(context, c[1].position, type)
        def result:Value?
        result, submessages := call(context, c.position, classLiteral, 
                "constructor", params)
        messages := addMessages(messages, submessages)
        return (result, messages)
    }

    method parseBareIdentifier(context:Context, id:ParseNode):
            (Value?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var name := id->>(String)
        if name = "class"
            name := "$class"
        def variable := context.getVariable(name)
        if variable != null {
            if variable-?>(FieldNode) {
                def classField := variable->(FieldNode).annotations.isClass | 
                        variable->(FieldNode).annotations.isThread
                if !context.isInstance & !classField {
                    messages := addMessage(messages, 
                            "instance field '\{name}' cannot be accessed " +
                            "from a class context", id.position)
                }
                def contextValue:Value
                if classField {
                    def cc := context.currentClass
                    assert cc != null
                    def type, submessages := context.getType(cc.name, 
                            id.position)
                    messages := addMessages(messages, submessages)
                    if type = null
                        return (null, messages)
                    contextValue := new ClassLiteral(context, id.position, type)
                }
                else
                    contextValue := context.getSelf(id.position)
                if isAccessible(context, variable->(FieldNode)) {
                    return (createFieldReference(context, id.position, 
                            contextValue, variable->(FieldNode), true), 
                            messages)
                }
            }
            else {
                def result := new VariableReference(id.position, variable)
                return (result, messages)
            }
        }
        if id->(TokenNode).token.type = TokenType.IDENTIFIER {
            def type, _ := context.getType(name, id.position)
            if type != null {
                return (new UnresolvedClassLiteral(context, id.position, type),
                        null)
            }
        }
        return (new Unresolved(id.position, null, name), null)
    }

    @pre(params.type = ParseNodeType.PARAMETERS)
    method convertParameters(context:Context, 
            params:ParseNode):(ListView<Value>?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        assert params[0]->(TokenNode).token.type = TokenType.LPAREN
        def result := new Array<Value>()
        for i in 1 .. params.length - 1 by 2 {
            var expr, submessages := convertExpression(context, params[i])
            messages := addMessages(messages, submessages)
            if expr = null
                return (null, messages)
            if i = params.length - 2 & expr-?>(UnresolvedRange) {
                def r := expr->(UnresolvedRange)
                def left := r.left
                if left != null & left.preferredVariableType.isPrimitiveArray & 
                        r.right = null & r.step = null & r.endInclusive
                    expr := new Unwrap(left)
            }
            result.add(expr)
        }
        return (result, messages)
    }

    -- FIXME remove this when array syntax is wired up to generic arrays
    function wrap(message:Message):ListView<Message> {
        def result := new Array<Message>()
        result.add(message)
        return result
    }

    -- FIXME refactoring required! I did this all wrong and dumb. When I first
    -- started working on Panda, all lvalues were also rvalues. Then one
    -- situation crept in where the two weren't exactly the same, so I hacked it
    -- a bit to get it working. Then another cropped up, and another, and slowly
    -- this nice simple method turned into this hellish monstrosity. It needs to
    -- be killed with extreme prejudice, and I apologize to anyone reading this
    -- code. It just built up a bit at a time until it was completely out of
    -- control.
    --
    -- The basic idea is that (due to the original simplicity) the processing
    -- originally just figured out the rvalue on the left side of the assignment
    -- operator, ran into an assignment operator, made sure the rvalue worked as
    -- an lvalue, and continued on its merry way. Since then, this has gotten so 
    -- hellishly complicated that it absolutely needs to be rewritten so as to 
    -- know up front to be looking for an lvalue, so we can eliminate all of 
    -- these special cases and cut this at least in half.
    --
    -- UPDATE:
    -- Oh god I made it even worse. It's so awful. Please don't judge me by this
    -- method, I'm better than this, I swear :-(
    --
    -- FURTHER UPDATE:
    -- Actually, I don't think the refactoring is as simple as I outlined. I 
    -- hadn't considered the complexities introduced by compound assignment. We
    -- can't just process the assignment target twice (once in "lvalue mode" and
    -- once in "rvalue mode"), because that would involve duplicate evaluations
    -- of things that are only supposed to be evaluated once. It can certainly
    -- be done simpler than it's being done, but I don't think it's possible to
    -- eliminate quite as much complexity as I had hoped.
    method processSingleAssignment(context:Context, var left:Value, 
            assignmentOp:ParseNode, right:Value, reuse:Bit):
            (ListView<Statement>?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def resolved, resolveMessages := resolve(context, left)
        if resolved != null
            left := resolved
        if left-?>(Unresolved) {
            -- could be an assignment method
            var contextValue := left->(Unresolved).contextValue
            def name := left->(Unresolved).name
            if contextValue = null {
                if context.isInstance
                    contextValue := context.getSelf(assignmentOp.position)
                else {
                    -- we're in a class context, so there can't possibly be an
                    -- assignment method. Go ahead and report the error.
                    return (null, resolveMessages)
                }
            }
            assert contextValue != null
-*            def call := callAssignmentMethod(contextValue, name, 
                    new PrimitiveArray<Value>(right))
            if call != null
                currentNode.add(call)
            else {
                -- no assignment method, trigger the exception
                resolve(left)
            }*-
            throw new NotSupportedException()
        }
-*        else if left-?>(AmbiguousReference) {
            var a := left->(AmbiguousReference)
            var object := a.context
            if reuse {
                def reusable := makeReusable(object)
                reusable.replace(reusable.createReference())
                currentNode.add(new ValueStatement(reusable))
                object := reusable.createReference()
            }
            checkAssignment(a.field, a.position)
            open(new FieldAssignment(assignmentOp.position, object, a.field))
            currentNode.add(implicitCast(right.position, right, a.type))
            close(class(FieldAssignment))
        } *-
        else if left-?>(VariableReference) {
            def variable := left->(VariableReference).variable
            def cast, submessages := right.implicitCast(variable.type)
            messages := addMessages(messages, submessages)
            def assignment := new VariableAssignment(assignmentOp.position,
                    variable, cast)
            def result := new Array<Statement>()
            result.add(new ValueStatement(assignment))
            return (result, messages)
        }
-*        else if left-?>(FieldReference) {
            var fv := left->(FieldReference)
            var object:Value
            if reuse {
                cm.add(right)
                if fv.object-!>(ClassLiteral) {
                    def reusable := makeReusable(fv.object)
                    reusable.replace(reusable.createReference())
                    currentNode.add(new ValueStatement(reusable))
                    object := reusable.createReference()
                }
                else
                    object := fv.object
            }
            else {
                object := fv.object
                cm.add(fv)
            }
            if reuse
                right.removeFromParent()
            else {
                fv.removeFromParent()
                object.removeFromParent()
            }
            var name := fv.field.name
            var call := callAssignmentMethod(object, name, 
                    new PrimitiveArray<Value>(right))
            if call != null {
                if currentClass != fv.field.parent & 
                        !fv.field.annotations.isReadOnly &
                        !fv.field.annotations.isFinal {
                    throw new CompilerException("reference to '\{name}' is " +
                            "ambiguous, both field \{name} (of type " +
                            "\{fv.field.type.displayName}) and method " +
                            "\{name}:=() match", fv.position)
                }
                currentNode.add(call)
            }
            else {
                if reuse & object-?>(ClassLiteral) {
                    object.replace(
                            new ClassLiteral(object->(ClassLiteral).value))
                }
                checkAssignment(fv.field, fv.position)
                open(new FieldAssignment(assignmentOp.position, object, 
                        fv.field))
                currentNode.add(implicitCast(right.position, right, fv.type))
                close(class(FieldAssignment))
            }
        }
        else if left-?>(IndexValue) {
            if left->(IndexValue).array.type.isImmutable
                error("cannot modify immutable array", assignmentOp.position)
            -- handle increasing array length when index = array length
            var iv := left->(IndexValue)
            if reuse {
                cm.add(right)
                def array := makeReusable(iv.array)
                def index := makeReusable(iv.index)
                index.removeFromParent()
                array.removeFromParent()
                iv.add(array.createReference())
                iv.add(index.createReference())
                right.removeFromParent()
                currentNode.add(new ValueStatement(array))
                currentNode.add(new ValueStatement(index))
                open(new IndexedAssignment(assignmentOp.position,
                        array.createReference(),
                        index.createReference()))
                currentNode.add(implicitCast(right.position, right, iv.type))
            }
            else {
                var array := iv.array
                var index := iv.index
                array.removeFromParent()
                index.removeFromParent()
                open(new IndexedAssignment(assignmentOp.position, array, index))
                currentNode.add(implicitCast(right.position, right, iv.type))
            }
            close(class(IndexedAssignment))
        }
        else if left-?>(PossibleIndexedAssignment) {
            var pia := left->(PossibleIndexedAssignment)
            var params := [pia.index, right]
            var call := callAssignmentMethod(pia.context, "[]", params)
            if call != null
                currentNode.add(call)
            else {
                -- FIXME use map
                var types := new PrimitiveArray<String>()
                for p in params
                    types.append(p.type.displayName)
                throw new CompilerException("'\{pia.context.type.displayName}' does " + 
                        "not define the indexed assignment ([]:=) operator " +
                        "for \{types}", pia.position)
            }
        }
        else if left-?>(PossibleSliceAssignment) {
            var psa := left->(PossibleSliceAssignment)
            var params := [psa.left, psa.right, psa.step, right]
            var name:String
            if psa.endInclusive
                name := "[...]"
            else
                name := "[..]"
            var call := callAssignmentMethod(psa.context, name, params)
            if call != null
                currentNode.add(call)
            else {
                var types := new PrimitiveArray<String>()
                for p in params
                    types.append(p.type.displayName)
                if psa.endInclusive
                    name := "inclusive slice assignment ([...]:=)"
                else
                    name := "exclusive slice assignment ([..]:=)"
                throw new CompilerException("\{psa.context.type.displayName} does " +
                        "not define the \{name} operator for \{types}", 
                        psa.position)
            }
        }
        else if left-?>(MethodCall) {
            -- assigning to a method call. We need to look for a corresponding
            -- assignment method / field.
            var mc := left->(MethodCall)
            var methodNode := mc.methodNode
            if !methodNode.annotations.isClass & (mc.parameters.length = 1 | 
                    methodNode.name = "[]" | methodNode.name = "[..]" |
                    methodNode.name = "[...]") {
                var cl := mc.methodNode.parent->(ClassNode)
                var oldParams := mc.parameters
                var testParams := oldParams[1..]
                -- undo implicit casts that happened as part of setting up the
                -- original method call
                for i, p in testParams {
                    testParams[i] := unwrapImplicitCast(p)
                }
                if methodNode.name = "[..]" | methodNode.name = "[...]" {
                    -- restore parameters that might have been stripped when we
                    -- matched the initial slice. Such a hack, I'm so sorry.
                    if testParams.length = 0
                        testParams.append(new NullLiteral(left.position))
                    if testParams.length = 1
                        testParams.append(new NullLiteral(left.position))
                    if testParams.length = 2
                        testParams.append(new IntegerLiteral(left.position, 1))
                }
                testParams.append(right)
                def src := unwrapImplicitCast(oldParams[0])
                def m := findAssignmentMethod(src, methodNode.name, 
                        testParams, mc.isSuper)
                if m != null {
                    -- found assignment method
                    -- promote our parameters, call it and we're done
                    var params := new PrimitiveArray<Value>()
                    if reuse
                        cm.add(right)
                    else
                        cm.add(mc)
                    for i, p in m.params {
                        if i = m.params.length - 1
                            break
                        if reuse {
                            def getMethod := left->(MethodCall).methodNode
                            var reusable := makeReusable(p)
                            reusable.replace(implicitCast(p.position,
                                    reusable.createReference(),
                                    getMethod.parameters[i].type))
                            params.append(reusable)
                        }
                        else
                            params.append(p)
                        if params[i].parent != null
                            params[i].removeFromParent()
                    }
                    if reuse
                        right.removeFromParent()
                    else
                        mc.removeFromParent()
                    params.append(right)
                    currentNode.add(new ValueStatement(call(
                            assignmentOp.position, m.methodNode, 
                            m.methodNode.isDeclaredVirtual() & !mc.isSuper, 
                            params)))
                }
                else {
                    -- no assignment method
                    if methodNode.name = "[]" {
                        var types := new PrimitiveArray<String>()
                        for p in testParams
                            types.append(p.type.displayName)
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the indexed assignment ([]:=) " +
                                "operator for \{types}", mc.position)
                    }
                    else if methodNode.name = "[..]" {
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the exclusive slice assignment ([..]:=) " +
                                "operator for these types", mc.position)
                    }
                    else if methodNode.name = "[...]" {
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the inclusive slice assignment ([...]:=) " +
                                "operator for these types", mc.position)
                    }
                    else {
                        -- check for a field by this name
                        if oldParams.length = 1 {
                            var object := oldParams[0]
                            def field := getField(left.position, 
                                    new Dummy(object.type), 
                                    mc.methodNode.name, false)
                            if field-?>(FieldReference) {
                                if reuse {
                                    cm.add(right)
                                    def reusable := makeReusable(object)
                                    reusable.replace(reusable.createReference())
                                    object := reusable
                                    right.removeFromParent()
                                }
                                else
                                    object.removeFromParent()
                                checkAssignment(field->(FieldReference).field,
                                        field.position)
                                open(new FieldAssignment(assignmentOp.position, 
                                        object, field->(FieldReference).field))
                                currentNode.add(implicitCast(right.position, 
                                        right, field.type))
                                close(class(FieldAssignment))
                                return
                            }
                        }
                        error("cannot assign to '\{left}'", assignmentOp)
                    }
                }
            }
            else
                error("cannot assign to '\{left}'", assignmentOp)
        }
        else
            error("cannot assign to '\{left}'", assignmentOp)*-
        throw new NotSupportedException()
    }

    @pre(assignmentOp.type = ParseNodeType.ASSIGNMENT_OPERATOR)
    method processAssignment(context:Context, var left:ListView<Value?>, 
            assignmentOp:ParseNode, var right:Value):
            (ListView<Statement>?, ListView<Message>?) {
        def cm := context.currentMethod
        assert cm != null
        def reuse:Bit
        def assignmentType := assignmentOp[0]->(TokenNode).token.type
        if assignmentType = TokenType.ASSIGNMENT
            reuse := false
        else {
            reuse := true
            def op:TokenType
            switch assignmentType {
                case TokenType.ADDEQ:        op := TokenType.ADD
                case TokenType.SUBEQ:        op := TokenType.SUB
                case TokenType.MULEQ:        op := TokenType.MUL
                case TokenType.DIVEQ:        op := TokenType.DIV
                case TokenType.INTDIVEQ:     op := TokenType.INTDIV
                case TokenType.POWEQ:        op := TokenType.POW
                case TokenType.REMEQ:        op := TokenType.REM
                case TokenType.SHIFTLEFTEQ:  op := TokenType.SHIFTLEFT
                case TokenType.SHIFTRIGHTEQ: op := TokenType.SHIFTRIGHT
                case TokenType.BITWISEANDEQ: op := TokenType.BITWISEAND
                case TokenType.BITWISEOREQ:  op := TokenType.BITWISEOR
                case TokenType.BITWISEXOREQ: op := TokenType.BITWISEXOR
                case TokenType.ANDEQ:        op := TokenType.AND
                case TokenType.OREQ:         op := TokenType.OR
                case TokenType.XOREQ:        op := TokenType.XOR
                default: throw new InternalCompilerException(
                        "unsupported assignment operator: " +
                        "'\{assignmentType}'", assignmentOp.position)
            }
            if left.length > 1
                return (null, wrap(new Message("compound assignment cannot " +
                        " assign to multiple values at once", 
                        assignmentOp.position)))
            var lvalue := left[0]
            if lvalue = null {
                return (null, wrap(new Message("'_' is only permitted in " +
                        "multiple assignments from a tuple", 
                        assignmentOp.position)))
            }
            var messages:ListView<Message>?
            lvalue, messages := resolve(context, lvalue)
            if lvalue = null
                return (null, messages)
            var submessages:ListView<Message>?
            def finalRight:Value?
            finalRight, submessages := getBinaryValue(context, 
                    assignmentOp.position, lvalue, op, right)
            messages := addMessages(messages, submessages)
            if finalRight != null
                right := finalRight
            -- deal with situations like int8 += 1 (which resolves into
            -- int8 := int8 + 1, and the right side promotes to an Int32, so we
            -- need to downcast)
            if right.type.isInteger & lvalue.type.isInteger {
                right, submessages := right.explicitCast(lvalue.type)
                messages := addMessages(messages, submessages)
            }
            def newLeft := new Array<Value?>()
            newLeft.add(lvalue)
            left := newLeft
        }

        var result := new Array<Statement>()
        if left.length > 1 {
            def reused := new ReusedValueDefinition(right)
            result.add(new ValueStatement(reused))
            var messages:ListView<Message>? := null
            for i, lvalue in left {
                if lvalue != null {
                    var tupleValue, submessages := getField(context, 
                            right.position, reused.createReference(), 
                            "$field" + i)
                    messages := addMessages(messages, submessages)
                    assert tupleValue != null : "can't-happen tuple failure: " +
                            submessages
                    var assignments:ListView<Statement>?
                    assignments, submessages := processSingleAssignment(
                            context, lvalue, assignmentOp, tupleValue, reuse)
                    messages := addMessages(messages, submessages)
                    if assignments != null
                        result.addAll(assignments)
                }
            }
            return (result, messages)
        }
        else {
            def lvalue := left[0]
            assert lvalue != null
            return processSingleAssignment(context, lvalue, assignmentOp, right,
                    reuse)
        }
    }

    ============================================================================
    Handles the nodes following the context in a CALL_OR_ASSIGNMENT. If it is a
    call, returns the call's value, otherwise returns null.

    ============================================================================
    -- FIXME Dear god this has gotten long and unwieldy, needs to be split apart
    method processCallOrAssignment(context:Context, var contextValue:Value?, 
            c:ParseNode):(Value?, Statement?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var i := 1
        def lvalues := new Array<Value?>()
        while i < c.length {
            if c[i].type = ParseNodeType.TOKEN {
                switch c[i]->(TokenNode).token.type {
                    case TokenType.DOT: {
                        def name := c[i + 1]->>(String)
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        contextValue, submessages := 
                                resolveUnresolvedConstructs(context,
                                    contextValue)
                        messages := addMessages(messages, submessages)
                        def field:Value?
                        field, submessages := getField(context, 
                                c[i + 1].position, contextValue, name)
                        messages := addMessages(messages, submessages)
                        if field != null 
                            contextValue := field
                        else {
                            if contextValue-!>(Unresolved) {
                                return (null, null, wrap(new Message(
                                        "unknown identifier",
                                        contextValue.position)))
                            }
                            contextValue := new Unresolved(c[i + 1].position, 
                                    contextValue->(Unresolved).contextValue, 
                                    contextValue + "." + name)
                        }
                        i += 2
                    }
                    case TokenType.LBRACKET: {
-*                        assert contextValue != null
                        contextValue := resolve(contextValue)
                        contextValue := resolveUnresolvedConstructs(context,
                                contextValue)
                        i += 1
                        var slice := false
                        var endInclusive := false
                        var left:Value?
                        var right:Value?
                        var step:Value? := null
                        if c[i]-?>(TokenNode) & 
                                c[i]->(TokenNode).token.type = TokenType.DOTDOT {
                            left := null
                            slice := true
                        }
                        else if c[i]-?>(TokenNode) & 
                                c[i]->(TokenNode).token.type = TokenType.ELLIPSIS {
                            left := null
                            slice := true
                            endInclusive := true
                        }
                        else {
                            left := convertExpression(context, c[i])
                            i += 1
                        }
                        if c[i]-?>(TokenNode) & 
                                (c[i]->(TokenNode).token.type = TokenType.DOTDOT |
                                c[i]->(TokenNode).token.type = TokenType.ELLIPSIS) {
                            slice := true
                            endInclusive := c[i]->(TokenNode).token.type = TokenType.ELLIPSIS
                            i += 1
                            if c[i]-?>(TokenNode) & 
                                    (c[i]->(TokenNode).token.type = 
                                        TokenType.RBRACKET | 
                                    c[i]->(TokenNode).token.type = 
                                        TokenType.BY)
                                right := null
                            else {
                                right := convertExpression(context, c[i])
                                i += 1
                            }
                            if c[i]->(TokenNode).token.type = TokenType.BY {
                                i += 1
                                step := convertExpression(context, c[i])
                                i += 1
                            }
                        }
                        else
                            right := null
                        if left != null & right = null & step = null {
                            if left-?>(UnresolvedRange) {
                                def range := left->(UnresolvedRange)
                                left := range.left
                                right := range.right
                                step := range.step
                                slice := true
                                endInclusive := range.endInclusive
                            }
                        }
                        if !slice {
                            assert left != null
                            if contextValue.type.isPrimitiveArray {
                                if contextValue.type.isNullable
                                    contextValue := implicitCast(c.position, contextValue,
                                            contextValue.type.unwrapNullable)
                                contextValue := new IndexValue(c.position, contextValue, 
                                        implicitCast(c.position, left, 
                                            Type.INDEX_TYPE))
                            }
                            else if contextValue.type.isTuple & 
                                    left-?>(IntegerLiteral) {
                                contextValue := getField(contextValue.position, contextValue,
                                        "$field" + left->(IntegerLiteral).value)
                            }
                            else {
                                -- look for overloaded [] operator
                                if contextValue-?>(UnresolvedClassLiteral)
                                    contextValue := contextValue->
                                            (UnresolvedClassLiteral)->>
                                            (ClassLiteral)
                                if contextValue.type.isPrimitive {
                                    def wrapper := contextValue.type->
                                            (PrimitiveType).wrapperVersion()
                                    contextValue := implicitCast(contextValue.position, 
                                            contextValue, wrapper, CastType.IMPLICIT)
                                }
                                def cl := contextValue.type.classNode
                                def params := new Array<Value>(contextValue, left)
                                def op := cl.symbolTable.getMethod(c.position, 
                                        "[]", params, false)
                                if op = null & contextValue-?>(ClassLiteral) {
                                    def targetType := 
                                            contextValue->(ClassLiteral).value
                                    def targetClass := targetType.classNode
                                    params := [left]
                                    op := targetClass.symbolTable.getMethod(
                                            c.position, "[]", params, true)
                                }
                                if op != null {
                                    contextValue := call(c[i].position, op, true, 
                                            params)
                                }
                                else
                                    contextValue := new PossibleIndexedAssignment(
                                            c.position, contextValue, left)
                            }
                        }
                        else {
                            -- slice
                            if contextValue-?>(UnresolvedClassLiteral)
                                contextValue := contextValue->
                                        (UnresolvedClassLiteral)->>
                                        (ClassLiteral)
                            if contextValue.type.isPrimitive {
                                def wrapper := contextValue.type->
                                                (PrimitiveType).wrapperVersion()
                                contextValue := implicitCast(contextValue.position, 
                                        contextValue, wrapper, CastType.IMPLICIT)
                            }
                            def cl := contextValue.type.classNode
                            if left = null
                                left := new NullLiteral(contextValue.position)
                            if right = null
                                right := new NullLiteral(contextValue.position)
                            if step = null
                                step := new IntegerLiteral(contextValue.position, 1)
                            def match := findSliceMethod(contextValue, endInclusive,
                                    [left, right, step])
                            if match != null {
                                contextValue := call(c[i].position, match.methodNode, 
                                        true, match.params)
                            }
                            else {
                                contextValue := new PossibleSliceAssignment(
                                        c.position, contextValue, left, right, 
                                        step, endInclusive)
                            }
                        }
                        assert c[i].type = ParseNodeType.TOKEN &
                                c[i]->(TokenNode).token.type = TokenType.RBRACKET
                        i += 1*-
                        throw new NotSupportedException("lbracket")
                    }
                    case TokenType.MEMBER: {-*
                        assert contextValue != null
                        contextValue := resolve(contextValue)
                        contextValue := resolveUnresolvedConstructs(context,
                                contextValue)
                        if contextValue-?>(UnresolvedClassLiteral)
                            contextValue := contextValue->(UnresolvedClassLiteral)->>(ClassLiteral)
                        def type := contextValue->(ClassLiteral).value
                        i += 1
                        def name := c[i]->>(String)
                        i += 1
                        var types:Array<Type>?
                        if i < c.length & c[i].type = ParseNodeType.TYPES {
                            types := convertTypes(c[i])
                            i += 1
                        }
                        else
                            types := null
                        var found := false
                        outer: for child in type.classNode.children {
                            if child-?>(MethodNode) & 
                                    child->(MethodNode).name = name {
                                def m := child->(MethodNode)
                                if types != null {
                                    var start:Int
                                    if m.annotations.isClass
                                        start := 0
                                    else
                                        start := 1
                                    def parameters := m.parameters[start..]
                                    if parameters.length != types.length
                                        continue
                                    for j, p in parameters {
                                        if p.type != types[j]
                                            continue outer
                                    }
                                }
                                if found {
                                    throw new CompilerException(
                                            "'\{type.displayName}' has more " +
                                            "than one method named " +
                                            "'\{name}', specify parameter " +
                                            "types to disambiguate", 
                                            contextValue.position)
                                }
                                if m.annotations.isAbstract {
                                    PandaCompiler.reportError(
                                            "'\{type.displayName}.\{name}' is " +
                                            "abstract", contextValue.position)
                                }
                                found := true
                                contextValue := methodReference(contextValue.position, m)
                            }
                        }
                        if !found {
                            throw new CompilerException("method not found",
                                    contextValue.position)
                        }*-
                        throw new NotSupportedException("member")
                    }
                    case TokenType.CONVERT: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def type:Type?
                        type, submessages := context.getType(c[i])
                        messages := addMessages(messages, submessages)
                        if type != null {
                            contextValue := convert(context, c[i].position, 
                                    contextValue, type)
                        }
                        else
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.CAST: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def type:Type?
                        type, submessages := context.getType(c[i])
                        messages := addMessages(messages, submessages)
                        if type != null {
                            contextValue, submessages := 
                                    contextValue.explicitCast(c[i].position, 
                                        type)
                            messages := addMessages(messages, submessages)
                        }
                        else
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.INSTANCEOF: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        def position := c[i].position
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def type:Type?
                        type, submessages := context.getType(c[i])
                        messages := addMessages(messages, submessages)
                        if type != null {
                            contextValue := convertInstanceOf(position, 
                                contextValue, type)
                        }
                        else
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.NINSTANCEOF: {
                        assert contextValue != null
                        var submessages:ListView<Message>?
                        contextValue, submessages := resolve(context, 
                                contextValue)
                        messages := addMessages(messages, submessages)
                        if contextValue = null
                            return (null, null, messages)
                        def position := c[i].position
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def type:Type?
                        type, submessages := context.getType(c[i])
                        messages := addMessages(messages, submessages)
                        if type != null {
                            def instanceof := convertInstanceOf(position, 
                                    contextValue, type)
                            contextValue := new UnaryOperation(position, 
                                    UnaryOperationType.NOT, instanceof)
                        }
                        else
                            return (null, null, messages)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.COMMA: {
                        assert contextValue != null
                        lvalues.add(contextValue)
                        i += 1
                        def submessages:ListView<Message>?
                        if c[i].type = ParseNodeType.CONSTRUCT {
                            contextValue, submessages := convertConstruct(
                                    context, c[i])
                            messages := addMessages(messages, submessages)
                        }
                        else {
                            def id := c[i]->>(String)
                            if id = "super"
                                contextValue := new Super(c.position)
                            else {
                                contextValue, submessages := 
                                        parseBareIdentifier(context, c[i])
                                messages := addMessages(messages, submessages)
                                if contextValue = null
                                    return (null, null, messages)
                            }
                        }
                        i += 1
                    }
                    case TokenType.UNDERSCORE: {
                        lvalues.add(contextValue)
                        contextValue := null
                    }
                    default: throw new InternalCompilerException(
                            "unsupported token '\{c[i]->(TokenNode).token.type}'", 
                                c[i].position)
                }
            }
            else if c[i].type = ParseNodeType.PARAMETERS {
                var params, submessages := convertParameters(context, c[i])
                messages := addMessages(messages, submessages)
                if params = null
                    return (null, null, messages)
                i += 1
                if contextValue-?>(Unresolved) {
                    contextValue, submessages := call(context, 
                            contextValue.position, 
                            contextValue->(Unresolved).contextValue, 
                            contextValue->(Unresolved).name, params)
                    messages := addMessages(messages, submessages)
                    if contextValue = null
                        return (null, null, messages)
                }
                else if contextValue-?>(Super) {
                    return (null, null, wrap(new Message(
                            "'super' is not a method", contextValue.position)))
                }
                else if contextValue-?>(Value) {
                    def v := contextValue->(Value)
                    if v.type.isMethod {
                        -- parentheses after a value of method type, need to
                        -- call the method
-*                        prepareMethodParameters(v, params)
                        contextValue := new DynamicCall(v.position, v, params)*-
                        throw new NotSupportedException("dynamic call")
                    }
                    else {
                        return (null, null, wrap(new Message("value of type '" + 
                                v.type.displayName + "' is not a method", 
                                contextValue.position)))
                    }
                }
                else {
                    assert contextValue != null
                    return (null, null, wrap(new Message(
                            "cannot call method on '\{contextValue}'", 
                            contextValue.position)))
                }
            }
            else {
                assert contextValue != null
                assert c[i].type = ParseNodeType.ASSIGNMENT_OPERATOR
                lvalues.add(contextValue)
                var expr, submessages := convertExpression(context, c[i + 1])
                messages := addMessages(messages, submessages)
                def result := new Array<Statement>()
                if expr != null {
                    def assignments:ListView<Statement>?
                    assignments, submessages := processAssignment(context, 
                            lvalues, c[i], expr)
                    if assignments != null
                        result.addAll(assignments)
                    messages := addMessages(messages, submessages)
                }
                return (null, new Block(c.position, result), messages)
            }
        }
        assert contextValue != null
        assert lvalues.length = 0
        def result, submessages := resolve(context, contextValue)
        messages := addMessages(messages, submessages)
        return (result, null, messages)
    }
    @post(@return[0] = null | @return[1] = null)

    ============================================================================
    Processes a CALL_OR_ASSIGNMENT parse node.
    ============================================================================
    @pre(c.type = ParseNodeType.CALL_OR_ASSIGNMENT)
    method convertCallOrAssignment(context:Context, c:ParseNode):
            (Statement?, ListView<Message>?) {
        var messages:ListView<Message>? := null
        var contextValue:Value? := null
        if c[0].type = ParseNodeType.CONSTRUCT
            contextValue, messages := convertConstruct(context, c[0])
        else if c[0].type = ParseNodeType.CALL_EXPRESSION {
--            contextValue := convertCallExpression(c[0])
            throw new NotSupportedException()
        }
        else {
            def id := c[0]->>(String)
            if id = "super"
                contextValue := new Super(c.position)
            else {
                def submessages:ListView<Message>?
                contextValue, submessages := parseBareIdentifier(context, c[0])
                messages := addMessages(messages, submessages)
                if contextValue = null
                    return (null, messages)
            }
        }
        def call, statement, submessages := processCallOrAssignment(context, 
                contextValue, c)
        messages := addMessages(messages, submessages)
        if call != null
            return (new ValueStatement(call), messages)
        else if statement != null
            return (statement, messages)
        else
            return (null, messages)
    }

    ============================================================================
    Processes an IF parse node.
    ============================================================================
    @pre(i.type = ParseNodeType.IF)
    method convertIf(context:Context, i:ParseNode):(If, ListView<Message>?) {
        assert i[0]->(TokenNode).token.type = TokenType.IF
        var messages:ListView<Message>? := null
        var test, submessages := convertExpression(context, i[1])
        messages := addMessages(messages, submessages)
        def cast:Value?
        if test != null {
            cast, submessages := test.implicitCast(BitType.BIT)
            messages := addMessages(messages, submessages)
        }
        else
            cast := new Dummy(i[1].position, BitType.BIT)
        assert i[2].type = ParseNodeType.STATEMENT_OR_BLOCK
        def ifBlock:Block
        ifBlock, submessages := convertStatementOrBlock(context, i[2])
        messages := addMessages(messages, submessages)
        def elseBlock:Block?
        if i.length > 3 {
            assert i[3]->(TokenNode).token.type = TokenType.ELSE
            elseBlock, submessages := convertStatementOrBlock(context, i[4])
            messages := addMessages(messages, submessages)
        }
        else
            elseBlock := null
        return (new If(i.position, cast, ifBlock, elseBlock), messages)
    }
    
    ============================================================================
    Processes an ANY_LOOP parse node.
    ============================================================================
    @pre(l.type = ParseNodeType.ANY_LOOP)
    method convertAnyLoop(context:Context, l:ParseNode):
            (AbstractLoop, ListView<Message>?) {
        def label:String?
        var i := 0
        if l[i]->(TokenNode).token.type = TokenType.IDENTIFIER {
            label := l[i]->>(String)
            assert l[i + 1].type = ParseNodeType.TOKEN &
                    l[i + 1]->(TokenNode).token.type = TokenType.COLON
            i += 2
        }
        else 
            label := null
        switch l[i]->(TokenNode).token.type {
--            case TokenType.FOR:
--                result := convertForLoop(l, i, label)
            case TokenType.DO: {
                i += 1
                var messages:ListView<Message>? := null
                assert l[i + 1].type = ParseNodeType.TOKEN &
                        l[i + 1]->(TokenNode).token.type = TokenType.WHILE
                var test, submessages := convertExpression(context, l[i + 2])
                messages := addMessages(messages, submessages)
                def cast:Value?
                if test != null {
                    cast, submessages := test.implicitCast(BitType.BIT)
                    messages := addMessages(messages, submessages)
                }
                else
                    cast := new Dummy(l[i + 2].position, BitType.BIT)
                def block:Block
                block, submessages := convertStatementOrBlock(context, l[i])
                messages := addMessages(messages, submessages)
                return (new Do(l.position, label, cast, block), messages)
            }
            case TokenType.LOOP: {
                i += 1
                var block, messages := convertStatementOrBlock(context, l[i])
                return (new Loop(l.position, label, block), messages)
            }
            case TokenType.WHILE: {
                i += 1
                var messages:ListView<Message>? := null
                var test, submessages := convertExpression(context, l[i])
                messages := addMessages(messages, submessages)
                def cast:Value?
                if test != null {
                    cast, submessages := test.implicitCast(BitType.BIT)
                    messages := addMessages(messages, submessages)
                }
                else
                    cast := new Dummy(l[i].position, BitType.BIT)
                i += 1
                def block:Block?
                block, submessages := convertStatementOrBlock(context, l[i])
                messages := addMessages(messages, submessages)
                return (new While(l.position, label, cast, block), messages)
            }
            default: {
                throw new InternalCompilerException("unsupported loop type", 
                        l.position)
            }
        }
    }
    
    ============================================================================
    Processes a VAR_DECLARATION parse node. Returns a list of variables and
    statements to initialize them.
    ============================================================================
    @pre(v.type = ParseNodeType.VAR_DECLARATION)
    method convertVariableDeclaration(var context:Context, v:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def variables := new Array<Variable>()
        def statements := new Array<Statement>()
        def varType:VariableType
        switch v[0]->(TokenNode).token.type {
            case TokenType.VAR:      varType := VariableType.VAR
            case TokenType.DEF:      varType := VariableType.DEF
            case TokenType.CONSTANT: varType := VariableType.CONSTANT
            default: unreachable
        }
        def positions := new Array<Position>()
        def names := new Array<String?>()
        def types := new Array<Type?>()
        var i := 1
        loop {
            positions.add(v[i].position)
            var name:String?
            if v[i]->(TokenNode).token.type = TokenType.UNDERSCORE
                name := null
            else {
                assert v[i]->(TokenNode).token.type = TokenType.IDENTIFIER
                name := v[i]->>(String)
            }
            i += 1
            def type:Type?
            if i < v.length & v[i].type = ParseNodeType.TYPE_DECLARATION {
                def submessages:ListView<Message>?
                type, submessages := context.getType(v[i][1])
                messages := addMessages(messages, submessages)
                i += 1
            }
            else
                type := null
            names.add(name)
            types.add(type)
            if i >= v.length | v[i].type != ParseNodeType.TOKEN | 
                    v[i]->(TokenNode).token.type != TokenType.COMMA
                break
            i += 1
        }
        def value:Value?
        if i < v.length {
            assert v[i]->(TokenNode).token.type = TokenType.ASSIGNMENT
            i += 1
            def submessages:ListView<Message>?
            value, submessages := convertExpression(context, v[i])
            messages := addMessages(messages, submessages)
        }
        else
            value := null
        var reusableTuple:ReusedValueDefinition? := null
        if names.length > 1 {
            if value != null {
                def valueType := value.preferredVariableType
                if !valueType.isTuple | 
                        valueType->>(TupleType).types.length != names.length {
                    messages := addMessage(messages, "expected a tuple with " +
                                "length \{names.length} for multi-value " +
                                "assignment", value.position)
                }
                for j, type in types {
                    if type = null
                        types[j] := valueType->>(TupleType).types[j].preferredVariableType
                }
                if value-!>(UnresolvedTuple)
                    reusableTuple := new ReusedValueDefinition(value)
            }
        }
        else if value != null & types[0] = null
            types[0] := value.preferredVariableType
        if names.length = 1 & names[0] = null {
            messages := addMessage(messages, "'_' is only permitted in " +
                    "multiple assignments from a tuple", positions[0])
        }
        for j, name in names {
            if name = null
                continue
            def position := positions[j]
            var type := types[j]
            if type = null | type = NullType.NULL {
                if messages = null {
                    messages := addMessage(messages, 
                            "'\{name}' has neither an initial " +
                            "value nor an explicit type", position)
                }
                type := ClassType.OBJECT
            }
            def variable := new LocalVariable(position, name, type, varType)
            context += variable
            if value != null {
                def effectiveValue:Value
                if reusableTuple != null {
-*                    effectiveValue := getField(value.position, 
                            reusableTuple.createReference(), "$field" + j).
                                implicitCast(variable.type)*-
                    unreachable
                }
                else if value-?>(UnresolvedTuple) & names.length > 1 {
                    def element := value->(UnresolvedTuple).values[j]
                    def submessages:ListView<Message>?
                    effectiveValue, submessages := element.implicitCast(
                            variable.type)
                    messages := addMessages(messages, submessages)
                }
                else {
                    def submessages:ListView<Message>?
                    effectiveValue, submessages := value.implicitCast(
                            variable.type)
                    messages := addMessages(messages, submessages)
                }
                def va := new VariableAssignment(position, variable, 
                        effectiveValue, true)
                statements.add(new ValueStatement(va))
            }
        }
        def newContext := context + variables
        if statements.length = 0
            return (null, newContext, messages)
        if statements.length = 1
            return (statements[0], newContext, messages)
        return (new Block(v.position, statements), newContext, messages)
    }

    ============================================================================
    Processes a SIMPLE_STATEMENT parse node.
    ============================================================================
    @pre(s.type = ParseNodeType.SIMPLE_STATEMENT)
    method convertSimpleStatement(context:Context, s:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.VAR_DECLARATION: 
                return convertVariableDeclaration(context, s[0])
--            case ParseNodeType.CONSTANT_DECLARATION: 
--                return convertConstantDeclaration(s[0])
            case ParseNodeType.CALL_OR_ASSIGNMENT: {
                def call, messages := convertCallOrAssignment(context, s[0])
                return (call, context, messages)
            }
            case ParseNodeType.ANY_LOOP:  {
                def l, messages := convertAnyLoop(context, s[0])
                return (l, context, messages)
            }
            case ParseNodeType.IF: {
                def i, messages := convertIf(context, s[0])
                return (i, context, messages)
            }
-*
            case ParseNodeType.SWITCH_STATEMENT: {
                def s, messages := convertSwitch(context, s[0])
                return (convertSwitch(s[0]), context, messages)
            }
            case ParseNodeType.ASSERT_STATEMENT: {
                def a, messages := convertAssert(context, s[0])
                return (a, context, messages)
            }
            case ParseNodeType.TRY_STATEMENT: {
                def t, messages := convertTryStatement(context, s[0])
                return (t, context, messages)
            }*-
            default: throw new InternalCompilerException(
                    "unsupported simple statement: \{s[0].type}", 
                    s.position)
        }
    }

    ============================================================================
    Processes a THROW_STATEMENT parse node.
    ============================================================================
    @pre(t.type = ParseNodeType.THROW_STATEMENT)
    method convertThrowStatement(t:ParseNode):(Throw, ListView<Message>?) {
-*        return new Throw(t.position, implicitCast(t[1].position,
                convertExpression(t[1]), ClassType.ERROR())))*-
        throw new NotSupportedException()
    }

    ============================================================================
    Processes an UNREACHABLE token.
    ============================================================================
    @pre(t->(TokenNode).token.type = TokenType.UNREACHABLE)
    function convertUnreachable(t:ParseNode):Unreachable {
        return new Unreachable(t.position)
    }

    @pre(s.type = ParseNodeType.TERMINAL_STATEMENT)
    method convertTerminalStatement(context:Context, s:ParseNode):
            (Statement, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.BREAK_STATEMENT: {
                def b := s[0]
                if b.length > 1
                    return (new Break(b.position, b[1]->>(String)), null)
                else
                    return (new Break(b.position), null)
            }
            case ParseNodeType.CONTINUE_STATEMENT: {
                def c := s[0]
                if c.length > 1
                    return (new Continue(c.position, c[1]->>(String)), null)
                else
                    return (new Continue(c.position), null)
            }
            case ParseNodeType.RETURN_STATEMENT: {
                def r := s[0]
                if r.length > 1 {
                    def cm := context.currentMethod
                    assert cm != null
                    var value, messages := convertExpression(context, r[1])
                    if value != null {
                        def cast, submessages := value.implicitCast(
                                cm.returnType)
                        messages := addMessages(messages, submessages)
                        return (new Return(r.position, cast), messages)
                    }
                    return (new Return(r.position, new Dummy(r.position,
                            cm.returnType)), messages)
                }
                else
                    return (new Return(r.position), null)
            }
-*            case ParseNodeType.THROW_STATEMENT: {
                def t, messages := convertThrowStatement(context, s[0])
                return (t, messages)
            }*-
            case ParseNodeType.TOKEN: 
                return (convertUnreachable(s[0]), null)
            default: {
                throw new InternalCompilerException(
                        "unsupported terminal statement: \{s[0].class.name}", 
                        s[0].position)
            }
        }
    }

    ============================================================================
    Processes a STATEMENT parse node.
    ============================================================================
    @pre(s.type = ParseNodeType.STATEMENT)
    method convertStatement(context:Context, s:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.SIMPLE_STATEMENT: 
                return convertSimpleStatement(context, s[0])
            case ParseNodeType.BLOCK: {
                def b, newContext, messages := convertBlock(context, s[0])
                return (b, context.addLocalsFrom(newContext), messages)
            }
            default: throw new InternalCompilerException(
                    "unsupported statement: \{s[0].class.name}", s[0].position)
        }
    }

    ============================================================================
    Processes a STATEMENT_OR_BLOCK parse node.
    ============================================================================
    @pre(b.type = ParseNodeType.STATEMENT_OR_BLOCK)
    method convertStatementOrBlock(context:Context, b:ParseNode):
            (Block, ListView<Message>?) {
        if b[0].type = ParseNodeType.BLOCK {
            def result, _, messages := convertBlock(context, b[0])
            return (result, messages)
        }
        else {
            def statement:Statement?
            def messages:ListView<Message>?
            if b[0].type = ParseNodeType.SIMPLE_STATEMENT {
                def ignored:Context
                statement, ignored, messages := convertSimpleStatement(context,
                        b[0])
            }
            else
                statement, messages := convertTerminalStatement(context, b[0])
            def statements := new Array<Statement>()
            if statement != null
                statements.add(statement)
            return (new Block(b.position, statements), messages)
        }
    }

    ============================================================================
    Processes a BLOCK parse node.
    ============================================================================
    @pre(b.type = ParseNodeType.BLOCK)
    method convertBlock(context:Context, b:ParseNode):
            (Block, Context, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def statements := new Array<Statement>()
        var currentContext := context
        for i in 1 ... b.length - 2 {
            switch b[i].type {
                case ParseNodeType.STATEMENT: {
                    def statement, newContext, submessages := 
                            convertStatement(currentContext, b[i])
                    if statement != null
                        statements.add(statement)
                    currentContext := newContext
                    messages := addMessages(messages, submessages)
                }
                case ParseNodeType.TERMINAL_STATEMENT: {
                    def statement, submessages := convertTerminalStatement(
                            currentContext, b[i])
                    statements.add(statement)
                    messages := addMessages(messages, submessages)
                }
                default: {
                    throw new InternalCompilerException(
                            "unsupported statement in block: \{b[i].class.name}", 
                            b[i].position)
                }
            }
        }
        return (new Block(b.position, statements), currentContext, messages)
    }

    method convertMethod(var context:Context, m:TypedMethodStub):
            (MethodNode, ListView<Message>?) {
        def block:Block?
        def messages:ListView<Message>?
        if m.block != null {
            def newContext := new Context(context.currentClass, m, 
                    context.lookupContext, context.typeMap, context.stubs,
                    new ImmutableArray<LocalVariable>(),
                    context.visibleVariables)
            block, context, messages := convertBlock(newContext, 
                    m.block->(ParseNode))
        }
        else {
            block := null
            messages := null
        }
        def parameters := new Array<Parameter>()
        for p in m.parameters {
            parameters.add(new Parameter(p.position, p.name, p.type, p.isFinal,
                    p.isConvert, p.isVarArg))
        }
        return (new MethodNode(m.position, m, m.name, m.methodType, parameters, 
                m.returnType, m.annotations, block, context.localVariables), 
                messages)
    }

    method convertClass(cl:TypedClassStub, typeMap:TypeMap, 
            stubs:ImmutableHashMap<String, TypedClassStub>):
            (ClassNode, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def methods := new Array<MethodNode>()
        def fields := new Array<FieldNode>()
        for m in cl.methods {
            def context := new Context(cl, null, cl.lookupContext, typeMap, 
                    stubs, new ImmutableArray<LocalVariable>(),
                    new ImmutableHashMap<String, Variable>(
                        new HashMap<String, Variable>()))
            def compiled, submessages := convertMethod(context, m)
            methods.add(compiled)
            messages := addMessages(messages, submessages)
        }
        def result := new ClassNode(cl.position, cl.name, cl.isInterface, 
            cl.annotations, cl.lookupContext, cl.superclass, cl.interfaces, 
            methods, fields, cl.invariants,
            cl.genericParameters)
        return (result, messages)
    }

    method convertCompilationUnit(compilationUnit:TypedCompilationUnitStub,
            typeMap:TypeMap, stubs:ImmutableHashMap<String, TypedClassStub>):
            (CollectionView<ClassNode>, ListView<Message>?) {
        def result := new Array<ClassNode>()
        var messages:ListView<Message>? := null
        for cl in compilationUnit.classes {
            if cl.genericParameters = null & !cl.isExternal {
                def classNode, submessages := convertClass(cl, typeMap, stubs)
                result.add(classNode)
                messages := addMessages(messages, submessages)
            }
        }
        return (result, messages)
    }

    method convertCompilationUnits(
            compilationUnits:CollectionView<TypedCompilationUnitStub>,
            typeMap:TypeMap):
                (CollectionView<ClassNode>, ListView<Message>?) {
        def result := new Array<ClassNode>()
        def stubs := new HashMap<String, TypedClassStub>()
        for cu in compilationUnits {
            for cl in cu.classes
                stubs[cl.name] := cl
        }
        def immutableStubs := new ImmutableHashMap<String, TypedClassStub>(stubs)
        var messages:ListView<Message>? := null
        for cu in compilationUnits {
            def classes, submessages := convertCompilationUnit(cu, typeMap, 
                    immutableStubs)
            result.addAll(classes)
            messages := addMessages(messages, submessages)
        }
        return (result, messages)
    }
}