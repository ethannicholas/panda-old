package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.parser.ParseNodeType
uses org.pandalanguage.pandac.parser.Token
uses org.pandalanguage.pandac.parser.TokenNode
uses org.pandalanguage.pandac.parser.TokenType
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.And
uses org.pandalanguage.pandac.tree.AndLeft
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.BitwiseAnd
uses org.pandalanguage.pandac.tree.BitwiseNot
uses org.pandalanguage.pandac.tree.BitwiseOr
uses org.pandalanguage.pandac.tree.BitwiseXor
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Divide
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.Equal
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.ForEach
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithRange
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryMinus
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedPrimitiveArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedLambda
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.RealLiteralType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.UnresolvedTypeException
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

@private
class MethodMatch {
    var methodNode:MethodNode
    var params:PrimitiveArray<Value>

    constructor(methodNode:MethodNode, params:PrimitiveArray<Value>) {
        self.methodNode := methodNode
        self.params := params
    }
}

================================================================================
A placeholder object which stands in for a `Value`, generally so we can perform
method lookup without having to have actual correct `Value`s.
================================================================================
class Dummy : Value {
    constructor(type:Type) {
        super.constructor(type)
    }

    constructor(position:Position, type:Type) {
        super.constructor(position, type)
    }
}

================================================================================
A reference to a field which could, depending on context, also refer to a no-arg
function of the same name.
================================================================================
@private
class AmbiguousReference : Value {
    var context:Value
    var field:FieldNode

    constructor(position:Position, context:Value, field:FieldNode) {
        super.constructor(position, field.type)
        self.context  := context
        self.field    := field
        self.position := position
    }
}

================================================================================
Represents a element of a shared tuple, for initializing several fields from the
same value.
================================================================================
@private
class TupleReference {
    var tuple:ParseNode
    var element:Int

    constructor(tuple:ParseNode, element:Int) {
        self.tuple := tuple
        self.element := element
    }
}

================================================================================
Used to represent something that looks like an array index (foo[bar]) but can't
actually be resolved into something meaningful. We do this because if the next
token we run into is a ":=", the expression could still resolve into an indexed
assignment.
================================================================================
@private
class PossibleIndexedAssignment : Value {
    var context:Value
    var index:Value

    constructor(position:Position, context:Value, index:Value) {
        super.constructor(position, Type.UNRESOLVED)
        self.context := context
        self.index := index
    }
}

================================================================================
Used to represent something that looks like an slice (foo[bar .. baz]) but can't
actually be resolved into something meaningful. We do this because if the next
token we run into is a ":=", the expression could still resolve into a slice
assignment.
================================================================================
@private
class PossibleSliceAssignment : Value {
    var context:Value
    var left:Value
    var right:Value
    var step:Value
    var endInclusive:Bit

    constructor(position:Position, context:Value, left:Value, right:Value,
            step:Value, endInclusive:Bit) {
        super.constructor(position, Type.UNRESOLVED)
        self.context := context
        self.left := left
        self.right := right
        self.step := step
        self.endInclusive := endInclusive
    }
}

================================================================================
Converts a Panda parse tree into an abstract syntax tree. This represents the
vast majority of the compilation effort; at the end of this process, we have
(hopefully) fully comprehended the program and have generated a ready-to-execute
syntax tree, though one which still needs safety analysis (including insertion
of precondition / postcondition checks) and optimization.
================================================================================
class ASTGenerator {
    constant INDEX_SUFFIX := "$index"

    constant AUTO_PREFIX := "$auto_"

    constant SHIM_PREFIX := "$shim_"

    constant STRING_GROUP := #/(?<!\\)\\\{.*?(?<!\\)\}/#

    constant UNESCAPED_BRACE := #/(?<!\\)\{/#

    @thread
    -- FIXME can't leave this a thread variable, will be broken in a 
    -- multithreaded situation
    var autoIndex := 0

    ============================================================================
    `true` if we are only converting linkage information (class, method, and
    field declarations), as opposed to the entire parse tree.
    ============================================================================
    var linkageOnly:Bit
    
    ============================================================================
    `true` to override the normal "don't resolve type names while gathering
    linkage information" rule.
    ============================================================================
    var forceTypeResolution:Bit

    ============================================================================
    Contains the stack of nodes being processed, beginning with a 
    `CompilationUnit`. `currentClass`, `currentMethod`, `currentBlock`, and 
    `currentObject` refer to the contents of this stack.
    ============================================================================
    var nodeStack := new Stack()
    
    ============================================================================
    Maps fields to their initializer expressions, so that we can insert them at
    the beginning of constructors. The values will either be ParseNodes or
    TupleReferences.
    ============================================================================
    var pendingFieldValues:Map := new HashMap()
    
    ============================================================================
    If this source file contains statements appearing outside of a class, holds 
    the implicit main method created to contain them.
    ============================================================================
    var implicitMain:MethodNode?
    
    ============================================================================
    If this source file contains statements or functions appearing outside of a
    class, holds the implicit class created to contain them.
    ============================================================================
    var implicitClass:ClassNode?
    
    ============================================================================
    `true` if we are parsing a `@post(...)` expression, meaning we should 
    permit `@pre(...)` and `@return` to appear in expressions.
    ============================================================================
    var inPostcondition:Bit

    ============================================================================
    `true` if we are in a context where Unwrap is legal (the last parameter of a
    method).
    ============================================================================
    var allowUnwrap:Bit

    ============================================================================
    When we are parsing a `@post(...)` expression, holds the value which should
    be substituted in for appearances of the `@return` token.
    ============================================================================
    var returnValue:ReusedValueDefinition?
    @invariant(returnValue = null | inPostcondition)

    ============================================================================
    The name of the package from the last `package` statement we saw.
    ============================================================================
    var currentPackage:String?

    ============================================================================
    A list of all packages referenced by `uses`.
    ============================================================================
    var packageUses := new PrimitiveArray<String>()

    ============================================================================
    A map of `uses` aliases to the classes those aliases represent.
    ============================================================================
    var classUses:Map := new HashMap()

    var namePrefix := hash.abs->>(String)

    var nameCount := 0

    var positionToNodeMap:Map? := new HashMap()

    ============================================================================
    Passed in to BinaryOperation.getOperandType(). Set to false when we are
    expanding generic code.
    ============================================================================
    var strictTypeChecking := true

    ============================================================================
    @returns the current node being processed (the top of the node stack).
    ============================================================================
    function currentNode():Node {
        return nodeStack.peek()->(Node)
    }
    
    ============================================================================
    @returns the current block being processed.
    ============================================================================
    function currentBlock():Block {
        for i in 0 .. nodeStack.length {
            var n := nodeStack.peek(i)
            if n-?>(Block)
                return n->(Block)
        }
        throw new AssertionError("called currentBlock with no current block")   
    }

    function inBlock():Bit {
        for i in 0 .. nodeStack.length {
            var n := nodeStack.peek(i)
            if n-?>(Block)
                return true
        }
        return false
    }

    ============================================================================
    @returns the current method being processed.
    ============================================================================
    function currentMethod():MethodNode? {
        for i in 0 .. nodeStack.length {
            var n := nodeStack.peek(i)
            if n-?>(MethodNode)
                return n->(MethodNode)
        }
        return null
    }
    
    ============================================================================
    @returns the current class being processed.
    ============================================================================
    function currentClass():ClassNode? {
        for i in 0 .. nodeStack.length {
            var n := nodeStack.peek(i)
            if n-?>(ClassNode)
                return n->(ClassNode)
        }
        return null
    }
    
    ============================================================================
    @returns the current compilation unit being processed.
    ============================================================================
    function currentCompilationUnit():CompilationUnit {
        for i in 0 .. nodeStack.length {
            var n := nodeStack.peek(i)
            if n-?>(CompilationUnit)
                return n->(CompilationUnit)
        }
        throw new InternalCompilerException("no currentCompilationUnit")
    }
    
    ============================================================================
    Pushes a new node to the node stack, also adding it as a child of 
    `currentNode` (if there is a current node).
    
    @param n the node to open
    ============================================================================
    method open(n:Node) {
        if nodeStack.length > 0
            currentNode.add(n)
        nodeStack.push(n)
    }
        
    ============================================================================
    Pops the current node from the node stack, ensuring that it is an instance
    of the specified class.
    
    @param c the class to verify the top of the stack against
    ============================================================================
    method close(c:Class) {
        var n := nodeStack.pop()
        assert n.class = c
    }

    method nextCount():String {
        nameCount += 1
        return namePrefix + nameCount
    }

    @private
    method captureNode(node:Node) {
        captureNode(node, node.position)
    }

    @private
    method captureNode(node:Node, position:Position) {
        captureNode(node, position, null)
    }

    @private
    method captureNode(node:Node, position:Position, type:String?) {
        if positionToNodeMap != null
            positionToNodeMap[position] := (node, type)
    }

    @private
    method captureTree(node:Node, parseNode:ParseNode, type:String?) {
        for child in parseNode.children
            captureTree(node, child, type)
        captureNode(node, parseNode.position, type)
    }
        
    ============================================================================
    Processes a TYPE parse node.
    ============================================================================
    @pre(t.type = ParseNodeType.TYPE)
    method convertType(t:ParseNode):Type {
        def name := new MutableString()
        for child in t.children
            name.append(child)
        return getType(t.position, name->>(String))
    }
    @post(nodeStack.length = @pre(nodeStack.length))
    
    @class
    @pre(v.parent != null)
    method makeReusable(v:Value):ReusedValueDefinition {
        def dummy := new Dummy(v.position, NullType.NULL)
        v.replace(dummy)
        def result := new ReusedValueDefinition(v)
        dummy.replace(result)
        return result
    }

    ============================================================================
    Handles an implicit cast from one type to another. Implicit casts handle any 
    case where you may use one type where another is expected without having to 
    specify any kind of conversion, such as passing a `String` where an `Object` 
    is expected or an `Int8` where a `Real32` is expected.
    
    @param position the position in the source file, for error-reporting 
            purposes
    @param v the value being converted
    @param t the type to convert the value to
    @param ct the CastType that resulting casts should be created with
    @returns a value of the specified type
    ============================================================================
    -- FIXME this has gotten ridiculous -- should probably refactor it into the
    -- values themselves
    @pre(t-!>(UnresolvedType))
    method implicitCast(position:Position, var v:Value, var t:Type, 
            ct:CastType):Value {
        var srcType := v.type
        if srcType = VoidType.VOID {
            throw new CompilerException(
                    "value '\{v}' does not have a type", position)
        }
        if srcType = t
            return v
        if !v.canImplicitCastTo(t) {
            if v-?>(UnresolvedLambda)
                v->(UnresolvedLambda).reportErrors()
            throw new CompilerException(
                    "expected '\{t.displayName}', but found " +
                    "'\{srcType.displayName}'", position)
        }
        if v-?>(UnresolvedClassLiteral) {
            return implicitCast(position, 
                    v->(UnresolvedClassLiteral)->>(ClassObjectLiteral),
                    t, ct)
        }
        if v-?>(NullLiteral)
            return new NullLiteral(position, t)
        if srcType.isNullable & t.isNullable
            return nullableToNullableConversion(v, t, CastType.IMPLICIT)
        var unwrapped := t.unwrapWrapper
        if srcType = StringOrCharType.STRING_OR_CHAR &
                ClassType.STRING().canImplicitCastTo(t) {
            return implicitCast(position, 
                    new StringLiteral(position, v->(StringLiteral).value, 
                        ClassType.STRING()), 
                    t, ct)
        }
        if srcType = StringOrCharType.STRING_OR_CHAR &
                CharType.CHAR.canImplicitCastTo(t) {
            def char := new IntegerLiteral(position, 
                    v->(StringLiteral).value[0]->(UInt), CharType.CHAR)
            return implicitCast(position, char, t, ct)
        }
        if srcType.isPrimitive & t-!>(PrimitiveType) {
            -- wrap primitive
            -- this is a bit complicated because we don't just handle 
            -- Int32->(Int32Wrapper), we also have to worry about e.g.
            -- Int8->(Real64Wrapper?) and Real32->(Object)
            var wrapperType:WrapperType
            if t.isWrapper {
                -- t is a wrapper, cast straight to it
                wrapperType := t.unwrapNullable->(WrapperType)
            }
            else {
                -- t isn't a wrapper (e.g. it could be Object), so wrap v in its
                -- native wrapper
                wrapperType := 
                        srcType.unwrapRealLiteral.wrapperVersion()
            }
            -- create the wrapper
            def wrapped := call(position, new ClassLiteral(position, 
                    wrapperType), "new", new PrimitiveArray<Value>(v))
            -- cast the wrapper to the final dest type (this may upcast and/or
            -- add nullability, but is often a no-op)
            return implicitCast(position, wrapped, t, ct)
        }
        else if srcType.unwrapNullable.isWrapper & t.isPrimitive {
            -- unwrap primitive
            if v-?>(Construct) {
                -- it's a call to a wrapper constructor, just pull out the
                -- parameter. FIXME PERFORMANCE: find spots where this 
                -- (wrapping->unwrapping) is happening and kill them. Obviously
                -- will only affect the performance of the compiler itself 
                -- rather than the generated code.
                v := v->(Construct).parameters[0]
                v.removeFromParent()
            }
            else {
                def cl := srcType.classNode
                def field := cl.unifiedFields[1]
                assert field.name = "value"
                if srcType.isNullable
                    v := implicitCast(position, v, srcType.unwrapNullable, ct)
                v := new FieldReference(position, v, field)
                captureNode(field)
            }
            return implicitCast(position, v, t, ct)
        }
        else if srcType.isWrapper & unwrapped.isPrimitive &
                srcType.unwrapWrapper != unwrapped {
            def intermediate := implicitCast(position, v, unwrapped, ct)
            return implicitCast(position, intermediate, t, ct)
        }
        else if v-?>(IntegerLiteral) & t.isInteger
            return new IntegerLiteral(v.position, v->(IntegerLiteral).value, t)
        else if v-?>(IntegerLiteral) & t.isReal
            return new RealLiteral(v.position, v->(IntegerLiteral).value, t)
        else if v-?>(RealLiteral) & t.isReal
            return new RealLiteral(v.position, v->(RealLiteral).value, t)
        else if v-?>(BinaryOperation) & srcType = RealLiteralType.REAL_LITERAL {
            def b := v->(BinaryOperation)
            def left := b.left
            def right := b.right
            left.removeFromParent()
            right.removeFromParent()
            b.add(implicitCast(left.position, left, t, ct))
            b.add(implicitCast(right.position, right, t, ct))
            b.type := t
            return v
        }
        else if v-?>(UnaryMinus) & srcType.isInteger & t.isInteger {
            def value := v->(UnaryMinus).value
            value.removeFromParent()
            return new UnaryMinus(v.position, implicitCast(position, value, t, 
                    ct), t)
        }
        else if v-?>(UnresolvedPrimitiveArray)
            return castUnresolvedPrimitiveArray(v->(UnresolvedPrimitiveArray), t, ct)
        else if v-?>(UnresolvedTuple)
            return castUnresolvedTuple(v->(UnresolvedTuple), t, ct)
        else if v-?>(UnresolvedRange)
            return castUnresolvedRange(v->(UnresolvedRange), t, ct)
        else if v-?>(UnresolvedLambda) & t.isMethod
            return castUnresolvedLambda(v->(UnresolvedLambda), t, ct)
        else if srcType-?>(MethodType) & srcType.isImmutable & t.isMethod & 
                !t.isImmutable
            return new Cast(position, convert(position, v, 
                    ClassType.MUTABLE_METHOD()), t, ct)
        return new Cast(position, v, t, ct)
    }


    method implicitCast(position:Position, v:Value, t:Type):Value {
        return implicitCast(position, v, t, CastType.IMPLICIT)
    }
    
    method implicitCast(v:Value, t:Type):Value {
        return implicitCast(v.position, v, t, CastType.IMPLICIT)
    }
    
    @private
    method determineUnresolvedPrimitiveArrayElementType(a:UnresolvedPrimitiveArray):Type {
        var values := a.values[..]
        if values.length = 0
            return Type.ANY()
        else {
            -- FIXME use a fold when that's working
            var elementType := values[0].variableType()
            for v in values
                elementType := Type.union(elementType, v.variableType())
            return elementType
        }
    }
    @post(@return-!>(UnresolvedType))

    @private
    @pre(ct = CastType.IMPLICIT | ct = CastType.EXPLICIT)
    method castUnresolvedPrimitiveArray(a:UnresolvedPrimitiveArray, t:Type, ct:CastType):Value {
        var values := a.values[..]
        var unwrapped := t.unwrapNullable
        var elementType:Type
        var immutable := false
        if unwrapped.isPrimitiveArray {
            elementType := unwrapped.elementType
            immutable := unwrapped.isImmutable
        }
        else
            elementType := determineUnresolvedPrimitiveArrayElementType(a)
        for i, v in values {
            v.removeFromParent()
            if ct = CastType.IMPLICIT
                values[i] := implicitCast(v.position, v, elementType)
            else if ct = CastType.EXPLICIT
                values[i] := explicitCast(v.position, v, elementType)
            else
                unreachable
        }
        var arrayType:Type
        if immutable {
            arrayType := SymbolTable.master.getType(a.position,
                    class(ImmutablePrimitiveArray).name + "<" + elementType.name + ">")
        }
        else {
            arrayType := SymbolTable.master.getType(a.position,
                    class(PrimitiveArray).name + "<" + elementType.name + ">")
        }
        var newPrimitiveArray := new NewPrimitiveArrayWithValues(a.position, arrayType, values)
        if ct = CastType.IMPLICIT
            return implicitCast(newPrimitiveArray.position, newPrimitiveArray, t)
        else
            return explicitCast(newPrimitiveArray.position, newPrimitiveArray, t)
    }

    @private
    @pre(ct = CastType.IMPLICIT | ct = CastType.EXPLICIT)
    method castUnresolvedRange(r:UnresolvedRange, t:Type, ct:CastType):Value {
        if !t.isPrimitiveArray {
            return implicitCast(r.position, implicitCast(r.position, r, 
                    r.variableType(), ct), t, ct)
        }
        var type := t.elementType
        if t.isImmutable {
            def mutableVersion := SymbolTable.master.getType(r.position,
                    class(PrimitiveArray).name + "<" + type.name + ">")
            return convert(r.position, castUnresolvedRange(r, mutableVersion, 
                    ct), t)
        }
        var array:Value? := null
        var left := r.left
        if left = null
            left := new NullLiteral(r.position)
        var right := r.right
        if right = null
            right := new NullLiteral(r.position)
        def step := r.step
        if type.isPrimitive
            type := type->(PrimitiveType).wrapperVersion()
        if !type.isWrapper
            type := r.variableType()
        if type.isWrapper {
            def wrapper := new ClassLiteral(r.position, type)
            var name:String
            if r.endInclusive
                name := "[...]"
            else
                name := "[..]"
            if step = null
                array := testCall(r.position, wrapper, name, [left, right])
            else {
                array := testCall(r.position, wrapper, name, [left, right,
                        step])
            }
        }
        if array = null {
            var msg:String
            if r.endInclusive
                msg := "inclusive"
            else
                msg := "exclusive"
            if step = null {
                msg += " range operator cannot operate on '" + 
                        "\{left.type.displayName}', '" + 
                        "\{right.type.displayName}'"
            }
            else {
                msg += " range operator cannot operate on '" + 
                        "\{left.type.displayName}', '" + 
                        "\{right.type.displayName}', '" +
                        "\{step.type.displayName}'"
            }
            throw new CompilerException(msg, r.position)
        }
        return implicitCast(r.position, array, t, ct)
    }

    @private
    @pre(ct = CastType.IMPLICIT | ct = CastType.EXPLICIT)
    method castUnresolvedTuple(u:UnresolvedTuple, t:Type, ct:CastType):Value {
        def values := u.values[..]
        def unwrapped := t.unwrapNullable
        var tupleType:TupleType
        if unwrapped.isTuple {
            tupleType := unwrapped.unwrapNullable->(TupleType)
            for i, v in values {
                v.removeFromParent()
                if ct = CastType.IMPLICIT
                    values[i] := implicitCast(v.position, v, tupleType.types[i])
                else if ct = CastType.EXPLICIT
                    values[i] := explicitCast(v.position, v, tupleType.types[i])
                else
                    unreachable
            }
        }
        else {
            tupleType := u.variableType().unwrapNullable->(TupleType)
            for v in values
                v.removeFromParent()
        }
        def tuple := call(u.position, new ClassLiteral(u.position,
                tupleType), "new", values)
        if ct = CastType.IMPLICIT
            return implicitCast(tuple.position, tuple, t)
        else
            return explicitCast(tuple.position, tuple, t)
    }

    @private
    @pre(ct = CastType.IMPLICIT | ct = CastType.EXPLICIT)
    @pre(t.isMethod)
    method castUnresolvedLambda(l:UnresolvedLambda, t:Type, ct:CastType):Value {
        def methodType := t.unwrapNullable->(MethodType)
        def parameters := methodType.methodParameters
        def returnType := methodType.returnType
        return implicitCast(l.position, resolveLambda(l, 
                new PrimitiveArray<Type>(parameters, 0, parameters.length), returnType), 
                t, ct)
    }

    ============================================================================
    Handles an explicit cast from one type to another. Explicit casts are
    specified in the source via the `->` operator.
    
    @param position the position in the source file, for error-reporting 
            purposes
    @param v the value being converted
    @param t the type to convert the value to
    @returns a value of the specified type
    ============================================================================
    method explicitCast(position:Position, var v:Value, var t:Type):Value {
        var srcType := v.type
        if srcType-?>(RealLiteralType) {
            if t-?>(PrimitiveType) & t->(PrimitiveType).size <= 32 {
                v := implicitCast(position, v, RealType.REAL32, 
                        CastType.EXPLICIT)
            }
            else {
                v := implicitCast(position, v, RealType.REAL64, 
                        CastType.EXPLICIT)
            }
            srcType := v.type
        }
        if srcType = t
            return v
        if srcType.isNullable & t.isNullable
            return nullableToNullableConversion(v, t, CastType.EXPLICIT)
        if srcType = StringOrCharType.STRING_OR_CHAR & t.isPrimitive &
                t.unwrapRealLiteral.isNumeric {
            v := implicitCast(position, v, CharType.CHAR, CastType.EXPLICIT)
            srcType := v.type
        }
        if v.canImplicitCastTo(t)
            return implicitCast(position, v, t, CastType.EXPLICIT)
        if v.canExplicitCastTo(t) {
            if srcType = StringOrCharType.STRING_OR_CHAR {
                -- we should only get here in the event of casts to numeric 
                -- types, as the other permitted cases would be caught by the 
                -- implicit cast check above
                assert t.unwrapWrapper.isPrimitive
                return explicitCast(position, implicitCast(position, v, 
                        CharType.CHAR, CastType.EXPLICIT), t)
            }
            if srcType.isWrapper & t.isPrimitive {
                v := implicitCast(position, v, srcType.unwrapWrapper)
                srcType := v.type
            }
            if srcType.isPrimitive & t.isPrimitive
                return new Cast(position, v, t, CastType.EXPLICIT)
            if !srcType.isPrimitive & t.isPrimitive {
                v := explicitCast(position, v, 
                        t.unwrapRealLiteral.wrapperVersion())
                srcType := v.type
            }
            if srcType.isPrimitive & t.isWrapper {
                return implicitCast(position,
                            explicitCast(position, v, t.unwrapWrapper), 
                            t)
            }
            if srcType.isWrapper & t.isWrapper {
                -- promote -> to ->> for primitives. This is so e.g. 
                -- new Int8(5) can safely "cast" to Int16, Int32, etc.; behind
                -- the scenes it just invokes the converter
                -- FIXME need bounds checking here
                return convert(position, v, t)
            }
            if v.canImplicitCastTo(t)
                return implicitCast(position, v, t, CastType.EXPLICIT)
            return new Cast(position, v, t, CastType.EXPLICIT)
        }
        throw new CompilerException(
                "cannot cast '\{srcType.displayName}' to '\{t.displayName}'", 
                    v.position)
    }
    
    ============================================================================
    Handles a conversion from one nullable type to another. This requires
    special handling because a `null` source should convert to a `null` target
    fine, but we need to be careful not to e.g. invoke conversion methods on
    `null`, try to unwrap a `null` wrapper class, etc. So we first have to
    check whether the source is `null`, and then either perform the conversion
    or simply return null.
    
    @param position the position in the source file, for error-reporting 
            purposes
    @param v the value being converted
    @param t the type to convert the value to
    @returns a value of the specified type
    ============================================================================
    @private
    @pre(value.type.isNullable)
    @pre(expected.isNullable)
    method nullableToNullableConversion(var value:Value, expected:Type, 
            conversion:CastType):Value {
        -- nullable source to nullable target means we need to check 
        -- if the source is null and, if so, just convert straight to null 
        -- (otherwise we might try to unbox a null wrapper, run a converter 
        -- function on null, etc.)
        var from := value.type
        -- create a test of src vs. null
        var nullTest := new Equal(value.position)
        nullTest.add(value)
        nullTest.add(new NullLiteral(value.position, from))
        var cm := currentMethod
        assert cm != null
        cm.add(nullTest)
        value := makeReusable(value).createReference()
        nullTest.removeFromParent()
        assert !from.isPrimitive
        var castToNonNull:Value
        if conversion = CastType.IMPLICIT {
            castToNonNull := implicitCast(value.position, value, 
                    from.unwrapNullable)
        }
        else
            castToNonNull := explicitCast(value.position, value, 
                    from.unwrapNullable)
        var finalConvert:Value
        switch conversion {
            case CastType.IMPLICIT: {
                finalConvert := implicitCast(value.position, castToNonNull, 
                        expected)
            }

            case CastType.EXPLICIT: 
                finalConvert := explicitCast(value.position, castToNonNull, 
                        expected)

            case CastType.CONVERT: 
                finalConvert := convert(value.position, castToNonNull, expected)
                
            default:
                throw new InternalCompilerException(
                        "unsupported conversion: \{conversion}", value.position)
        }
        return new Ternary(value.position, nullTest, 
                new NullLiteral(value.position, expected),
                finalConvert)
    }

    ============================================================================
    Handles a conversion from one type to another. Conversions are specified in 
    the source via the `->>` operator.
    
    @param position the position in the source file, for error-reporting 
            purposes
    @param v the value being converted
    @param t the type to convert the value to
    @returns a value of the specified type
    ============================================================================
    method convert(position:Position, var v:Value, var t:Type):Value {
        v := resolveUnresolvedConstructs(v)
        if v.type.isNullable {
            return convert(position, implicitCast(position, v, 
                    v.type.unwrapNullable), t)
        }
        var isSuper := false
        if v-?>(Super) {
            v := new Cast(position, getSelf(),
                    getSelf().type.classNode.supertype->(Type),
                    CastType.EXPLICIT)
            isSuper := true
        }
        var srcType := v.type
        if srcType-?>(RealLiteralType) {
            if t-?>(PrimitiveType) & t->(PrimitiveType).size <= 32 {
                v := implicitCast(position, v, RealType.REAL32, 
                        CastType.EXPLICIT)
            }
            else {
                v := implicitCast(position, v, RealType.REAL64, 
                        CastType.EXPLICIT)
            }
            srcType := v.type
        }
        if srcType = t
            return v
        if srcType = StringOrCharType.STRING_OR_CHAR & 
                t.unwrapWrapper.isNumeric
            return explicitCast(position, v, t)
        if srcType.unwrapWrapper.isPrimitive & v.canExplicitCastTo(t) {
            -- handle primitive-to-primitive conversions
            var intermediate := new Cast(position, implicitCast(position, v, 
                    v.type.unwrapWrapper, CastType.IMPLICIT), t.unwrapWrapper,
                    CastType.CONVERT)
            return implicitCast(position, intermediate, t, CastType.IMPLICIT)
        }
        var convert := v.findConverterTo(t)
        if convert != null {
            -- found a relevant "->>" method, call it directly
            -- we perform an explicit conversion of the parameter here, rather
            -- than let implicit method conversion handle it, because if we're
            -- doing a nullable->non-nullable conversion we don't want it 
            -- flagged as implicit (and thus trigger an error)
            var param:Value
            if convert.parameters[0].isConvert
                param := v -- the call() will handle the conversion
            else
                param := explicitCast(position, v, convert.parameters[0].type)
            var params := new PrimitiveArray<Value>(param)
            return implicitCast(position, call(position, convert, 
                    convert.isDeclaredVirtual() & !isSuper, isSuper, params), t)
        }
        else {
            var msg := "cannot convert '{}' to '{}'"
            if v.canExplicitCastTo(t)
                msg += ", did you mean to use the cast ('->') operator instead?"
            throw new CompilerException(String.format(msg, srcType.displayName, 
                    t.displayName), position)
        }
    }
    @post(@return.type = t)

    method call(position:Position, m:MethodNode, virtual:Bit,
            params:PrimitiveArray<Value>):MethodCall {
        return call(position, m, virtual, false, params)
    }

    method call(position:Position, var m:MethodNode, virtual:Bit, isSuper:Bit,
            params:PrimitiveArray<Value>):MethodCall {
        var methodParams := m.parameters
        var isVarArg := methodParams.length > 0 &
                methodParams[methodParams.length - 1].isVarArg
        for i, p in params {
            if p-?>(Unwrap) {
                if !isVarArg {
                    throw new CompilerException("'...' may not be used with " +
                            "non-variadic \{m}", position)
                }
                if i < params.length - 1 {
                    throw new CompilerException("'...' may only be used with " +
                            "the last parameter of a call")
                }
            }
        }
        if isVarArg & params.length > 0 & params[params.length - 1]-?>(Unwrap)
            isVarArg := false
        var count:Int
        if isVarArg
            count := methodParams.length - 1
        else
            count := methodParams.length
        var finalParams := new PrimitiveArray<Value>()
        for i in 0 .. count {
            var target := m.parameters[i].type
            if params[i].canImplicitCastTo(target)
                finalParams.append(implicitCast(params[i].position, params[i], 
                        target))
            else if m.parameters[i].isConvert & 
                    params[i].canConvertTo(target) {
                finalParams.append(convert(params[i].position, params[i], 
                        target))
            }
            else {
                error("expected value of type '\{target.displayName}', but " +
                        "found '\{params[i].type.displayName}'", params[i])
            }
        }
        if isVarArg {
            var values := new PrimitiveArray<Value>()
            var isConvert := methodParams[methodParams.length - 1].isConvert
            var type := methodParams[methodParams.length - 1].type->(PrimitiveArrayType).elementType
            for i in count ... params.length - 1 {
                if isConvert
                    values.append(convert(params[i].position, params[i], type))
                else {
                    values.append(implicitCast(params[i].position, params[i], 
                            type))
                }
            }
            finalParams.append(new NewPrimitiveArrayWithValues(position,
                methodParams[methodParams.length - 1].type, values))
        }
        return new MethodCall(position, m, virtual, isSuper, finalParams)
    }

    method construct(position:Position, m:MethodNode,
            params:PrimitiveArray<Value>):Construct {
        if m.owner.annotations.isAbstract() {
            throw new CompilerException("cannot create abstract object '" +
                    m.owner.name + "'", position)
        }
        var methodParams := m.parameters
        var isVarArg := methodParams.length > 0 &
                methodParams[methodParams.length - 1].isVarArg
        if params.length > 0 & params[params.length - 1]-?>(Unwrap)
            isVarArg := false
        var count:Int
        if isVarArg
            count := methodParams.length - 2
        else
            count := methodParams.length - 1
        var finalParams := new PrimitiveArray<Value>()
        for i in 0 ... count - 1 {
            var target := m.parameters[i + 1].type
            if params[i].canImplicitCastTo(target)
                finalParams.append(implicitCast(position, params[i], target))
            else if m.parameters[i].isConvert & 
                    params[i].canConvertTo(target)
                finalParams.append(convert(position, params[i], target))
            else {
                error("expected value of type '\{target.displayName}', but " +
                        "found '\{params[i].type.displayName}'", params[i])
            }
        }
        if isVarArg {
            def values := new PrimitiveArray<Value>()
            def isConvert := methodParams[methodParams.length - 1].isConvert
            def type := methodParams[methodParams.length - 1].type->(PrimitiveArrayType).elementType
            for i in count ... params.length - 1 {
                if isConvert
                    values.append(convert(params[i].position, params[i],
                        type))
                else
                    values.append(implicitCast(params[i].position, 
                        params[i], type))
            }
            finalParams.append(new NewPrimitiveArrayWithValues(position,
                methodParams[methodParams.length - 1].type, values))
        }
        return new Construct(position, m, finalParams)
    }

    -- FIXME testCall was written before I had exceptions working, so I suspect
    -- that all of this can be done more easily simply by rolling this into 
    -- call, and then wrapping the spots we want to test the call in 
    -- try/catches.
    method testCall(position:Position, var context:Value?, 
                var methodName:String, var params:PrimitiveArray<Value>):Value? {
        if methodName = "constructor"
            methodName := "new"
        var cm := currentMethod
        if context = null {
            var cc := currentClass
            assert cc != null
            if cm != null & !cm.annotations.isClass {
                -- bare identifier, could be either instance or class
                var result := cc.symbolTable.getMethod(position, methodName, 
                        params, null)
                if result != null {
                    if result.annotations.isClass {
                        -- class method, update the context
                        context := new ClassLiteral(result.owner.type())
                    }
                }
                if context = null
                    context := getSelf()
            }
            else {
                -- in a class context
                context := new ClassLiteral(cc.type())
            }
        }
        var type:Type
        var symbolTable:SymbolTable
        var classMethod:Bit
        var supercall:Bit
        if context-?>(UnresolvedClassLiteral)
            context := context->(UnresolvedClassLiteral)->>(ClassLiteral)
        if context-?>(ClassLiteral) {
            classMethod := true
            supercall := false
            type := context->(ClassLiteral).value
            symbolTable := type.classNode.symbolTable
        }
        else if context-?>(ClassObjectLiteral) {
            classMethod := false
            supercall := false
            type := ClassType.CLASS()
            symbolTable := type.classNode.symbolTable
        }
        else {
            classMethod := false
            var oldParams := params
            params := new PrimitiveArray<Value>()
            if context-?>(Super) {
                var cl := currentClass
                assert cl != null
                var superclass := cl.superclass
                if superclass = null {
                    throw new CompilerException(
                            "class '\{cl}' has no superclass", context.position)
                }
                params.append(implicitCast(position, getSelf(), 
                        superclass.type()))
                supercall := true
                type := superclass.type()
            }
            else {
                type := context.type
                params.append(context)
                supercall := false
            }
            for param in oldParams
                params.append(param)
            var cl := type.classNode
            symbolTable := cl.symbolTable
        }
        var methodNode := symbolTable.getMethod(position, methodName, params, 
                classMethod)
        if methodNode = null {
            if classMethod {
                -- check for a constructor, which is called like a class method
                -- but implemented as an instance method
                if type.isPrimitiveArray & methodName = "new" {
                    -- FIXME: hardcoded yuck
                    if params.length = 1 & 
                            params[0].canImplicitCastTo(Type.INDEX_TYPE) {
                        var elementType := type->(PrimitiveArrayType).elementType
                        return new NewPrimitiveArrayWithLength(position, type, 
                                implicitCast(position, params[0], 
                                Type.INDEX_TYPE))
                    }
                    else if params.length = 3 & params[0].type.isPrimitiveArray &
                            (params[0].type.elementType = type.elementType |
                                params[0].type.elementType.canImplicitCastTo(
                                    type.elementType) & 
                                    !params[0].type.elementType.isPrimitive &
                                    !type.elementType.isPrimitive) &
                            params[1].canImplicitCastTo(Type.INDEX_TYPE) &
                            params[2].canImplicitCastTo(Type.INDEX_TYPE) {
                        if params[0].type.elementType.isNullable & 
                                !type.elementType.isNullable
                            PandaCompiler.reportError("cannot create array " +
                                    "with possibly-null values", position)
                        return new NewPrimitiveArrayWithRange(position, type, 
                                params[0], 
                                implicitCast(params[1].position, params[1], 
                                    Type.INDEX_TYPE),
                                implicitCast(params[2].position, params[2], 
                                    Type.INDEX_TYPE))
                    }
                    else {
                        var finalParams := new PrimitiveArray<Value>()
                        for param in params {
                            finalParams.append(implicitCast(position, param,
                                    type.elementType))
                        }
                        return new NewPrimitiveArrayWithValues(position, type, 
                                finalParams)
                    }
                }
                var oldParams := params
                params := new PrimitiveArray<Value>()
                params.append(new Dummy(context.position,
                        context->(ClassLiteral).value))
                for param in oldParams
                    params.append(param)
                methodNode := symbolTable.getMethod(position, methodName, 
                        params, false)
                if methodNode != null & 
                        methodNode.methodType != MethodNodeType.CONSTRUCTOR {
                    error("instance method '\{methodNode.name}' cannot be " +
                            "accessed from a class context", 
                            position)
                }
                params := oldParams
            }
        }
        if methodNode != null {
            var isSelf := context = null | (context-?>(VariableReference) &
                context->(VariableReference).variable.name = Parameter.SELF_NAME)
                
            if isSelf & methodNode.methodType = MethodNodeType.CONSTRUCTOR &
                    cm != null & cm.methodType != MethodNodeType.CONSTRUCTOR
                error("constructors may only be directly called as the " +
                        "first statement in a constructor", position)
            
            if methodNode.methodType = MethodNodeType.CONSTRUCTOR & 
                    (!supercall & !isSelf) {
                return construct(position, methodNode, params)
            }
            else {
                var virtual := methodNode.isDeclaredVirtual() & !supercall
                var result := call(position, methodNode, virtual, supercall,
                        params)
                captureNode(result)
                return result
            }
        }
        else
            return null
    }
    
    method call(position:Position, context:Value?, methodName:String, 
            params:PrimitiveArray<Value>):Value {
        var methodNode := testCall(position, context, methodName, params)
        if methodNode = null {
            def cl := currentClass->(ClassNode)
            def msg := "no match found for method "->>(MutableString)
            msg.append(methodName)
            msg.append("(")
            for i, p in params {
                if i != 0
                     msg.append(", ")
                msg.append(p.type.displayName)
            }
            msg.append(")")
            if context != null {
                if context-?>(Super)
                    msg.append(" in \{currentMethod->(MethodNode).owner.supertype->(Type).displayName}")
                else if context-?>(ClassLiteral)
                    msg.append(" in \{context}")
                else
                    msg.append(" in \{context.type.displayName}")
            }
            for p in params {
                if p-?>(UnresolvedLambda) {
                    def lambda := p->(UnresolvedLambda)
                    if lambda.errors.length > 0 {
                        msg.append("\n    possible error in lambda at " +
                                "\{lambda.position}:")
                        var entries := new PrimitiveArray<Object>(lambda.errors.entries, 
                                0, lambda.errors.entries.length)
                        Panda.sort(entries, function(eo1:Object, eo2:Object):Bit {
                            def e1 := eo1->((Object?, Object?))[0]->(PrimitiveArray<Type>)
                            def e2 := eo2->((Object?, Object?))[0]->(PrimitiveArray<Type>)
                            assert e1.length = e2.length
                            for i in 0 .. e1.length {
                                def n1 := e1[i].name
                                def n2 := e2[i].name
                                if n1 > n2
                                    return true
                                if n2 > n1
                                    return false
                            }
                            return false
                        })
                        for raw in entries {
                            def e := raw->((Object?, Object?))
                            def types := e[0]->(PrimitiveArray<Type>)
                            def typeString := new MutableString()
                            typeString.append("(")
                            for i, type in types {
                                if i > 0
                                    typeString.append(",")
                                typeString.append(type.displayName)
                            }
                            typeString.append(")=>(...)")
                            var error, errorPos := e[1]->((String, Position?))
                            if errorPos = null
                                errorPos := Position.INTERNAL
                            msg.append("\n        when interpreted as \{typeString}:\n")
                            msg.append("            \{error}")
                            if errorPos != lambda.position
                                msg.append(" at \{errorPos}")
                        }
                    }
                }
            }
            throw new CompilerException(msg->>(String), position)
        }
        return methodNode
    }

    ============================================================================
    Returns the actual text of a doccomment, minus the lines of equals before
    and after it.

    @param dc the doccomment token
    @returns the doccomment text
    ============================================================================
    @pre(dc.type = TokenType.DOCCOMMENT)
    function getDocComment(dc:Token):String {
        def result := new MutableString(dc.text)
        for i in result.length - 1 ... 0 by -1 {
            if result[i] != "=" {
                result.remove(i + 1, result.length)
                break
            }
        }
        for i in 0 .. result.length {
            if result[i] != "=" {
                result.remove(0, i)
                break
            }
        }
        return result->>(String)
    }

    method isAccessible(f:FieldNode):Bit {
        var cl := currentClass
        assert cl != null
        if cl.type()-?>(GenericType) {
            -- we've already performed access checks for the unspecified version
            -- of this class, and the specified version could be (legally) 
            -- accessing private members of the unspecified version
            return true
        }
        def a := f.annotations
        if a.isPrivate {
            while cl.containingClass != null
                cl := cl.containingClass->(ClassNode)
            def targetClass := f.owner
            def c1 := cl.parent
            def c2 := targetClass.parent
            return c1 = c2
        }
        else if a.isProtected {
            def cm := currentMethod
            assert cm != null
            var caller := cm.parent->(ClassNode?)
            while caller != null & caller.containingClass != null
                caller := caller.containingClass
            var callee := f.parent->(ClassNode)
            while caller != null {
                if caller = callee
                    return true
                caller := caller.superclass
            }
            return false
        }
        return true
    }

    method checkAssignment(f:FieldNode, position:Position) {
        var valid := true
        if !isAccessible(f)
            valid := false
        else if f.annotations.isReadOnly & currentClass != f.owner
            valid := false
        else if f.annotations.isFinal { 
            def cm := currentMethod
            if currentClass != f.owner | cm = null | 
                    (cm.methodType != MethodNodeType.CONSTRUCTOR & 
                    cm.name != MethodNode.CLASS_INIT_NAME) {
                valid := false
                assert cm != null
            }
        }
        if !valid {
            throw new CompilerException("'" + f.owner.name + "." + f.name + 
                    "' may not be modified", position)
        }
    }

    method resolveUnresolvedConstructs(var v:Value):Value {
        if v-?>(UnresolvedPrimitiveArray) | v-?>(UnresolvedTuple) | v-?>(UnresolvedRange)
            v := implicitCast(v.position, v, v.variableType())
        return v
    }
    
    method getField(position:Position, context:Value, name:String):Value {
        return getField(position, context, name, true)
    }

    method getField(position:Position, var context:Value, var name:String, 
            allowNoArgFunctions:Bit):Value {
        var cl:ClassNode
        if name = "class"
            name := "$class"
        if context.type = StringOrCharType.STRING_OR_CHAR {
            context := implicitCast(position, context, CharType.CHAR,
                    CastType.IMPLICIT)
        }
        if context-!>(Super) {
            context := resolveUnresolvedConstructs(context)
            if context.type.isPrimitive {
                return getField(position, implicitCast(position, context,
                            context.type.unwrapRealLiteral.wrapperVersion()), 
                            name, allowNoArgFunctions)
            }
            else if context.type != Type.UNRESOLVED {
                var contextClass := context.type.classNode
                cl := contextClass
            }
            else
                throw new UnresolvedTypeException(position)
            if context-!>(ClassLiteral) {
                var fields := cl.unifiedFields
                -- need to search backwards since ancestor classes are at the
                -- beginning of the array, and we may be shadowing fields
                for i in fields.length - 1  ... 0 by -1 {
                    var f := fields[i]->(FieldNode)
                    if f.name = name & !f.annotations.isClass &
                            !f.annotations.isThread & isAccessible(f) {
                        if context-?>(UnresolvedClassLiteral) {
                            context := context->(UnresolvedClassLiteral)->>
                                    (ClassObjectLiteral)
                        }
                        return createFieldReference(position, context, f,
                                allowNoArgFunctions)
                    }
                }
            }
            if context-?>(UnresolvedClassLiteral)
                context := context->(UnresolvedClassLiteral)->>(ClassLiteral)
            if context-?>(ClassLiteral) {
                var type := context->(ClassLiteral).value
                if type.isPrimitive
                    type := type.unwrapRealLiteral.wrapperVersion()
                cl := type.classNode
                for child in cl.children {
                    if child-?>(FieldNode) {
                        var f := child->(FieldNode)
                        if f.name = name & (f.annotations.isClass |
                                f.annotations.isThread) &
                                isAccessible(f) {
                            return createFieldReference(position, context, f,
                                    allowNoArgFunctions)
                        }
                    }
                }
            }
        }
        return new Unresolved(position, context, name)
    }

    ============================================================================
    Looks for an overloaded version of `name` (which could be `"="`, `"+"`, 
    etc.) and returns a call to it, or `null` if no such overloaded operator was
    found.
    
    @param position the position of the call in the source code
    @param name the name of the method to call
    @param left the left argument
    @param right the right argument
    @returns a method call, or `null`
    ============================================================================
    method callOverloadedOperator(position:Position, var name:String, 
            var left:Value, var right:Value):Value? {
        left := resolveUnresolvedConstructs(left)
        right := resolveUnresolvedConstructs(right)
        -- avoid calling the various "fake" operators we define in the wrapper
        -- classes
        if name = "=" | name = "!=" {
            if left.type.isPrimitive & right.type.isPrimitive
                return null
        }
        else if !name.startsWith("[") & (left.type.isNumber | 
                left.type.isWrapper) & (right.type.isNumber | 
                right.type.isWrapper)
            return null
        if left.type = NullType.NULL | right.type = NullType.NULL
            return null -- force this to be compiled as ==, which is quicker 
                        -- than calling nullableEquals.
        if name != "=" {
            if left.type = StringOrCharType.STRING_OR_CHAR
                return callOverloadedOperator(position, name, 
                    implicitCast(left.position, left, ClassType.STRING()), 
                    right)
            if right.type = StringOrCharType.STRING_OR_CHAR
                return callOverloadedOperator(position, name, 
                    left, implicitCast(right.position, right, 
                    ClassType.STRING()))
        }

        var rawName := name
        -- map != and !== to = and ==. We'll invert the answer on return.
        if name.startsWith("!")
            name := name[1..]
        var result:Value? := null
        var parameters := new PrimitiveArray<Value>(left, right)
        if name = "=" & (left.type.isNullable | right.type.isNullable) {
            -- for equality, if one or both parameters are null, we need to
            -- funnel this through Panda.nullableEquals
            var panda := ClassType.PANDA().classNode
            var op := panda.symbolTable.getMethod(position, "nullableEquals", 
                    parameters, true)
            assert op != null
            result := call(position, op, false, parameters)
        }
        if result = null {
            -- check for overload on left (both instance & static)
            var c:ClassNode? := null
            if !left.type.isPrimitive
                c := left.type.classNode
            if c = null & name != "="
                c := left.type.unwrapRealLiteral.wrapperVersion().classNode
            if c != null {
                var op := c.symbolTable.getMethod(position, name, parameters, 
                        true)
                if op != null
                    result := call(position, op, false, parameters)
                op := c.symbolTable.getMethod(position, name, parameters, false)
                if op != null & !op.annotations.isClass
                    result := call(position, op, true, parameters)
            }
        }
        if result = null {
            -- check for overload on right (static only)
            var c:ClassNode? := null
            if !right.type.isPrimitive
                c := right.type.classNode
            if c = null & name != "="
                c := right.type.unwrapRealLiteral.wrapperVersion().classNode
            if c != null {
                var op := c.symbolTable.getMethod(position, name, parameters, 
                        true)
                if op != null
                    result := call(position, op, false, parameters)
            }
        }
        if rawName.startsWith("!") & result != null
            result := new Not(position, result)
        return result
    }

    -- FIXME switch to built-in string parser when it exists
    @pre(base >= 2 & base <= 36)
    function parseInt(s:String, base:UInt):UInt64? {
        var result:UInt64 := 0
        var digits := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        var digitsLower := "0123456789abcdefghijklmnopqrstuvwxyz"
        for i in 0 ... s.length - 1 {
            var digit := digits.indexOf(s[i])->(UInt?)
            if digit = null
                digit := digitsLower.indexOf(s[i])->(UInt?)
            if digit = null | digit >= base
                return null
            result := result * base + digit
        }
        return result
    }
    
    @pre(t.type = TokenType.NUMBER)
    method parseNumericLiteral(t:Token):Value {
        var value:UInt64?
        if t.text.startsWith("0x") | t.text.startsWith("0X")
            value := parseInt(t.text[2..], 16)
        else if t.text.startsWith("0b") | t.text.startsWith("0B")
            value := parseInt(t.text[2..], 2)
        else
            value := t.text->>(UInt64?)
        if value != null
            return new IntegerLiteral(t.position, value)
        else {
            var real := t.text->>(Real64?)
            if real != null
                return new RealLiteral(t.position, real)
            else {
                error("invalid numeric literal", t)
                return new NullLiteral()
            }
        }
    }

    ============================================================================
    Given a sequence of chars from a string literal (e.g. "Hello\n!"), returns a
    string representing the contents of the literal (e.g. "Hello<newline>!")

    If `interpolating` is true, permits the additional escape sequences `\:`,
    `\{`, and `\}`, passing them through unmodified.
    ============================================================================
    method convertStringChars(position:Position, s:String, 
            interpolating:Bit):String {
        var result := new MutableString()
        var i := 0
        loop {
            var next := s.indexOf("\\", i)
            if next = null {
                result.append(s[i..])
                break
            }
            result.append(s[i .. next])
            var c := s[next + 1]
            switch c {
                case "n":  result.append("\n")
                case "r":  result.append("\r")
                case "t":  result.append("\t")
                case '"':  result.append('"')
                case "\\": {
                    result.append("\\")
                    if interpolating
                        result.append("\\")
                }
                case "'":  result.append("'")
                case ":", "{", "}": {
                    if interpolating {
                        result.append("\\")
                        result.append(c)
                    }
                    else {
                        error("invalid string escape '\\" + c + "'", 
                                new Position(position.compilationUnit, 
                                    position.line, position.column + i))
                    }
                }
                default: 
                    error("invalid string escape '\\" + c + "'", 
                            new Position(position.compilationUnit, 
                                position.line, position.column + i))
            }
            i := next + 2
        }
        return result->>(String)
    }

    @pre(t.type = TokenType.STRING)
    method parseStringLiteral(t:Token):Value {
        var s := t.text[1 .. t.text.length - 1]
        def result := new MutableString()
        def matcher := STRING_GROUP.matcher(s)
        def values := new PrimitiveArray<Value>()
        var lastEnd := 0
        while matcher.find() {
            result.append(convertStringChars(t.position,
                    s[lastEnd .. matcher.start], false).replace(UNESCAPED_BRACE, "\\{"))
            def text := s[matcher.start + 2 .. matcher.end - 1]
            var expr, remaining := new PandaParser().parseExpressionWithExtraText(
                    text, t.position)
            values.append(convertExpression(expr))
            result.append("{" + 
                    convertStringChars(t.position, remaining, true) + "}")
            lastEnd := matcher.end()
        }
        if lastEnd > 0 {
            result.append(convertStringChars(t.position,
                    s[lastEnd..], false).replace(UNESCAPED_BRACE, "\\{"))
            s := result->>(String)
            values[0 .. 0] := [new StringLiteral(t.position, s)]
            return call(t.position, new ClassLiteral(ClassType.STRING()), 
                    "format", values)
        }
        else {
            return new StringLiteral(t.position, 
                    convertStringChars(t.position, s, false))
        }
    }
    
    function getSelf():VariableReference {
        var cm := currentMethod
        if cm = null | cm.annotations.isClass {
            throw new CompilerException("'self' is not valid in this context",
                    currentNode.position)
        }
        assert cm.parameters[0].name = Parameter.SELF_NAME
        return new VariableReference(cm.position, cm.parameters[0])
    }


    @private
    method createFieldReference(position:Position, var context:Value, 
            f:FieldNode, allowNoArgFunctions:Bit):Value {
        var annotations := f.annotations
        if !annotations.isClass & !annotations.isThread {
            context := implicitCast(position, context, f.owner.type(), 
                    CastType.IMPLICIT)
        }
        if allowNoArgFunctions {
            var name := f.name
            var m := currentMethod
            assert m != null
            var unresolved := new Unresolved(position, context, name)
            var noArg := resolveNoArgFunction(unresolved)
            if noArg != null {
                if currentClass = f.parent {
                    -- while we're in the same class as an ambiguous reference,
                    -- assume we mean the no-arg function
                    return noArg
                }
                if context.parent != null
                    context.removeFromParent()
                return new AmbiguousReference(position, context, f)
            }
        }
        if context.parent != null
            context.removeFromParent()
        if f.annotations.isClass {
            -- generic types (HashMap<String, String>) will have the generic
            -- type as the context even though the field actually appears in the
            -- base type (HashMap), need to fix the context
            context := new ClassLiteral(position, f.owner.type())
        }
        def result := new FieldReference(position, context, f)
        captureNode(result)
        return result
    }
    
    method parseBareIdentifier(id:ParseNode):Value {
        var name := id->>(String)
        if name = "class"
            name := "$class"
        def variable := currentBlock.symbolTable.getVariable(name)
        if variable != null {
            if variable.type = Type.UNRESOLVED
                throw new UnresolvedTypeException(id.position)
            if variable-?>(FieldNode) {
                def classField := variable->(FieldNode).annotations.isClass | 
                        variable->(FieldNode).annotations.isThread
                var cm := currentMethod
                assert cm != null                        
                if cm.annotations.isClass & !classField {
                    error("instance field '\{name}' cannot be accessed from " +
                            "a class context", id.position)
                }
                var context:Value
                if classField {
                    var cc := currentClass
                    assert cc != null
                    context := new ClassLiteral(id.position, 
                            getType(id.position, cc.name))
                    captureNode(context)
                }
                else
                    context := getSelf()
                if isAccessible(variable->(FieldNode)) {
                    return createFieldReference(id.position, context, 
                            variable->(FieldNode), true)
                }
            }
            else {
                def result := new VariableReference(id.position, variable)
                captureNode(result)
                return result
            }
        }
        assert !linkageOnly
        if id->(TokenNode).token.type = TokenType.IDENTIFIER {
            def type := currentBlock.symbolTable.getType(id.position, name)
            if type-!>(UnresolvedType)
                return new UnresolvedClassLiteral(id.position, type)
        }
        return new Unresolved(id.position, null, name)
    }
    
    @pre(s.startsWith("#") & s.endsWith("#"))
    method convertPlugin(position:Position, var s:String):Value {
        s := s[1 .. s.length - 1]
        if s.startsWith("/") & s.endsWith("/") {
            s := s[1 .. s.length - 1]
            s := s.replace("\\", "\\\\").replace('"', '\\"')
            var block := currentBlock
            new ASTGenerator().compileStatement(block, 
                    'new panda.core.RegularExpression("' + s + '")', 
                    position)
            var statement := block[block.length - 1]
            assert statement-?>(ValueStatement)
            var result := statement->(ValueStatement).value
            result.removeFromParent()
            statement.removeFromParent()
            return result
        }
        throw new CompilerException("unsupported plugin: \{s}", position)
    }

    @pre(c.type = ParseNodeType.CONSTRUCT)
    method convertConstruct(c:ParseNode):Value {
        assert c[0]->(TokenNode).token.type = TokenType.NEW
        def type := convertType(c[1])
        def params := convertParameters(c[2])
        def classLiteral := new ClassLiteral(c[1].position, type)
        captureTree(classLiteral, c[1], null)
        def result := call(c.position, classLiteral, "new", 
                params)
        captureNode(result, c[1].position)
        return result
    }

    @pre(a.type = ParseNodeType.ARRAY_LITERAL)
    method convertPrimitiveArrayLiteral(a:ParseNode):Value {
        assert a[0]->(TokenNode).token.type = TokenType.LBRACKET
        var values := new PrimitiveArray<Value>()
        for i in 1 ... a.length - 2 by 2
            values.append(convertExpression(a[i]))
        assert a[a.length - 1]->(TokenNode).token.type = TokenType.RBRACKET
        return new UnresolvedPrimitiveArray(a.position, values)
    }

    @pre(m.type = ParseNodeType.MAP_LITERAL)
    method convertMapLiteral(m:ParseNode, immutable:Bit):Value {
        assert m[0]->(TokenNode).token.type = TokenType.LBRACE
        var rawKeys := new PrimitiveArray<Value>()
        var rawValues := new PrimitiveArray<Value>()
        var index := 1
        while index < m.length - 1 {
            rawKeys.append(implicitCast(m[index].position,
                    convertExpression(m[index]), Type.ANY(), CastType.IMPLICIT))
            index += 1
            assert m[index]->(TokenNode).token.type = TokenType.COLON
            index += 1
            rawValues.append(implicitCast(m[index].position,
                    convertExpression(m[index]), Type.ANY(), CastType.IMPLICIT))
            index += 1
            if m[index]->(TokenNode).token.type = TokenType.COMMA
                index += 1
        }
        assert m[index]->(TokenNode).token.type = TokenType.RBRACE
        var keys := new NewPrimitiveArrayWithValues(m.position, PrimitiveArrayType.ARRAY_ANY(), 
                rawKeys)
        var values := new NewPrimitiveArrayWithValues(m.position, PrimitiveArrayType.ARRAY_ANY(), 
                rawValues)
        return call(m.position, new ClassLiteral(ClassType.HASHMAP()), 
                "new", [keys, values])
    }

    ============================================================================
    For methods which return primitive values, creates a corresponding shim 
    method that calls the original method and returns the result casted to 
    Object. This is used to work around difficulties mixing primitives and 
    Objects by giving callers the ability to choose either.
    ============================================================================
    @pre(m.returnType != VoidType.VOID)
    method createShim(m:MethodNode):MethodNode {
        def name := "shimmed"
        def position := new Position(m.position.compilationUnit, 
                m.position.line, 
                m.position.column + 1)
        def parameters := new PrimitiveArray<Parameter>()
        for i, p in m.parameters {
            def newParam := new Parameter(position, p.name, p.type)
            parameters.append(newParam)
        }          
        def result := new MethodNode(position, name, m.methodType, parameters)
        result.annotations.isSynthetic := true
        if m.returnType.isNullable {
            result.returnType := SymbolTable.master.getType(Position.INTERNAL,
                    class(Object).name + "?")
        }
        else
            result.returnType := ClassType.OBJECT()
        m.owner.add(result)
        m.owner.symbolTable.putMethod(result)
        def symbolTable := new SymbolTable(result, m.owner.symbolTable)
        for param in parameters
            symbolTable.putVariable(param)
        def block := new Block(position, symbolTable)
        result.add(block)
        def callParams := new PrimitiveArray<Value>()
        for p in parameters
            callParams.append(new VariableReference(p))
        block.add(new Return(implicitCast(position,
                call(position, m, true, callParams), result.returnType)))
        return result
    }

    @private
    function hasVariableNamed(list:PrimitiveArray<Variable>, name:String):Bit {
        for v in list {
            if v.name = name
                return true
        }
        return false
    }

    ============================================================================
    Recursively scans nodes in a closure, finding field references and "fixing"
    them to ensure they are pointing to the right objects, as well as marking 
    them $used so we can remove all unused captured fields. The fact that they
    end up pointing to the wrong objects in the first place is due to the hacky
    way closures are currently implemented; obviously it would be better to have
    a real understanding of inner classes during compilation so we resolve
    everything properly, but this was a lot quicker to implement...
    ============================================================================
    @private
    method fixClosureReferences(node:Node) {
        if node-?>(FieldReference) | node-?>(FieldAssignment) {
            def field:FieldNode
            var object:Node
            if node-?>(FieldReference) {
                field := node->(FieldReference).field
                object := node->(FieldReference).object
            }
            else {
                field := node->(FieldAssignment).fieldNode
                object := node->(FieldAssignment).object
            }
            def cl := currentClass
            assert cl != null
            while object-?>(Cast) | object-?>(ReusedValue) {
                if object-?>(Cast)
                    object := object->(Cast).value
                else
                    object := object->(ReusedValue).value
            }
            if object-?>(VariableReference) & 
                    object->(VariableReference).variable.name = Parameter.SELF_NAME &
                    field.owner = cl.containingClass {
                -- reference to the containing class. Eventually we'll have full 
                -- support for inner classes and not require this extra cleanup 
                -- here
                def s := cl.symbolTable.getVariable("$" + Parameter.SELF_NAME)
                assert s != null
                def containingSelf := new FieldReference(node.position, 
                        getSelf(), s->(FieldNode))
                object.replace(containingSelf)
            }
            else {
                if field.annotations.isClass {
                    object.replace(new ClassLiteral(node.position, 
                            field.owner.type()))
                }
                field.setProperty("$used", true)
            }
        }
        else if node-?>(MethodCall) {
            def mc := node->(MethodCall)
            def m := mc.methodNode
            if !m.annotations.isClass {
                var object := mc.parameters[0]
                while object-?>(Cast) | object-?>(ReusedValue) {
                    if object-?>(Cast)
                        object := object->(Cast).value
                    else
                        object := object->(ReusedValue).value
                }
                if object-?>(VariableReference) &
                        object->(VariableReference).variable.name = Parameter.SELF_NAME {
                    def cl := currentClass
                    assert cl != null
                    def s := cl.symbolTable.getVariable("$" + Parameter.SELF_NAME)
                    assert s != null
                    object.replace(implicitCast(new FieldReference(
                                node.position, getSelf(), s->(FieldNode)), 
                            m.parameters[0].type))
                }
            }
        }
        for child in node.children
            fixClosureReferences(child)
    }

    @private
    function safeString(position:Position):String {
        def result := new MutableString()
        for i in 0 .. position.compilationUnit.length {
            if "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_".contains(position.compilationUnit[i])
                result.append(position.compilationUnit[i])
            else
                result.append("_")
        }
        result.append("_")
        result.append(position.line)
        result.append("_")
        result.append(position.column)
        return result->>(String)
    }

    ============================================================================
    Creates the mutable version of the closure on top of the stack, returning an
    instance of it.
    ============================================================================
    @private
    method createMutableClosure():ClassNode {
        def closure := currentClass
        assert closure != null
        def mutable := new ClassNode(closure.position, "$mutableClosure" + 
                safeString(closure.position) + nextCount(), SymbolTable.master)
        def type := new ClassType(mutable.name)
        SymbolTable.putType(type)
        mutable.annotations.isSynthetic := true
        mutable.supertype := ClassType.MUTABLE_METHOD()
        mutable.state := ClassNodeState.DEFINED
        nodeStack.push(mutable)
        SymbolTable.putClass(mutable)

        def immutableVersion := new FieldNode("immutableVersion", 
                closure.type())
        mutable.add(immutableVersion)
        mutable.symbolTable.putVariable(immutableVersion)

        def code := new MutableString("constructor(immutableVersion:\{closure.type().name}) {")
        code.append("self.immutableVersion := immutableVersion")
        code.append("}")
        var dedup := 1
        new ASTGenerator().compileMethod(mutable, code->>(String), 
                new Position(mutable.position.compilationUnit, 
                    mutable.position.line + dedup, 
                    0))
        dedup += 1

        for m in closure.methods {
            def copy := new MutableString()
            if m.methodType = MethodNodeType.FUNCTION
                copy.append("function ")
            else if m.methodType = MethodNodeType.METHOD
                copy.append("method ")
            else
                continue
            copy.append("\{m.name}(")
            for i, param in m.parameters {
                if i = 0
                    continue
                if i > 1
                    copy.append(", ")
                copy.append("\{param.name}:\{param.type.name}")
            }
            copy.append(")")
            if m.returnType != VoidType.VOID
                copy.append(":" + m.returnType.name)
            copy.append(" {\n")
            if m.returnType != VoidType.VOID
                copy.append("return ")
            copy.append("immutableVersion.\{m.name}(")
            for i, param in m.parameters {
                if i = 0
                    continue
                if i > 1
                    copy.append(", ")
                copy.append("\{param.name}")
            }
            copy.append(")\n}")
            new ASTGenerator().compileMethod(mutable, copy->>(String),
                    new Position(mutable.position.compilationUnit, 
                        mutable.position.line + dedup, 
                        0))
            dedup += 1
        }
        close(class(ClassNode))
        return mutable
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Finishes processing a closure. Removes unused captures, creates a 
    shim and a constructor, and returns an instance of the closure.
    ============================================================================
    @private
    method finishClosure(position:Position, captures:PrimitiveArray<Variable>, 
            outerSelf:Value?):Value {
        def cm := currentMethod
        assert cm != null
        def cl := cm.owner
        fixClosureReferences(cm.block)
        def fields := new PrimitiveArray<FieldNode>()
        for i in cl.children.length - 1 ... 0 by -1 {
            def child := cl.children[i]
            if child-?>(FieldNode) {
                if child.getProperty("$used") = true {
                    fields.append(child->(FieldNode))
                    child.clearProperty("$used")
                }
                else
                    child.removeFromParent()
            }
        }

        def raw := cl.methods[cl.methods.length - 1]
        assert raw.name = "raw"
        if raw.returnType != VoidType.VOID
            createShim(raw)

        def code := new MutableString("constructor(")
        for i, field in fields {
            if i > 0
                code.append(", ")
            if field.name = Parameter.SELF_NAME
                code.append("$")
            code.append("\{field.name}:\{field.type.name}")
        }
        code.append(") {\n")
        def immutable := cl.fields.filter(f => !f.type.isImmutable).length = 0
        if immutable {
            cl.supertype := getType(position, class(Method).name)->(ClassType)
            def mutableVersion := createMutableClosure()
            code.append("super.constructor(new \{mutableVersion.name}(self))\n")
        }
        else
            cl.supertype := getType(position, class(MutableMethod).name)->(ClassType)
        for field in fields {
            var name := field.name
            if name = Parameter.SELF_NAME
                name := "$" + name
            code.append("self.\{name} := \{name}\n")
        }
        code.append("}")
        new ASTGenerator().compileMethod(cl, code->>(String), 
                new Position(cl.position.compilationUnit, cl.position.line + 2, 
                0))

        cl.symbolTable.putMethod(cm)
        def c := cl[cl.length - 1]->(MethodNode)
        assert c->(MethodNode).methodType = MethodNodeType.CONSTRUCTOR
        def params := new PrimitiveArray<Value>()
        for i, p in c.parameters {
            if i = 0
                continue
            if p.name = "$" + Parameter.SELF_NAME {
                assert outerSelf != null
                params.append(outerSelf)
            }
            else {
                var found := false
                for capture in captures {
                    if capture.name = p.name {
                        if capture-?>(FieldNode) {
                            assert outerSelf != null
                            params.append(new FieldReference(position, 
                                    outerSelf, capture->(FieldNode)))
                        }
                        else
                            params.append(new VariableReference(position,
                                    capture))
                        found := true
                    }
                }
                assert found
            }
        }
        close(class(MethodNode))
        close(class(ClassNode))
        cm.markLive()
        def type := new MutableString("(")
        for i, param in cm.parameters {
            if i = 0
                continue
            if i > 1
                type.append(",")
            type.append(param.type.name)
        }
        type.append(")=")
        if cm.methodType = MethodNodeType.METHOD
            type.append("&")
        type.append(">")
        if immutable
            type.append("*")
        type.append("(")
        if cm.returnType != VoidType.VOID
            type.append(cm.returnType.name)
        type.append(")")
        def result := new Construct(position, c, params)
        return new Cast(result, getType(position, type->>(String)), 
                CastType.IMPLICIT)
    }

    ============================================================================
    Sets up the stack to prepare for parsing a closure block. Creates a class,
    method, etc.
    ============================================================================
    @private
    method prepareForClosureBlock(position:Position, methodType:MethodNodeType,
            parameterPrototypes:ParseNode, returnType:Type?):PrimitiveArray<Variable> {
        def containing := currentClass
        assert containing != null : "no containing class"

        -- grab captured variables for closure
        def captures := new PrimitiveArray<Variable>()
        def parent := currentMethod
        assert parent != null : "no parent method"
        for v in parent.localVariables {
            if v.annotations.isFinal & !hasVariableNamed(captures, v.name) {
                -- we could have multiple variables with the same name in scope,
                -- so grab from the symbol table to make sure we get the correct
                -- one
                def variable := currentBlock.symbolTable.getVariable(v.name)
                if variable != null
                    captures.append(variable)
                -- else it isn't in scope at this point
            }
        }
        for v in parent.parameters {
            if v.annotations.isFinal & !hasVariableNamed(captures, v.name) {
                -- we wouldn't have gotten here if there were any other 
                -- variables with this name in scope, so we can skip the symbol
                -- table lookup we perform above
                captures.append(v)
            }
        }
        for f in containing.fields {
            if !f.annotations.isClass
                captures.append(f)
        }

        def cl := new ClassNode(position, "$closure" + safeString(position) +
                nextCount(), containing.symbolTable)
        cl.symbolTable.classUses := 
                new HashMap(containing.symbolTable.classUses)
        cl.symbolTable.packageUses := containing.symbolTable.packageUses[..]
        def type := new ClassType(cl.name)
        SymbolTable.putType(type)
        cl.annotations.isSynthetic := true
        cl.state := ClassNodeState.DEFINED
        cl.containingClass := containing
        nodeStack.push(cl)
        SymbolTable.putClass(cl)
        for capture in captures {
            if capture-?>(FieldNode) {
                cl.symbolTable.putVariable(capture)
                continue
            }
            var name := capture.name
            if name = Parameter.SELF_NAME
                name := "$" + name
            def field := new FieldNode(name, capture.type)
            field.annotations.isFinal := true
            cl.add(field)
            cl.symbolTable.putVariable(field)
        }
        for m in containing.methods
            cl.symbolTable.putMethod(m)

        def cm := new MethodNode(position, "raw", methodType)
        cl.add(cm)
        cl.symbolTable.putMethod(cm)
        nodeStack.push(cm)
        def selfParam := new Parameter(position, Parameter.SELF_NAME, 
                cl.type())
        selfParam.annotations.isFinal := true
        cm.parameters.append(selfParam)
        convertParameterPrototypeList(parameterPrototypes)
        if returnType != null
            cm.returnType := returnType
        else {
            if methodType = MethodNodeType.FUNCTION
                error("functions must have a return type", position)
            cm.returnType := VoidType.VOID
        }
        return captures
    }

    @pre(!linkageOnly)
    method convertMethodValue(position:Position, methodType:MethodNodeType, 
            parameterPrototypes:ParseNode, returnType:Type?, 
            block:ParseNode):Value {
        def parent := currentMethod
        assert parent != null
        def outerSelf:Value?
        if !parent.annotations.isClass
            outerSelf := getSelf()
        else
            outerSelf := null
        def captures := prepareForClosureBlock(position, methodType, 
                parameterPrototypes, returnType)
        convertBlock(block)
        def result := finishClosure(position, captures, outerSelf)
        return result
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    @pre(m.type = ParseNodeType.METHOD_VALUE)
    @pre(!linkageOnly)
    method convertMethodValue(m:ParseNode):Value {
        def methodType:MethodNodeType
        switch m[0]->(TokenNode).token.type {
            case TokenType.METHOD: 
                    methodType := MethodNodeType.METHOD
            case TokenType.FUNCTION: 
                    methodType := MethodNodeType.FUNCTION
            default: throw new CompilerException("invalid methodValue " +
                    "methodType")
        }        
        def returnType:Type?
        if m[2].type = ParseNodeType.TYPE_DECLARATION
            returnType := convertType(m[2][1])
        else
            returnType := null
        return convertMethodValue(m.position, methodType, m[1], returnType, 
                m[m.length - 1])
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Given an unresolved lambda and concrete parameter / return types, 
    instantiates the lambda with those types and returns a value representing
    it.
    ============================================================================
    @pre(lambda.parameterNames.length = types.length)
    method resolveLambda(lambda:UnresolvedLambda, 
            types:PrimitiveArray<Type>, returnType:Type):Value {
        def code := new MutableString("function(")
        for i, name in lambda.parameterNames {
            if i > 0
                code.append(", ")
            code.append("\{name}:\{types[i].name}")
        }
        code.append("):\{returnType.name} { return \{lambda.expression} }")
        def node := new PandaParser().parseMethodValue(code->>(String), 
                lambda.position)
        return convertMethodValue(node)
    }

    @pre(l.type = ParseNodeType.LAMBDA)
    method convertLambda(l:ParseNode):Value {
        var parameterNames:PrimitiveArray<ParseNode> := []
        var parameterTypes:PrimitiveArray<Type>? := null
        var i := 0
        var expectParen := false
        if l[i]->(TokenNode).token.type = TokenType.LPAREN {
            expectParen := true
            i += 1
        }
        do {
            if parameterNames.length > 0
                i += 1
            parameterNames.append(l[i])
            i += 1
            if l[i].type = ParseNodeType.TYPE_DECLARATION {
                if parameterTypes = null
                    parameterTypes := []
                parameterTypes.append(convertType(l[i][1]))
                i += 1
            }
        }
        while l[i]->(TokenNode).token.type = TokenType.COMMA
        if expectParen {
            assert l[i]->(TokenNode).token.type = TokenType.RPAREN
            i += 1
        }
        assert l[i]->(TokenNode).token.type = TokenType.YIELDS
        i += 1
        var exp := l[i]
        -- we always have unresolved types here, even if the lambda's parameter
        -- types are specified. Consider:
        --     def a:(Int)=>(Int)  := x:Int => x * 2
        --     def b:(Int)=>(Real) := x:Int => x * 2
        -- The same lambda expression results in two different interpretations 
        -- depending on context.
        return new UnresolvedLambda(currentNode->(Node), parameterNames, 
                parameterTypes, exp, l.position)
    }

    @pre(t.type = ParseNodeType.TERM)
    method convertTuple(t:ParseNode):Value {
        assert t[0]->(TokenNode).token.type = TokenType.LPAREN
        assert t[t.length - 1]->(TokenNode).token.type = TokenType.RPAREN
        def params := new PrimitiveArray<Value>()
        for i in 1 ... t.length - 2 by 2 {
            def expr := convertExpression(t[i])
            params.append(expr)
            assert i = 1 | t[i - 1]->(TokenNode).token.type = TokenType.COMMA
        }
        return new UnresolvedTuple(t.position, params)
    }

    @pre(e.type = ParseNodeType.TERM)
    method convertTerm(e:ParseNode):Value {
        switch e[0].type {
            case ParseNodeType.TOKEN: {
                switch e[0]->(TokenNode).token.type {
                    case TokenType.STRING:
                        return parseStringLiteral(e[0]->(TokenNode).token)
                    case TokenType.NUMBER:
                        return parseNumericLiteral(e[0]->(TokenNode).token)
                    case TokenType.TRUE:
                        return new BitLiteral(e[0].position, 
                                e[0]->(TokenNode).token->>(String)->>(Bit))
                    case TokenType.FALSE:
                        return new BitLiteral(e[0].position, 
                                e[0]->(TokenNode).token->>(String)->>(Bit))
                    case TokenType.NULL:
                        return new NullLiteral(e[0].position)
                    case TokenType.IDENTIFIER, TokenType.SELF:
                        if e.length = 1
                            return parseBareIdentifier(e[0])
                        else
                            return convertLambda(e)
                    case TokenType.CLASS:
                        return parseBareIdentifier(e[0])
                    case TokenType.LPAREN: {
                        if e[2]->(TokenNode).token.type = TokenType.COMMA
                            return convertTuple(e)
                        assert e[2]->(TokenNode).token.type = TokenType.RPAREN
                        return convertExpression(e[1])
                    }
                    case TokenType.PLUGIN: return convertPlugin(e[0].position, 
                            e[0]->>(String))
                    case TokenType.SUPER: return new Super(e[0].position)
                    case TokenType.ATRETURN: {
                        var returnValue := self.returnValue
                        if returnValue != null
                            return returnValue.createReference()
                        else {
                            throw new CompilerException(
                                "@return may only appear within @post(...) " +
                                "in methods which return a value", 
                                e[0].position)
                        }
                    }
                    case TokenType.PRE: {
                        if !inPostcondition {
                            error("@pre(...) expressions may only appear " +
                                    "within @post(...)", e)
                        }
                        assert e[1]->(TokenNode).token.type = TokenType.LPAREN
                        var expr := convertExpression(e[2])
                        var cm := currentMethod
                        assert cm != null
                        var mainBlock := cm.block
                        -- add a dummy object, will replace it as we slide other
                        -- nodes down
                        mainBlock.children.append(new Dummy(VoidType.VOID))
                        for i in mainBlock.length - 1 ... 1 by -1
                            mainBlock[i] := mainBlock[i - 1]
                        var statement := new ValueStatement(e.position, expr)
                        mainBlock[0] := statement
                        statement.parent := mainBlock
                        assert e[3]->(TokenNode).token.type = TokenType.RPAREN
                        def reused := makeReusable(expr)
                        return reused.createReference()
                    }
                    default: throw new CompilerException(
                                "unsupported term: '\{e[0]->(TokenNode).token}'", 
                                e[0].position)
                }
            }
            case ParseNodeType.CLASS_LITERAL: {
                def literal := e[0]
                assert literal[0]->(TokenNode).token.type = TokenType.CLASS
                assert literal[1]->(TokenNode).token.type = TokenType.LPAREN
                assert literal[2].type = ParseNodeType.TYPE
                assert literal[3]->(TokenNode).token.type = TokenType.RPAREN
                return new ClassObjectLiteral(literal.position, 
                        convertType(literal[2]))
            }
            case ParseNodeType.CONSTRUCT:
                return convertConstruct(e[0])
            case ParseNodeType.ARRAY_LITERAL:
                return convertPrimitiveArrayLiteral(e[0])
            case ParseNodeType.MAP_LITERAL:
                return convertMapLiteral(e[0], false)
            case ParseNodeType.METHOD_VALUE:
                return convertMethodValue(e[0])
            case ParseNodeType.TYPE: {
                var typeName := e[0]->>(String).replace(#/\s+/#, "")
                var type := getType(e[0].position, typeName)
                return new UnresolvedClassLiteral(e[0].position, type)
            }
            case ParseNodeType.LAMBDA:
                return convertLambda(e[0])
            default: throw new CompilerException(
                    "unsupported term: '\{e[0].type}'", 
                    e.position)
        }
    }

    @pre(e.type = ParseNodeType.CALL_EXPRESSION)
    method convertCallExpression(e:ParseNode):Value {
        var value := convertTerm(e[0])
        if e.length > 1 {
            var call := processCallOrAssignment(value, e)
            if call = null
                throw new CompilerException("syntax error", e.position)
            value := call
        }
        return resolve(value)
    }

    @pre(e.type = ParseNodeType.EXPONENT_EXPRESSION)
    method convertExponentExpression(e:ParseNode):Value {
        var left := convertCallExpression(e[0])
        for i in 1 ... e.length - 1 by 2 {
            assert e[i]->(TokenNode).token.type = TokenType.POW
            var right := convertCallExpression(e[i + 1])
            left := getBinaryValue(e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
        }
        return left
    }

    @pre(e.type = ParseNodeType.UNARY_EXPRESSION)
    method convertUnaryExpression(e:ParseNode):Value {
        var exp := convertExponentExpression(e[e.length - 1])
        if e[0].type = ParseNodeType.UNARY_OPERATOR {
            var op := e[0][0]->(TokenNode).token.type
            switch op {
                case TokenType.SUB: {
                    if exp-?>(RealLiteral)
                        exp->(RealLiteral).value := -(exp->(RealLiteral).value)
                    else {
                        if exp.type.isWrapper {
                            exp := implicitCast(exp.position, exp, 
                                    exp.type.unwrapWrapper)
                        }
                        if exp.type.isNumber
                            exp := new UnaryMinus(e.position, exp)
                        else {
                            error("expected a number, but found '" + 
                                    exp.type.displayName + "'", e)
                        }
                    }
                }
                case TokenType.NOT: {
                    exp := new Not(e.position, implicitCast(exp.position, exp, 
                            BitType.BIT))
                }
                case TokenType.BITWISENOT: {
                    if exp.type.isWrapper {
                        exp := implicitCast(exp.position, exp, 
                                exp.type.unwrapWrapper)
                    }
                    if exp.type.isInteger {
                        if exp.type.size < 4 {
                            if exp.type->(IntType).signed {
                                exp := implicitCast(exp.position, exp,
                                        IntType.INT32)
                            }
                            else {
                                exp := implicitCast(exp.position, exp,
                                        IntType.UINT32)
                            }
                        }
                        exp := new BitwiseNot(e.position, exp)
                    }
                    else {
                        error("expected an integer, but found '" + 
                                exp.type.displayName + "'", e)
                    }
                }
                default: error("unknown unary operator: '\{op}'", e)
            }
        }
        return exp
    }

    ============================================================================
    As implicitCast, but with the ability to toggle whether we care about 
    signedness. If `signMatters` is false, the signedness is not considered
    important and will not stop a cast that would normally not be allowed.

    Note that the source and destination types are not necessarily integers; if
    not, we ignore the signMatters flag altogether and just perform a normal
    implicitCast.
    ============================================================================
    @private
    method signMattersCast(position:Position, v:Value, t:Type, 
            signMatters:Bit):Value {
        if !signMatters {
            var srcType := v.type.unwrapWrapper
            if srcType.isInteger & t.isInteger & 
                    srcType->(IntType).signed != t->(IntType).signed & 
                    srcType.size <= t.size {
                return explicitCast(position, v, t)
            }
        }
        return implicitCast(position, v, t)
    }
    
    ============================================================================
    Returns `<left> <op> <right>`, where `op` is the type of a token 
    representing a binary operator.
    
    @param node the position, for error reporting purposes
    @param left the left operand
    @param op the token type of a binary operator
    @param right the right operand
    ============================================================================
    method getBinaryValue(position:Position, var left:Value, op:TokenType, 
            var right:Value):Value {
        var methodName:String
        switch op {
            case TokenType.ADD:                  methodName := "+"
            case TokenType.SUB:                  methodName := "-"
            case TokenType.MUL:                  methodName := "*"
            case TokenType.DIV:                  methodName := "/"
            case TokenType.INTDIV:               methodName := "//"
            case TokenType.REM:                  methodName := "%"
            case TokenType.SHIFTLEFT:            methodName := "<<"
            case TokenType.SHIFTRIGHT:           methodName := ">>"
            case TokenType.AND:                  methodName := "&"
            case TokenType.OR:                   methodName := "|"
            case TokenType.XOR:                  methodName := "~"
            case TokenType.BITWISEAND:           methodName := "&&"
            case TokenType.BITWISEOR:            methodName := "||"
            case TokenType.BITWISEXOR:           methodName := "~~"
            case TokenType.POW:                  methodName := "^"
            case TokenType.EQ:                   methodName := "="
            case TokenType.NEQ:                  methodName := "!="
            case TokenType.IDENTITY:             methodName := "=="
            case TokenType.NIDENTITY:            methodName := "!=="
            case TokenType.LT:                   methodName := "<"
            case TokenType.GT:                   methodName := ">"
            case TokenType.LTEQ:                 methodName := "<="
            case TokenType.GTEQ:                 methodName := ">="
            case TokenType.IN:                   methodName := "in"
            default: throw new CompilerException(
                    "unsupported binary operator '\{op}'",
                    position)
        }
        left := resolveUnresolvedConstructs(left)
        if methodName = "in" {
            var type := left.type
            if type = RealLiteralType.REAL_LITERAL
                type := RealType.REAL64
            else if type = StringOrCharType.STRING_OR_CHAR
                type := CharType.CHAR
            def target := getType(right.position, 
                    class(PrimitiveArray).name + "<" + type.name + ">")
            if right.canImplicitCastTo(target)
                right := implicitCast(right.position, right, target)
            else
                right := resolveUnresolvedConstructs(right)

            def temp := left
            left := right
            right := temp
        }
        else
            right := resolveUnresolvedConstructs(right)
        var value:Value? := callOverloadedOperator(position, methodName, left, 
            right)
        if value = null {
            switch op {
                case TokenType.ADD:        value := new Add(position)
                case TokenType.SUB:        value := new Subtract(position)
                case TokenType.MUL:        value := new Multiply(position)
                case TokenType.DIV:        value := new Divide(position)
                case TokenType.INTDIV:     value := new IntDivide(position)
                case TokenType.REM:        value := new Remainder(position)
                case TokenType.SHIFTLEFT:  value := new ShiftLeft(position)
                case TokenType.AND:        value := new And(position)
                case TokenType.OR:         value := new Or(position)
                case TokenType.XOR:        value := new Xor(position)
                case TokenType.BITWISEAND: value := new BitwiseAnd(position)
                case TokenType.BITWISEOR:  value := new BitwiseOr(position)
                case TokenType.BITWISEXOR: value := new BitwiseXor(position)
                case TokenType.EQ:         value := new Equal(position)
                case TokenType.NEQ:        value := new NotEqual(position)
                case TokenType.IDENTITY:   value := new Identity(position)
                case TokenType.NIDENTITY:  value := new NotIdentity(position)
                case TokenType.LT:         value := new LessThan(position)
                case TokenType.GT:         value := new GreaterThan(position)
                case TokenType.LTEQ:       value := new LessThanOrEqual(position)
                case TokenType.GTEQ:       value := new GreaterThanOrEqual(position)
                case TokenType.SHIFTLEFT:  value := new ShiftLeft(position)
                case TokenType.SHIFTRIGHT: value := new ShiftRight(position)
                case TokenType.POW: {
                    def panda := ClassType.PANDA().classNode
                    def params := new PrimitiveArray<Value>(left, right)
                    def exp := panda.symbolTable.getMethod(position, "pow", 
                            params, true)
                    if exp = null {
                        throw new CompilerException(
                                "'^' cannot operate on '\{left.type.displayName}', " +
                                "'\{right.type.displayName}'", position)
                    }
                    return call(position, exp, true, params)
                }
                case TokenType.IN: {
                    throw new CompilerException("'in' cannot " +
                            "operate on '\{right.type.displayName}', " +
                            "'\{left.type.displayName}'", position)
                }
                default: throw new InternalCompilerException(position)
            }
            var operandType := value->(BinaryOperation).getOperandType(left, 
                    right, strictTypeChecking)
            if operandType = null {
                throw new CompilerException(
                        "'\{methodName}' cannot operate on '\{left.type.displayName}'" +
                        ", '\{right.type.displayName}'", position)
            }
            left := signMattersCast(position, left, operandType, 
                    value->(BinaryOperation).signMatters)
            if value-?>(And)
                left := new AndLeft(left)
            else if value-?>(Or)
                left := new OrLeft(left)
            right := signMattersCast(position, right, operandType,
                    value->(BinaryOperation).signMatters)
            value.add(left)
            value.add(right)
        }
        return value
    }
    @post(@return.type != Type.UNRESOLVED)

    @pre(e.type = ParseNodeType.MULTIPLICATIVE_EXPRESSION)
    method convertMultiplicativeExpression(e:ParseNode):Value {
        var left := convertUnaryExpression(e[0])
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right := convertUnaryExpression(e[i + 1])
            left := getBinaryValue(e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
        }
        return left
    }

    @pre(e.type = ParseNodeType.ADDITIVE_EXPRESSION)
    method convertAdditiveExpression(e:ParseNode):Value {
        var left := convertMultiplicativeExpression(e[0])
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right := convertMultiplicativeExpression(e[i + 1])
            left := getBinaryValue(e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
        }
        return left
    }

    @pre(e.type = ParseNodeType.RANGE_EXPRESSION)
    method convertRangeExpression(e:ParseNode):Value {
        var result := convertAdditiveExpression(e[0])
        if e.length > 1 {
            def type := e[1]->(TokenNode).token.type
            var right:Value? := null
            var step:Value?  := null
            if e.length > 2 {
                var i := 2
                if e[i].type = ParseNodeType.ADDITIVE_EXPRESSION {
                    right := convertAdditiveExpression(e[2])
                    i += 1
                }
                if e.length > i {
                    assert e[i]->(TokenNode).token.type = TokenType.BY
                    i += 1
                    step := convertAdditiveExpression(e[i])
                }
            }
            result := new UnresolvedRange(e.position, result, right, step, 
                    type = TokenType.ELLIPSIS)
        }
        return result
    }

    @pre(e.type = ParseNodeType.COMPARISON_EXPRESSION)
    method convertComparisonExpression(e:ParseNode):Value {
        var left := convertRangeExpression(e[0])
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right := convertRangeExpression(e[i + 1])
            left := getBinaryValue(e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
        }
        return left
    }

    @pre(e.type = ParseNodeType.AND_EXPRESSION)
    method convertAndExpression(e:ParseNode):Value {
        var left := convertComparisonExpression(e[0])
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right := convertComparisonExpression(e[i + 1])
            left := getBinaryValue(e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
        }
        return left
    }
    
    @pre(e.type = ParseNodeType.OR_EXPRESSION)
    method convertOrExpression(e:ParseNode):Value {
        var left := convertAndExpression(e[0])
        for i in 1 ... e.length - 1 by 2 {
            assert e[i].type = ParseNodeType.TOKEN
            var right := convertAndExpression(e[i + 1])
            left := getBinaryValue(e[i].position, left, 
                    e[i]->(TokenNode).token.type, right)
        }
        return left
    }
    
    method convertExpression(e:ParseNode):Value {
        assert e.type = ParseNodeType.EXPRESSION: 
                "expected expression, but found \{e} (\{e.type}): \{e.position}"
        return convertOrExpression(e[0])
    }
    
    method resolveNoArgFunction(u:Unresolved):MethodCall? {
        try {
            var result := testCall(u.position, u.context, u.name, 
                    new PrimitiveArray<Value>())->(MethodCall?)
            if result != null & 
                    result.methodNode.methodType = MethodNodeType.FUNCTION
                return result
        }
        catch e:CompilerException {
        }
        return null
    }
    
    ============================================================================
    Resolves a possibly-unresolved value. During the code analysis phase, we
    often end up with partial sequences of tokens: for instance, the sequence
    `panda.core.String` could potentially represent a type name (`panda`) having
    a class function (`core`) called upon it, resulting in an object which we 
    are going to extract a field (`String`) from. Or it could (as it obviously
    does in this case) represent the name of a class (`panda.core.String`). But
    as we are parsing it, and have so far just seen the "panda.core" part, we
    don't yet know we have a type name until we reach the "String", and the
    partial value will be represented by objects that are not fully resolved.

    This method means "we have all the information about this value we are ever
    going to get, so either give me the value it's describing or raise an 
    error". Note that a resolved construct may still have an unresolved type,
    such as `UnresolvedPrimitiveArray` or `UnresolvedRange`; those are legal returns from
    this method.
    ============================================================================
    method resolve(raw:Value):Value {
        var result:Value? := raw
        if result.type = RealType.REAL64
            result := implicitCast(result.position, result, RealType.REAL64)
        else if result-?>(Unresolved) {
            def context := result->(Unresolved).context
            try {
                if context-?>(UnresolvedClassLiteral) {
                    return call(raw.position, 
                            new ClassLiteral(raw.position, ClassType.CLASS()), 
                            result->(Unresolved).name, 
                            [context->(UnresolvedClassLiteral)->>
                                    (ClassObjectLiteral)])
                }
            }
            catch e:CompilerException {
            }
            try {
                def literal := new ClassLiteral(raw.position, 
                        getType(raw.position, raw->>(String)))
                captureNode(literal)
                return literal
            }
            catch e:CompilerException {
            }
            if !result->(Unresolved).name.contains(".")
                result := resolveNoArgFunction(result->(Unresolved))
            else
                result := null
            if result = null
                throw new CompilerException("unknown identifier", raw.position)
        }
        else if result-?>(AmbiguousReference) {
            def a := result->(AmbiguousReference)
            def name := a.field.name
            throw new CompilerException("reference to '\{name}' is " +
                    "ambiguous, both field \{name} (of type " +
                    "\{a.field.type.displayName}) and function " +
                    "\{name}() match", a.position)
        }
        else if result-?>(PossibleIndexedAssignment) {
            def pia := result->(PossibleIndexedAssignment)
            throw new CompilerException("'\{pia.context.type.displayName}' " +
                    "does not define the index ([]) operator for " +
                    "'\{pia.index.type.displayName}'", pia.position)
        }
        else if result-?>(PossibleSliceAssignment) {
            def psa := result->(PossibleSliceAssignment)
            var name:String
            if psa.endInclusive
                name := "inclusive slice ([...])"
            else
                name := "exclusive slice ([..])"
            throw new CompilerException("'\{psa.context.type.displayName}' " +
                    "does not define the \{name} operator for these types", 
                    psa.position)
        }
        return result
    }

    method findAssignmentMethod(context:Value, name:String, 
            params:PrimitiveArray<Value>, isSuper:Bit):MethodMatch? {
        if name = "[..]" | name = "[...]" {
            -- check for reduced argument methods first
            if params.length = 4 & params[2]-?>(IntegerLiteral) & 
                    params[2]->(IntegerLiteral).value = 1 {
                var result := findAssignmentMethod(context, name,
                        [params[0], params[1], params[3]], isSuper)
                if result != null
                    return result
            }
            else if params.length = 3 & params[1]-?>(NullLiteral) {
                var result := findAssignmentMethod(context, name,
                        [params[0], params[2]], isSuper)
                if result != null
                    return result
            }
            else if params.length = 2 & params[0]-?>(NullLiteral) {
                var result := findAssignmentMethod(context, name,
                        [params[1]], isSuper)
                if result != null
                    return result
            }
        }
        var type:Type
        if context-?>(ClassLiteral)
            type := context->(ClassLiteral).value
        else
            type := context.type
        if type.isPrimitive
            return null
        var cl := type.classNode
        if isSuper
            cl := cl.superclass->(ClassNode)
        def cm := currentMethod
        assert cm != null
        var finalParams := [context]
        finalParams.appendAll(params)
        var result := cl.symbolTable.getMethod(context.position, name + ":=",
                finalParams, context-?>(ClassLiteral))
        if result != null
            return new MethodMatch(result, finalParams)
        return null
    }

    method callAssignmentMethod(context:Value, name:String, 
            params:PrimitiveArray<Value>):Statement? {
        var m := findAssignmentMethod(context, name, params, false)
        if m != null {
            return new ValueStatement(call(context.position, m.methodNode, 
                    m.methodNode.isDeclaredVirtual, m.params))
        }
        return null
    }

    method unwrapImplicitCast(var v:Value):Value {
        -- we're not actually expecting to run into more than one level of 
        -- nesting, but do it in a loop just to be safe
        while v-?>(Cast) & v->(Cast).castType = CastType.IMPLICIT {
            def unwrapped := v->(Cast).value
            unwrapped.removeFromParent()
            v.replace(unwrapped)
            v := unwrapped
        }
        if v-?>(FieldReference) {
            def f := v->(FieldReference)
            if f.object.type.isWrapper & f.object-?>(Cast) & 
                    f.object->(Cast).castType = CastType.IMPLICIT {
                def object := f.object->(Cast).value
                object.removeFromParent()
                v := object
            }
        }
        return v
    }

    -- FIXME refactoring required! I did this all wrong and dumb. When I first
    -- started working on Panda, all lvalues were also rvalues. Then one
    -- situation crept in where the two weren't exactly the same, so I hacked it
    -- a bit to get it working. Then another cropped up, and another, and slowly
    -- this nice simple method turned into this hellish monstrosity. It needs to
    -- be killed with extreme prejudice, and I apologize to anyone reading this
    -- code. It just built up a bit at a time until it was completely out of
    -- control.
    --
    -- The basic idea is that (due to the original simplicity) the processing
    -- originally just figured out the rvalue on the left side of the assignment
    -- operator, ran into an assignment operator, made sure the rvalue worked as
    -- an lvalue, and continued on its merry way. Since then, this has gotten so 
    -- hellishly complicated that it absolutely needs to be rewritten so as to 
    -- know up front to be looking for an lvalue, so we can eliminate all of 
    -- these special cases and cut this at least in half.
    --
    -- UPDATE:
    -- Oh god I made it even worse. It's so awful. Please don't judge me by this
    -- method, I'm better than this, I swear :-(
    --
    -- FURTHER UPDATE:
    -- Actually, I don't think the refactoring is as simple as I outlined. I 
    -- hadn't considered the complexities introduced by compound assignment. We
    -- can't just process the assignment target twice (once in "lvalue mode" and
    -- once in "rvalue mode"), because that would involve duplicate evaluations
    -- of things that are only supposed to be evaluated once. It can certainly
    -- be done simpler than it's being done, but I don't think it's possible to
    -- eliminate quite as much complexity as I had hoped.
    method processSingleAssignment(var left:Value, assignmentOp:ParseNode, 
            right:Value, reuse:Bit) {
        try {
            left := resolve(left)
        }
        catch e:CompilerException {
        }
        def cm := currentMethod
        assert cm != null
        if left-?>(Unresolved) {
            -- could be an assignment method
            var context := left->(Unresolved).context
            var name := left->(Unresolved).name
            if context = null {
                if cm != null & !cm.annotations.isClass
                    context := getSelf()
                else {
                    -- we're in a class context, so there can't possibly be an
                    -- assignment method. Go ahead and trigger the exception
                    resolve(left)
                }
            }
            assert context != null
            var call := callAssignmentMethod(context, name, 
                    new PrimitiveArray<Value>(right))
            if call != null
                currentNode.add(call)
            else {
                -- no assignment method, trigger the exception
                resolve(left)
            }
        }
        else if left-?>(AmbiguousReference) {
            var a := left->(AmbiguousReference)
            var object := a.context
            if reuse {
                def reusable := makeReusable(object)
                reusable.replace(reusable.createReference())
                currentNode.add(new ValueStatement(reusable))
                object := reusable.createReference()
            }
            checkAssignment(a.field, a.position)
            open(new FieldAssignment(assignmentOp.position, object, a.field))
            currentNode.add(implicitCast(right.position, right, a.type))
            close(class(FieldAssignment))
        }
        else if left-?>(VariableReference) {
            var variable := left->(VariableReference).variable
            open(new ValueStatement(assignmentOp.position))
            open(new VariableAssignment(assignmentOp.position, variable))
            currentNode.add(implicitCast(right.position, right, variable.type))
            close(class(VariableAssignment))
            close(class(ValueStatement))
        }
        else if left-?>(FieldReference) {
            var fv := left->(FieldReference)
            var object:Value
            if reuse {
                cm.add(right)
                if fv.object-!>(ClassLiteral) {
                    def reusable := makeReusable(fv.object)
                    reusable.replace(reusable.createReference())
                    currentNode.add(new ValueStatement(reusable))
                    object := reusable.createReference()
                }
                else
                    object := fv.object
            }
            else {
                object := fv.object
                cm.add(fv)
            }
            if reuse
                right.removeFromParent()
            else {
                fv.removeFromParent()
                object.removeFromParent()
            }
            var name := fv.field.name
            var call := callAssignmentMethod(object, name, 
                    new PrimitiveArray<Value>(right))
            if call != null {
                if currentClass != fv.field.parent & 
                        !fv.field.annotations.isReadOnly &
                        !fv.field.annotations.isFinal {
                    throw new CompilerException("reference to '\{name}' is " +
                            "ambiguous, both field \{name} (of type " +
                            "\{fv.field.type.displayName}) and method " +
                            "\{name}:=() match", fv.position)
                }
                currentNode.add(call)
            }
            else {
                if reuse & object-?>(ClassLiteral) {
                    object.replace(
                            new ClassLiteral(object->(ClassLiteral).value))
                }
                checkAssignment(fv.field, fv.position)
                open(new FieldAssignment(assignmentOp.position, object, 
                        fv.field))
                currentNode.add(implicitCast(right.position, right, fv.type))
                close(class(FieldAssignment))
            }
        }
        else if left-?>(IndexValue) {
            if left->(IndexValue).array.type.isImmutable
                error("cannot modify immutable array", assignmentOp.position)
            -- handle increasing array length when index = array length
            var iv := left->(IndexValue)
            if reuse {
                cm.add(right)
                def array := makeReusable(iv.array)
                def index := makeReusable(iv.index)
                index.removeFromParent()
                array.removeFromParent()
                iv.add(array.createReference())
                iv.add(index.createReference())
                right.removeFromParent()
                currentNode.add(new ValueStatement(array))
                currentNode.add(new ValueStatement(index))
                open(new IndexedAssignment(assignmentOp.position,
                        array.createReference(),
                        index.createReference()))
                currentNode.add(implicitCast(right.position, right, iv.type))
            }
            else {
                var array := iv.array
                var index := iv.index
                array.removeFromParent()
                index.removeFromParent()
                open(new IndexedAssignment(assignmentOp.position, array, index))
                currentNode.add(implicitCast(right.position, right, iv.type))
            }
            close(class(IndexedAssignment))
        }
        else if left-?>(PossibleIndexedAssignment) {
            var pia := left->(PossibleIndexedAssignment)
            var params := [pia.index, right]
            var call := callAssignmentMethod(pia.context, "[]", params)
            if call != null
                currentNode.add(call)
            else {
                -- FIXME use map
                var types := new PrimitiveArray<String>()
                for p in params
                    types.append(p.type.displayName)
                throw new CompilerException("'\{pia.context.type.displayName}' does " + 
                        "not define the indexed assignment ([]:=) operator " +
                        "for \{types}", pia.position)
            }
        }
        else if left-?>(PossibleSliceAssignment) {
            var psa := left->(PossibleSliceAssignment)
            var params := [psa.left, psa.right, psa.step, right]
            var name:String
            if psa.endInclusive
                name := "[...]"
            else
                name := "[..]"
            var call := callAssignmentMethod(psa.context, name, params)
            if call != null
                currentNode.add(call)
            else {
                var types := new PrimitiveArray<String>()
                for p in params
                    types.append(p.type.displayName)
                if psa.endInclusive
                    name := "inclusive slice assignment ([...]:=)"
                else
                    name := "exclusive slice assignment ([..]:=)"
                throw new CompilerException("\{psa.context.type.displayName} does " +
                        "not define the \{name} operator for \{types}", 
                        psa.position)
            }
        }
        else if left-?>(MethodCall) {
            -- assigning to a method call. We need to look for a corresponding
            -- assignment method / field.
            var mc := left->(MethodCall)
            var methodNode := mc.methodNode
            if !methodNode.annotations.isClass & (mc.parameters.length = 1 | 
                    methodNode.name = "[]" | methodNode.name = "[..]" |
                    methodNode.name = "[...]") {
                var cl := mc.methodNode.parent->(ClassNode)
                var oldParams := mc.parameters
                var testParams := oldParams[1..]
                -- undo implicit casts that happened as part of setting up the
                -- original method call
                for i, p in testParams {
                    testParams[i] := unwrapImplicitCast(p)
                }
                if methodNode.name = "[..]" | methodNode.name = "[...]" {
                    -- restore parameters that might have been stripped when we
                    -- matched the initial slice. Such a hack, I'm so sorry.
                    if testParams.length = 0
                        testParams.append(new NullLiteral(left.position))
                    if testParams.length = 1
                        testParams.append(new NullLiteral(left.position))
                    if testParams.length = 2
                        testParams.append(new IntegerLiteral(left.position, 1))
                }
                testParams.append(right)
                def src := unwrapImplicitCast(oldParams[0])
                def m := findAssignmentMethod(src, methodNode.name, 
                        testParams, mc.isSuper)
                if m != null {
                    -- found assignment method
                    -- promote our parameters, call it and we're done
                    var params := new PrimitiveArray<Value>()
                    if reuse
                        cm.add(right)
                    else
                        cm.add(mc)
                    for i, p in m.params {
                        if i = m.params.length - 1
                            break
                        if reuse {
                            def getMethod := left->(MethodCall).methodNode
                            var reusable := makeReusable(p)
                            reusable.replace(implicitCast(p.position,
                                    reusable.createReference(),
                                    getMethod.parameters[i].type))
                            params.append(reusable)
                        }
                        else
                            params.append(p)
                        if params[i].parent != null
                            params[i].removeFromParent()
                    }
                    if reuse
                        right.removeFromParent()
                    else
                        mc.removeFromParent()
                    params.append(right)
                    currentNode.add(new ValueStatement(call(
                            assignmentOp.position, m.methodNode, 
                            m.methodNode.isDeclaredVirtual() & !mc.isSuper, 
                            params)))
                }
                else {
                    -- no assignment method
                    if methodNode.name = "[]" {
                        var types := new PrimitiveArray<String>()
                        for p in testParams
                            types.append(p.type.displayName)
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the indexed assignment ([]:=) " +
                                "operator for \{types}", mc.position)
                    }
                    else if methodNode.name = "[..]" {
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the exclusive slice assignment ([..]:=) " +
                                "operator for these types", mc.position)
                    }
                    else if methodNode.name = "[...]" {
                        throw new CompilerException("'\{src.type.displayName}' " +
                                "does not define the inclusive slice assignment ([...]:=) " +
                                "operator for these types", mc.position)
                    }
                    else {
                        -- check for a field by this name
                        if oldParams.length = 1 {
                            var object := oldParams[0]
                            def field := getField(left.position, 
                                    new Dummy(object.type), 
                                    mc.methodNode.name, false)
                            if field-?>(FieldReference) {
                                if reuse {
                                    cm.add(right)
                                    def reusable := makeReusable(object)
                                    reusable.replace(reusable.createReference())
                                    object := reusable
                                    right.removeFromParent()
                                }
                                else
                                    object.removeFromParent()
                                checkAssignment(field->(FieldReference).field,
                                        field.position)
                                open(new FieldAssignment(assignmentOp.position, 
                                        object, field->(FieldReference).field))
                                currentNode.add(implicitCast(right.position, 
                                        right, field.type))
                                close(class(FieldAssignment))
                                return
                            }
                        }
                        error("cannot assign to '\{left}'", assignmentOp)
                    }
                }
            }
            else
                error("cannot assign to '\{left}'", assignmentOp)
        }
        else
            error("cannot assign to '\{left}'", assignmentOp)
    }

    @pre(assignmentOp.type = ParseNodeType.ASSIGNMENT_OPERATOR)
    method processAssignment(left:PrimitiveArray<Value?>, assignmentOp:ParseNode, 
            var right:Value) {
        var cm := currentMethod
        assert cm != null
        var reuse := true
        var assignmentType := assignmentOp[0]->(TokenNode).token.type
        if assignmentType = TokenType.ASSIGNMENT
            reuse := false
        else {
            var op:TokenType
            switch assignmentType {
                case TokenType.ADDEQ:        op := TokenType.ADD
                case TokenType.SUBEQ:        op := TokenType.SUB
                case TokenType.MULEQ:        op := TokenType.MUL
                case TokenType.DIVEQ:        op := TokenType.DIV
                case TokenType.INTDIVEQ:     op := TokenType.INTDIV
                case TokenType.POWEQ:        op := TokenType.POW
                case TokenType.REMEQ:        op := TokenType.REM
                case TokenType.SHIFTLEFTEQ:  op := TokenType.SHIFTLEFT
                case TokenType.SHIFTRIGHTEQ: op := TokenType.SHIFTRIGHT
                case TokenType.BITWISEANDEQ: op := TokenType.BITWISEAND
                case TokenType.BITWISEOREQ:  op := TokenType.BITWISEOR
                case TokenType.BITWISEXOREQ: op := TokenType.BITWISEXOR
                case TokenType.ANDEQ:        op := TokenType.AND
                case TokenType.OREQ:         op := TokenType.OR
                case TokenType.XOREQ:        op := TokenType.XOR
                default: throw new InternalCompilerException(
                        "unsupported assignment operator: " +
                        "'\{assignmentType}'", assignmentOp.position)
            }
            if left.length > 1
                throw new CompilerException("compound assignment cannot " +
                        " assign to multiple values at once", 
                        assignmentOp.position)
            var lvalue := left[0]
            if lvalue = null {
                throw new CompilerException("'_' is only permitted in " +
                        "multiple assignments from a tuple", 
                        assignmentOp.position)
            }
            lvalue := resolve(lvalue)
            right := getBinaryValue(assignmentOp.position, lvalue, op, right)
            -- deal with situations like int8 += 1 (which resolves into
            -- int8 := int8 + 1, and the right side promotes to an Int32, so we
            -- need to downcast)
            if right.type.isInteger & lvalue.type.isInteger {
                right := explicitCast(assignmentOp.position, right, 
                        lvalue.type)
            }
            left[0] := lvalue
        }


        if left.length > 1 {
            def vs := new ValueStatement(right)
            currentNode.add(vs)
            def reusable := makeReusable(right)
            for i, lvalue in left {
                if lvalue != null {
                    processSingleAssignment(lvalue, assignmentOp, 
                            getField(right.position, 
                                reusable.createReference(), 
                                "$field" + i), reuse)
                }
            }
        }
        else {
            def lvalue := left[0]
            assert lvalue != null
            processSingleAssignment(lvalue, assignmentOp, right, reuse)
        }
    }
    
    method convertInstanceOf(position:Position, var object:Value, 
            var type:Type):Value {
        if object.type = StringOrCharType.STRING_OR_CHAR {
            -- hardcode STRING_OR_CHAR-?>(Char) and STRING_OR_CHAR-?>(String)
            -- as true
            if type = CharType.CHAR | ClassType.STRING().canImplicitCastTo(type)
                return new BitLiteral(position, true)
        }
        var primitiveTarget := type.isPrimitive | type.isWrapper
        if primitiveTarget {
            if object.type = StringOrCharType.STRING_OR_CHAR
                object := implicitCast(position, object, CharType.CHAR)
            if object.type = CharType.CHAR & type.isNumber
                object := explicitCast(position, object, IntType.INT32)
        }
        var primitiveSource := object.type.isPrimitive | 
                object.type.isWrapper

        if object.type.isNumber & type.isReal
            return new BitLiteral(position, true)

        if !primitiveSource & type.isPrimitive
            type := type.unwrapRealLiteral.wrapperVersion()

        if !object.canExplicitCastTo(type) {
            error("'\{object}' (\{object.type.displayName}) cannot possibly " +
                    "be an instance of '\{type.displayName}'", position)
        }

        def panda := ClassType.PANDA().classNode
        var parameters := new PrimitiveArray<Value>(object)
        if !primitiveTarget
            parameters.append(new ClassObjectLiteral(position, type.unwrapNullable))
        
        var methodName := "instanceOf"
        if primitiveTarget {
            var target := type.unwrapNullable
            var name := target.name
            assert name.startsWith(ClassNode.CORE)
            name := name[ClassNode.CORE.length..]
            if target.isWrapper {
                name := name.replace("Wrapper", "")
            }
            methodName += name
        }
        var instanceOf:MethodNode? := null
        if !object.type.isNullable {
            instanceOf := panda.symbolTable.getMethod(position, methodName, 
                    parameters, true)
        }
        if instanceOf = null {
            parameters.append(new BitLiteral(position, type.isNullable))
            instanceOf := panda.symbolTable.getMethod(position, methodName, 
                    parameters, true)
        }
        assert instanceOf != null
        return call(position, instanceOf, false, parameters)
    }

    @private
    method getType(position:Position, s:String):Type {
        if linkageOnly & !forceTypeResolution
            return new UnresolvedType(s.replace(" ", ""), position)
        var cc := currentClass
        var symbolTable:SymbolTable
        if cc != null
            symbolTable := cc.symbolTable
        else
            symbolTable := SymbolTable.master
        var result := symbolTable.getType(position, s)
        if !linkageOnly & result-?>(UnresolvedType)
            throw new CompilerException("symbol '\{s}' not found", position)
        if cc != null & !cc.annotations.isUnspecified {
            if !result.isPrimitive & result.classNode.annotations.isUnspecified {
                throw new CompilerException("'\{result.displayName}' is not a " +
                        "fully-specified type", position)
            }
        }
        return result
    }

    @pre(params.type = ParseNodeType.PARAMETERS)
    method convertParameters(params:ParseNode):PrimitiveArray<Value> {
        assert params[0]->(TokenNode).token.type = TokenType.LPAREN
        def result := new PrimitiveArray<Value>()
        for i in 1 .. params.length - 1 by 2 {
            var expr := convertExpression(params[i])
            if i = params.length - 2 & expr-?>(UnresolvedRange) {
                def r := expr->(UnresolvedRange)
                def left := r.left
                if left != null & left.variableType().isPrimitiveArray & r.right = null & 
                        r.step = null & r.endInclusive
                    expr := new Unwrap(left)
            }
            result.append(expr)
        }
        allowUnwrap := false
        return result
    }

    ============================================================================
    Converts a list of parameters to the types required by a method type, or
    throws an exception if a conversion is not possible. Note that this method
    is for use with dynamic calls, and thus only performs a subset of the work 
    that is done during a normal call (for instance, dynamic calls cannot be
    variadic or have convert parameters).
    ============================================================================
    @private
    @pre(v.type.isMethod)
    method prepareMethodParameters(v:Value, params:PrimitiveArray<Value>) {
        var parameterTypes := v.type.unwrapNullable->(MethodType).methodParameters
        if parameterTypes.length != params.length {
            var msg :=  "\{v.type.displayName} requires \{parameterTypes.length}"
            if parameterTypes.length = 1
                msg += " parameter"
            else
                msg += " parameters"
            msg += ", but found " + params.length
            throw new CompilerException(msg, v.position)
        }
        for i, param in params
            params[i] := implicitCast(param.position, param, parameterTypes[i])
    }
    
    method findSliceMethod(context:Value, endInclusive:Bit,
            params:PrimitiveArray<Value>):MethodMatch? {
        if params.length = 3 & params[2]-?>(IntegerLiteral) & 
                params[2]->(IntegerLiteral).value = 1 {
            def result := findSliceMethod(context, endInclusive,
                    [params[0], params[1]])
            if result != null
                return result
        }
        else if params.length = 2 & params[1]-?>(NullLiteral) {
            def result := findSliceMethod(context, endInclusive,
                    [params[0]])
            if result != null
                return result
        }
        else if params.length = 1 & params[0]-?>(NullLiteral) {
            def result := findSliceMethod(context, endInclusive, [])
            if result != null
                return result
        }
        var finalParams:PrimitiveArray<Value>
        var type:Type
        if context-?>(ClassLiteral) {
            type := context->(ClassLiteral).value
            finalParams := []
        }
        else {
            type := context.type
            finalParams := [context]
        }
        if type.isPrimitive
            return null
        def cl := type.classNode
        def cm := currentMethod
        assert cm != null
        finalParams.appendAll(params)
        var name:String
        if endInclusive
            name := "[...]"
        else
            name := "[..]"
        var result := cl.symbolTable.getMethod(context.position, name,
                finalParams, context-?>(ClassLiteral))
        if result != null
            return new MethodMatch(result, finalParams)
        return null
    }

    @private
    @pre(types.type = ParseNodeType.TYPES)
    method convertTypes(types:ParseNode):PrimitiveArray<Type> {
        def result:PrimitiveArray<Type> := []
        assert types[0]->(TokenNode).token.type = TokenType.LPAREN
        for i in 1 ... types.length - 2 by 2
            result.append(convertType(types[i]))
        assert types[types.length - 1]->(TokenNode).token.type = 
                TokenType.RPAREN
        return result
    }

    ============================================================================
    Returns a value which refers to the given method.
    ============================================================================
    method methodReference(position:Position, m:MethodNode):Value {
        -- Unfortunately we can't just use a straight pointer to the method,
        -- because (for the sake of closures) method references take an 
        -- additional parameter for the closure itself and the raw method won't
        -- be expecting that. So for right now we just create a simple closure
        -- which calls the method.
        def parameters := new MutableString("(")
        for i, param in m.parameters {
            if i > 0
                parameters.append(", ")
            parameters.append("$\{param.name}:\{param.type.name}")
        }
        parameters.append(")")
        def isClass := m.annotations.isClass | 
                m.annotations.isWrapperMethod

        def parent := currentMethod
        assert parent != null
        def outerSelf:Value?
        if !parent.annotations.isClass
            outerSelf := getSelf()
        else
            outerSelf := null
        prepareForClosureBlock(position, m.methodType, 
                new PandaParser().parseParameterPrototypeList(
                    parameters->>(String), position),
                m.returnType)
        def cm := currentMethod
        assert cm != null
        def symbols := new SymbolTable(cm, cm.owner.symbolTable)
        def params := new PrimitiveArray<Value>()
        for i, param in cm.parameters {
            symbols.putVariable(param)
            if i != 0
                params.append(new VariableReference(param))
        }
        def block := new Block(position, symbols)
        open(block)
        def invocation := call(position, m, true, params)
        if m.returnType != VoidType.VOID
            currentNode.add(new Return(invocation))
        else
            currentNode.add(new ValueStatement(invocation))
        close(class(Block))
        return finishClosure(position, [], outerSelf)
    }

    ============================================================================
    Handles the nodes following the context in a CALL_OR_ASSIGNMENT. If it is a
    call, returns the call's value, otherwise returns null.
    ============================================================================
    method processCallOrAssignment(var context:Value?, c:ParseNode):Value? {
        var i := 1
        def lvalues := new PrimitiveArray<Value?>()
        while i < c.length {
            if c[i].type = ParseNodeType.TOKEN {
                switch c[i]->(TokenNode).token.type {
                    case TokenType.DOT: {
                        var name := c[i + 1]->>(String)
                        assert context != null
                        try {
                            context := resolve(context)
                            context := resolveUnresolvedConstructs(context)
                            context := getField(c[i + 1].position, context, 
                                    name)
                        }
                        catch e:CompilerException {
                            if context-!>(Unresolved)
                                throw e
                            context := new Unresolved(c[i + 1].position, 
                                    context->(Unresolved).context, 
                                    context + "." + name)
                        }
                        i += 2
                    }
                    case TokenType.LBRACKET: {
                        assert context != null
                        context := resolve(context)
                        context := resolveUnresolvedConstructs(context)
                        i += 1
                        var slice := false
                        var endInclusive := false
                        var left:Value?
                        var right:Value?
                        var step:Value? := null
                        if c[i]-?>(TokenNode) & 
                                c[i]->(TokenNode).token.type = TokenType.DOTDOT {
                            left := null
                            slice := true
                        }
                        else if c[i]-?>(TokenNode) & 
                                c[i]->(TokenNode).token.type = TokenType.ELLIPSIS {
                            left := null
                            slice := true
                            endInclusive := true
                        }
                        else {
                            left := convertExpression(c[i])
                            i += 1
                        }
                        if c[i]-?>(TokenNode) & 
                                (c[i]->(TokenNode).token.type = TokenType.DOTDOT |
                                c[i]->(TokenNode).token.type = TokenType.ELLIPSIS) {
                            slice := true
                            endInclusive := c[i]->(TokenNode).token.type = TokenType.ELLIPSIS
                            i += 1
                            if c[i]-?>(TokenNode) & 
                                    (c[i]->(TokenNode).token.type = 
                                        TokenType.RBRACKET | 
                                    c[i]->(TokenNode).token.type = 
                                        TokenType.BY)
                                right := null
                            else {
                                right := convertExpression(c[i])
                                i += 1
                            }
                            if c[i]->(TokenNode).token.type = TokenType.BY {
                                i += 1
                                step := convertExpression(c[i])
                                i += 1
                            }
                        }
                        else
                            right := null
                        if left != null & right = null & step = null {
                            if left-?>(UnresolvedRange) {
                                def range := left->(UnresolvedRange)
                                left := range.left
                                right := range.right
                                step := range.step
                                slice := true
                                endInclusive := range.endInclusive
                            }
                        }
                        if !slice {
                            assert left != null
                            if context.type.isPrimitiveArray {
                                if context.type.isNullable
                                    context := implicitCast(c.position, context,
                                            context.type.unwrapNullable)
                                context := new IndexValue(c.position, context, 
                                        implicitCast(c.position, left, 
                                            Type.INDEX_TYPE))
                            }
                            else if context.type.isTuple & 
                                    left-?>(IntegerLiteral) {
                                context := getField(context.position, context,
                                        "$field" + left->(IntegerLiteral).value)
                            }
                            else {
                                -- look for overloaded [] operator
                                if context-?>(UnresolvedClassLiteral)
                                    context := context->
                                            (UnresolvedClassLiteral)->>
                                            (ClassLiteral)
                                if context.type.isPrimitive {
                                    var wrapper := context.type->
                                            (PrimitiveType).wrapperVersion()
                                    context := implicitCast(context.position, 
                                            context, wrapper, CastType.IMPLICIT)
                                }
                                def cl := context.type.classNode
                                var params := new PrimitiveArray<Value>(context, left)
                                var op := cl.symbolTable.getMethod(c.position, 
                                        "[]", params, false)
                                if op = null & context-?>(ClassLiteral) {
                                    var targetType := 
                                            context->(ClassLiteral).value
                                    var targetClass := targetType.classNode
                                    params := [left]
                                    op := targetClass.symbolTable.getMethod(
                                            c.position, "[]", params, true)
                                }
                                if op != null {
                                    context := call(c[i].position, op, true, 
                                            params)
                                }
                                else
                                    context := new PossibleIndexedAssignment(
                                            c.position, context, left)
                            }
                        }
                        else {
                            -- slice
                            if context-?>(UnresolvedClassLiteral)
                                context := context->
                                        (UnresolvedClassLiteral)->>
                                        (ClassLiteral)
                            if context.type.isPrimitive {
                                var wrapper := context.type->
                                                (PrimitiveType).wrapperVersion()
                                context := implicitCast(context.position, 
                                        context, wrapper, CastType.IMPLICIT)
                            }
                            def cl := context.type.classNode
                            if left = null
                                left := new NullLiteral(context.position)
                            if right = null
                                right := new NullLiteral(context.position)
                            if step = null
                                step := new IntegerLiteral(context.position, 1)
                            def match := findSliceMethod(context, endInclusive,
                                    [left, right, step])
                            if match != null {
                                context := call(c[i].position, match.methodNode, 
                                        true, match.params)
                            }
                            else {
                                context := new PossibleSliceAssignment(
                                        c.position, context, left, right, 
                                        step, endInclusive)
                            }
                        }
                        assert c[i].type = ParseNodeType.TOKEN &
                                c[i]->(TokenNode).token.type = TokenType.RBRACKET
                        i += 1
                    }
                    case TokenType.MEMBER: {
                        assert context != null
                        context := resolve(context)
                        context := resolveUnresolvedConstructs(context)
                        if context-?>(UnresolvedClassLiteral)
                            context := context->(UnresolvedClassLiteral)->>(ClassLiteral)
                        def type := context->(ClassLiteral).value
                        i += 1
                        def name := c[i]->>(String)
                        i += 1
                        var types:PrimitiveArray<Type>?
                        if i < c.length & c[i].type = ParseNodeType.TYPES {
                            types := convertTypes(c[i])
                            i += 1
                        }
                        else
                            types := null
                        var found := false
                        outer: for child in type.classNode.children {
                            if child-?>(MethodNode) & 
                                    child->(MethodNode).name = name {
                                def m := child->(MethodNode)
                                if types != null {
                                    var start:Int
                                    if m.annotations.isClass
                                        start := 0
                                    else
                                        start := 1
                                    def parameters := m.parameters[start..]
                                    if parameters.length != types.length
                                        continue
                                    for j, p in parameters {
                                        if p.type != types[j]
                                            continue outer
                                    }
                                }
                                if found {
                                    throw new CompilerException(
                                            "'\{type.displayName}' has more " +
                                            "than one method named " +
                                            "'\{name}', specify parameter " +
                                            "types to disambiguate", 
                                            context.position)
                                }
                                if m.annotations.isAbstract {
                                    PandaCompiler.reportError(
                                            "'\{type.displayName}.\{name}' is " +
                                            "abstract", context.position)
                                }
                                found := true
                                context := methodReference(context.position, m)
                            }
                        }
                        if !found {
                            throw new CompilerException("method not found",
                                    context.position)
                        }
                    }
                    case TokenType.CONVERT: {
                        assert context != null
                        context := resolve(context)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        context := convert(c[i].position, context, 
                                convertType(c[i]))
                        captureNode(context, c[i].position, "type")
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.CAST: {
                        assert context != null
                        context := resolve(context)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        context := explicitCast(c[i].position, context, 
                                convertType(c[i]))
                        captureNode(context, c[i].position, "type")
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.INSTANCEOF: {
                        assert context != null
                        context := resolve(context)
                        var position := c[i].position
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        context := convertInstanceOf(position, context, 
                                convertType(c[i]))
                        captureNode(context, c[i].position, "type")
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.NINSTANCEOF: {
                        assert context != null
                        context := resolve(context)
                        var position := c[i].position
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.LPAREN
                        i += 1
                        def instanceof := convertInstanceOf(position, context, 
                                convertType(c[i]))
                        captureNode(instanceof, c[i].position, "type")
                        context := new Not(position, instanceof)
                        i += 1
                        assert c[i]->(TokenNode).token.type = TokenType.RPAREN
                        i += 1
                    }
                    case TokenType.COMMA: {
                        assert context != null
                        lvalues.append(context)
                        i += 1
                        if c[i].type = ParseNodeType.CONSTRUCT
                            context := convertConstruct(c[i])
                        else {
                            var id := c[i]->>(String)
                            if id = "super"
                                context := new Super(c.position)
                            else
                                context := parseBareIdentifier(c[i])
                        }
                        i += 1
                    }
                    case TokenType.UNDERSCORE: {
                        lvalues.append(context)
                        context := null
                    }
                    default: error("unsupported token '\{c[i]->(TokenNode).token.type}'", 
                            c[i])
                }
            }
            else if c[i].type = ParseNodeType.PARAMETERS {
                var params := convertParameters(c[i])
                i += 1
                if context-?>(Unresolved) {
                    context := call(context.position, 
                            context->(Unresolved).context, 
                            context->(Unresolved).name, params)
                }
                else if context-?>(Super) {
                    throw new CompilerException("'super' is not a method", 
                            context.position)
                }
                else if context-?>(Value) {
                    var v := context->(Value)
                    if v.type.isMethod {
                        -- parentheses after a value of method type, need to
                        -- call the method
                        prepareMethodParameters(v, params)
                        context := new DynamicCall(v.position, v, params)
                    }
                    else {
                        throw new CompilerException("value of type '" + 
                                v.type.displayName + "' is not a method", 
                                context.position)
                    }
                }
                else {
                    assert context != null
                    error("cannot call method on '\{context}'",
                            context.position)
                }
            }
            else {
                assert context != null
                assert c[i].type = ParseNodeType.ASSIGNMENT_OPERATOR
                lvalues.append(context)
                processAssignment(lvalues, c[i], convertExpression(c[i + 1]))
                return null
            }
        }
        assert context != null
        assert lvalues.length = 0
        return resolve(context)
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Processes a CALL_OR_ASSIGNMENT parse node.
    ============================================================================
    @pre(c.type = ParseNodeType.CALL_OR_ASSIGNMENT)
    method convertCallOrAssignment(c:ParseNode) {
        var context:Value? := null
        if c[0].type = ParseNodeType.CONSTRUCT
            context := convertConstruct(c[0])
        else if c[0].type = ParseNodeType.CALL_EXPRESSION
            context := convertCallExpression(c[0])
        else {
            var id := c[0]->>(String)
            if id = "super"
                context := new Super(c.position)
            else
                context := parseBareIdentifier(c[0])
        }
        var call := processCallOrAssignment(context, c)
        if call != null
            currentNode.add(new ValueStatement(c.position, call))
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    @private
    @pre(t.type = ParseNodeType.FOR_TUPLE)
    method convertForTuple(t:ParseNode):PrimitiveArray<(Position, String?, Type?, ParseNode?)> {
        def result := new PrimitiveArray<(Position, String?, Type?, ParseNode?)>()
        var i := 0
        assert t[0]->(TokenNode).token.type = TokenType.LPAREN
        i += 1
        while t[i]->(TokenNode).token.type != TokenType.RPAREN {
            def position := t[i].position
            var name:String?
            if t[i]->(TokenNode).token.type = TokenType.IDENTIFIER
                name := t[i]->>(String)
            else {
                assert t[i]->(TokenNode).token.type = TokenType.UNDERSCORE
                name := null
            }
            i += 1
            def type:Type?
            def typeNode:ParseNode?
            if t[i].type = ParseNodeType.TYPE_DECLARATION {
                typeNode := t[i][1]
                type := convertType(typeNode)
                i += 1
            }
            else {
                typeNode := null
                type := null
            }
            if t[i]->(TokenNode).token.type = TokenType.COMMA
                i += 1
            result.append((position, name, type, typeNode))
        }
        return result
    }

    @private
    method castToIterable(value:Value):Value {
        def cl := value.type.classNode
        for intf in cl.allInterfaces() {
            if intf.name.startsWith("panda.collections.Iterable<")
                return implicitCast(value, intf.type())
        }
        throw new CompilerException("expected 'panda.collections.Iterable<T>'" +
                ", but found '\{value.type.displayName}'", value.position)
    }

    @private
    function getElementType(value:Value):Type {
        if value.type.isPrimitiveArray
            return value.type.unwrapNullable->(PrimitiveArrayType).elementType
        else {
            assert value.type.name.startsWith("panda.collections.Iterable<")
            return value.type.unwrapNullable->(GenericType).parameters[0]
        }
    }

    ============================================================================
    Processes an ANY_LOOP parse node which contains a for-each `for` loop.

    @param l the ANY_LOOP parse node
    @param i the index of the COMMA or IN token
    @param name the name of the first loop variable
    @param type the type declaration of the first loop variable, if any
    @param label the loop label, if any
    ============================================================================
    @private
    @pre(l.type = ParseNodeType.ANY_LOOP)
    method convertForEachLoop(l:ParseNode, var i:Int, 
            var vars:PrimitiveArray<(Position, String?, Type?, ParseNode?)>, 
            label:String?):Node {
        var indexPosition:Position? := null
        var indexName:String? := null
        var indexType:Type? := null
        var indexTypeNode:ParseNode? := null
        if l[i]->(TokenNode).token.type = TokenType.COMMA {
            -- we have both an index and a value
            i += 1
            assert vars.length = 1
            indexPosition := vars[0][0]
            indexName := vars[0][1]
            indexType := vars[0][2]
            indexTypeNode := vars[0][3]
            if indexType = null
                indexType := Type.INDEX_TYPE
            if !indexType.isInteger {
                throw new CompilerException("loop index must be an integer",
                        indexPosition)
            }
            if l[i].type = ParseNodeType.FOR_TUPLE {
                vars := convertForTuple(l[i])
                i += 1
            }
            else {
                def position := l[i].position
                def name := l[i]->>(String)
                def type:Type?
                def typeNode:ParseNode?
                i += 1
                if l[i].type = ParseNodeType.TYPE_DECLARATION {
                    typeNode := l[i][1]
                    type := convertType(typeNode)
                    i += 1
                }
                else {
                    type := null
                    typeNode := null
                }
                vars := [(position, name, type, typeNode)]
            }
        }
        assert l[i]->(TokenNode).token.type = TokenType.IN
        i += 1
        var array := convertExpression(l[i])
        i += 1
        if vars.length = 1 & vars[0][2] != null {
            if array-?>(UnresolvedPrimitiveArray) | array-?>(UnresolvedRange) {
                -- eventually, can just cast to Iterable<type>, but as of this
                -- writing generics are still under construction. So first we 
                -- make sure that this is an unresolved construct (and thus we 
                -- don't need to worry about mutable vs. immutable arrays)
                def type := vars[0][2]->(Type)
                def cl := currentClass
                assert cl != null
                if array-!>(UnresolvedRange) | type.isNumber {
                    array := implicitCast(array.position, array, 
                            cl.symbolTable.getType(array.position,
                                "\{class(PrimitiveArray).name}<\{type.name}>"))
                }
            }
        }
        array := resolveUnresolvedConstructs(array)
        if !array.type.isPrimitiveArray
            array := castToIterable(array)
        if vars.length > 1 {
            if !getElementType(array).isTuple {
                throw new CompilerException("'\{array.type.displayName}' " +
                        "is not a tuple", array.position)
            }
            def count := getElementType(array).unwrapNullable->(TupleType)
                    .types.length
            if count != vars.length {
                throw new CompilerException("number of for-loop variables (" + 
                        "\{vars.length}) and tuple elements (\{count}) do " +
                        "not match", l.position)
            }
        }
        var valueName:String?
        var valuePosition := vars[0][0]
        var valueType:Type?
        var valueTypeNode:ParseNode?
        if vars.length = 1 {
            valueName := vars[0][1]
            if valueName = null
                throw new CompilerException("'_' is only permitted in " +
                            "multiple assignments from a tuple", vars[0][0])
            valueType := vars[0][2]
            valueTypeNode := vars[0][3]
            if valueType != null & 
                    !getElementType(array).canImplicitCastTo(valueType) {
                throw new CompilerException("elements of " + 
                        "\{array.type.displayName} cannot be converted to " +
                        valueType.displayName, valuePosition)
            }
        }
        else {
            valueName := "$tuple" + nextCount()
            valueType := getElementType(array)
            valueTypeNode := null
        }
        if valueType = null
            valueType := getElementType(array)
        def cm := currentMethod
        assert cm != null
        def locals := cm.localVariables
        var indexVar:Variable?
        if indexName != null {
            assert indexPosition != null
            assert indexType != null
            indexVar := new LocalVariable(indexPosition, indexName, indexType)
            captureNode(indexVar)
            if indexTypeNode != null
                captureTree(indexVar, indexTypeNode, "type")
            locals.append(indexVar)
        }
        else
            indexVar := null
        def valueVar := new LocalVariable(valuePosition, valueName, valueType)
        captureNode(valueVar)
        if valueTypeNode != null
            captureTree(valueVar, valueTypeNode, "type")
        valueVar.annotations.isFinal := true
        locals.append(valueVar)
        def forEach := new ForEach(l.position, label, indexVar, valueVar, array)
        open(forEach)
        var symbols := new SymbolTable(currentNode,
                currentBlock.symbolTable)
        if indexVar != null
            symbols.putVariable(indexVar)
        symbols.putVariable(valueVar)
        open(new Block(symbols))
        if vars.length > 1 {
            for index, t in vars {
                def position := t[0]
                def name := t[1]
                if name = null
                    continue
                var type := t[2]
                if type = null
                    type := getElementType(array).unwrapNullable->(TupleType).types[index]
                def elementVar := new LocalVariable(t[0], name, type)
                locals.append(elementVar)
                symbols.putVariable(elementVar)
                def field := getField(array.position,
                        new VariableReference(valueVar), "$field" + index)
                currentNode.add(new ValueStatement(
                        new VariableAssignment(elementVar, 
                            implicitCast(array.position, field, 
                                type))))
            }
        }
        convertStatementOrBlock(l[i])
        close(class(Block))
        close(class(ForEach))
        return forEach
    }

    ============================================================================
    Processes an ANY_LOOP parse node which contains a `for` loop.

    @param l the ANY_LOOP parse node
    @param i the index of the FOR token
    @param label the loop label, if any
    ============================================================================
    @private
    method convertForLoop(l:ParseNode, var i:Int, label:String?):Node {
        i += 1
        var vars:PrimitiveArray<(Position, String?, Type?, ParseNode?)>
        if l[i].type = ParseNodeType.FOR_TUPLE {
            vars := convertForTuple(l[i])
            i += 1
        }
        else {
            assert l[i]->(TokenNode).token.type = TokenType.IDENTIFIER
            def name := l[i]->>(String)
            def namePosition := l[i].position
            var type:Type? := null
            var typeNode:ParseNode? := null
            i += 1
            if l[i].type = ParseNodeType.TYPE_DECLARATION {
                typeNode := l[i][1]
                type := convertType(typeNode)
                i += 1
            }
            vars := [(namePosition, name, type, typeNode)]
        }
        return convertForEachLoop(l, i, vars, label)
    }

    ============================================================================
    Processes an ANY_LOOP parse node.
    ============================================================================
    @pre(l.type = ParseNodeType.ANY_LOOP)
    method convertAnyLoop(l:ParseNode) {
        var label:String? := null
        var i := 0
        if l[i]->(TokenNode).token.type = TokenType.IDENTIFIER {
            label := l[i]->>(String)
            assert l[i + 1].type = ParseNodeType.TOKEN &
                    l[i + 1]->(TokenNode).token.type = TokenType.COLON
            i += 2
        }
        def result:Node
        switch l[i]->(TokenNode).token.type {
            case TokenType.FOR:
                result := convertForLoop(l, i, label)
            case TokenType.DO: {
                i += 1
                assert l[i + 1].type = ParseNodeType.TOKEN &
                        l[i + 1]->(TokenNode).token.type = TokenType.WHILE
                var test := implicitCast(l[i + 2].position, 
                        convertExpression(l[i + 2]), BitType.BIT)
                result := new Do(l.position, label, test)
                open(result)
                convertStatementOrBlock(l[i])
                close(class(Do))
            }
            case TokenType.LOOP: {
                i += 1
                result := new Loop(l.position, label)
                open(result)
                convertStatementOrBlock(l[i])
                close(class(Loop))
            }
            case TokenType.WHILE: {
                i += 1
                var test := implicitCast(l[i].position, convertExpression(l[i]),
                        BitType.BIT)
                result := new While(l.position, label, test)
                open(result)
                i += 1
                convertStatementOrBlock(l[i])
                close(class(While))
            }
            default: {
                throw new InternalCompilerException("unsupported loop type", 
                        l.position)
            }
        }
        if label != null {
            captureNode(result, l[0].position, "label")
            captureNode(result, l[1].position, "label")
        }
    }
    
    ============================================================================
    Processes an IF parse node.
    ============================================================================
    @pre(i.type = ParseNodeType.IF)
    method convertIf(i:ParseNode) {
        assert i[0]->(TokenNode).token.type = TokenType.IF
        var test := implicitCast(i[1].position, convertExpression(i[1]), 
                BitType.BIT)
        def ifNode := new If(i.position, test)
        open(ifNode)
        assert i[2].type = ParseNodeType.STATEMENT_OR_BLOCK
        convertStatementOrBlock(i[2])
        if i.length > 3 {
            assert i[3].type = ParseNodeType.TOKEN
            assert i[3]->(TokenNode).token.type = TokenType.ELSE
            convertStatementOrBlock(i[4])
        }
        close(class(If))
    }
    
    @protected
    @pre(s.type = ParseNodeType.SWITCH_STATEMENT)
    method convertSwitch(s:ParseNode) {
        assert s[0]->(TokenNode).token.type = TokenType.SWITCH
        def switchObject := new ReusedValueDefinition(convertExpression(s[1]))
        currentNode.add(new ValueStatement(switchObject))
        assert s[2]->(TokenNode).token.type = TokenType.LBRACE
        var count := 0
        for i in 3 .. s.length - 1 {
            switch s[i].type {
                case ParseNodeType.SWITCH_CASE: {
                    var c := s[i]
                    assert c[0]->(TokenNode).token.type = TokenType.CASE
                    var test := getBinaryValue(c[1].position,
                            switchObject.createReference(),
                            TokenType.EQ,
                            convertExpression(c[1]))
                    var j := 2
                    while c[j]->(TokenNode).token.type = TokenType.COMMA {
                        var or := new Or()
                        or.add(test)
                        or.add(getBinaryValue(c[j + 1].position,
                            switchObject.createReference(),
                            TokenType.EQ,
                            convertExpression(c[j + 1])))
                        test := or
                        j += 2
                    }
                    assert c[j]->(TokenNode).token.type = TokenType.COLON
                    open(new Block(currentBlock.symbolTable))
                    open(new If(test))
                    convertStatementOrBlock(c[j + 1])
                    count += 1
                }
                case ParseNodeType.SWITCH_DEFAULT:
                    convertStatementOrBlock(s[i][2])
                default:
                    error("unsupported switch node: \{s[i]}", s[i].position)
            }
        }
        for i in 0 .. count {
            close(class(If))
            close(class(Block))
        }
    }
    
    function getSingle(node:ParseNode, type:ParseNodeType):ParseNode? {
        if node.type = type
            return node
        if node.length != 1
            return null
        return getSingle(node[0], type)
    }

    ============================================================================
    Processes a VAR_DECLARATION parse node.
    ============================================================================
    @pre(v.type = ParseNodeType.VAR_DECLARATION)
    method convertVariableDeclaration(v:ParseNode) {
        var isFinal:Bit
        def varType := v[0]->(TokenNode).token.type
        if varType = TokenType.VAR
            isFinal := false
        else {
            assert varType = TokenType.DEF
            isFinal := true
        }
        def varPositions := new PrimitiveArray<Position>()
        def varNames := new PrimitiveArray<String?>()
        def varTypeNodes := new PrimitiveArray<ParseNode?>()
        def varTypes := new PrimitiveArray<Type?>()
        var i := 1
        loop {
            varPositions.append(v[i].position)
            var name:String?
            if v[i]->(TokenNode).token.type = TokenType.UNDERSCORE
                name := null
            else {
                assert v[i]->(TokenNode).token.type = TokenType.IDENTIFIER
                name := v[i]->>(String)
            }
            i += 1
            var type:Type? := null
            if i < v.length & v[i].type = ParseNodeType.TYPE_DECLARATION {
                type := convertType(v[i][1])
                varTypeNodes.append(v[i][1])
                i += 1
            }
            else
                varTypeNodes.append(null)
            varNames.append(name)
            varTypes.append(type)
            if i >= v.length | v[i].type != ParseNodeType.TOKEN | 
                    v[i]->(TokenNode).token.type != TokenType.COMMA
                break
            i += 1
        }
        var value:Value? := null
        if i < v.length {
            assert v[i]->(TokenNode).token.type = TokenType.ASSIGNMENT
            i += 1
            value := convertExpression(v[i])
        }
        var reusableTuple:ReusedValueDefinition? := null
        if varNames.length > 1 {
            if value != null {
                def valueType := value.variableType()
                if !valueType.isTuple | 
                        valueType.unwrapNullable->(TupleType).types.length != varNames.length {
                    throw new CompilerException("expected a tuple with length " + 
                            varNames.length + " for multi-value assignment",
                            value.position)
                }
                for j, type in varTypes {
                    if type = null
                        varTypes[j] := valueType.unwrapNullable->(TupleType).types[j].variableType()
                }
                def cn := currentNode
                if value-!>(UnresolvedTuple) {
                    -- need to promote it; for an unresolved tuple we'll just 
                    -- pull the values from it directly
                    reusableTuple := new ReusedValueDefinition(value)
                    cn.add(new ValueStatement(reusableTuple))
                }
            }
        }
        else if value != null & varTypes[0] = null
            varTypes[0] := value.variableType()
        if varNames.length = 1 & varNames[0] = null {
            throw new CompilerException("'_' is only permitted in " +
                    "multiple assignments from a tuple", varPositions[0])
        }
        for j, name in varNames {
            if name = null
                continue
            def position := varPositions[j]
            def type := varTypes[j]
            if type = null | type = NullType.NULL {
                throw new CompilerException(
                        "'\{name}' has neither an initial " +
                            "value nor an explicit type", position)
            }
            def variable := new LocalVariable(position, name, type)
            captureNode(variable)
            def typeNode := varTypeNodes[j]
            if typeNode != null
                captureTree(variable, typeNode, "type")
            variable.annotations.isFinal := isFinal
            currentBlock.symbolTable.putVariable(variable)
            def cm := currentMethod
            assert cm != null
            cm.localVariables.append(variable)
            if value != null {
                open(new ValueStatement(position))
                def va := new VariableAssignment(position, variable)
                va.isInitialValue := true
                open(va)
                if reusableTuple != null {
                    assert value != null
                    currentNode.add(implicitCast(value.position, 
                            getField(value.position, 
                            reusableTuple.createReference(), "$field" + j),
                            variable.type))
                }
                else if value-?>(UnresolvedTuple) & varNames.length > 1 {
                    def element := value->(UnresolvedTuple).values[j]
                    element.parent := null
                    currentNode.add(implicitCast(element.position, element, 
                            variable.type))
                }
                else {
                    currentNode.add(implicitCast(value.position, value, 
                            variable.type))
                }
                close(class(VariableAssignment))
                close(class(ValueStatement))
            }
        }
    }

    ============================================================================
    Processes a CONSTANT_FIELD_DECLARATION parse node.
    ============================================================================
    @pre(c.type = ParseNodeType.CONSTANT_FIELD_DECLARATION)
    @pre(currentClass != null)
    method convertConstantFieldDeclaration(doccomment:String?,
             annotations:Annotations, c:ParseNode) {
        def cl := currentClass
        assert cl != null
        var field:FieldNode? := null
        if linkageOnly {
            assert c[0]->(TokenNode).token.type = TokenType.CONSTANT
            assert c[1]->(TokenNode).token.type = TokenType.IDENTIFIER
            var name := c[1]->(TokenNode).token.text
            def type:Type
            def typeNode:ParseNode?
            if c[2].type = ParseNodeType.TYPE_DECLARATION {
                typeNode := c[2][1]
                type := convertType(typeNode)
            }
            else {
                typeNode := null
                type := Type.UNRESOLVED
            }
            field := new FieldNode(c.position, name, type)
            captureNode(field, c[1].position)
            if typeNode != null
                captureTree(field, typeNode, "type")
            field.annotations := annotations
            field.annotations.isClass := true
            field.annotations.isFinal := true
            field.doccomment := doccomment
            cl.add(field)
            cl.symbolTable.putVariable(field)
            var i := c.length - 2
            if c[i].type = ParseNodeType.TOKEN & 
                    c[i]->(TokenNode).token.type = TokenType.ASSIGNMENT {
                i += 1
                pendingFieldValues[field] := c[i]
            }
        }
        else {
            for child in cl.children {
                if child.position = c.position {
                    field := child->(FieldNode)
                    break
                }
            }
            assert field != null
            if !field.type.isImmutable {
                error("constants must be immutable (found mutable type '" + 
                        field.type.displayName + "')", field)
            }
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Processes a CONSTANT_DECLARATION parse node.
    ============================================================================
    @pre(c.type = ParseNodeType.CONSTANT_DECLARATION)
    method convertConstantDeclaration(c:ParseNode) {
        assert c[0]->(TokenNode).token.type = TokenType.CONSTANT
        assert c[1]->(TokenNode).token.type = TokenType.IDENTIFIER
        def name := c[1]->>(String)
        var type:Type? := null
        var value:Value? := null
        var i := 2
        if c[i].type = ParseNodeType.TYPE_DECLARATION {
            type := convertType(c[i][1])
            i += 1
        }
        assert c[i]->(TokenNode).token.type = TokenType.ASSIGNMENT
        i += 1
        value := convertExpression(c[i])
        if type = null
            type := value.variableType(true)
        if !type.isImmutable {
            PandaCompiler.reportError("constants must be immutable (found " +
                    "mutable type '\{type.displayName}'", c.position)
        }
        def variable := new LocalVariable(c[1].position, name, type)
        variable.annotations.isFinal := true
        currentBlock.symbolTable.putVariable(variable)
        def cm := currentMethod
        assert cm != null
        cm.localVariables.append(variable)
        if value != null {
            open(new ValueStatement(c.position))
            open(new VariableAssignment(c.position, variable))
            currentNode.add(implicitCast(value.position, value, variable.type))
            close(class(VariableAssignment))
            close(class(ValueStatement))
        }
    }
    
    ============================================================================
    Processes an ASSERT parse node.
    ============================================================================
    @pre(a.type = ParseNodeType.ASSERT_STATEMENT)
    method convertAssert(a:ParseNode) {
        assert a[0]->(TokenNode).token.type = TokenType.ASSERT
        def node := new Assert(a.position, implicitCast(a[1].position, 
                convertExpression(a[1]), BitType.BIT))
        if a.length > 2 {
            assert a[2]->(TokenNode).token.type = TokenType.COLON
            var msg := convertExpression(a[3])
            if msg.canImplicitCastTo(ClassType.SAFETYERROR()) {
                -- note that we verify it's a SafetyError, but actually cast to
                -- error, since that's what throw expects
                msg := implicitCast(msg.position, msg, ClassType.ERROR(), 
                        CastType.IMPLICIT)
            }
            else if msg.canImplicitCastTo(ClassType.STRING()) {
                msg := implicitCast(msg.position, msg, ClassType.STRING(), 
                        CastType.IMPLICIT)
            }
            else {
                PandaCompiler.reportError(new CompilerException(
                        "expected either 'panda.core.String' " +
                        "or 'panda.core.SafetyError', but found " +
                        "'\{msg.type.displayName}'", msg.position))
            }
            node.message := msg
        }
        currentNode.add(node)
    }

    ============================================================================
    Processes a CATCH_BLOCK parse node.
    ============================================================================
    @pre(c.type = ParseNodeType.CATCH_BLOCK)
    method convertCatchBlock(c:ParseNode) {
        assert c[0]->(TokenNode).token.type = TokenType.CATCH
        def variable := new LocalVariable(c[1].position, c[1]->>(String), 
                convertType(c[2][1]))
        def cm := currentMethod
        assert cm != null
        cm.localVariables.append(variable)
        open(new Catch(c.position, currentBlock.symbolTable, variable))
        convertBlock(c[3])
        close(class(Catch))
    }

    ============================================================================
    Processes a FINALLY_BLOCK parse node.
    ============================================================================
    @pre(f.type = ParseNodeType.FINALLY_BLOCK)
    method convertFinallyBlock(f:ParseNode) {
        open(new Finally(f.position, currentBlock.symbolTable))
        assert f[0]->(TokenNode).token.type = TokenType.FINALLY
        convertBlock(f[1])
        close(class(Finally))
    }

    ============================================================================
    Processes a TRY_STATEMENT parse node.
    ============================================================================
    @pre(t.type = ParseNodeType.TRY_STATEMENT)
    method convertTryStatement(t:ParseNode) {
        open(new Try(t.position))
        convertBlock(t[1])
        for i in 2 ... t.length - 1 {
            if t[i].type = ParseNodeType.CATCH_BLOCK
                convertCatchBlock(t[i])
            else
                convertFinallyBlock(t[i])
        }
        close(class(Try))
    }

    ============================================================================
    Processes a THROW_STATEMENT parse node.
    ============================================================================
    @pre(t.type = ParseNodeType.THROW_STATEMENT)
    method convertThrowStatement(t:ParseNode) {
        currentNode.add(new Throw(t.position, implicitCast(t[1].position,
                convertExpression(t[1]), ClassType.ERROR())))
    }

    ============================================================================
    Processes an UNREACHABLE token.
    ============================================================================
    @pre(t->(TokenNode).token.type = TokenType.UNREACHABLE)
    method convertUnreachable(t:ParseNode) {
        currentNode.add(new Unreachable(t.position))
    }

    ============================================================================
    Processes a SIMPLE_STATEMENT parse node.
    ============================================================================
    @pre(s.type = ParseNodeType.SIMPLE_STATEMENT)
    method convertSimpleStatement(s:ParseNode) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.VAR_DECLARATION: convertVariableDeclaration(s[0])
            case ParseNodeType.CONSTANT_DECLARATION: 
                    convertConstantDeclaration(s[0])
            case ParseNodeType.CALL_OR_ASSIGNMENT: convertCallOrAssignment(s[0])
            case ParseNodeType.ANY_LOOP: convertAnyLoop(s[0])
            case ParseNodeType.IF: convertIf(s[0])
            case ParseNodeType.SWITCH_STATEMENT: convertSwitch(s[0])
            case ParseNodeType.ASSERT_STATEMENT: convertAssert(s[0])
            case ParseNodeType.TRY_STATEMENT: convertTryStatement(s[0])
            default: error("unsupported simple statement: \{s[0].class.name}", 
                    s)
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Processes a TERMINAL_STATEMENT parse node.
    ============================================================================
    @pre(s.type = ParseNodeType.TERMINAL_STATEMENT)
    method convertTerminalStatement(s:ParseNode) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.BREAK_STATEMENT: {
                def b := s[0]
                if b.length > 1
                    currentNode.add(new Break(b.position, b[1]->>(String)))
                else
                    currentNode.add(new Break(b.position))
            }
            case ParseNodeType.CONTINUE_STATEMENT: {
                def c := s[0]
                if c.length > 1
                    currentNode.add(new Continue(c.position, c[1]->>(String)))
                else
                    currentNode.add(new Continue(c.position))
            }
            case ParseNodeType.RETURN_STATEMENT: {
                def r := s[0]
                if r.length > 1 {
                    def cm := currentMethod
                    assert cm != null
                    currentNode.add(new Return(r.position, 
                            implicitCast(r[1].position, convertExpression(r[1]), 
                                    cm.returnType)))
                }
                else
                    currentNode.add(new Return(r.position))
            }
            case ParseNodeType.THROW_STATEMENT: convertThrowStatement(s[0])
            case ParseNodeType.TOKEN: convertUnreachable(s[0])
            default: error("unsupported terminal statement: \{s[0].class.name}",
                    s[0])
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))
    
    ============================================================================
    Processes a STATEMENT parse node.
    ============================================================================
    @pre(s.type = ParseNodeType.STATEMENT)
    method convertStatement(s:ParseNode) {
        def entry := currentNode
        try {
            assert s.length = 1
            switch s[0].type {
                case ParseNodeType.SIMPLE_STATEMENT: convertSimpleStatement(s[0])
                case ParseNodeType.BLOCK: convertBlock(s[0])
                default: error("unsupported statement: \{s[0].class.name}", 
                        s[0])
            }
        }
        catch e:CompilerException {
            while currentNode != entry
                nodeStack.pop()
            PandaCompiler.reportError(e)
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Processes a BLOCK parse node.
    ============================================================================
    @pre(b.type = ParseNodeType.BLOCK)
    method convertBlock(b:ParseNode) {
        def cm := currentMethod
        assert cm != null
        def cc := currentClass
        assert cc != null
        var parent:SymbolTable
        if currentNode-?>(MethodNode) {
            -- top-level block, add method parameters to symboltable
            parent := new SymbolTable(cm, cc.symbolTable)
            for param in cm.parameters
                parent.putVariable(param)
        }
        else
            parent := currentBlock.symbolTable
        def block := new Block(b.position, parent)
        open(block)
        for i in 1 ... b.length - 2 {
            switch b[i].type {
                case ParseNodeType.STATEMENT: convertStatement(b[i])
                case ParseNodeType.TERMINAL_STATEMENT: 
                        convertTerminalStatement(b[i])
                default: {
                    error("unsupported statement in block: \{b[i].class.name}", 
                            b[i])
                }
            }
        }
        if block.parent-?>(Catch)
            currentNode.add(new CatchExit(b.position))
        close(class(Block))
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Processes a STATEMENT_OR_BLOCK parse node.
    ============================================================================
    @pre(b.type = ParseNodeType.STATEMENT_OR_BLOCK)
    method convertStatementOrBlock(b:ParseNode) {
        if b[0].type = ParseNodeType.BLOCK
            convertBlock(b[0])
        else {
            open(new Block(b.position, currentBlock.symbolTable))
            if b[0].type = ParseNodeType.SIMPLE_STATEMENT
                convertSimpleStatement(b[0])
            else
                convertTerminalStatement(b[0])
            close(class(Block))
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Processes a PARAMETER_PROTOTYPE parse node.
    ============================================================================
    @pre(p.type = ParseNodeType.PARAMETER_PROTOTYPE)
    method convertParameterPrototype(p:ParseNode) {
        var isFinal:Bit
        var i := 0
        if p[i]->(TokenNode).token.type = TokenType.VAR {
            isFinal := false
            i += 1
        }
        else
            isFinal := true
        assert p[i]->(TokenNode).token.type = TokenType.IDENTIFIER
        def name := p[i]->(TokenNode).token
        i += 1
        var isConvert:Bit
        if p[i]->(TokenNode).token.type = TokenType.COLON
            isConvert := false
        else {
            assert p[i]->(TokenNode).token.type = TokenType.CONVERT
            isConvert := true
        }
        i += 1
        def typeNode := p[i]
        var type := convertType(typeNode)
        i += 1
        var isVarArg := false
        if p.length > i {
            assert p[i]->(TokenNode).token.type = TokenType.ELLIPSIS
            isVarArg := true
            type := getType(p.position, class(PrimitiveArray).name + "<" + type.name + 
                    ">")
        }
        var param := new Parameter(p.position, name.text, type)
        captureNode(param, name.position)
        captureTree(param, typeNode, "type")
        param.isVarArg := isVarArg
        param.isConvert := isConvert
        param.annotations.isFinal := isFinal
        var cm := currentMethod
        assert cm != null
        cm.parameters.append(param)
    }
    @post(nodeStack.length = @pre(nodeStack.length))
    
    ============================================================================
    Processes a PARAMETER_PROTOTYPE_LIST parse node.
    ============================================================================
    @pre(pl.type = ParseNodeType.PARAMETER_PROTOTYPE_LIST)
    method convertParameterPrototypeList(pl:ParseNode) {
        var cm := currentMethod
        assert cm != null
        var params := cm.parameters
        for i in 1 ... pl.length - 2 by 2 {
            convertParameterPrototype(pl[i])
            if i < pl.length - 2 & 
                    params[params.length - 1].isVarArg
                error("only the last parameter of a method may accept a " +
                        "variable number of arguments", pl[i])
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))
    
    @class
    method replaceSelf(n:Node, newSelf:Variable) {
        if n-?>(VariableReference) & n->(VariableReference).variable.name =
                Parameter.SELF_NAME
            n->(VariableReference).variable := newSelf
        for child in n.children
            replaceSelf(child, newSelf)
    }

    @class
    @pre(m.methodType = MethodNodeType.CONSTRUCTOR)
    function callsOtherSelfConstructor(m:MethodNode):Bit {
        var block := m.block
        if block.length > 0 {
            if block[0]-?>(ValueStatement) {
                var value := block[0]->(ValueStatement).value
                if value-?>(MethodCall) {
                    var call := value->(MethodCall)
                    if call.methodNode.methodType = MethodNodeType.CONSTRUCTOR
                        return call.parameters[0].type.classNode = m.parent
                }
            }
        }
        return false
    }
    
    @class
    @pre(m.methodType = MethodNodeType.CONSTRUCTOR)
    function callsSuperConstructor(m:MethodNode):Bit {
        var block := m.block
        if block.length > 0 {
            if block[0]-?>(ValueStatement) {
                var value := block[0]->(ValueStatement).value
                if value-?>(MethodCall) {
                    var call := value->(MethodCall)
                    if call.methodNode.methodType = MethodNodeType.CONSTRUCTOR
                        return call.parameters[0].type.classNode = 
                                m.parent->(ClassNode).superclass
                }
            }
        }
        return false
    }
    
    ============================================================================
    Adds implicit code to the constructor, such as an implicit call to the super
    constructor. (Instance initializers are now handled by the CodeGenerator,
    based on field.initialValue).
    ============================================================================
    @pre(m.methodType = MethodNodeType.CONSTRUCTOR)
    method fixConstructor(m:MethodNode) {
        def cc := currentClass
        assert cc != null
        if !cc.annotations.isUnspecified & cc.name != ClassNode.OBJECT_NAME & 
                !callsOtherSelfConstructor(m) & !callsSuperConstructor(m) {
            var block := m.block
            var originalLength := block.length
            var sc := cc.superclass
            assert sc != null
            var found := false
            for child in sc.children {
                if child-?>(MethodNode) {
                    var other := child->(MethodNode)
                    if other.methodType = MethodNodeType.CONSTRUCTOR &
                            other.parameters.length = 1 {
                        found := true
                        break
                    }
                }
            }
            if !found
                throw new CompilerException("no explicit call to superclass " +
                        "constructor, and superclass does not have a " +
                        "no-argument constructor", m.position)

            -- this compiles the statement to the end of the block, we then
            -- need to shift it to the beginning
            new ASTGenerator().compileStatement(block, "super.constructor()", 
                    m.position)
            assert block.length = originalLength + 1
            var call := block[block.length - 1]
            for i in block.length - 1 ... 1 by -1
                block[i] := block[i - 1]
            block[0] := call
        }
    }

    @private
    function getBaseType(var t:Type):Type {
        t := t.unwrapNullable
        if t-?>(GenericType)
            return t->(GenericType).base
        return t
    }

    ============================================================================
    Verify that a method has a legal signature. In the case of overloaded
    operators, there are many constraints (such as addition must be a function
    rather than a method) which could result in a method not being legal.
    ============================================================================
    @private
    method checkMethodSignature(m:MethodNode) {
        -- wrappers are allowed to have overloads applying to their primitive
        -- equivalents, so don't bother checking them
        if m.owner.type().isWrapper
            return
        switch m.name {
            case "+", "-", "*", "/", "//", "^", ">", "<", ">=", "<=", "%",
                    "&", "&&", "|", "||", "~", "~~", "<<", ">>": {
                var name:String
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    if m.parameters.length != 2 {
                        throw new CompilerException("expected \{name} " +
                                "to have exactly two parameters", m.position)
                    }
                    if m.parameters[0].type != m.owner.type() & 
                            m.parameters[1].type != m.owner.type() {
                        throw new CompilerException("expected \{name} to " +
                                "take \{m.owner} as at least one of " +
                                "its two parameters", m.position)
                    }
                }
                else {
                    name := "operator '" + m.name + "'"
                    if m.parameters.length != 2 {
                        throw new CompilerException("expected \{name} to " + 
                                "have exactly one parameter", m.position)
                    }
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    throw new CompilerException("expected \{name} to be a " +
                            "function", m.position)
                }
            }
            case "=": {
                if m.annotations.isClass {
                    throw new CompilerException("operator '=' cannot be " +
                            "declared '@class'", m.position)
                }
                if m.parameters.length != 2 | 
                        m.parameters[1].type != ClassType.OBJECT() {
                    throw new CompilerException("operator '=' must take " +
                            "exactly one parameter of type 'panda.core.Object'",
                            m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    throw new CompilerException("expected operator '=' to " +
                            "be a function", m.position)
                }
            }
            case "[]": {
                var name:String
                var start:Int
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    start := 0
                }
                else {
                    name := "operator '\{m.name}'"
                    start := 1
                }
                if m.parameters.length - start != 1 {
                    throw new CompilerException("expected \{name} to have " +
                            "exactly one parameter", m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    throw new CompilerException("expected \{name} to be a " +
                            "function", m.position)
                }
            }
            case "[]:=": {
                var name:String
                var start:Int
                if m.annotations.isClass {
                    throw new CompilerException("indexed assignment is not " + 
                            "permitted on classes", m.position)
                }
                else {
                    name := "operator '\{m.name}'"
                    start := 1
                }
                if m.parameters.length - start != 2 {
                    throw new CompilerException("expected \{name} to have " +
                            "exactly two parameters", m.position)
                }
                if m.methodType = MethodNodeType.FUNCTION {
                    throw new CompilerException("\{name} may not be a " +
                            "function", m.position)
                }
                if m.returnType != VoidType.VOID {
                    throw new CompilerException("\{name} may not return a " +
                            "value", m.position)
                }
            }
            case "[..]", "[...]": {
                var name:String
                var start:Int
                if m.annotations.isClass {
                    name := "@class operator '\{m.name}'"
                    start := 0
                }
                else {
                    name := "operator '\{m.name}'"
                    start := 1
                }
                if m.parameters.length - start > 3 {
                    throw new CompilerException("expected \{name} to have " +
                            "zero to three parameters", m.position)
                }
                if m.parameters.length - start = 3 & 
                        m.parameters[start + 2].type.isNullable {
                    throw new CompilerException("expected parameter " + 
                            "'\{m.parameters[start + 2].name}' of \{name} " + 
                            "to be non-nullable", m.position)
                }
                if m.methodType != MethodNodeType.FUNCTION {
                    throw new CompilerException("expected \{name} to be a " + 
                            "function", m.position)
                }
            }
            case "[..]:=", "[...]:=": {
                var name:String
                var start:Int
                if m.annotations.isClass {
                    throw new CompilerException("slice assignment is not " + 
                            "permitted on classes", m.position)
                }
                else {
                    name := "operator '\{m.name}'"
                    start := 1
                }
                if m.parameters.length - start < 1 | 
                        m.parameters.length - start > 4 {
                    throw new CompilerException("expected \{name}" +
                            " to have one to four parameters", m.position)
                }
                if m.parameters.length - start = 4 & 
                        m.parameters[start + 2].type.isNullable {
                    throw new CompilerException("expected parameter " + 
                            "'\{m.parameters[start + 2].name}' of \{name} " +
                            "to be non-nullable", m.position)
                }
                if m.methodType = MethodNodeType.FUNCTION {
                    throw new CompilerException("\{name} may not be a function",
                            m.position)
                }
                if m.returnType != VoidType.VOID {
                    throw new CompilerException("\{name} may not return a " +
                            "value", m.position)
                }
            }
            case "->>": {
                if m.annotations.isClass {
                    constant name := "@class operator '->>'"
                    if m.parameters.length != 1 {
                        throw new CompilerException("expected \{name} to " +
                                "take a single parameter", m.position)
                    }
                    if m.returnType != m.owner.type() & 
                            getBaseType(m.returnType) != m.owner.type() {
                        throw new CompilerException("expected \{name} to " +
                                "return '\{m.owner.type().displayName}'", 
                                m.position)
                    }
                    if m.parameters[0].type = m.owner.type() {
                        throw new CompilerException("parameter type and " + 
                                "return types of \{name} must be different", 
                                m.position)
                    }
                }
                else {
                    constant name := "operator '->>'"
                    if m.parameters.length != 1 {
                        throw new CompilerException("expected \{name} to take" +
                                " no parameters", m.position)
                    }
                }
                if m.methodType = MethodNodeType.METHOD & 
                        !m.annotations.isSelf {
                    throw new CompilerException("convert methods must " + 
                            "have the '@self' annotation", m.position)
                }
            }
            case "main": {
                if m.returnType != VoidType.VOID {
                    throw new CompilerException("method 'main' may not " +
                            "return a value", m.position)
                }
                if !m.annotations.isClass {
                    throw new CompilerException("method 'main' must be " + 
                            "declared '@class'", m.position)
                }
                if m.parameters.length > 1 | (m.parameters.length = 1 &
                        m.parameters[0].type != PrimitiveArrayType.ARRAY_STRING()) {
                    throw new CompilerException("method 'main' must accept " +
                            "either no parameters or one parameter of type " +
                            "'\{class(PrimitiveArray<String>).name}'", m.position)
                }
            }
            default: {
                if m.name.endsWith(":=") {
                    var name:String
                    var start:Int
                    if m.annotations.isClass {
                        name := "@class operator '\{m.name}'"
                        start := 0
                    }
                    else {
                        name := "operator '\{m.name}'"
                        start := 1
                    }
                    if m.parameters.length - start != 1 {
                        throw new CompilerException("expected \{name} to " +
                                "have exactly one parameter", m.position)
                    }
                    if m.methodType = MethodNodeType.FUNCTION {
                        throw new CompilerException("\{name} may not be a " +
                                "function", m.position)
                    }
                    if m.returnType != VoidType.VOID {
                        throw new CompilerException("\{name} may not return " +
                                "a value", m.position)
                    }
                    if !m.annotations.isSelf {
                        throw new CompilerException("\{name} must be " +
                                "declared '@self'", m.position)
                    }
                }
            }
        }
    }

    @private
    method checkMethodAnnotations(m:MethodNode) {
        if m.annotations.isFinal & m.annotations.isClass {
            PandaCompiler.reportError("@class methods are not " +
                    "inherited, they may not be marked @final", 
                    m.position)
        }
        def isInterface := m.owner.isInterface
        for a in m.annotations.all {
            switch a {
                case AnnotationType.OVERFLOW, AnnotationType.PRE, 
                        AnnotationType.POST, AnnotationType.SELF, 
                        AnnotationType.SYNTHETIC, AnnotationType.UNSPECIFIED,
                        AnnotationType.GENERIC_METHOD: { }
                case AnnotationType.PRIVATE, AnnotationType.PROTECTED: {
                    if isInterface {
                        PandaCompiler.reportError(
                                "interface methods must be public", m.position)
                    }
                }
                case AnnotationType.ABSTRACT, AnnotationType.CLASS,
                        AnnotationType.EXTERNAL, AnnotationType.OVERRIDE, 
                        AnnotationType.FINAL: {
                    if m.methodType = MethodNodeType.CONSTRUCTOR {
                        PandaCompiler.reportError(
                                "annotation '\{new Annotations([a])}' is not " +
                                "supported on constructors", m.position)
                    }
                    else if isInterface & (a = AnnotationType.EXTERNAL |
                            a = AnnotationType.FINAL) {
                        PandaCompiler.reportError(
                                "annotation '\{new Annotations([a])}' is not " +
                                "supported on interface methods", m.position)
                    }
                }
                case AnnotationType.LIMITED: {
                    var start:Int
                    if m.annotations.isClass
                        start := 0
                    else
                        start := 1
                    var found := false
                    for i in start ... m.parameters.length - 1 {
                        if !m.parameters[i].type.isImmutable {
                            found := true
                            break
                        }
                    }
                    if !found {
                        PandaCompiler.reportError(
                                "'@limited' may not be used on methods " +
                                "which do not take any mutable parameters; " +
                                "did you mean to use '@self' instead?", 
                                m.position)
                    }

                }
                case AnnotationType.SAFERETURN: {
                    if m.returnType = VoidType.VOID {
                        PandaCompiler.reportError(
                                "@safeReturn may not be used on methods " +
                                "which do not return anything", m.position)
                    }
                }
                case AnnotationType.UNSAFEFUNCTION: {
                    if m.methodType != MethodNodeType.FUNCTION {
                        PandaCompiler.reportError(
                                "@unsafeFunction may not be used on \{m}", 
                                m.position)
                    }
                }
                case AnnotationType.WRAPPER_METHOD: {
                    if !m.owner.type().isWrapper {
                        PandaCompiler.reportError(
                                "@$wrapperMethod may not be used outside of " +
                                "wrappers", m.position)
                    }
                }
                default: {
                    PandaCompiler.reportError(
                            "annotation '\{new Annotations([a])}' is not " +
                            "supported on methods", m.position)
                }
            }
        }
    }

    ============================================================================
    Processes a METHOD_DECLARATION parse node.
    ============================================================================
    @pre(m.type = ParseNodeType.METHOD_DECLARATION)
    method convertMethodDeclaration(var doccomment:String?, 
            annotations:Annotations, m:ParseNode) {
        var cl := currentClass
        assert cl != null : "currentClass is null"
        var name:String
        var paramIndex:Int
        if m[1].type = ParseNodeType.METHOD_NAME {
            name := m[1]->>(String).replace(" ", "")
            paramIndex := 2
        }
        else {
            name := "new"
            paramIndex := 1
        }
        if m[paramIndex].type = ParseNodeType.GENERIC_PARAMETERS_DECLARATION
            paramIndex += 1
        if linkageOnly {
            var methodType:MethodNodeType
            switch m[0]->(TokenNode).token.type {
                case TokenType.METHOD: 
                    methodType := MethodNodeType.METHOD
                case TokenType.FUNCTION: 
                    methodType := MethodNodeType.FUNCTION
                case TokenType.CONSTRUCTOR: {
                    methodType := MethodNodeType.CONSTRUCTOR
                    -- FIXME HACK constructors are almost invariably @self, and
                    -- will be auto-detected as such in the future. For right
                    -- now, just mark everything @self until we have such
                    -- detection in place.
                    if !annotations.isSelf
                        annotations.isSelf := true
                }
                default: throw new CompilerException(
                        "unsupported methodType: " + m[0][0])
            }
            var cm := new MethodNode(m.position, name, methodType)
            if methodType != MethodNodeType.CONSTRUCTOR
                captureTree(cm, m[1], null)
            open(cm)
            cm.annotations := annotations

            if !cm.annotations.isClass {
                var type:Type := cl.type()
                if annotations.isWrapperMethod
                    type := type->(WrapperType).primitiveVersion
                var s := new Parameter(m.position, Parameter.SELF_NAME, 
                        type)
                s.annotations.isFinal := true
                cm.parameters.append(s)
            }
            convertParameterPrototypeList(m[paramIndex])
            var typeIndex := paramIndex + 1
            var blockIndex := typeIndex + 1
            if m.length > typeIndex & 
                    m[typeIndex].type = ParseNodeType.TYPE_DECLARATION {
                if methodType = MethodNodeType.CONSTRUCTOR
                    error("constructors may not have a return type", m)
                def typeNode := m[3][1]
                cm.returnType := convertType(typeNode)
                captureTree(cm, typeNode, "type")
                blockIndex += 1
            }
            else {
                if methodType = MethodNodeType.FUNCTION
                    error("functions must have a return type", m)
                cm.returnType := VoidType.VOID
            }
            if doccomment = null & name.endsWith(":=") & !name.contains("[") {
                def propertyName := name[..name.length - 2]
                def parameterName := cm.parameters[
                        cm.parameters.length - 1].name
                doccomment := "Sets the value of the " + propertyName + 
                        " property. @param \{parameterName} new value for " + 
                        "the property"
            }
            cm.doccomment := doccomment
            for child in m.children {
                if child.type = ParseNodeType.BLOCK
                    cm.parseNode := child
            }
            cl.symbolTable.putMethod(cm)
            assert cm.parent = cl : "wrong cm.parent"
        }
        else {
            var cm:MethodNode? := null
            for child in cl.children {
                if child.position = m.position {
                    cm := child->(MethodNode)
                    if cl.annotations.isUnspecified & !cm.annotations.isClass
                        return
                    nodeStack.push(cm)
                    break
                }
            }
            assert cm != null: "\{m}:\{m.position} not found in \{cl}"
            checkMethodSignature(cm)
            for child in m.children {
                if child.type = ParseNodeType.BLOCK {
                    assert cm.length = 0 : "expected 0 children"
                    convertBlock(child)
                    assert cm.length = 1 : "expected 1 child, found \{cm.children}"
                }
                else if child.type = ParseNodeType.POSTCONDITION {
                    var override := cm.annotations.isOverride
                    var postType := child[0]->(TokenNode).token.type
                    if override & postType = TokenType.POST {
                        reportError("@post may not be used in override " +
                                "methods; did you mean to use @postAnd?", 
                                child.position)
                    }
                    else if !override & postType = TokenType.POST_AND {
                        reportError("@postAnd may only be used in override " + 
                                "methods; did you mean to use @post?", 
                                child.position)
                    }
                    cm.annotations.post.append(child[2])
                }
            }
            if cm.annotations.isAbstract & cm.owner.isInterface {
                PandaCompiler.reportError(
                        "interface methods are implicitly abstract, " +
                        "'@abstract' annotation is redundant", 
                        cm.position)
            }
            def effectivelyAbstract := cm.annotations.isAbstract |
                    cm.annotations.isExternal
            if effectivelyAbstract & cm.length = 1 {
                reportError("abstract \{cm} may not have a method body", 
                        cm.position)
            }
            else if !effectivelyAbstract & cm.length = 0 {
                if cm.owner.isInterface
                    cm.annotations.isAbstract := true
                else {
                    reportError("non-abstract \{cm} must have a method body", 
                            cm.position)
                }
            }
            if cm.isDeclaredVirtual {
                var isOverride := cm.annotations.isOverride
                var overridden := cm.findOverriddenMethod()
                if !isOverride & overridden != null {
                    reportError("\{cm} overrides a superclass method, but is " +
                            "not declared @override", cm.position)
                }
                if isOverride & overridden = null {
                    reportError("\{cm} is declared @override, but does not " +
                            "override a superclass method", cm.position)
                }
                if isOverride & overridden != null {
                    if overridden.methodType = MethodNodeType.FUNCTION &
                            cm.methodType != MethodNodeType.FUNCTION {
                        reportError("a method may not override a function", 
                                cm.position)
                    }
                    if overridden.annotations.isFinal {
                        reportError("corresponding method in '" + 
                                overridden.owner.name + 
                                "' is static and may not be overridden", 
                                cm.position)
                    }
                    if overridden.annotations.isSelf & !cm.annotations.isSelf {
                        reportError("corresponding method in '" + 
                                overridden.owner.name + 
                                "' has '@self' annotation, may not be " +
                                "overridden by a method lacking '@self' " +
                                "annotation", 
                                cm.position)
                    }
                    if overridden.annotations.isLimited & 
                            !cm.annotations.isSelf &
                            !cm.annotations.isLimited {
                        reportError("corresponding method in '" + 
                                overridden.owner.name + 
                                "' has '@limited' annotation, may not be " +
                                "overridden by a method lacking '@limited' " +
                                "or '@self' annotation", 
                                cm.position)
                    }
                    if overridden.annotations.isSafeReturn & 
                            !cm.annotations.isSafeReturn {
                        reportError("corresponding method in '" + 
                                overridden.owner.name + 
                                "' has '@safeReturn' annotation, may not be " +
                                "overridden by a method lacking " +
                                "'@safeReturn' annotation", 
                                cm.position)
                    }
                    var r1 := cm.returnType
                    var r2 := overridden.returnType
                    if !cm.returnType.canImplicitCastTo(
                            overridden.returnType) | 
                            (r1.isPrimitive & r1 != r2) |
                            (r1.isNullable & !r2.isNullable) {
                        reportError("incompatible return type: a method " +
                                "returning '\{cm.returnType.displayName}'" + 
                                " may not override a method returning " + 
                                "'\{overridden.returnType.displayName}'", 
                                cm.position)
                    }              
                }
            }
            checkMethodAnnotations(cm)
        }
        close(class(MethodNode))
    }
    @post(nodeStack.length = @pre(nodeStack.length))
    
    ============================================================================
    Processes a FIELD_DECLARATION parse node.
    ============================================================================
    @pre(f.type = ParseNodeType.FIELD_DECLARATION)
    method convertFieldDeclaration(doccomment:String?,
             annotations:Annotations, f:ParseNode) {
        var cl := currentClass
        assert cl != null
        def fields := new PrimitiveArray<FieldNode?>()
        if linkageOnly {
            def fieldType := f[0]->(TokenNode).token.type
            var isFinal:Bit
            if fieldType = TokenType.VAR
                isFinal := false
            else if fieldType = TokenType.DEF
                isFinal := true
            else {
                assert fieldType = TokenType.PROPERTY
                isFinal := false
                annotations.isProperty := true
            }
            if isFinal
                annotations.isFinal := true
            var i := 1
            while i < f.length & 
                    (f[i]->(TokenNode).token.type = TokenType.IDENTIFIER | 
                        f[i]->(TokenNode).token.type = TokenType.UNDERSCORE) {
                def position := f[i].position
                var name:String?
                if f[i]->(TokenNode).token.type = TokenType.IDENTIFIER {
                    name := f[i]->(TokenNode).token.text
                    if annotations.isProperty
                        name := FieldNode.PROPERTY_PREFIX + name
                }
                else
                    name := null
                i += 1
                if name != null {
                    def type:Type
                    def typeNode:ParseNode?
                    if f.length > i & f[i].type = ParseNodeType.TYPE_DECLARATION {
                        typeNode := f[i][1]
                        type := convertType(typeNode)
                        i += 1
                    }
                    else {
                        type := Type.UNRESOLVED
                        typeNode := null
                    }
                    def field := new FieldNode(position, name, type)
                    captureNode(field)
                    if typeNode != null
                        captureTree(field, typeNode, "type")
                    fields.append(field)
                    field.annotations := annotations
                    field.doccomment := doccomment
                    cl.add(field)
                    cl.symbolTable.putVariable(field)
                    
                    var indexName := name + INDEX_SUFFIX
                    if field.annotations.isThread {
                        var fieldIndex := new FieldNode(f.position, indexName,
                                IntType.INT32)
                        fieldIndex.annotations.isClass := true
                        fieldIndex.annotations.isFinal := true
                        fieldIndex.annotations.isSynthetic := true
                        cl.add(fieldIndex)
                        cl.symbolTable.putVariable(fieldIndex)
                    }
                }
                else
                    fields.append(null)
                if i < f.length & f[i]->(TokenNode).token.type = TokenType.COMMA
                    i += 1
            }
        }
        else {
            var i := 1
            while i < f.length & 
                    (f[i]->(TokenNode).token.type = TokenType.IDENTIFIER |
                        f[i]->(TokenNode).token.type = TokenType.UNDERSCORE) {
                if f[i]->(TokenNode).token.type = TokenType.UNDERSCORE {
                    fields.append(null)
                    i += 1
                }
                else {
                    var field:FieldNode? := null
                    for child in cl.children {
                        if child.position = f[i].position {
                            field := child->(FieldNode)
                            break
                        }
                    }
                    assert field != null
                    fields.append(field)
                    i += 1
                    if i < f.length & f[i].type = ParseNodeType.TYPE_DECLARATION
                        i += 1
                }
                if i < f.length & f[i]->(TokenNode).token.type = TokenType.COMMA
                    i += 1
            }
            for a in annotations.all {
                switch a {
                    case AnnotationType.PRIVATE, AnnotationType.PROTECTED,
                            AnnotationType.READONLY: { }
                    case AnnotationType.FINAL: {
                        def token := f[0]->(TokenNode).token
                        if token.type != TokenType.VAR {
                            PandaCompiler.reportError(
                                    "annotation '@final' is not supported " +
                                    "on '\{token}'", f.position)
                        }
                    }
                    case AnnotationType.THREAD: {
                        if annotations.isProperty {
                            PandaCompiler.reportError(
                                    "annotation '@thread' is not supported " +
                                    "on 'property'", f.position)
                        }
                    }
                    default: {
                        PandaCompiler.reportError(
                                "annotation '\{new Annotations([a])}' is not " +
                                "supported on fields", f.position)
                    }
                }
            }
            if cl.type().isImmutable & 
                    !annotations.isFinal &
                    !annotations.isThread
                annotations.isFinal := true
        }
        assert fields.length > 0
        for i, field in fields {
            if field = null
                continue
            if f[f.length - 2].type = ParseNodeType.TOKEN & 
                    f[f.length - 2]->(TokenNode).token.type = TokenType.ASSIGNMENT {
                if fields.length > 1
                    pendingFieldValues[field] := new TupleReference(f[f.length - 1], i)
                else
                    pendingFieldValues[field] := f[f.length - 1]
                field.pendingValue := pendingFieldValues[field]
            }
            if field.annotations.isThread &
                    cl.state = ClassNodeState.DEFINED {
                var indexName := field.name + INDEX_SUFFIX 
                var fieldIndex := cl.symbolTable.getVariable(indexName)
                if fieldIndex = null {
                    throw new InternalCompilerException(
                            "field '\{indexName}' not found in \{cl}",
                            f.position)
                }
                def panda := ClassType.PANDA().classNode
                fieldIndex->(FieldNode).initialValue := call(fieldIndex.position, 
                        new ClassLiteral(panda.type()), "allocThreadLocal", 
                        new PrimitiveArray<Value>())
            }
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))
    
    ============================================================================
    Processes an ANNOTATIONS parse node.
    ============================================================================
    @pre(annotations.type = ParseNodeType.ANNOTATIONS)
    method convertAnnotations(annotations:ParseNode):Annotations {
        var result := new Annotations(annotations.position)
        var foundPre := false
        var foundPreOr := false
        for ann in annotations.children {
            switch ann.type {
                case ParseNodeType.TOKEN: {
                    switch ann->(TokenNode).token.type {
                        case TokenType.PROTECTED:  result.isProtected  := true
                        case TokenType.PRIVATE:    result.isPrivate    := true
                        case TokenType.ABSTRACT:   result.isAbstract   := true
                        case TokenType.ATCLASS:    result.isClass      := true
                        case TokenType.THREAD:     result.isThread     := true
                        case TokenType.EXTERNAL:   result.isExternal   := true
                        case TokenType.FINAL :     result.isFinal      := true
                        case TokenType.OVERRIDE:   result.isOverride   := true
                        case TokenType.READONLY:   result.isReadOnly   := true
                        case TokenType.LIMITED:    result.isLimited    := true
                        case TokenType.ATSELF:     result.isSelf       := true
                        case TokenType.SAFERETURN: result.isSafeReturn := true
                        case TokenType.WRAPPER_METHOD:   
                                result.isWrapperMethod := true
                        case TokenType.UNSAFEFUNCTION: 
                                result.isUnsafeFunction := true
                        default: error("unsupported annotation: \{ann}", ann)
                    }
                }
                case ParseNodeType.MATH_ANNOTATION: {
                    result.isOverflow := true
                }
                case ParseNodeType.PRECONDITION: {
                    switch ann[0]->(TokenNode).token.type {
                        case TokenType.PRE: foundPre := true
                        case TokenType.PRE_OR: foundPreOr := true
                        default: unreachable
                    }
                    result.pre.append(ann[2])
                }
                default: unreachable
            }
        }
        if result.isPrivate & result.isProtected {
            PandaCompiler.reportError("@private may not be used " +
                    "together with @protected", annotations.position)
        }
        if result.isSelf & result.isClass {
            PandaCompiler.reportError("@self may not be used " +
                    "together with @class", annotations.position)
        }
        if result.isOverride & result.isClass {
            PandaCompiler.reportError("@override may not be used " +
                    "together with @class", annotations.position)
        }
        if result.isThread & result.isClass {
            PandaCompiler.reportError("@thread may not be used " +
                    "together with @class", annotations.position)
        }
        if result.isAbstract & result.isFinal {
            PandaCompiler.reportError("@abstract may not be used " +
                    "together with @final", annotations.position)
        }
        if result.isAbstract & result.isExternal {
            PandaCompiler.reportError("@abstract may not be used " +
                    "together with @external", annotations.position)
        }
        if result.isLimited & result.isSelf {
            PandaCompiler.reportError("@limited may not be used " +
                    "together with @self", annotations.position)
        }
        var override := result.isOverride
        if override & foundPre {
            PandaCompiler.reportError("@pre may not be used " +
                    "together with @override; did you mean to use @preOr?", 
                    annotations.position)
        }
        else if !override & foundPreOr {
            PandaCompiler.reportError("@preOr must be used " +
                    "together with @override", annotations.position)
        }
        return result
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Processes a CLASS_MEMBER_DECLARATION parse node.
    ============================================================================
    @pre(cm.type = ParseNodeType.CLASS_MEMBER_DECLARATION)
    method convertClassMember(cm:ParseNode) {
        def entry := currentNode
        try {
            def cl := currentClass
            assert cl != null
            if cm[0].type = ParseNodeType.INVARIANT {
                cl.annotations.invariants.append(cm[0][2])
                return
            }
            var i := 0
            var doccomment:String? := null
            if cm[i].type = ParseNodeType.TOKEN {
                assert cm[i]->(TokenNode).token.type = TokenType.DOCCOMMENT
                doccomment := getDocComment(cm[i]->(TokenNode).token)
                i += 1
            }
            assert cm[i].type = ParseNodeType.ANNOTATIONS
            var annotations:Annotations
            annotations := convertAnnotations(cm[i])
            i += 1
            switch cm[i].type {
                case ParseNodeType.METHOD_DECLARATION:
                    convertMethodDeclaration(doccomment, annotations, cm[i])
                case ParseNodeType.FIELD_DECLARATION: {
                    -- if you have come here to try to enable interface 
                    -- thread-local fields for the THIRD TIME, remember that it
                    -- won't work for Java output without jumping through some
                    -- hoops
                    if cl.isInterface {
                        PandaCompiler.reportError("interfaces may " +
                                "not contain fields", cm[i].position)
                    }
                    convertFieldDeclaration(doccomment, annotations, cm[i])
                }
                case ParseNodeType.CONSTANT_FIELD_DECLARATION: {
                    convertConstantFieldDeclaration(doccomment, annotations, 
                            cm[i])
                }
                default: unreachable
            }
        }
        catch e:CompilerException {
            PandaCompiler.reportError(e)
            while currentNode != entry
                nodeStack.pop()
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))
    
    @class
    function getThreadLocalInitializerName(f:FieldNode):String {
        return "$init\{f.name}"
    }
    
    method createThreadLocalInitializer(f:FieldNode) {
        var cl := f.parent->(ClassNode)
        var m := new MethodNode(f.position, getThreadLocalInitializerName(f), 
                MethodNodeType.METHOD)
        m.annotations.isClass := true
        m.annotations.isSynthetic := true
        m.returnType := f.type
        var b := new Block(cl.symbolTable)
        var value := f.initialValue
        assert value != null
        value.removeFromParent()
        b.add(new Return(value.position, value))
        m.add(b)
        cl.add(m)
        cl.symbolTable.putMethod(m)
    }
    
    method createClassInit(cl:ClassNode) {
        var init:MethodNode? := null
        for child in cl.children {
            if child-?>(FieldNode) {
                var f := child->(FieldNode)
                if f.annotations.isClass | 
                        f.annotations.isThread {
                    -- for isThread, we just ensure that the class init method
                    -- exists (it doesn't have to contain anything). This is so
                    -- code generators can easily do required thread local 
                    -- setup.
                    if init = null {
                        init := new MethodNode(cl.position, 
                                MethodNode.CLASS_INIT_NAME,
                                MethodNodeType.METHOD)
--                        init.annotations.isPrivate := true
                        init.annotations.isClass := true
                        init.annotations.isSynthetic := true
                        init.add(new Block(cl.symbolTable))
                        nodeStack.push(init)
                        nodeStack.push(init.block)
                        cl.add(init)
                        cl.symbolTable.putMethod(init)
                        
                        var inited := new FieldNode(FieldNode.CLASS_INITED_NAME,
                                BitType.BIT)
                        inited.annotations.isClass := true
                        inited.annotations.isSynthetic := true
--                        inited.annotations.isPrivate := true
                        cl.add(inited)
                        cl.symbolTable.putVariable(inited)
                        
                        var ast := new ASTGenerator()
                        ast.compileStatement(init.block, String.format(
                                "if {0} return else {0} := true", 
                                FieldNode.CLASS_INITED_NAME), cl.position)
                    }
                    if f.annotations.isClass {
                        var value := f.initialValue
                        if value != null {
                            value.removeFromParent()
                            var context := new ClassLiteral(value.position, 
                                    getType(value.position, cl.name))
                            checkAssignment(f, context.position)
                            init.block.add(new FieldAssignment(f.position, 
                                    context, f, value))
                            -- FIXME temporary hack clone until I have an actual 
                            -- copy()
                            if value-?>(IntegerLiteral) {
                                f.initialValue := new IntegerLiteral(
                                        value->(IntegerLiteral).value, value.type)
                            }
                            else if value-?>(RealLiteral) {
                                f.initialValue := new RealLiteral(
                                        value->(RealLiteral).value, value.type)
                            }
                        }
                    }
                }
            }
        }
        if init != null {
            close(class(Block))
            close(class(MethodNode))
        }
    }

    @private
    method postprocessClass(cl:ClassNode) {
        if !cl.annotations.isUnspecified {
            -- add default constructor if needed
            var hasConstructor := false
            for child in cl.children {
                if child-?>(MethodNode) {
                    var m := child->(MethodNode)
                    if m.methodType = MethodNodeType.CONSTRUCTOR {
                        if !linkageOnly
                            fixConstructor(m)
                        hasConstructor := true
                    }
                }
            }
            if !hasConstructor & !cl.isInterface {
                new ASTGenerator().compileMethod(cl, 
                        "constructor() { }", cl.position)
                cl[cl.length - 1]->(MethodNode).doccomment := 
                        "Creates a new \{cl.simpleName}."
            }
            if !linkageOnly {
                var isAbstract := cl.annotations.isAbstract | 
                        cl.isInterface
                for m in cl.virtualMethods {
                    if m.annotations.isAbstract & !isAbstract {
                        PandaCompiler.reportError(new CompilerException(
                                "non-abstract class \{cl.name} does not " +
                                "implement abstract \{m}",
                                cl.position))
                    }
                }
                for intf in cl.allInterfaces() {
                    if !intf.isInterface {
                        PandaCompiler.reportError(new CompilerException(
                                "\{intf.name} is not an interface", cl.position))
                    }
                    for m in cl.interfaceMethods(intf) {
                        if m.annotations.isAbstract &
                                !(cl.annotations.isAbstract | cl.isInterface) {
                            error("non-abstract class \{cl.name} " + 
                                    "does not implement interface \{m}",
                                    cl.position)
                        }
                    }
                }
            }
        }
        if cl.state = ClassNodeState.DEFINED
            createClassInit(cl)
    }
    
    ============================================================================
    Adds the `uses` directives that we have seen in this compilation unit to the
    specified class' symbol table.
    ============================================================================
    @private
    method processUses(cl:ClassNode) {
        cl.symbolTable.inPackage := currentPackage
        for p in packageUses
            cl.symbolTable.usePackage(p)
        for (key, value) in classUses.entries
            cl.symbolTable.useClass(value->(String), key->(String))
    }

    @private
    @pre(p.type = ParseNodeType.GENERIC_PARAMETERS_DECLARATION)
    method convertGenericParameterTypes(p:ParseNode):PrimitiveArray<GenericParameterType> {
        var cc := currentClass
        assert cc != null
        var result := new PrimitiveArray<GenericParameterType>()
        assert p[0]->(TokenNode).token.type = TokenType.LT
        var i := 1
        while i < p.length - 1 {
            assert p[i]->(TokenNode).token.type = TokenType.IDENTIFIER
            var position := p[i].position
            var name := p[i]->>(String)
            var type:Type
            i += 1
            if p[i].type = ParseNodeType.TYPE_DECLARATION {
                type := convertType(p[i][1])
                i += 1
            }
            else {
                type := SymbolTable.master.getType(Position.INTERNAL,
                        class(Object).name + "?")
            }
            def g := new GenericParameterType(cc.type(), "\{cc.name}.\{name}", 
                    type)
            SymbolTable.putType(g)
            cc.symbolTable.useClass(g.name, name)
            result.append(g)
            -- skip comma
            i += 1
        }
        return result
    }

    @pre(classMembers.type = ParseNodeType.CLASS_MEMBERS)
    method convertClassOrInterface(position:Position, doccomment:String?, 
            annotations:Annotations, var className:String, isInterface:Bit,
            genericParametersNode:ParseNode?,
            supertypeNode:ParseNode?, interfaceNodes:PrimitiveArray<ParseNode>, 
            classMembers:ParseNode):ClassNode {
        def currentPackage := self.currentPackage
        if currentPackage != null
            className := currentPackage + "." + className
        var classNode := SymbolTable.classMap[className]->(ClassNode?)
        if linkageOnly & classNode != null & 
                classNode.state = ClassNodeState.EXTERNALLY_DEFINED {
            -- FIXME need to detect (permitted) duplicate of plink & normal 
            -- class vs. not ok duplicate of normal class & normal class
            classNode.children.length := 0
            classNode.symbolTable := new SymbolTable(classNode, 
                    SymbolTable.master)
        }
        if classNode = null {
            classNode := new ClassNode(position, className,
                    currentCompilationUnit.symbolTable)
            if isInterface
                classNode.isInterface := true
            SymbolTable.putClass(classNode)
            def type := new ClassType(classNode.name)
            SymbolTable.putType(type)
            if currentPackage != null
                classNode.symbolTable.usePackage(currentPackage)
        }
        if classNode.parent != null
            classNode.removeFromParent()
        currentCompilationUnit.add(classNode)
        nodeStack.push(classNode)
        if linkageOnly {
            if genericParametersNode != null {
                classNode.genericParameterTypes := 
                        convertGenericParameterTypes(genericParametersNode)
            }
            else
                classNode.genericParameterTypes := []
            processUses(classNode)
            classNode.state := ClassNodeState.EXTERNALLY_DEFINED
        }
        else
            classNode.state := ClassNodeState.DEFINED
        for a in annotations.all {
            switch a {
                case AnnotationType.PRIVATE, AnnotationType.PROTECTED,
                        AnnotationType.ABSTRACT, AnnotationType.FINAL,
                        AnnotationType.UNSPECIFIED: { }
                default: {
                    PandaCompiler.reportError(
                            "annotation '\{new Annotations([a])}' is not " +
                            "supported on classes", classNode.position)
                }
            }
        }
        classNode.annotations := annotations
        classNode.doccomment := doccomment

        if supertypeNode != null {
            var supertype := convertType(supertypeNode)
            if supertype.isPrimitive
                supertype := supertype->(PrimitiveType).wrapperVersion()
            classNode.supertype := supertype->(ClassType)
        }
        else if className != ClassType.OBJECT().name
            classNode.supertype := ClassType.OBJECT()

        if linkageOnly {
            for intf in interfaceNodes {
                var intfType := convertType(intf)
                if intfType-?>(ClassType)
                    classNode.interfaces.append(intfType->(ClassType))
                else {
                    throw new CompilerException(intfType + 
                            " is not an interface type", intf.position)
                }
            }
        }

        for m in classMembers.children
            convertClassMember(m)

        var type := getType(classNode.position, classNode.name)
        postprocessClass(classNode)
        close(class(ClassNode))
        return classNode
    }

    ============================================================================
    Processes a CLASS_DECLARATION parse node.
    ============================================================================
    @pre(cl.type = ParseNodeType.CLASS_DECLARATION)
    method convertClass(doccomment:String?, annotations:Annotations,
            cl:ParseNode) {
        assert cl[0]->(TokenNode).token.type = TokenType.CLASS
        assert cl[1]->(TokenNode).token.type = TokenType.IDENTIFIER
        var className := cl[1]->>(String)
        var i := 2
        var genericParametersNode:ParseNode? := null
        if cl[i].type = ParseNodeType.GENERIC_PARAMETERS_DECLARATION {
            genericParametersNode := cl[i]
            i += 1
            annotations.isUnspecified := true
        }
        else
            genericParametersNode := null
        
        var supertypeNode:ParseNode? := null
        if cl[i].type = ParseNodeType.TOKEN & 
                cl[i]->(TokenNode).token.type = TokenType.COLON {
            supertypeNode := cl[i + 1]
            i += 2
        }

        var interfaces := new PrimitiveArray<ParseNode>()
        if cl[i].type = ParseNodeType.INTERFACES {
            var interfacesNode := cl[i]
            assert interfacesNode[0]->(TokenNode).token.type = TokenType.LPAREN
            for j in 1 ... interfacesNode.length - 2 by 2
                interfaces.append(interfacesNode[j])
            assert interfacesNode[interfacesNode.length - 
                    1]->(TokenNode).token.type = TokenType.RPAREN
            i += 1
        }
        assert cl[i]->(TokenNode).token.type = TokenType.LBRACE
        i += 1
        var classNode := convertClassOrInterface(cl.position, doccomment, 
                annotations, className, false, genericParametersNode,
                supertypeNode, interfaces, cl[i])
        captureNode(classNode, cl[1].position)

        if !linkageOnly {
            var superclass := classNode.superclass
            if superclass != null {
                if superclass.isInterface {
                    PandaCompiler.reportError(new CompilerException(
                            "class " + className + " may not extend " +
                            "interface " + superclass, cl.position))
                }
            }
        }
    }
    @post(nodeStack.length = @pre(nodeStack.length))

    ============================================================================
    Processes an INTERFACE_DECLARATION parse node.
    ============================================================================
    @pre(cl.type = ParseNodeType.INTERFACE_DECLARATION)
    method convertInterface(doccomment:String?, annotations:Annotations,
            cl:ParseNode) {
        assert cl[0]->(TokenNode).token.type = TokenType.INTERFACE
        assert cl[1]->(TokenNode).token.type = TokenType.IDENTIFIER
        var className := cl[1]->>(String)
        var i := 2
        var genericParametersNode:ParseNode?
        if cl[i].type = ParseNodeType.GENERIC_PARAMETERS_DECLARATION {
            genericParametersNode := cl[i]
            i += 1
            annotations.isUnspecified := true
        }
        else
            genericParametersNode := null
        
        var interfaces := new PrimitiveArray<ParseNode>()
        if cl[i]-?>(TokenNode) & cl[i]->(TokenNode).token.type = TokenType.COLON {
            i += 1
            interfaces.append(cl[i])
            i += 1
            while cl[i]-?>(TokenNode) & 
                    cl[i]->(TokenNode).token.type = TokenType.COMMA {
                i += 1
                interfaces.append(cl[i])
                i += 1
            }
        }
        assert cl[i]->(TokenNode).token.type = TokenType.LBRACE
        i += 1
        convertClassOrInterface(cl.position, doccomment, annotations, className, 
                true, genericParametersNode, null, interfaces, cl[i])
    }
    @post(nodeStack.length = @pre(nodeStack.length))    
    
    ============================================================================
    Processes an ENUM parse node.
    ============================================================================
    @private
    method convertEnum(doccomment:String?, annotations:Annotations, 
            e:ParseNode) {
        assert e[0]->(TokenNode).token.type = TokenType.ENUM
        assert e[1]->(TokenNode).token.type = TokenType.IDENTIFIER
        var className := e[1]->(TokenNode).token.text
        var currentPackage := self.currentPackage
        if currentPackage != null
            className := currentPackage + "." + className
        assert e[2]->(TokenNode).token.type = TokenType.LBRACE

        var classNode := SymbolTable.classMap[className]->(ClassNode?)
        if classNode = null {
            classNode := new ClassNode(e.position, className,
                currentCompilationUnit.symbolTable)
            def type := new ClassType(className)
            SymbolTable.putType(type)
            currentCompilationUnit.add(classNode)
            SymbolTable.putClass(classNode)
            classNode.annotations.isFinal := true
        }
        else if linkageOnly {
            while classNode.length > 0 {
                def node := classNode[classNode.length - 1]
                node.removeFromParent()
                if pendingFieldValues[node] != null
                    pendingFieldValues.remove(node)
            }
            classNode.symbolTable := new SymbolTable(classNode,
                    currentCompilationUnit.symbolTable)
        }
        classNode.doccomment := doccomment
        var nameMap:FieldNode? := null
        if linkageOnly {
            classNode.supertype := SymbolTable.master.getType(e.position,
                    class(Enumeration).name)->(ClassType)
            var name := new FieldNode("name", ClassType.STRING())
            name.annotations.isFinal := true
            name.doccomment := "The name of the enumeration constant."
            classNode.symbolTable.putVariable(name)
            classNode.add(name)
            var value := new FieldNode("value", IntType.INT32)
            value.annotations.isFinal := true
            value.doccomment := "The numeric value of the enumeration constant."
            classNode.symbolTable.putVariable(value)
            classNode.add(value)
            nameMap := new FieldNode("NAME_MAP", ClassType.IMMUTABLE_HASHMAP())
            nameMap.annotations.isClass := true
            nameMap.annotations.isPrivate := true
            nameMap.annotations.isFinal := true

            classNode.symbolTable.putVariable(nameMap)
            -- note we haven't added nameMap yet -- we'll do that after all of
            -- the constants have been added, so they are initialized first
        }
        var keyInitializer := new MutableString()
        var valueInitializer := new MutableString()

        -- HACK: method identity is determined by start position.
        -- we have multiple methods being synthesized at the same
        -- position, shift the positions by 1 to make them unique
        var position1 := e.position
        var ast := new ASTGenerator()
        ast.compileMethod(classNode, 
                "constructor(name:String, value:Int) {\n" +
                "    self.name := name\n" +
                "    self.value := value\n" +
                "}", new Annotations([AnnotationType.PRIVATE]), position1, 
                linkageOnly)
        var position2 := new Position(position1.compilationUnit,
                position1.line, position1.column + 1)
        ast.compileMethod(classNode, 
                "function ->>():Int32 {\n" +
                "    return value\n" +
                "}", position2, linkageOnly)
        if linkageOnly {
            classNode[classNode.length - 1]->(MethodNode).doccomment := 
                    "Returns the numeric value of this enumeration entry." +
                    "@returns the numeric value of this enumeration entry"
        }
        var position3 := new Position(position1.compilationUnit,
                position1.line, position1.column + 2)
        ast.compileMethod(classNode, 
                "function format(fmt:String):String {\n" +
                "    return name\n" +
                "}", new Annotations([AnnotationType.OVERRIDE]), position3, 
                linkageOnly)
        var position4 := new Position(position1.compilationUnit,
                position1.line, position1.column + 3)
        ast.compileMethod(classNode, 
                "function =(o:Object):Bit {\n" +
                "    return o-?>(" + classNode.name + ") & o->(" + 
                    classNode.name + ").value = value\n" +
                "}", new Annotations([AnnotationType.OVERRIDE]), position4, 
                linkageOnly)
        var position5 := new Position(position1.compilationUnit,
                position1.line, position1.column + 4)
        ast.compileMethod(classNode, 
                "function hash():Int {\n" +
                "    return value\n" +
                "}", new Annotations([AnnotationType.OVERRIDE]), position5, 
                linkageOnly)
        var count := 0

        var fromInt := ("function ->>(i:Int):" + className + 
                " {\nswitch i {")->>(MutableString)
        var defaultReturn := "error"
        var fieldComment:String? := null
        for i in 3 ... e.length - 2 {
            if e[i]->(TokenNode).token.type = TokenType.DOCCOMMENT {
                fieldComment := getDocComment(e[i]->(TokenNode).token)
                continue
            }
            if e[i]->(TokenNode).token.type != TokenType.IDENTIFIER
                continue
            var field := new FieldNode(e[i].position, e[i]->>(String), 
                    classNode.type())
            field.doccomment := fieldComment
            fieldComment := null
            field.annotations.isClass := true
            field.annotations.isFinal := true
            var key := e[i]->>(String)
            defaultReturn := key
            var enumValue := count
            var code := "new " + classNode.name + "('" + key + "', " + 
                    enumValue + ")"
            pendingFieldValues[field] := new PandaParser().parseExpression(
                code, e[i].position)
            if linkageOnly {
                classNode.add(field)
                classNode.symbolTable.putVariable(field)
            }
            
            fromInt.append("case " + enumValue + ": return " + key + "\n")
            if keyInitializer.length > 0
                keyInitializer.append(", ")
            keyInitializer.append('"' + key + '"')
            if valueInitializer.length > 0
                valueInitializer.append(", ")
            valueInitializer.append(key)
            count += 1
        }
        fromInt.append("default: { throw new PreconditionError(i + " +
                "' is not a valid \{className} value') } } }")
        var position6 := new Position(position1.compilationUnit,
                position1.line, position1.column + 5)
        ast.compileMethod(classNode, fromInt->>(String), 
                new Annotations([AnnotationType.CLASS]), position6, linkageOnly)
        if linkageOnly {
            classNode[classNode.length - 1]->(MethodNode).doccomment := 
                    "Converts a number to the corresponding enumeration entry.\n" +
                    "@param i the number to convert\n" +
                    "@returns the corresponding enumeration entry"
        }
        var position7 := new Position(position1.compilationUnit,
                position1.line, position1.column + 6)
        ast.compileMethod(classNode, "function ->>(name:String):" + 
                className + " {\n" +
                "    def result := NAME_MAP[name]->(" + className + "?)\n" +
                "    if result = null\n" +
                "        throw new PreconditionError(name + \n" +
                "               ' is not a valid \{className} value')\n" +
                "    return result" +
                "}", 
                new Annotations([AnnotationType.CLASS]), position7, linkageOnly)
        if linkageOnly {
            classNode[classNode.length - 1]->(MethodNode).doccomment := 
                    "Converts a string to the corresponding enumeration entry.\n" +
                    "@param name the string to convert\n" + 
                    "@returns the corresponding enumeration entry"

            assert nameMap != null
            pendingFieldValues[nameMap] := new PandaParser().parseExpression(
                    "new panda.collections.HashMap(new PrimitiveArray<Object?>(" + 
                    keyInitializer + "), new PrimitiveArray<Object?>(" + 
                    valueInitializer + "))->>(ImmutableHashMap)", 
                    e.position)
        }

        if nameMap != null
            classNode.add(nameMap)

        if linkageOnly
            classNode.state := ClassNodeState.EXTERNALLY_DEFINED
        else
            classNode.state := ClassNodeState.DEFINED
        nodeStack.push(classNode)
        postprocessClass(classNode)
        close(class(ClassNode))
    }
    
    @private
    method requireImplicitClass() {
        var implicitClass := self.implicitClass
        if implicitClass = null {
            implicitClass := new ClassNode("$ImplicitClass" + nextCount(), 
                    SymbolTable.master)
            self.implicitClass := implicitClass
            currentCompilationUnit.add(implicitClass)
            implicitClass.state := ClassNodeState.DEFINED
            implicitClass.annotations.isSynthetic := true
            assert currentNode-?>(CompilationUnit)
            SymbolTable.putClass(implicitClass)
            processUses(implicitClass)
            def type := new ClassType(implicitClass.name)
            SymbolTable.putType(type)
        }
        if currentClass = null
            nodeStack.push(implicitClass)
    }
    
    @private
    method requireImplicitMain() {
        requireImplicitClass()
        var implicitMain := self.implicitMain
        if implicitMain = null {
            implicitMain := new MethodNode(MethodNode.MAIN_NAME, 
                    MethodNodeType.METHOD)
            self.implicitMain := implicitMain
            implicitMain.annotations := new Annotations(
                    [AnnotationType.SYNTHETIC, AnnotationType.CLASS])
            var implicitClass := self.implicitClass
            assert implicitClass != null
            implicitMain.add(new Block(implicitClass.symbolTable))
            var cl := currentClass
            assert cl != null & cl = implicitClass
            cl.symbolTable.putMethod(implicitMain)
            cl.add(implicitMain)
        }
        if currentMethod = null {
            nodeStack.push(implicitMain)
            nodeStack.push(implicitMain.block)
        }
    }
    
    ============================================================================
    Processes a USES_STATEMENT parse node.
    ============================================================================
    @pre(u.type = ParseNodeType.USES_STATEMENT)
    method convertUsesStatement(u:ParseNode) {
        assert u[0]->(TokenNode).token.type = TokenType.USES
        var index := 1
        var className := new MutableString()
        var alias:String? := null
        var cc := currentClass
        while index < u.length & 
                u[index]->(TokenNode).token.type != TokenType.AS {
            className.append(u[index])
            index += 1
        }
        if index < u.length {
            assert u[index]->(TokenNode).token.type = TokenType.AS
            assert index = u.length - 2
            alias := u[u.length - 1]->>(String)
        }
        var starSuffix := ".*"
        if className.endsWith(starSuffix) {
            if alias != null
                error("packages may not have aliases", u)
            def packageName := className[0 .. className.length - 
                    starSuffix.length]
            packageUses.append(packageName)
            if cc != null
                cc.symbolTable.usePackage(packageName)
        }
        else {
            if alias = null {
                var dot := className.lastIndexOf(".")
                if dot != null
                    alias := className[dot + 1..]
                else
                    alias := className->>(String)
            }
            var im := classUses[alias]
            if im != null {
                throw new CompilerException("duplicate 'uses': " +
                        "\{im} was previously used as '\{alias}'", u.position)
            }
            classUses[alias] := className->>(String)
            if cc != null
                cc.symbolTable.useClass(className->>(String), alias)
        }
    }

    ============================================================================
    Processes an INSTANCE_DECLARATION parse node.
    ============================================================================
    @pre(id.type = ParseNodeType.INSTANCE_DECLARATION)
    method convertInstanceDeclaration(id:ParseNode) {
        assert id[0]->(TokenNode).token.type = TokenType.INSTANCE
        forceTypeResolution := true
        var t := convertType(id[1])
        forceTypeResolution := false
        t.classNode.state := ClassNodeState.EXTERNAL_INSTANCE
    }

    ============================================================================
    Processes a BODY_ENTRY parse node.
    ============================================================================
    @pre(be.type = ParseNodeType.BODY_ENTRY)
    method convertBodyEntry(be:ParseNode) {
        var entry := currentNode
        try {
            switch be[0].type {
                case ParseNodeType.SIMPLE_STATEMENT: {
                    if currentClass = null
                        requireImplicitClass()
                    if !linkageOnly {
                        if currentMethod = null {
                            requireImplicitMain()
                            convertSimpleStatement(be[0])
                        }
                        def cl := currentClass
                        if cl != null & cl.name.startsWith("$Implicit") {
                            while nodeStack.length > 1
                                nodeStack.pop()
                        }
                    }
                }
                case ParseNodeType.PACKAGE_DECLARATION: {
                    var result := new MutableString()
                    for i in 1 ... be[0].length - 1
                        result.append(be[0][i]->>(String))
                    currentPackage := result->>(String)
                }
                case ParseNodeType.USES_STATEMENT:
                    convertUsesStatement(be[0])
                case ParseNodeType.INSTANCE_DECLARATION:
                    convertInstanceDeclaration(be[0])
                default: {
                    var i := 0
                    var doccomment:String? := null
                    if be[i].type = ParseNodeType.TOKEN {
                        assert be[i]->(TokenNode).token.type = 
                                TokenType.DOCCOMMENT
                        doccomment := getDocComment(be[i]->(TokenNode).token)
                        i += 1
                    }
                    assert be[i].type = ParseNodeType.ANNOTATIONS
                    var annotations := convertAnnotations(be[i])
                    i += 1
                    switch be[i].type {
                        case ParseNodeType.CLASS_DECLARATION:
                            convertClass(doccomment, annotations, be[i])
                        case ParseNodeType.INTERFACE_DECLARATION:
                            convertInterface(doccomment, annotations, be[i])
                        case ParseNodeType.METHOD_DECLARATION: {
                            requireImplicitClass()
                            annotations.isClass := true
                            convertMethodDeclaration(doccomment, annotations, 
                                    be[i])
                        }
                        case ParseNodeType.ENUM:
                            convertEnum(doccomment, annotations, be[i])
                        default:
                            error("unsupported body entry", be.position)
                    }
                }
            }
        }
        catch e:CompilerException {
            PandaCompiler.reportError(e)
            while currentNode != entry
                nodeStack.pop()
        }
    }

    @pre(t.isPrimitiveArray)
    method makePrimitiveArrayImmutable(position:Position, t:Type):Type {
        var elementType := t->(PrimitiveArrayType).elementType
        if elementType.isPrimitiveArray
            elementType := makePrimitiveArrayImmutable(position, elementType)
        if !elementType.isImmutable {
            throw new CompilerException("constants must be immutable (found " +
                    "mutable type '" + elementType.displayName + "')", position)
        }
        return getType(position, class(ImmutablePrimitiveArray).name + "<" + 
                elementType.name + ">")
    }

    @private
    @pre(f.annotations.isProperty)
    method createGetter(f:FieldNode) {
        def rawName := f.name
        assert rawName.startsWith(FieldNode.PROPERTY_PREFIX)
        def name := rawName[FieldNode.PROPERTY_PREFIX.length..]
        def annotations := new Annotations([AnnotationType.SYNTHETIC])
        def match := f.owner.symbolTable.getMethod(f.position, name, 
                [new Dummy(f.owner.type())], false)
        if match != null {
            if !match.annotations.isAbstract & !match.owner.isInterface {
                PandaCompiler.reportError(
                        "inherited \{match} (defined at \{match.position}) " +
                        "is not abstract and may not be overridden by a " +
                        "property getter", f.position)
            }
            annotations.isOverride := true
        }
        annotations.isPrivate := f.annotations.isPrivate
        annotations.isProtected := f.annotations.isProtected
        new ASTGenerator().compileMethod(f.owner, "function " + name + 
                "():" + f.type.name + " { return self." + rawName + " }", 
                annotations, new Position(f.position.compilationUnit, 
                f.position.line, f.position.column + 1))
    }

    @private
    @pre(f.annotations.isProperty)
    method createSetter(f:FieldNode) {
        def rawName := f.name
        assert rawName.startsWith(FieldNode.PROPERTY_PREFIX)
        def name := rawName[FieldNode.PROPERTY_PREFIX.length..]
        def annotations := new Annotations([AnnotationType.SYNTHETIC])
        def match := f.owner.symbolTable.getMethod(f.position, name + ":=", 
                [new Dummy(f.owner.type()), new Dummy(f.type)], false)
        if match != null {
            if !match.annotations.isAbstract & !match.owner.isInterface {
                PandaCompiler.reportError(
                        "inherited \{match} (defined at \{match.position}) " +
                        "is not abstract and may not be overridden by a " +
                        "property setter", f.position)
            }
            annotations.isOverride := true
        }
        annotations.isPrivate := f.annotations.isPrivate
        annotations.isProtected := f.annotations.isProtected
        new ASTGenerator().compileMethod(f.owner, "method " + name + 
                ":=(value:" + f.type.name + ") { self." + rawName + 
                " := value }", new Annotations([AnnotationType.SYNTHETIC,
                    AnnotationType.SELF]),
                new Position(f.position.compilationUnit, f.position.line,
                    f.position.column + 2))
    }

    @private
    method createPropertySynthetics() {
        for cl in SymbolTable.classes {
            var properties := new PrimitiveArray<FieldNode>()
            var getters := new HashMap()
            var setters := new HashMap()
            for child in cl.children {
                if child-?>(FieldNode) {
                    var f := child->(FieldNode)
                    if f.annotations.isProperty
                        properties.append(f)
                }
                else if child-?>(MethodNode) {
                    var m := child->(MethodNode)
                    if m.name.endsWith(":=")
                        setters[m.name[..m.name.length - ":=".length]] := m
                    else if !m.annotations.isClass & m.parameters.length = 1
                        getters[m.name] := m
                }
            }
            for p in properties {
                assert p.name.startsWith(FieldNode.PROPERTY_PREFIX)
                var created := false
                var name := p.name[FieldNode.PROPERTY_PREFIX.length..]
                if getters[name] = null {
                    createGetter(p)
                    created := true
                }
                var setterDenyReason:String? := null
                if p.annotations.isReadOnly
                    setterDenyReason := "'" + name + "' is declared @readonly"
                else if p.annotations.isFinal
                    setterDenyReason := "'" + name + "' is declared @final"
                else if p.owner.type().isImmutable
                    setterDenyReason := "'" + p.owner.name + "' is immutable"
                else if setters[name] != null {
                    setterDenyReason := "an explicit setter was defined at " +
                            setters[name]->(MethodNode).position
                }
                else {
                    createSetter(p)
                    created := true
                }
                p.annotations.isPrivate := true
                p.annotations.isProtected := false
                if !created {
                    assert setterDenyReason != null
                    def getterDenyReason := "an explicit getter was defined " +
                            "at " + getters[name]->(MethodNode).position
                    PandaCompiler.reportWarning("property '" + 
                            p.name[FieldNode.PROPERTY_PREFIX.length..] +
                            "' had neither a getter or a setter " +
                            "created for it:\n    getter not created because " + 
                            getterDenyReason + 
                            "\n    setter not created because " + 
                            setterDenyReason + "\nThis declaration is " + 
                            "therefore equivalent to 'var " + p.name + ":" + 
                            p.type.displayName + "'", p.position)
                }
            }
        }
    }

    method processField(f:FieldNode, tuples:HashMap):Bit? {
        def pending := pendingFieldValues[f]
        def cl := f.owner
        def immutable := cl.type().isImmutable
        var result:Bit? := null
        if (!cl.annotations.isUnspecified | 
                f.annotations.isThread |
                f.annotations.isClass) {
            if pending != null {
                nodeStack.push(cl)
                def m := new MethodNode("<dummy>", 
                        MethodNodeType.METHOD)
                m.parent := currentClass
                if f.annotations.isClass | 
                        f.annotations.isThread {
                    m.annotations.isClass := true
                }
                else {
                    m.parameters.append(new Parameter(
                            Parameter.SELF_NAME, cl.type()))
                }
                nodeStack.push(m)
                def block := new Block(cl.symbolTable)
                m.add(block)
                nodeStack.push(block)
                try {
                    var node:ParseNode
                    if pending-?>(ParseNode)
                        node := pending->(ParseNode)
                    else
                        node := pending->(TupleReference).tuple
                    var value := convertExpression(node)
                    if pending-?>(TupleReference) {
                        def element :=
                                pending->(TupleReference).element
                        if value-?>(UnresolvedTuple)
                            value := value[element]->(Value)
                        else {
                            var reused := tuples[value.position]->(ReusedValueDefinition?)
                            if reused = null {
                                reused := new ReusedValueDefinition(value)
                                tuples[value.position] := reused
                            }
                            value := getField(value.position, 
                                    reused.createReference(),
                                    "$field" + element)
                        }
                    }
                    if f.type-!>(UnresolvedType) & 
                            value.canImplicitCastTo(f.type) {
                        value := implicitCast(value.position, value,
                                f.type)
                    }
                    if value-?>(UnresolvedPrimitiveArray) {
                        def elementType := 
                                determineUnresolvedPrimitiveArrayElementType(
                                    value->(UnresolvedPrimitiveArray))
                        var type := SymbolTable.master.getType(
                                    value.position, 
                                    class(PrimitiveArray).name + "<" + 
                                    elementType.name + ">")
                        if f.annotations.isClass {
                            type := makePrimitiveArrayImmutable(
                                    value.position,
                                    type)
                        }
                        value := implicitCast(value.position, value,
                                type)
                    }
                    if value.type = Type.UNRESOLVED {
                        throw new UnresolvedTypeException(
                                value.position)
                    }
                    if f.type-?>(UnresolvedType)
                        f.type := value.variableType()
                    f.initialValue := implicitCast(value.position, 
                            value, f.type, CastType.IMPLICIT)
                    pendingFieldValues.remove(f)
                    result := true
                }
                catch e:UnresolvedTypeException {
                    result := false
                }
                close(class(Block))
                close(class(MethodNode))
                close(class(ClassNode))
            }
            else if f.type = Type.UNRESOLVED {
                error("field '\{f.name}' has neither an " +
                        "explicit type nor an initialization value",
                        f.position)
            }
        }

        if immutable & !f.annotations.isClass & 
                !f.annotations.isThread &
                !f.type.isImmutable &
                cl.name != class(Method).name &
                !cl.name.startsWith("panda.collections.ImmutableArray") {
            PandaCompiler.reportError(
                    "immutable class '\{cl.name}' has " +
                    "mutable field '\{f.name}' " +
                    "(\{f.type.displayName})", f.position)
        }
        if immutable & !f.annotations.isFinal {
            PandaCompiler.reportError(
                    "immutable class '\{cl.name}' may not " +
                    "contain variables; did you mean to use " +
                    "'def' instead?", f.position)
        }

        if f.annotations.isThread & 
                f.initialValue != null &
                cl.symbolTable.getMethod(cl.position,
                    getThreadLocalInitializerName(f),
                    new PrimitiveArray<Value>(), 
                    true) = null {
            createThreadLocalInitializer(f)
        }

        return result
    }

    ============================================================================
    Determines the type of unresolved fields based on their initialization
    expressions.
    ============================================================================
    method inferFieldTypes(genericOnly:Bit) {
        var remaining:PrimitiveArray<FieldNode>
        var madeProgress:Bit
        var classes := SymbolTable.classes
        -- maps Positions to ReusedValueDefinitions
        def tuples := new HashMap()
        do {
            madeProgress := false
            remaining := []
            for cl in classes {
                if genericOnly & cl.type()-!>(GenericType)
                    continue
                for child in cl.children {
                    if child-?>(FieldNode) {
                        def f := child->(FieldNode)
                        def result := processField(f, tuples)
                        if result = true
                            madeProgress := true
                        else if result = false
                            remaining.append(f)
                    }
                }
            }
        }
        while madeProgress & remaining.length > 0
        if remaining.length > 0 {
            var msg := ("unable to infer field types, possibly due to a " +
                    "circular dependency involving:")->>(MutableString)
            for f in remaining {
                msg.append("\n    " + f.owner + "." + f.name + " (" + 
                        f.position + ")")
            }
            throw new CompilerException(msg->>(String))
        }
    }

    method markPropertiesFinal() {
        for cl in SymbolTable.classes {
            if cl.annotations.isUnspecified | !cl.type().isImmutable
                continue
            for child in cl.children {
                if child-?>(FieldNode) {
                    def f := child->(FieldNode)
                    if f.annotations.isProperty & !f.annotations.isFinal
                        f.annotations.isFinal := true
                }
            }
        }
    }

    method phase1Complete() {
        markPropertiesFinal()
        inferFieldTypes(false)
        createPropertySynthetics()
    }
    
    ============================================================================
    Processes a COMPILATION_UNIT parse node.
    ============================================================================
    @pre(root.type = ParseNodeType.COMPILATION_UNIT)
    method convertCompilationUnit(root:ParseNode, name:String, 
            source:File?):CompilationUnit {
        reset()
        var compilationUnit := new CompilationUnit(name, SymbolTable.master,
                source)
        open(compilationUnit)
        for node in root.children {
            assert node.type = ParseNodeType.BODY_ENTRY
            convertBodyEntry(node)
        }
        var implicitMain := self.implicitMain
        if implicitMain != null & currentNode = implicitMain.block
            close(class(Block))
        if currentNode = implicitMain
            close(class(MethodNode))
        if currentNode = implicitClass
            close(class(ClassNode))
        close(class(CompilationUnit))
        if !linkageOnly
            pendingFieldValues := new HashMap()
        return compilationUnit
    }
    @post(nodeStack.length = @pre(nodeStack.length))
    
    ============================================================================
    Resets the `ASTGenerator` to prepare for a new compilation unit.
    ============================================================================
    method reset() {
        currentPackage := null
        classUses := new HashMap()
        packageUses := new PrimitiveArray<String>()
    }

    method convertExpression(s:String, start:Position):Value {
        var parser := new PandaParser()
        var parseNode := parser.parseExpression(s, start)
        return convertExpression(parseNode)
    }

    @pre(nodeStack.length = 0)
    method compileStatement(b:Block, node:ParseNode) {
        var context := new PrimitiveArray<Node>()
        var m:Node := b
        while m-!>(MethodNode) {
            def parent := m.parent
            assert parent != null  : "\{m} has no parent (\{m.position})"
            m := parent
        }
        def parent := m.parent
        assert parent != null
        nodeStack.push(parent)
        nodeStack.push(m)
        nodeStack.push(b)
        convertStatement(node)
        close(class(Block))
        close(class(MethodNode))
        close(class(ClassNode))
    }
    @post(b.length > @pre(b.length))
    
    @pre(nodeStack.length = 0)
    method compileStatement(b:Block, s:String, start:Position) {
        var parser := new PandaParser()
        var parseNode := parser.parseStatement(s, start)
        compileStatement(b, parseNode)
    }
    @post(b.length > @pre(b.length))
    
    method compileMethod(cl:ClassNode, s:String, start:Position) {
        compileMethod(cl, s, new Annotations(), start)
    }
    
    method compileMethod(cl:ClassNode, s:String, annotations:Annotations, 
            start:Position) {
        compileMethod(cl, s, annotations, start, true)
        compileMethod(cl, s, annotations, start, false)
    }

    method compileMethod(cl:ClassNode, s:String, start:Position, 
            linkageOnly:Bit) {
        compileMethod(cl, s, new Annotations(), start, linkageOnly)
    }

    @pre(nodeStack.length = 0)
    method compileMethod(cl:ClassNode, s:String, annotations:Annotations, 
            start:Position, linkageOnly:Bit) {
        var oldLinkage := self.linkageOnly
        self.linkageOnly := linkageOnly
        self.forceTypeResolution := true
        var parser := new PandaParser()
        var parseNode := parser.parseMethod(s, start)
        var context := new PrimitiveArray<Node>()
        nodeStack.push(cl)
        convertMethodDeclaration(null, annotations, parseNode)
        close(class(ClassNode))
        self.linkageOnly := oldLinkage
        self.forceTypeResolution := false
    }

    method reportError(msg:String, position:Position) {
        PandaCompiler.reportError(new CompilerException(msg, position))
    }
    
    method error(msg:String, token:Token) {
        error(msg, token.position)
    }
    
    method error(msg:String, node:Node) {
        error(msg, node.position)
    }
    
    method error(msg:String, node:ParseNode) {
        error(msg, node.position)
    }
    
    method error(msg:String, position:Position) {
        throw new CompilerException(msg, position)
    }
}