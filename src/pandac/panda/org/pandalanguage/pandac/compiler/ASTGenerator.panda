package org.pandalanguage.pandac.compiler

uses org.pandalanguage.pandac.compiler.TypeMap
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.parser.ParseNodeType
uses org.pandalanguage.pandac.parser.Token
uses org.pandalanguage.pandac.parser.TokenNode
uses org.pandalanguage.pandac.parser.TokenType
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.stubs.TypedCompilationUnitStub
uses org.pandalanguage.pandac.stubs.TypedMethodStub
uses org.pandalanguage.pandac.tree.AbstractLoop
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.And
uses org.pandalanguage.pandac.tree.AndLeft
uses org.pandalanguage.pandac.tree.Annotation
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.Assert
uses org.pandalanguage.pandac.tree.BinaryOperation
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.BitwiseAnd
uses org.pandalanguage.pandac.tree.BitwiseNot
uses org.pandalanguage.pandac.tree.BitwiseOr
uses org.pandalanguage.pandac.tree.BitwiseXor
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.Catch
uses org.pandalanguage.pandac.tree.CatchExit
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.ClassLiteral
uses org.pandalanguage.pandac.tree.ClassObjectLiteral
uses org.pandalanguage.pandac.tree.CompilationUnit
uses org.pandalanguage.pandac.tree.Construct
uses org.pandalanguage.pandac.tree.Continue
uses org.pandalanguage.pandac.tree.Divide
uses org.pandalanguage.pandac.tree.Do
uses org.pandalanguage.pandac.tree.DynamicCall
uses org.pandalanguage.pandac.tree.Equal
uses org.pandalanguage.pandac.tree.ExpressionAnnotation
uses org.pandalanguage.pandac.tree.FieldAssignment
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.Finally
uses org.pandalanguage.pandac.tree.For
uses org.pandalanguage.pandac.tree.ForEach
uses org.pandalanguage.pandac.tree.GreaterThan
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.Identity
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntDivide
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LessThan
uses org.pandalanguage.pandac.tree.Loop
uses org.pandalanguage.pandac.tree.LessThanOrEqual
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.MethodValue
uses org.pandalanguage.pandac.tree.Multiply
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithLength
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithRange
uses org.pandalanguage.pandac.tree.NewPrimitiveArrayWithValues
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.NotEqual
uses org.pandalanguage.pandac.tree.NotIdentity
uses org.pandalanguage.pandac.tree.NullLiteral
uses org.pandalanguage.pandac.tree.Not
uses org.pandalanguage.pandac.tree.Or
uses org.pandalanguage.pandac.tree.OrLeft
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.RealLiteral
uses org.pandalanguage.pandac.tree.Remainder
uses org.pandalanguage.pandac.tree.ReusedValue
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.ShiftLeft
uses org.pandalanguage.pandac.tree.ShiftRight
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.StringLiteral
uses org.pandalanguage.pandac.tree.Subtract
uses org.pandalanguage.pandac.tree.Super
uses org.pandalanguage.pandac.compiler.SymbolTable
uses org.pandalanguage.pandac.tree.Ternary
uses org.pandalanguage.pandac.tree.Throw
uses org.pandalanguage.pandac.tree.Try
uses org.pandalanguage.pandac.tree.UnaryMinus
uses org.pandalanguage.pandac.tree.Unreachable
uses org.pandalanguage.pandac.tree.UnresolvedPrimitiveArray
uses org.pandalanguage.pandac.tree.UnresolvedClassLiteral
uses org.pandalanguage.pandac.tree.UnresolvedLambda
uses org.pandalanguage.pandac.tree.UnresolvedRange
uses org.pandalanguage.pandac.tree.UnresolvedTuple
uses org.pandalanguage.pandac.tree.Unwrap
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.tree.While
uses org.pandalanguage.pandac.tree.Xor
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.RealLiteralType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.TupleType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType
uses org.pandalanguage.pandac.types.UnresolvedTypeException
uses org.pandalanguage.pandac.types.VoidType
uses org.pandalanguage.pandac.types.WrapperType

class Context : Immutable {
    def lookupContext:LookupContext

    def typeMap:TypeMap

    def localVariables:ImmutableHashMap<String, Variable>

    constructor(lookupContext:LookupContext, typeMap:TypeMap,
            localVariables:ListView<Variable>) {
        self.lookupContext := lookupContext
        self.typeMap := typeMap
        def localVariableMap := new HashMap<String, Variable>()
        for v in localVariables
            localVariableMap[v.name] := v
        self.localVariables := new ImmutableHashMap<String, Variable>(
                localVariableMap)
    }

    function +(variables:ListView<Variable>):Context {
        def newVariables := new Array<Variable>(localVariables.values)
        newVariables.addAll(variables)
        return new Context(lookupContext, typeMap, newVariables)
    }
}

================================================================================
Converts typed stubs into AST nodes.
================================================================================
class ASTGenerator : Immutable (MessageProcessor) {
    @class
    @pre(t.type = ParseNodeType.TYPE)
    method convertType(context:Context, t:ParseNode):
            (Type?, ListView<Message>?) {
        return context.typeMap.getType(t, context.lookupContext)
    }

    @class
    @pre(e.type = ParseNodeType.EXPRESSION)
    method convertExpression(context:Context, e:ParseNode):
            (Value, ListView<Message>?) {
        throw new NotSupportedException()
    }

    ============================================================================
    Processes a VAR_DECLARATION parse node. Returns a list of variables and
    statements to initialize them.
    ============================================================================
    @class
    @pre(v.type = ParseNodeType.VAR_DECLARATION)
    method convertVariableDeclaration(context:Context, v:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def variables := new Array<Variable>()
        def statements := new Array<Statement>()
        def varType:VariableType
        switch v[0]->(TokenNode).token.type {
            case TokenType.VAR:      varType := VariableType.VAR
            case TokenType.DEF:      varType := VariableType.DEF
            case TokenType.CONSTANT: varType := VariableType.CONSTANT
            default: unreachable
        }
        def positions := new Array<Position>()
        def names := new Array<String?>()
        def types := new Array<Type?>()
        var i := 1
        loop {
            positions.add(v[i].position)
            var name:String?
            if v[i]->(TokenNode).token.type = TokenType.UNDERSCORE
                name := null
            else {
                assert v[i]->(TokenNode).token.type = TokenType.IDENTIFIER
                name := v[i]->>(String)
            }
            i += 1
            def type:Type?
            if i < v.length & v[i].type = ParseNodeType.TYPE_DECLARATION {
                def submessages:ListView<Message>?
                type, submessages := convertType(context, v[i][1])
                messages := addMessages(messages, submessages)
                i += 1
            }
            else
                type := null
            names.add(name)
            types.add(type)
            if i >= v.length | v[i].type != ParseNodeType.TOKEN | 
                    v[i]->(TokenNode).token.type != TokenType.COMMA
                break
            i += 1
        }
        def value:Value?
        if i < v.length {
            assert v[i]->(TokenNode).token.type = TokenType.ASSIGNMENT
            i += 1
            def submessages:ListView<Message>?
            value, submessages := convertExpression(context, v[i])
            messages := addMessages(messages, submessages)
        }
        else
            value := null
        var reusableTuple:ReusedValueDefinition? := null
        if names.length > 1 {
            if value != null {
                def valueType := value.preferredVariableType
                if !valueType.isTuple | 
                        valueType->>(TupleType).types.length != names.length {
                    messages := addMessage(messages, "expected a tuple with " +
                                "length \{names.length} for multi-value " +
                                "assignment", value.position)
                }
                for j, type in types {
                    if type = null
                        types[j] := valueType->>(TupleType).types[j].preferredVariableType
                }
                if value-!>(UnresolvedTuple)
                    reusableTuple := new ReusedValueDefinition(value)
            }
        }
        else if value != null & types[0] = null
            types[0] := value.preferredVariableType
        if names.length = 1 & names[0] = null {
            messages := addMessage(messages, "'_' is only permitted in " +
                    "multiple assignments from a tuple", positions[0])
        }
        for j, name in names {
            if name = null
                continue
            def position := positions[j]
            def type := types[j]
            if type = null | type = NullType.NULL {
                throw new CompilerException(
                        "'\{name}' has neither an initial " +
                            "value nor an explicit type", position)
            }
            def variable := new LocalVariable(position, name, type, varType)
--            currentBlock.symbolTable.putVariable(variable)
            if value != null {
                def effectiveValue:Value
                if reusableTuple != null {
-*                    effectiveValue := getField(value.position, 
                            reusableTuple.createReference(), "$field" + j).
                                implicitCast(variable.type)*-
                    unreachable
                }
                else if value-?>(UnresolvedTuple) & names.length > 1 {
                    def element := value->(UnresolvedTuple).values[j]
                    def submessages:ListView<Message>?
                    effectiveValue, submessages := element.implicitCast(
                            variable.type)
                    messages := addMessages(messages, submessages)
                }
                else {
                    def submessages:ListView<Message>?
                    effectiveValue, submessages := value.implicitCast(
                            variable.type)
                    messages := addMessages(messages, submessages)
                }
                def va := new VariableAssignment(position, variable, 
                        effectiveValue, true)
                statements.add(new ValueStatement(va))
            }
        }
        def newContext := context + variables
        if statements.length = 0
            return (null, newContext, messages)
        if statements.length = 1
            return (statements[0], newContext, messages)
        return (new Block(v.position, statements), newContext, messages)
    }

    ============================================================================
    Processes a SIMPLE_STATEMENT parse node.
    ============================================================================
    @class
    @pre(s.type = ParseNodeType.SIMPLE_STATEMENT)
    method convertSimpleStatement(context:Context, s:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.VAR_DECLARATION: 
                return convertVariableDeclaration(context, s[0])
-*            case ParseNodeType.CONSTANT_DECLARATION: 
                return convertConstantDeclaration(s[0])
            case ParseNodeType.CALL_OR_ASSIGNMENT: {
                def call, message := convertCallOrAssignment(context, s[0])
                return (call, context, messages)
            }
            case ParseNodeType.ANY_LOOP:  {
                def l, messages := convertAnyLoop(context, s[0])
                return (l, context, messages)
            }
            case ParseNodeType.IF: {
                def i, messages := convertIf(context, s[0])
                return (i, context, messages)
            }
            case ParseNodeType.SWITCH_STATEMENT: {
                def s, messages := convertSwitch(context, s[0])
                return (convertSwitch(s[0]), context, messages)
            }
            case ParseNodeType.ASSERT_STATEMENT: {
                def a, messages := convertAssert(context, s[0])
                return (a, context, messages)
            }
            case ParseNodeType.TRY_STATEMENT: {
                def t, messages := convertTryStatement(context, s[0])
                return (t, context, messages)
            }*-
            default: throw new InternalCompilerException(
                    "unsupported simple statement: \{s[0].type}", 
                    s.position)
        }
    }

    ============================================================================
    Processes a THROW_STATEMENT parse node.
    ============================================================================
    @class
    @pre(t.type = ParseNodeType.THROW_STATEMENT)
    method convertThrowStatement(t:ParseNode):(Throw, ListView<Message>?) {
-*        return new Throw(t.position, implicitCast(t[1].position,
                convertExpression(t[1]), ClassType.ERROR())))*-
        throw new NotSupportedException()
    }

    ============================================================================
    Processes an UNREACHABLE token.
    ============================================================================
    @class
    @pre(t->(TokenNode).token.type = TokenType.UNREACHABLE)
    function convertUnreachable(t:ParseNode):Unreachable {
        return new Unreachable(t.position)
    }

    @class
    @pre(s.type = ParseNodeType.TERMINAL_STATEMENT)
    method convertTerminalStatement(context:Context, s:ParseNode):
            (Statement, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.BREAK_STATEMENT: {
                def b := s[0]
                if b.length > 1
                    return (new Break(b.position, b[1]->>(String)), null)
                else
                    return (new Break(b.position), null)
            }
            case ParseNodeType.CONTINUE_STATEMENT: {
                def c := s[0]
                if c.length > 1
                    return (new Continue(c.position, c[1]->>(String)), null)
                else
                    return (new Continue(c.position), null)
            }
            case ParseNodeType.RETURN_STATEMENT: {
                def r := s[0]
                if r.length > 1 {
                    throw new NotSupportedException()
-*                    def cm := currentMethod
                    assert cm != null
                    return new Return(r.position, 
                            implicitCast(r[1].position, convertExpression(r[1]), 
                                    cm.returnType)))*-
                }
                else
                    return (new Return(r.position), null)
            }
-*            case ParseNodeType.THROW_STATEMENT: {
                def t, messages := convertThrowStatement(context, s[0])
                return (t, messages)
            }*-
            case ParseNodeType.TOKEN: 
                return (convertUnreachable(s[0]), null)
            default: {
                throw new InternalCompilerException(
                        "unsupported terminal statement: \{s[0].class.name}", 
                        s[0].position)
            }
        }
    }

    ============================================================================
    Processes a STATEMENT parse node.
    ============================================================================
    @class
    @pre(s.type = ParseNodeType.STATEMENT)
    method convertStatement(context:Context, s:ParseNode):
            (Statement?, Context, ListView<Message>?) {
        assert s.length = 1
        switch s[0].type {
            case ParseNodeType.SIMPLE_STATEMENT: 
                return convertSimpleStatement(context, s[0])
            case ParseNodeType.BLOCK: {
                def b, messages := convertBlock(context, s[0])
                return (b, context, messages)
            }
            default: throw new InternalCompilerException(
                    "unsupported statement: \{s[0].class.name}", s[0].position)
        }
    }

    ============================================================================
    Processes a STATEMENT_OR_BLOCK parse node.
    ============================================================================
    @class
    @pre(b.type = ParseNodeType.STATEMENT_OR_BLOCK)
    method convertStatementOrBlock(context:Context, b:ParseNode):
            (Block, ListView<Message>?) {
        if b[0].type = ParseNodeType.BLOCK
            return convertBlock(context, b[0])
        else {
            def statement:Statement?
            def messages:ListView<Message>?
            if b[0].type = ParseNodeType.SIMPLE_STATEMENT {
                def ignored:Context
                statement, ignored, messages := convertSimpleStatement(context,
                        b[0])
            }
            else
                statement, messages := convertTerminalStatement(context, b[0])
            def statements := new Array<Statement>()
            if statement != null
                statements.add(statement)
            return (new Block(b.position, statements), messages)
        }
    }

    ============================================================================
    Processes a BLOCK parse node.
    ============================================================================
    @class
    @pre(b.type = ParseNodeType.BLOCK)
    method convertBlock(context:Context, b:ParseNode):
            (Block, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def statements := new Array<Statement>()
        var currentContext := context
        for i in 1 ... b.length - 2 {
            switch b[i].type {
                case ParseNodeType.STATEMENT: {
                    def statement, newContext, submessages := 
                            convertStatement(currentContext, b[i])
                    if statement != null
                        statements.add(statement)
                    currentContext := newContext
                    messages := addMessages(messages, submessages)
                }
                case ParseNodeType.TERMINAL_STATEMENT: {
                    def statement, submessages := convertTerminalStatement(
                            currentContext, b[i])
                    statements.add(statement)
                    messages := addMessages(messages, submessages)
                }
                default: {
                    throw new InternalCompilerException(
                            "unsupported statement in block: \{b[i].class.name}", 
                            b[i].position)
                }
            }
        }
        return (new Block(b.position, statements), messages)
    }

    method convertMethod(context:Context, m:TypedMethodStub):
            (MethodNode, ListView<Message>?) {
        def block:Block?
        def messages:ListView<Message>?
        if m.block != null
            block, messages := convertBlock(context, m.block->(ParseNode))
        else {
            block := null
            messages := null
        }
        def parameters := new Array<Parameter>()
        return (new MethodNode(m.position, m.name, parameters, m.returnType,
                m.annotations, block), messages)
    }

    method convertClass(cl:TypedClassStub, typeMap:TypeMap):
            (ClassNode, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def methods := new Array<MethodNode>()
        def fields := new Array<FieldNode>()
        for m in cl.methods {
            def context := new Context(cl.lookupContext, typeMap, 
                    new Array<Variable>())
            def compiled, submessages := convertMethod(context, m)
            methods.add(compiled)
            messages := addMessages(messages, submessages)
        }
        def result := new ClassNode(cl.position, cl.name, cl.isInterface, 
            cl.annotations, cl.lookupContext, cl.superclass, cl.interfaces, 
            methods, fields, cl.invariants,
            cl.genericParameters)
        return (result, messages)
    }

    method convertCompilationUnit(compilationUnit:TypedCompilationUnitStub,
            typeMap:TypeMap):
            (CollectionView<ClassNode>, ListView<Message>?) {
        def result := new Array<ClassNode>()
        var messages:ListView<Message>? := null
        for cl in compilationUnit.classes {
            def classNode, submessages := convertClass(cl, typeMap)
            result.add(classNode)
            messages := addMessages(messages, submessages)
        }
        return (result, messages)
    }

    method convertCompilationUnits(
            compilationUnits:CollectionView<TypedCompilationUnitStub>,
            typeMap:TypeMap):
                (CollectionView<ClassNode>, ListView<Message>?) {
        def result := new Array<ClassNode>()
        var messages:ListView<Message>? := null
        for cu in compilationUnits {
            def classes, submessages := convertCompilationUnit(cu, typeMap)
            result.addAll(classes)
            messages := addMessages(messages, submessages)
        }
        return (result, messages)
    }
}