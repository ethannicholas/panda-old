package org.pandalanguage.pandac.stubs

uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.MethodType

================================================================================
Represents a group of same-named method overloads.
================================================================================
class Methods : Immutable (Symbol) {
    class Entry {
        def stub:MethodStub

        def effectiveType:MethodType

        init(stub:MethodStub, effectiveType:MethodType) {
            self.stub := stub
            self.effectiveType := effectiveType
        }

        ========================================================================
        Returns true if this method overrides `parent`.
        ========================================================================
        function isOverrideOf(parent:Entry):Bit {
            if parent.stub.name != stub.name {
                return false
            }
            if parent.stub.annotations.isClass != stub.annotations.isClass {
                return false
            }
            return parent.effectiveType.methodParameters = 
                    effectiveType.methodParameters &
                    parent.effectiveType.returnType = effectiveType.returnType
        }

        @override
        function get_hash():Int {
            return stub.hash ~~ effectiveType.hash
        }

        @override
        function =(o:Object):Bit {
            if o-!>Entry {
                return false
            }
            def e := o->Entry
            return stub = e.stub & effectiveType = e.effectiveType
        }

        @override
        function convert():String {
            return "(\{stub.owner}.\{stub}, \{effectiveType})"
        }
    }

    @private
    var _name:String

    def entries:ImmutableArray<Entry>

    init(stub:MethodStub, effectiveType:MethodType) {
        self._name := stub.name
        self.entries := [Entry(stub, effectiveType)]
    }

    init(entries:ListView<Entry>) {
        self._name := entries[0].stub.name
        self.entries := ImmutableArray<Entry>(entries)
        assert HashSet<Entry>(entries).count = entries.count : 
                "duplicate method in \{entries}"
    }

    @override
    function get_name():String {
        return _name
    }

    function +(m:Entry):Methods {
        def result := Array<Entry>()
        for old in entries {
            if !m.isOverrideOf(old) {
                result.add(old)
            }
        }
        assert !result.contains(m) : "already have \{m.stub}"
        result.add(m)
        return Methods(result)
    }

    function +(m:Methods):Methods {
        -- FIXME brain-dead O(N^2) approach
        def result := Array<Entry>()
        outer: for oldMethod in entries {
            for newMethod in m.entries {
                assert newMethod.stub.name = oldMethod.stub.name
                if newMethod.isOverrideOf(oldMethod) {
                    continue outer
                }
            }
            result.add(oldMethod)
        }
        for newMethod in m.entries {
            assert !result.contains(newMethod) : "already have \{newMethod.stub}"
            result.add(newMethod)
        }
        return Methods(result)
    }

    function forType(context:Context, type:GenericType):Methods {
        def result := Array<Entry>()
        for m in entries {
            def newStub := m.stub.specializeFor(context, type)
            result.add(Entry(newStub, newStub.type))
        }
        return Methods(result)
    }

    @override
    function convert():String {
        return entries.convert()
    }
}