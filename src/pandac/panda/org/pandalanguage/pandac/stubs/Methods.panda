package org.pandalanguage.pandac.stubs

uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.MethodType

================================================================================
Represents a group of same-named method overloads.
================================================================================
class Methods : Immutable (Symbol) {
    class MethodEntry {
        def stub:MethodStub

        def effectiveType:MethodType

        init(stub:MethodStub, effectiveType:MethodType) {
            self.stub := stub
            self.effectiveType := effectiveType
        }

        ========================================================================
        Returns true if this method overrides `parent`.
        ========================================================================
        function isOverrideOf(parent:MethodEntry):Bit {
            if parent.stub.name != stub.name {
                return false
            }
            if parent.stub.annotations.isClass != stub.annotations.isClass {
                return false
            }
            return parent.effectiveType.methodParameters = 
                    effectiveType.methodParameters &
                    parent.effectiveType.returnType = effectiveType.returnType
        }

        @override
        function get_hash():Int {
            return stub.hash ~~ effectiveType.hash
        }

        @override
        function =(o:Object):Bit {
            if o-!>MethodEntry {
                return false
            }
            def e := o->MethodEntry
            return stub = e.stub & effectiveType = e.effectiveType
        }

        @override
        function convert():String {
            return "(\{stub.name}, \{effectiveType})"
        }
    }

    @private
    var _name:String

    def entries:ImmutableArray<MethodEntry>

    init(stub:MethodStub, effectiveType:MethodType) {
        self._name := stub.name
        self.entries := [MethodEntry(stub, effectiveType)]
    }

    init(entries:ListView<MethodEntry>) {
        self._name := entries[0].stub.name
        self.entries := ImmutableArray<MethodEntry>(entries)
        assert HashSet<MethodEntry>(entries).count = entries.count : 
                "duplicate method in \{entries}"
    }

    @override
    function get_name():String {
        return _name
    }

    function +(m:MethodEntry):Methods {
        def result := Array<MethodEntry>()
        for old in entries {
            if !m.isOverrideOf(old) {
                result.add(old)
            }
        }
        assert !result.contains(m) : "already have \{m.stub}"
        result.add(m)
        return Methods(result)
    }

    function +(m:Methods):Methods {
        -- FIXME brain-dead O(N^2) approach
        def result := Array<MethodEntry>()
        outer: for oldMethod in entries {
            for newMethod in m.entries {
                assert newMethod.stub.name = oldMethod.stub.name
                if newMethod.isOverrideOf(oldMethod) {
                    continue outer
                }
            }
            result.add(oldMethod)
        }
        for newMethod in m.entries {
            assert !result.contains(newMethod) : "already have \{newMethod.stub}"
            result.add(newMethod)
        }
        return Methods(result)
    }

    function withGenerics(parameters:ListView<Type>):Methods {
        def result := Array<MethodEntry>()
        for m in entries {
            result.add(MethodEntry(m.stub, m.stub.typeWithGenerics(parameters)))
        }
        return Methods(result)
    }

    @override
    function convert():String {
        return entries.convert()
    }
}