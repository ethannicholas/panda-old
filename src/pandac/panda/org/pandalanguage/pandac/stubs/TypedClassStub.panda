package org.pandalanguage.pandac.stubs

uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.compiler.LookupContext
uses org.pandalanguage.pandac.compiler.StubMap
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

================================================================================
Represents a parsed but not-yet-compiled class after symbol resolution.
================================================================================
class TypedClassStub : ClassStub {
    def superclass:ClassType?

    def interfaces:ImmutableArray<ClassType>

    def methods:ImmutableArray<TypedMethodStub>

    def fields:ImmutableArray<FieldNode>

    def fullyResolved:Bit

    def genericParameters:ImmutableArray<GenericParameterType>?

    @invariant(genericParameters = null | genericParameters.length > 0)

    @pre(genericParameters = null | genericParameters.length > 0)
    constructor(position:Position, name:String, isInterface:Bit, 
            annotations:Annotations, lookupContext:LookupContext, 
            superclass:ClassType?, interfaces:ListView<ClassType>, 
            methods:ListView<TypedMethodStub>, fields:ListView<FieldNode>, 
            invariants:ListView<ParseNode>,
            genericParameters:ListView<GenericParameterType>?, isExternal:Bit) {
        super.constructor(position, name, isInterface, annotations, 
                lookupContext, invariants, isExternal)
        self.superclass := superclass
        self.interfaces := new ImmutableArray<ClassType>(interfaces)
        self.methods := new ImmutableArray<TypedMethodStub>(methods)
        self.fields := new ImmutableArray<FieldNode>(fields)
        def filter := f:FieldNode => f.type-?>(UnresolvedType)
        self.fullyResolved := fields.filter(filter).length = 0
        if genericParameters != null {
            self.genericParameters := new ImmutableArray<GenericParameterType>(
                    genericParameters)
        }
    }

    ============================================================================
    Returns a list of all of the interface methods in this class corresponding
    to a particular interface. The order of methods in the resulting array is 
    consistent across all classes implementing this interface.
    ============================================================================
    @safeReturn
    method interfaceMethods(intf:TypedClassStub, 
            stubs:MapView<String, TypedClassStub>):ListView<TypedMethodStub> {
        def result := new Array<TypedMethodStub>(intf.virtualMethods(stubs))
        def myMethods := virtualMethods(stubs)
        for i, m in result {
            for m2 in myMethods {
                if m2.isOverrideOf(m) {
                    result[i] := m2
                    break
                }
            }
        }
        return result
    }

    ============================================================================
    Returns the set of all of the interfaces directly or indirectly implemented
    by this class. If this class represents an interface, it will include itself
    in the result.
    ============================================================================
    function allInterfaces(stubs:MapView<String, TypedClassStub>):
            CollectionView<TypedClassStub> {
        def result := new HashSet<TypedClassStub>()
        def sc := superclass
        if sc != null
            result.addAll(stubs[sc.name]->(TypedClassStub).allInterfaces(stubs))
        if isInterface
            result.add(self)
        for intf in interfaces {
            result.addAll(stubs[intf.name]->(TypedClassStub).allInterfaces(
                    stubs))
        }
        return result
    }

    function getField(context:Context, name:String):FieldNode? {
        for f in fields {
            if f.name = name
                return f
        }
        if superclass != null {
            def superField := context.getStub(superclass).getField(context, 
                    name)
            if superField != null
                return superField
        }
        for intf in interfaces {
            def intfField := context.getStub(intf).getField(context, name)
            if intfField != null
                return intfField
        }
        return null
    }

    method instanceFields(stubs:StubMap):
            ListView<FieldNode> {
        def result := new Array<FieldNode>()
        if superclass != null {
            def stub := stubs.getStub(superclass.name)
            if stub != null { -- FIXME remove this test, stub should never be null when this is done
                assert stub != null : "no stub for \{superclass.name}"
                result.addAll(stub.instanceFields(stubs))
            }
        }
        result.addAll(fields.filter(f => !f.annotations.isClass & 
                !f.annotations.isThread))
        return result
    }

    function instanceFields(stubs:MapView<String, TypedClassStub>):
            ListView<FieldNode> {
        def result := new Array<FieldNode>()
        if superclass != null {
            def stub := stubs[superclass.name]
            if stub != null { -- FIXME remove this test, stub should never be null when this is done
                assert stub != null : "no stub for \{superclass.name}"
                result.addAll(stub.instanceFields(stubs))
            }
        }
        result.addAll(fields.filter(f => !f.annotations.isClass & 
                !f.annotations.isThread))
        return result
    }

    @class
    @limited
    method addOverrides(source:ListView<TypedMethodStub>, 
            dest:List<TypedMethodStub>) {
        outer: for s in source {
            if !s.isDeclaredVirtual
                continue
            for i, d in dest {
                if s.isOverrideOf(d) {
                    dest[i] := s
                    continue outer
                }
            }
            dest.add(s)
        }
    }

    function instanceMethods(stubs:MapView<String, TypedClassStub>):
            CollectionView<TypedMethodStub> {
        def result := new Array<TypedMethodStub>()
        if superclass != null {
            result.addAll(stubs[superclass.name]->(TypedClassStub).
                    instanceMethods(stubs).filter(
                        m => !m.annotations.isPrivate))
        }
        result.addAll(methods.filter(
                m => m.methodType != MethodNodeType.CONSTRUCTOR & 
                !m.annotations.isClass))
        return result
    }

    function instanceMethods(stubs:StubMap):
            CollectionView<TypedMethodStub> {
        def result := new Array<TypedMethodStub>()
        if superclass != null {
            result.addAll(stubs.getStub(superclass.name)->(TypedClassStub).
                    instanceMethods(stubs).filter(
                        m => !m.annotations.isPrivate))
        }
        result.addAll(methods.filter(
                m => m.methodType != MethodNodeType.CONSTRUCTOR & 
                !m.annotations.isClass))
        return result
    }

    ============================================================================
    Returns a ListView of all of the virtual methods in this class. Methods 
    which are inherited or overridden from parent classes appear in this array 
    in the same index in which they were present in the parent class, and new 
    methods will appear at the end of the array.
    ============================================================================
    @safeReturn
    method virtualMethods(stubs:MapView<String, TypedClassStub>):
            ListView<TypedMethodStub> {
        def getStub := function(type:Type):TypedClassStub {
            def result := stubs[type.name]
            -- FIXMY temporary, remove this when new compiler is done
            if result = null {
                Panda.log("INTERNAL ERROR: no stub for \{type.name}")
                return stubs[class(Object).name]->(TypedClassStub)
            } 
            return result
        }
        def result := new Array<TypedMethodStub>()
        for i in interfaces.length - 1 ... 0 by -1
            addOverrides(getStub(interfaces[i]).virtualMethods(stubs), result)
        def sc := superclass
        if sc != null
            addOverrides(getStub(sc).virtualMethods(stubs), result)
        addOverrides(methods, result)
        return result
    }

    @override
    function format(fmt:String):String {
        return "\{name}(\{fields}, \{methods})"
    }
}