package org.pandalanguage.pandac.stubs

uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.compiler.LookupContext
uses org.pandalanguage.pandac.compiler.StubMap
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

================================================================================
Represents a parsed but not-yet-compiled class.
================================================================================
class ClassStub : Immutable (Symbol) {
    def position:Position

    def type:ClassType

    def isInterface:Bit

    def annotations:Annotations

    def lookupContext:LookupContext

    def isExternal:Bit

    def superclass:ClassType?

    def interfaces:ImmutableArray<ClassType>

    def fullyResolved:Bit

    def symbols:ImmutableHashMap<String, Symbol>

    def invariants:ImmutableArray<ASTInvariant>

    def genericParameters:ImmutableArray<ASTTypedIdentifier>?

    @invariant(genericParameters = null | genericParameters.length > 0)

    @pre(genericParameters = null | genericParameters.length > 0)
    constructor(position:Position, type:ClassType, isInterface:Bit, 
            annotations:Annotations, lookupContext:LookupContext, 
            superclass:ClassType?, interfaces:CollectionView<ClassType>, 
            symbols:MapView<String, Symbol>, 
            invariants:CollectionView<ASTInvariant>,
            genericParameters:ListView<ASTTypedIdentifier>?, isExternal:Bit) {
        super.constructor()
        self.position := position
        self.type := type
        self.isInterface := isInterface
        self.annotations := annotations
        self.lookupContext := lookupContext
        self.invariants := new ImmutableArray<ASTInvariant>(invariants)
        self.isExternal := isExternal
        self.superclass := superclass
        self.interfaces := new ImmutableArray<ClassType>(interfaces)
        self.symbols := new ImmutableHashMap<String, Symbol>(symbols)
        def filter := f:FieldNode => f.type-?>(UnresolvedType)
        self.fullyResolved := fields.filter(filter).length = 0
        if genericParameters != null {
            self.genericParameters := 
                    new ImmutableArray<ASTTypedIdentifier>(
                        genericParameters)
        }
    }

    @override
    function name():String {
        return type.name
    }

    function fields():ListView<FieldNode> {
        def result := new Array<FieldNode>()
        for (_, s) in symbols {
            if s-?>(FieldNode)
                result.add(s->(FieldNode))
        }
        return result
    }

    function methods():ListView<MethodStub> {
        def result := new Array<MethodStub>()
        for (_, s) in symbols {
            if s-?>(Methods)
                result.addAll(s->(Methods).methods)
        }
        return result
    }

    ============================================================================
    Returns a list of all of the interface methods in this class corresponding
    to a particular interface. The order of methods in the resulting array is 
    consistent across all classes implementing this interface.
    ============================================================================
    @safeReturn
    method interfaceMethods(intf:ClassStub, 
            context:Context):ListView<MethodStub> {
        def result := new Array<MethodStub>(intf.virtualMethods(context))
        def myMethods := virtualMethods(context)
        for i, m in result {
            for m2 in myMethods {
                if m2.isOverrideOf(m) {
                    result[i] := m2
                    break
                }
            }
        }
        return result
    }

    ============================================================================
    Returns the set of all of the interfaces directly or indirectly implemented
    by this class. If this class represents an interface, it will include itself
    in the result.
    ============================================================================
    function allInterfaces(context:Context):CollectionView<ClassStub> {
        def result := new HashSet<ClassStub>()
        def sc := superclass
        if sc != null
            result.addAll(context.getStub(sc.name).allInterfaces(context))
        if isInterface
            result.add(self)
        for intf in interfaces
            result.addAll(context.getStub(intf.name).allInterfaces(context))
        return result
    }

    function getField(context:Context, name:String):FieldNode? {
        for f in fields {
            if f.name = name
                return f
        }
        if superclass != null {
            def superField := context.getStub(superclass).getField(context, 
                    name)
            if superField != null
                return superField
        }
        for intf in interfaces {
            def intfField := context.getStub(intf).getField(context, name)
            if intfField != null
                return intfField
        }
        return null
    }

    method instanceFields(context:Context):ListView<FieldNode> {
        def result := new Array<FieldNode>()
        if superclass != null {
            def stub := context.getStub(superclass.name)
            result.addAll(stub.instanceFields(context))
        }
        result.addAll(fields.filter(f => !f.annotations.isClass & 
                !f.annotations.isThread))
        return result
    }

    @class
    @limited
    method addOverrides(source:ListView<MethodStub>, 
            dest:List<MethodStub>) {
        outer: for s in source {
            if !s.isDeclaredVirtual
                continue
            for i, d in dest {
                if s.isOverrideOf(d) {
                    dest[i] := s
                    continue outer
                }
            }
            dest.add(s)
        }
    }

    function instanceMethods(context:Context):
            CollectionView<MethodStub> {
        def result := new Array<MethodStub>()
        if superclass != null {
            result.addAll(context.getStub(superclass.name)->(ClassStub).
                    instanceMethods(context).filter(
                        m => !m.annotations.isPrivate))
        }
        result.addAll(methods.filter(
                m => m.methodType != MethodNodeType.CONSTRUCTOR & 
                !m.annotations.isClass))
        return result
    }

    ============================================================================
    Returns a ListView of all of the virtual methods in this class. Methods 
    which are inherited or overridden from parent classes appear in this array 
    in the same index in which they were present in the parent class, and new 
    methods will appear at the end of the array.
    ============================================================================
    @safeReturn
    method virtualMethods(context:Context):ListView<MethodStub> {
        def result := new Array<MethodStub>()
        for i in interfaces.length - 1 ... 0 by -1 {
            addOverrides(context.getStub(interfaces[i]).virtualMethods(context),
                    result)
        }
        def sc := superclass
        if sc != null
            addOverrides(context.getStub(sc).virtualMethods(context), result)
        addOverrides(methods, result)
        return result
    }

    method isImmutable(context:Context):Bit {
        if type = ClassType.IMMUTABLE
            return true
        if superclass = null
            return false
        return context.getStub(superclass).isImmutable(context)
    }

    @override
    function format(fmt:String):String {
        return "\{name}(\{fields}, \{methods})"
    }
}