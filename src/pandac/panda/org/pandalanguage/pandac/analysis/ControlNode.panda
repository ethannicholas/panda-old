package org.pandalanguage.pandac.analysis

uses org.pandalanguage.pandac.compiler.XMLWriter
uses org.pandalanguage.pandac.tree.Node

================================================================================
Represents a node in the control flow graph. During CFG construction, each
`ControlNode` may correspond to less than an entire basic block, but by the time
the CFG is finished each `ControlNode` will represent a basic block.
================================================================================
class ControlNode {
    ============================================================================
    The abstract syntax tree nodes this control flow graph node represents.
    ============================================================================
    @readonly
    var nodes:Array<Node>
    
    ============================================================================
    Contains the values of variables and fields at the beginning of this node.
    ============================================================================
    var inValues:Map := new HashMap()
    
    ============================================================================
    An array containing the exits of this node.
    ============================================================================
    @readonly
    var exits := new Array<ControlNode>()
    
    ============================================================================
    An array containing the entrances of this node.
    ============================================================================
    @readonly
    var entrances := new Array<ControlNode>()

    -- used for XML output
    @thread
    var idCount := 0

    -- used for XML output
    var id:Int? := null

    
    constructor(node:Node) {
        self.nodes := [node]
    }
    
    method addNode(n:Node) {
        self.nodes.append(n)
    }
    
    ============================================================================
    Adds a new exit node.
    
    @param n the node to add
    ============================================================================
    method addExit(n:ControlNode) {
        if !exits.contains(n) {
            exits.append(n)
            n.entrances.append(self)
        }
    }

    method getId():String {
        var id := self.id
        if id = null {
            id := idCount
            self.id := id
            idCount += 1
        }
        return "node" + id
    }

    @private
    method writeXML(xml:XMLWriter, visited:Map) {
        if visited[self] != null
            return
        visited[self] := self
        xml.open("controlNode")
        xml.attribute("id", getId())
        xml.open("nodes")
        for node in nodes
            xml.textTag(node.class.simpleName, node->>(String))
        xml.close("nodes")
        xml.open("inValues")
        for (key, value) in inValues.entries {
            xml.open("in")
            key->(ValueKey).writeXML(xml)
            value->(DataFlowValue).writeXML(xml)
            xml.close("in")
        }
        xml.close("inValues")
        xml.open("entrances")
        for entrance in entrances
            xml.textTag("node", entrance.getId())
        xml.close("entrances")
        xml.open("exits")
        for exit in exits
            xml.textTag("node", exit.getId())
        xml.close("exits")
        xml.close("controlNode")
        for exit in exits
            exit.writeXML(xml, visited)
    }

    method writeXML(xml:XMLWriter) {
        var visited := new HashMap()
        writeXML(xml, visited)
    }

    @override
    function format(fmt:String):String {
        var result := new MutableString()
        result.append(class.name)
        result.append("(")
        for i, node in nodes {
            if i > 0
                result.append(", ")
            result.append(node)
        }
        result.append(", ")
        result.append(exits.length)
        result.append(" exit(s))")
        return result->>(String)
    }
}
