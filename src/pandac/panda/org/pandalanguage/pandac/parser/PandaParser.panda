package org.pandalanguage.pandac.parser

uses org.pandalanguage.pandac.ast.ArrowOperationType
uses org.pandalanguage.pandac.ast.ASTArrayLiteral
uses org.pandalanguage.pandac.ast.ASTArrowExpression
uses org.pandalanguage.pandac.ast.ASTAnnotation
uses org.pandalanguage.pandac.ast.ASTAssert
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTAtReturn
uses org.pandalanguage.pandac.ast.ASTBinaryExpression
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTBreak
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTCatch
uses org.pandalanguage.pandac.ast.ASTClass
uses org.pandalanguage.pandac.ast.ASTClassLiteral
uses org.pandalanguage.pandac.ast.ASTClassType
uses org.pandalanguage.pandac.ast.ASTContinue
uses org.pandalanguage.pandac.ast.ASTDo
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTEnum
uses org.pandalanguage.pandac.ast.ASTEnumValue
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTField
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTFor
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTIndex
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTLambdaExpression
uses org.pandalanguage.pandac.ast.ASTLoop
uses org.pandalanguage.pandac.ast.ASTMemberExpression
uses org.pandalanguage.pandac.ast.ASTMethod
uses org.pandalanguage.pandac.ast.ASTMethodType
uses org.pandalanguage.pandac.ast.ASTMethodValue
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTNode
uses org.pandalanguage.pandac.ast.ASTNullLiteral
uses org.pandalanguage.pandac.ast.ASTPackageDeclaration
uses org.pandalanguage.pandac.ast.ASTParameter
uses org.pandalanguage.pandac.ast.ASTPlugin
uses org.pandalanguage.pandac.ast.ASTPostcondition
uses org.pandalanguage.pandac.ast.ASTPre
uses org.pandalanguage.pandac.ast.ASTPrecondition
uses org.pandalanguage.pandac.ast.ASTUnaryExpression
uses org.pandalanguage.pandac.ast.ASTRangeExpression
uses org.pandalanguage.pandac.ast.ASTRealLiteral
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
uses org.pandalanguage.pandac.ast.ASTSlice
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSuper
uses org.pandalanguage.pandac.ast.ASTSwitch
uses org.pandalanguage.pandac.ast.ASTSwitchCase
uses org.pandalanguage.pandac.ast.ASTThrow
uses org.pandalanguage.pandac.ast.ASTTry
uses org.pandalanguage.pandac.ast.ASTTupleExpression
uses org.pandalanguage.pandac.ast.ASTTupleType
uses org.pandalanguage.pandac.ast.ASTType
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTUsesDeclaration
uses org.pandalanguage.pandac.ast.ASTVarDeclaration
uses org.pandalanguage.pandac.ast.ASTWhile
uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.compiler.ErrorReporter
uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.UnaryOperationType
uses org.pandalanguage.pandac.tree.VariableType

================================================================================
Recursive-descent parser which constructs an abstract syntax tree from Panda 
source code. The Panda grammar is *mostly* context-free LALR(1), but there are a
couple spots where we require additional lookahead or a bit of context. I have 
done my best to keep the comments at the beginning of each method which formally
describe the grammar accurate, but don't take them as gospel without looking at
the code.
================================================================================
class PandaParser {
    ============================================================================
    The lexer we are using as a token source.
    ============================================================================
    var lexer:PandaLexer := new PandaLexer()

    def errors:ErrorReporter

    ============================================================================
    Holds nodes inserted using `pushback()`. `nextToken()` will pull from here
    first.
    ============================================================================
    @private
    def pushbackBuffer := new Array<Token>()

    @private
    var inLookahead := false

    @private
    def lookaheadBuffer := new Array<Token>()
    
    ============================================================================
    Current indentation level for debug output.
    ============================================================================
    @private
    var indent := 0
    
    ============================================================================
    True if we are currently in a method with a return type.
    ============================================================================
    @private
    var expectReturnValue:Bit
    
    ============================================================================
    True if we are currently in a 'case' or 'assert' (causes us to treat ':' as 
    ending the case / assert rather than beginning a typeDeclaration for a 
    lambda).

    Note that this is 100% ok in the case of 'case', but means that asserts may
    run into parse errors when including single-parameter explicitly-typed 
    lambdas. Including such a lambda in an assert is hopefully a vanishingly-
    rare case, and fortunately there's an easy workaround: just put parentheses 
    around the parameter. I'd like to actually fix the parsing at some point, 
    but I will probably wait until somebody actually runs into this in the wild.
    ============================================================================
    @private
    var suppressLambdas:Bit
    
    ============================================================================
    Loop labels we have encountered while parsing the current method.
    ============================================================================
    @private
    def loopLabels := new HashSet<String>()

    constructor(errors:ErrorReporter) {
        self.errors := errors
    }

    ============================================================================
    Returns the next token from the lexer.
    
    @return the next token in the input stream
    ============================================================================
    @protected
    method nextToken():Token {
        def result:Token
        if pushbackBuffer.length > 0 {
            result := pushbackBuffer[pushbackBuffer.length - 1]
            pushbackBuffer.removeIndex(pushbackBuffer.length - 1)
        }
        else {
            do {
                result := lexer.next()
            }
            while result.type = TokenType.WHITESPACE | 
                    result.type = TokenType.LINECOMMENT | 
                    result.type = TokenType.BLOCKCOMMENT
            if result.type = TokenType.UNTERMINATED_STRING
                error("unterminated string literal", result)
            if inLookahead
                lookaheadBuffer.add(result)
        }
        return result
    }
    
    ============================================================================
    "Unreads" the specified token, pushing it back onto the stream so it will be
    the next token read.
    
    @param t the token to push back
    ============================================================================
    @protected
    method pushback(t:Token) {
        pushbackBuffer.add(t)
    }
    
    ============================================================================
    Returns the next token without consuming it.
    
    @return the next token from the lexer
    ============================================================================
    @protected
    method peek():Token {
        if pushbackBuffer.length = 0
            pushback(nextToken())
        return pushbackBuffer[pushbackBuffer.length - 1]
    }

    @protected
    method checkNext(type:TokenType):Token? {
        var t := nextToken()
        if t.type = type {
            return t
        }
        else {
            pushback(t)
            return null
        }
    }

    @protected
    method expect(type:TokenType, message:String):Token? {
        var t := nextToken()
        if t.type = type
            return t
        else {
            error("expected " + message + ", but found '" + t + "'", t)
            return null
        }
    }
 
    @protected
    method error(s:String, t:Token) {
        error(s, t.position)
    }
    
    @protected
    method error(s:String, position:Position) {
        if !inLookahead
            errors.error(s, position)
    }
    
    @protected
    @pre(!inLookahead)
    method startLookahead() {
        lookaheadBuffer.clear()
        inLookahead := true
        lookaheadBuffer.addAll(pushbackBuffer)
    }
    @post(inLookahead)

    @protected
    @pre(inLookahead)
    method rollback() {
        pushbackBuffer.clear()
        for i in lookaheadBuffer.length - 1 ... 0 by -1
            pushback(lookaheadBuffer[i])
        inLookahead := false
    }
    @post(!inLookahead)

    @protected
    @pre(inLookahead)
    method endLookahead() {
        inLookahead := false
    }
    @post(!inLookahead)

    ============================================================================
    file = bodyEntry* EOF
    ============================================================================
    @protected
    method file():ASTFile? {
        def name    := lexer.lex.file
        def entries := new Array<ASTNode>()
        while peek().type != TokenType.EOF {
            def entry := bodyEntry()
            if entry = null
                continue
            entries.add(entry)
        }
        return new ASTFile(name, entries)
    }

    ============================================================================
    instanceDeclaration = INSTANCE type
    ============================================================================
    @protected
    method instanceDeclaration():ASTNode? {
        if expect(TokenType.INSTANCE, "'@$instance'") = null
            return null
        def type := type()
        if type = null
            return null

        -- not implemented!
        return null
    }

    ============================================================================
    bodyEntry = (DOCCOMMENT? annotations (classDeclaration | 
                    interfaceDeclaration | enum | methodDeclaration) |
                packageDeclaration | usesStatement | instance | simpleStatement
    ============================================================================
    @protected
    method bodyEntry():ASTNode? {
        var t := peek()
        switch t.type {
            case TokenType.DOCCOMMENT, TokenType.PROTECTED, TokenType.PRIVATE,
                    TokenType.ATCLASS, TokenType.FINAL, TokenType.ABSTRACT,
                    TokenType.EXTERNAL, TokenType.OVERRIDE, TokenType.READONLY, 
                    TokenType.MATH, TokenType.LIMITED, TokenType.SAFERETURN, 
                    TokenType.PRE, TokenType.WRAPPER_METHOD, TokenType.CLASS, 
                    TokenType.INTERFACE, TokenType.ENUM, TokenType.METHOD, 
                    TokenType.FUNCTION: {
                def doccommentNode := checkNext(TokenType.DOCCOMMENT)
                def doccomment:String?
                if doccommentNode != null
                    doccomment := doccommentNode.text
                else
                    doccomment := null
                def annotations := annotations()
                t := peek()
                switch t.type {
                    case TokenType.CLASS: 
                        return classDeclaration(doccomment, annotations)
                    case TokenType.INTERFACE: 
                        return interfaceDeclaration(doccomment, 
                                annotations)
                    case TokenType.METHOD, TokenType.FUNCTION:
                        return methodDeclaration(doccomment, annotations)
                    case TokenType.ENUM: 
                        return enumeration(doccomment, annotations)
                    default: {                    
                        def next := nextToken()
                        error("expected 'class' or 'method', found '" + 
                                next.text + "' instead", next)
                        return null
                    }
                }
            }
            case TokenType.PACKAGE: return packageDeclaration()
            case TokenType.USES: return usesStatement()
            case TokenType.INSTANCE:
                return instanceDeclaration()
            default:
                return simpleStatement()
        }
    }
    
    ============================================================================
    packageDeclaration = PACKAGE IDENTIFIER (DOT IDENTIFIER)*
    ============================================================================
    @protected
    method packageDeclaration():ASTPackageDeclaration? {
        def start := expect(TokenType.PACKAGE, "'package'")
        if start = null
            return null
        def name := new MutableString()
        var t := expect(TokenType.IDENTIFIER, "package name")
        if t = null
            return null
        name.append(t.text)
        while checkNext(TokenType.DOT) != null {
            name.append(".")
            t := expect(TokenType.IDENTIFIER, 
                    "identifer as part of package name")
            if t = null
                return null
            name.append(t)
        }
        return new ASTPackageDeclaration(start.position, name->>(String))
    }

    ============================================================================
    usesStatement = USES IDENTIFIER (DOT IDENTIFIER)* (DOT STAR)?
            (AS IDENTIFIER)?
    ============================================================================
    @protected
    method usesStatement():ASTUsesDeclaration? {
        def start := expect(TokenType.USES, "'uses'")
        if start = null
            return null
        def name := new MutableString()
        var t := expect(TokenType.IDENTIFIER, "class name")
        if t = null
            return null
        name.append(t.text)
        while checkNext(TokenType.DOT) != null {
            name.append(".")
            t := nextToken()
            if t.type != TokenType.IDENTIFIER & t.type != TokenType.MUL {
                error("expected identifier or '*', " +
                        "found '\{t}'", t.position)
                return null
            }
            name.append(t.text)
        }
        def alias:String?
        if checkNext(TokenType.AS) != null {
            def next := expect(TokenType.IDENTIFIER, "identifier")
            if next = null
                return null
            alias := next.text
        }
        else
            alias := null
        return new ASTUsesDeclaration(start.position, name->>(String), alias)
    }

    ============================================================================
    classMembers = (invariant | 
            DOCCOMMENT? annotations (methodDeclaration | varDeclaration))*
    ============================================================================
    @protected
    method classMembers():(ListView<ASTMethod>, ListView<ASTField>, 
            ListView<ASTInvariant>)? {
        def methods := new Array<ASTMethod>()
        def fields := new Array<ASTField>()
        def invariants := new Array<ASTInvariant>()
        while peek().type != TokenType.RBRACE {
            if peek().type = TokenType.INVARIANT {
                def inv := invariant()
                if inv = null
                    return null
                invariants.add(inv)
            }
            else {
                def doccommentNode := checkNext(TokenType.DOCCOMMENT)
                def doccomment:String?
                if doccommentNode != null
                    doccomment := doccommentNode.text
                else
                    doccomment := null
                def ann := annotations()
                if ann = null
                    return null
                switch peek().type {
                    case TokenType.METHOD,
                            TokenType.FUNCTION,
                            TokenType.CONSTRUCTOR: {
                        def m := methodDeclaration(doccomment, ann)
                        if m = null
                            return null
                        methods.add(m)
                    }
                    case TokenType.VAR, TokenType.DEF, TokenType.PROPERTY, 
                            TokenType.CONSTANT: {
                        def v := varDeclaration()
                        if v = null
                            return null
                        fields.add(new ASTField(doccomment, ann, v))
                    }
                    default: {
                        def t := nextToken()
                        error("expected 'method', 'var', or 'constant', but " +
                            "found '\{t}'", t)
                    }
                }
            }
        }
        return (methods, fields, invariants)
    }

    ============================================================================
    classDeclaration = CLASS IDENTIFIER genericParametersDeclaration? 
            (COLON classType)? types? LBRACE classMembers RBRACE
    ============================================================================
    @protected
    method classDeclaration(doccomment:String?, 
            annotations:ListView<ASTAnnotation>?):ASTClass? {
        def start := expect(TokenType.CLASS, "'class'")
        if start = null
            return null
        def name := expect(TokenType.IDENTIFIER, "class name (an identifier)")
        if name = null
            return null
        def genericParameters:ListView<ASTTypedIdentifier>?
        if peek().type = TokenType.LT {
            genericParameters := genericParametersDeclaration()
            if genericParameters = null
                return null
        }
        else
            genericParameters := null
        def superclass:ASTType?
        if checkNext(TokenType.COLON) != null {
            superclass := classType()
            if superclass = null
                return null
        }
        else
            superclass := null
        def interfaces:ListView<ASTType>?
        if peek().type = TokenType.LPAREN {
            interfaces := types()
            if interfaces = null
                return null
        }
        else
            interfaces := null
        if expect(TokenType.LBRACE, "'{' to begin class body") = null
            return null
        def members := classMembers()
        if members = null
            return null
        def methods, fields, invariants := members
        expect(TokenType.RBRACE, "'}' to complete class body")
        return new ASTClass(start.position, name.text, false, doccomment, 
                annotations, superclass, interfaces, genericParameters, 
                methods, fields, invariants, 
                lexer.lex.file.endsWith(".plink"))
    }
    
    ============================================================================
    interfaceDeclaration = INTERFACE IDENTIFIER genericParametersDeclaration? 
            (COLON classType (COMMA classType)*)? LBRACE classMemberDeclaration* 
            RBRACE
    ============================================================================
    @protected
    method interfaceDeclaration(doccomment:String?, 
            annotations:ListView<ASTAnnotation>?):ASTClass? {
        def start := expect(TokenType.INTERFACE, "'interface'")
        if start = null
            return null
        def name := expect(TokenType.IDENTIFIER, 
                "interface's name (an identifier)")
        if name = null
            return null
        def genericParameters:ListView<ASTTypedIdentifier>?
        if peek().type = TokenType.LT {
            genericParameters := genericParametersDeclaration()
            if genericParameters = null
                return null
        }
        else
            genericParameters := null
        def interfaces:ListView<ASTType>?
        if checkNext(TokenType.COLON) != null {
            def intf := new Array<ASTType>()
            var t := classType()
            if t = null
                return null
            intf.add(t)
            while checkNext(TokenType.COMMA) != null {
                t := classType()
                if t = null
                    return null
                intf.add(t)
            }
            interfaces := intf
        }
        else
            interfaces := null
        if expect(TokenType.LBRACE, "'{' to begin interface body") = null
            return null
        def members := classMembers()
        if members = null
            return null
        def methods, fields, invariants := members
        expect(TokenType.RBRACE, "'}' to complete class body")
        return new ASTClass(start.position, name.text, true, doccomment, 
                annotations, null, interfaces, genericParameters, methods,
                fields, invariants, lexer.lex.file.endsWith(".plink"))
    }

    ============================================================================
    enum = ENUM LBRACE (DOCCOMMENT? IDENTIFIER (COMMA DOCCOMMENT? IDENTIFIER)*)? 
            RBRACE
    ============================================================================
    @protected
    method enumeration(doccomment:String?, 
            annotations:ListView<ASTAnnotation>?):ASTNode? {
        def start := expect(TokenType.ENUM, "'enum'")
        if start = null
            return null
        def name := expect(TokenType.IDENTIFIER, "enum's name (an identifier)")
        if name = null
            return null
        if expect(TokenType.LBRACE, "'{' to begin enum body") = null
            return null
        def values := new Array<ASTEnumValue>()
        if peek().type != TokenType.RBRACE {
            var doccommentNode := checkNext(TokenType.DOCCOMMENT)
            var valueDoccomment:String?
            if doccommentNode != null
                valueDoccomment := doccommentNode.text
            else
                valueDoccomment := null
            var value := expect(TokenType.IDENTIFIER, "identifier")
            if value = null
                return null
            values.add(new ASTEnumValue(value.position, value.text, 
                    valueDoccomment))
            while checkNext(TokenType.COMMA) != null {
                doccommentNode := checkNext(TokenType.DOCCOMMENT)
                if doccommentNode != null
                    valueDoccomment := doccommentNode.text
                else
                    valueDoccomment := null
                value := expect(TokenType.IDENTIFIER, "identifier")
                if value = null
                    return null
                values.add(new ASTEnumValue(value.position, value.text, 
                        valueDoccomment))
            }
            expect(TokenType.RBRACE, "'}' to complete enum body")
        }
        return new ASTEnum(start.position, name.text, doccomment, annotations, 
                values)
    }
    
    ============================================================================
    methodName = IDENTIFIER | ADD | SUB | MUL | DIV | INTDIV | POW | EQ | GT | 
            LT | GTEQ | LTEQ | REM | AND | BITWISEAND | OR | BITWISEOR | XOR |
            BITWISEXOR | NOT | BITWISENOT | SHIFTLEFT | SHIFTRIGHT | 
            CONVERT | (LBRACKET (DOTDOT | ELLIPSIS)? RBRACKET ASSIGNMENT?)
    ============================================================================
    @protected
    method methodName():String? {
        def name := new MutableString()
        def t := nextToken()
        name.append(t.text)
        switch t.type {
            case TokenType.IDENTIFIER:
                if checkNext(TokenType.ASSIGNMENT) != null
                    name.append(":=")
            case TokenType.ADD,
                     TokenType.SUB,
                     TokenType.MUL,
                     TokenType.DIV,
                     TokenType.INTDIV,
                     TokenType.POW,
                     TokenType.EQ,
                     TokenType.GT,
                     TokenType.LT,
                     TokenType.GTEQ,
                     TokenType.LTEQ,
                     TokenType.REM,
                     TokenType.AND,
                     TokenType.BITWISEAND,
                     TokenType.OR,
                     TokenType.BITWISEOR,
                     TokenType.XOR,
                     TokenType.BITWISEXOR,
                     TokenType.NOT,
                     TokenType.BITWISENOT,
                     TokenType.SHIFTLEFT,
                     TokenType.SHIFTRIGHT,
                     TokenType.CONVERT: { }
            case TokenType.LBRACKET: {
                if checkNext(TokenType.DOTDOT) != null {
                    name.append("..")
                }
                else if checkNext(TokenType.ELLIPSIS) != null {
                    name.append("...")
                }
                if expect(TokenType.RBRACKET, "']'") = null
                    return null
                name.append("]")
                if checkNext(TokenType.ASSIGNMENT) != null
                    name.append(":=")
            }
            default: {
                error("'\{t}' is not a valid method name", t.position)
                return null
            }
        }
        return name->>(String)
    }

    ============================================================================
    methodDeclaration = ((METHOD | FUNCTION) IDENTIFIER) | CONSTRUCTOR) 
            genericParametersDeclaration? formalParameterList 
            typeDeclaration? block? postcondition*
    ============================================================================
    @protected
    method methodDeclaration(doccomment:String?, 
            annotations:ListView<ASTAnnotation>?):ASTMethod? {
        loopLabels.clear()
        def methodTypeNode := nextToken()
        def methodType:MethodNodeType
        switch methodTypeNode.type {
            case TokenType.FUNCTION:
                methodType := MethodNodeType.FUNCTION
            case TokenType.METHOD:
                methodType := MethodNodeType.METHOD
            case TokenType.CONSTRUCTOR:
                methodType := MethodNodeType.CONSTRUCTOR
            default: {
                error("expected 'method', 'function', or 'constructor'",
                        methodTypeNode)
                return null
            }
        }
        
        def name:String?
        if methodType = MethodNodeType.CONSTRUCTOR {
            name := MethodNode.CONSTRUCTOR_NAME
        }
        else {
            name := methodName()
            if name = null
                return null
        }
        if peek().type = TokenType.LT {
            def genericParameters := genericParametersDeclaration()
            throw new NotSupportedException()
        }
        def parameters := formalParameterList()
        if parameters = null
            return null
        def returnType:ASTType?
        if methodType = MethodNodeType.FUNCTION | 
                peek().type = TokenType.COLON {
            expectReturnValue := true
            returnType := typeDeclaration()
            if returnType = null
                return null
        }
        else {
            expectReturnValue := false
            returnType := null
        }
        def body:ASTBlock?
        if peek().type = TokenType.LBRACE {
            body := block()
            if body = null
                return null
        }
        else
            body := null
        def postconditions := new Array<ASTPostcondition>()
        while peek().type = TokenType.POST | peek().type = TokenType.POST_AND {
            def post := postcondition()
            if post != null
                postconditions.add(post)
        }
        return new ASTMethod(methodTypeNode.position, name, methodType, 
            doccomment, annotations, parameters, returnType, body, 
            postconditions)
    }

    ============================================================================
    formalParameter = VAR? IDENTIFIER (COLON | CONVERT) type ELLIPSIS?
    ============================================================================
    @protected
    method formalParameter():ASTParameter? {
        def isVar := checkNext(TokenType.VAR) != null
        def name := expect(TokenType.IDENTIFIER, 
                "parameter name (an identifier)")
        if name = null
            return null
        def next := nextToken()
        def isConvert:Bit
        switch next.type {
            case TokenType.COLON:   isConvert := false
            case TokenType.CONVERT: isConvert := true
            default: {
                error("expected ':' or '->>' after parameter name", next)
                return null
            }
        }
        def t := type()
        if t = null
            return null
        def isVarArg := checkNext(TokenType.ELLIPSIS) != null
        return new ASTParameter(name.position, name.text, t, isVar, isConvert, 
                isVarArg)
    }
    
    ============================================================================
    formalParameterList = LPAREN formalParameter (COMMA formalParameter)* RPAREN
    ============================================================================
    @protected
    method formalParameterList():ListView<ASTParameter>? {
        def result := new Array<ASTParameter>()
        if expect(TokenType.LPAREN, "'(' to begin parameter list") = null
            return null
        if peek().type != TokenType.RPAREN {
            var p := formalParameter()
            if p = null
                return null
            result.add(p)
            while checkNext(TokenType.COMMA) != null {
                p := formalParameter()
                if p = null
                    return null
                result.add(p)
            }
        }
        expect(TokenType.RPAREN, "', children)' to complete parameter list")
        return result
    }

    ============================================================================
    methodValue = (FUNCTION | METHOD) formalParameterList typeDeclaration? block
    ============================================================================
    @protected
    method methodValue():ASTMethodValue? {
        def t := nextToken()
        def methodType:MethodNodeType
        switch t.type {
            case TokenType.METHOD:
                methodType := MethodNodeType.METHOD
            case TokenType.FUNCTION:
                methodType := MethodNodeType.FUNCTION
            default: {
                error("expected 'function' or 'method', " +
                        "but found '" + t + "'", t.position)
                return null
            }
        }
        def parameters := formalParameterList()
        if parameters = null
            return null
        def returnType:ASTType?
        def oldExpect := expectReturnValue
        if peek().type = TokenType.COLON {
            returnType := typeDeclaration()
            if returnType = null
                return null
            expectReturnValue := true
        }
        else {
            returnType := null
            expectReturnValue := false
        }
        def bl := block()
        expectReturnValue := oldExpect
        if bl = null
            return null
        return new ASTMethodValue(t.position, methodType, parameters, 
                returnType, bl)
    }

    ============================================================================
    typeDeclaration = COLON type
    ============================================================================
    @protected
    method typeDeclaration():ASTType? {
        if expect(TokenType.COLON, "':'") = null
            return null
        return type()
    }

    ============================================================================
    varDeclaration = (VAR | DEF | CONSTANT | PROPERTY) (IDENTIFIER | UNDERSCORE) 
            typeDeclaration? (COMMA (IDENTIFIER | UNDERSCORE) typeDeclaration?)* 
            (ASSIGNMENT expression)?
    ============================================================================
    @protected
    method varDeclaration():ASTVarDeclaration? {
        def vars := new Array<ASTTypedIdentifier>()
        def start := nextToken()
        def varType:VariableType
        switch start.type {
            case TokenType.VAR:      varType := VariableType.VAR
            case TokenType.DEF:      varType := VariableType.DEF
            case TokenType.CONSTANT: varType := VariableType.CONSTANT
            case TokenType.PROPERTY: varType := VariableType.PROPERTY
            default: {
                error("expected 'var', 'def', 'constant', or " +
                        "'property', but found '\{start.text}'", start.position)
                return null
            }
        }
        var name := checkNext(TokenType.UNDERSCORE) 
        if name = null {
            name := expect(TokenType.IDENTIFIER,
                    "variable name (an identifier)")
            if name = null
                return null
        }
        var type:ASTType?
        if peek().type = TokenType.COLON {
            type := typeDeclaration()
            if type = null
                return null
        }
        else
            type := null
        vars.add(new ASTTypedIdentifier(name.position, name.text, type))
        while checkNext(TokenType.COMMA) != null {
            name := checkNext(TokenType.UNDERSCORE) 
            if name = null {
                name := expect(TokenType.IDENTIFIER,
                        "variable name (an identifier)")
                if name = null
                    return null
            }
            if peek().type = TokenType.COLON {
                type := typeDeclaration()
                if type = null
                    return null
            }
            else
                type := null
            vars.add(new ASTTypedIdentifier(name.position, name.text, type))
        }
        def initializer:ASTExpression?
        if checkNext(TokenType.ASSIGNMENT) != null
            initializer := expression()
        else
            initializer := null
        return new ASTVarDeclaration(start.position, varType, 
                vars, initializer)
    }
    
    ============================================================================
    genericParametersDeclaration = LT IDENTIFIER typeDeclaration? 
            (COMMA IDENTIFIER typeDeclaration?)? GT
    ============================================================================
    @protected
    method genericParametersDeclaration():ListView<ASTTypedIdentifier>? {
        if expect(TokenType.LT, "'<'") = null
            return null
        def result := new Array<ASTTypedIdentifier>()
        var name := expect(TokenType.IDENTIFIER, 
                "generic parameter name (an identifier)")
        if name = null
            return null
        var type:ASTType?
        if peek().type = TokenType.COLON {
            type := typeDeclaration()
            if type = null
                return null
        }
        else
            type := null
        result.add(new ASTTypedIdentifier(name.position, name.text, type))
        while checkNext(TokenType.COMMA) != null {
            name := expect(TokenType.IDENTIFIER, 
                    "generic parameter name (an identifier)")
            if name = null
                return null
            if peek().type = TokenType.COLON {
                type := typeDeclaration()
                if type = null
                    return null
            }
            else
                type := null
            result.add(new ASTTypedIdentifier(name.position, name.text, type))
        }
        expect(TokenType.GT, 
                "',' or '>', to continue or complete generic parameters")
        return result
    }

    ============================================================================
    genericParameters = LT type (COMMA type)? GT
    ============================================================================
    @protected
    method genericParameters():ListView<ASTType>? {
        def result := new Array<ASTType>()
        if expect(TokenType.LT, "'<'") = null
            return null
        def first := type()
        if first = null
            return null
        result.add(first)
        while checkNext(TokenType.COMMA) != null {
            def next := type()
            if next = null
                return null
            result.add(next)
        }
        expect(TokenType.GT, 
                "',' or '>', to continue or complete generic parameters")
        return result
    }
    
    ============================================================================
    annotations = PROTECTED | PRIVATE | ATCLASS | IMMUTABLE | SINGLETON |
            FINAL | ABSTRACT | NATIVE | OVERRIDE | WRAPPER_METHOD |
            mathAnnotation | precondition
    ============================================================================
    @protected
    method annotations():ListView<ASTAnnotation>? {
        def result := new Array<ASTAnnotation>()
        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.PROTECTED,
                        TokenType.PRIVATE,
                        TokenType.ATCLASS,
                        TokenType.THREAD,
                        TokenType.ABSTRACT,
                        TokenType.EXTERNAL,
                        TokenType.OVERRIDE,
                        TokenType.READONLY,
                        TokenType.LIMITED,
                        TokenType.ATSELF,
                        TokenType.SAFERETURN,
                        TokenType.UNSAFEFUNCTION,
                        TokenType.FINAL,
                        TokenType.WRAPPER_METHOD:
                    result.add(new ASTSimpleAnnotation(t.position, t.text))
                case TokenType.MATH: {
                    pushback(t)
                    def ma := mathAnnotation()
                    if ma = null
                        return null
                    result.add(ma)
                }
                case TokenType.PRE, TokenType.PRE_OR: {
                    pushback(t)
                    def pre := precondition()
                    if pre = null
                        return null
                    result.add(pre)
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return result
    }
    
    ============================================================================
    mathAnnotation = MATH LPAREN OVERFLOW RPAREN
    ============================================================================
    @protected
    @self
    method mathAnnotation():ASTSimpleAnnotation? {
        def start := expect(TokenType.MATH, "'@math'") 
        if start = null
            return null
        if expect(TokenType.LPAREN, "'(' for @math annotation") = null
            return null
        if expect(TokenType.OVERFLOW, "'overflow' for @math annotation") = null
            return null
        if expect(TokenType.RPAREN, "')' to complete @math annotation") = null
            return null
        return new ASTSimpleAnnotation(start.position, "@math(overflow)")
    }
    
    ============================================================================
    invariant = INVARIANT LPAREN expression RPAREN
    ============================================================================
    @protected
    @self
    method invariant():ASTInvariant? {
        def start := expect(TokenType.INVARIANT, "'@invariant'")
        if start = null
            return null
        if expect(TokenType.LPAREN, "'(' for @invariant") = null
            return null
        def expr := expression()
        if expr = null
            return null
        expect(TokenType.RPAREN, "')' to complete @invariant")
        return new ASTInvariant(start.position, expr)
    }
    
    ============================================================================
    precondition = (PRE | PRE_OR) LPAREN expression RPAREN
    ============================================================================
    @protected
    @self
    method precondition():ASTPrecondition? {
        var start := checkNext(TokenType.PRE_OR) 
        if start = null {
            start := expect(TokenType.PRE, "'@pre'")
            if start = null
                return null
        }
        expect(TokenType.LPAREN, "'(' for precondition")
        def expr := expression()
        if expr = null
            return null
        expect(TokenType.RPAREN, "')' to complete precondition")
        return new ASTPrecondition(start.position, expr, 
                start.type = TokenType.PRE_OR)
    }

    ============================================================================
    postcondition = POST LPAREN expression RPAREN
    ============================================================================
    @protected
    @self
    method postcondition():ASTPostcondition? {
        var start := checkNext(TokenType.POST_AND) 
        if start = null {
            start := expect(TokenType.POST, "'@post'")
            if start = null
                return null
        }
        expect(TokenType.LPAREN, "'(' for postcondition")
        def expr := expression()
        if expr = null
            return null
        expect(TokenType.RPAREN, "')' to complete postcondition")
        return new ASTPostcondition(start.position, expr, 
                start.type = TokenType.POST_AND)
    }

    ============================================================================
    classType = IDENTIFIER (DOT IDENTIFIER)* genericParameters? question?
    ============================================================================
    @protected
    @self
    method classType():ASTClassType? {
        def name := new MutableString()
        def start := expect(TokenType.IDENTIFIER, "type name (an identifier)")
        if start = null
            return null
        name.append(start.text)
        while checkNext(TokenType.DOT) != null {
            name.append(".")
            def next := expect(TokenType.IDENTIFIER, 
                    "identifier as part of type name")
            if next = null
                return null
            name.append(next.text)
        }
        def parameters:ListView<ASTType>?
        if peek().type = TokenType.LT
            parameters := genericParameters()
        else
            parameters := null
        def nullable := checkNext(TokenType.QUESTION) != null
        return new ASTClassType(start.position, name->>(String), parameters, 
                nullable)
    }

    ============================================================================
    methodOrTupleType = LPAREN (type (COMMA type)*)? RPAREN 
            ((YIELDS | YIELDS_METHOD | YIELDS_IMMUTABLE | 
            YIELDS_METHOD_IMMUTABLE) LPAREN type? RPAREN)? QUESTION?
    ============================================================================
    @protected
    @self
    method methodOrTupleType():ASTType? {
        def start := expect(TokenType.LPAREN, "'('")
        if start = null
            return null
        def parameters := new Array<ASTType>()
        if peek().type != TokenType.RPAREN {
            var t := type()
            if t = null
                return null
            parameters.add(t)
            while checkNext(TokenType.COMMA) != null {
                t := type()
                if t = null
                    return null
                parameters.add(t)
            }
        }
        if expect(TokenType.RPAREN, "')'") = null
            return null
        def yields := nextToken()
        def isFunction:Bit
        def isImmutable:Bit
        switch yields.type {
            case TokenType.YIELDS: {
                isFunction := true
                isImmutable := false
            }
            case TokenType.YIELDS_METHOD: {
                isFunction := false
                isImmutable := false
            }
            case TokenType.YIELDS_IMMUTABLE: {
                isFunction := true
                isImmutable := true
            }
            case TokenType.YIELDS_METHOD_IMMUTABLE: {
                isFunction := false
                isImmutable := true
            }
            default: {
                pushback(yields)
                def question := checkNext(TokenType.QUESTION)
                def isNullable := question != null
                return new ASTTupleType(start.position, parameters, isNullable)
            }
        }
        if expect(TokenType.LPAREN, "'(' after '\{yields}' in method type") =
                null
            return null
        def returnType:ASTType?
        if checkNext(TokenType.RPAREN) = null {
            returnType := type()
            if returnType = null 
                return null
            expect(TokenType.RPAREN, "')' to complete method type")
        }
        else
            returnType := null
        def isNullable := checkNext(TokenType.QUESTION) != null
        return new ASTMethodType(start.position, parameters, returnType,
                isNullable, isFunction, isImmutable)
    }

    ============================================================================
    type = methodOrTupleType | classType
    ============================================================================
    @protected
    @self
    method type():ASTType? {
        if peek().type = TokenType.LPAREN
            return methodOrTupleType()
        else
            return classType()
    }
    
    ============================================================================
    parameters = LPAREN (expression (COMMA expression)*)? RPAREN
    ============================================================================
    @protected
    @self
    method parameters():Array<ASTExpression>? {
        if expect(TokenType.LPAREN, "'(' to begin parameters") = null
            return null
        def result := new Array<ASTExpression>()
        if checkNext(TokenType.RPAREN) = null {
            def first := expression()
            if first = null
                return null
            result.add(first)
            while checkNext(TokenType.COMMA) != null {
                def next := expression()
                if next = null
                    return null
                result.add(next)
            }
            expect(TokenType.RPAREN, "')' to complete parameters")
        }
        return result
    }

    ============================================================================
    construct = NEW type parameters
    ============================================================================
    @protected
    @self
    method construct():ASTExpression? {
        def start := expect(TokenType.NEW, "'new'") 
        if start = null
            return null
        def type := type()
        if type = null
            return null
        def parameters := parameters()
        if parameters = null
            return null
        return new ASTNew(start.position, type, parameters)
    }

    ============================================================================
    arrayLiteral = LBRACKET (expression (COMMA expression)*)? RBRACKET
    ============================================================================
    @protected
    @self
    method arrayLiteral():ASTArrayLiteral? {
        def values := new Array<ASTExpression>()
        def start := expect(TokenType.LBRACKET, "'['")
        if start = null
            return null
        if checkNext(TokenType.RBRACKET) = null {
            def first := expression()
            if first = null
                return null
            values.add(first)
            while checkNext(TokenType.COMMA) != null {
                def next := expression()
                if next = null
                    return null
                values.add(next)
            }
            expect(TokenType.RBRACKET, "',' or ']' to continue or " +
                    "complete array")
        }
        return new ASTArrayLiteral(start.position, values)
    }

    ============================================================================
    unparenthesizedLambda = IDENTIFIER typeDeclaration? YIELDS expression
    ============================================================================
    @protected
    @self
    method unparenthesizedLambda():ASTLambdaExpression? {
        def start := expect(TokenType.IDENTIFIER, "lambda parameter name")
        if start = null
            return null
        def type:ASTType?
        if peek().type = TokenType.COLON {
            type := typeDeclaration()
            if type = null
                return null
        }
        else
            type := null
        if expect(TokenType.YIELDS, "'=>'") = null
            return null
        def result := expression()
        if result = null
            return null
        def parameters := new Array<ASTTypedIdentifier>()
        parameters.add(new ASTTypedIdentifier(start.position, start.text, type))
        return new ASTLambdaExpression(start.position, parameters, result)
    }

    ============================================================================
    parenthesizedLambda = LPAREN IDENTIFIER typeDeclaration? (COMMA 
            IDENTIFIER typeDeclaration?)* RPAREN YIELDS expression
    ============================================================================
    @protected
    @self
    @pre(!inLookahead)
    method parenthesizedLambda():ASTLambdaExpression? {
        startLookahead()

        def start := expect(TokenType.LPAREN, "'('")
        if start = null {
            rollback()
            return null
        }
        def identifiers := new Array<String>()
        def types := new Array<ASTType>()
        var id := expect(TokenType.IDENTIFIER, "an identifier")
        if id = null {
            rollback()
            return null
        }
        identifiers.add(id.text)
        if peek().type = TokenType.COLON {
            def type := typeDeclaration()
            if type = null {
                rollback()
                return null
            }
            types.add(type)
        }
        while checkNext(TokenType.COMMA) != null {
            id := expect(TokenType.IDENTIFIER, "an identifier")
            if id = null {
                rollback()
                return null
            }
            identifiers.add(id.text)
            if peek().type = TokenType.COLON {
                def type := typeDeclaration()
                if type = null {
                    rollback()
                    return null
                }
                types.add(type)
            }
        }
        if expect(TokenType.RPAREN, "')'") = null {
            rollback()
            return null
        }
        if expect(TokenType.YIELDS, "'=>'") = null {
            rollback()
            return null
        }

        endLookahead()

        def result := expression()
        if result = null {
            -- return a dummy lambda to keep parenthesizedExpression() from 
            -- reattempting the parse
            return new ASTLambdaExpression(start.position, 
                    new Array<ASTTypedIdentifier>(),
                    new ASTSelf(start.position))
        }
        if types.length != 0 & types.length != identifiers.length {
            error("either all lambda parameters must have type " +
                    "declarations, or none must", start.position)
            -- return a dummy lambda to keep parenthesizedExpression() from 
            -- reattempting the parse
            return new ASTLambdaExpression(start.position, 
                    new Array<ASTTypedIdentifier>(),
                    new ASTSelf(start.position))
        }
        def parameters := new Array<ASTTypedIdentifier>()
        for i, name in identifiers {
            if types.length = 0 {
                parameters.add(new ASTTypedIdentifier(
                        start.position, name, null))
            }
            else {
                parameters.add(new ASTTypedIdentifier(
                        start.position, name, types[i]))
            }
        }
        return new ASTLambdaExpression(start.position, parameters, result)
    }

    ============================================================================
    parenthesizedExpression = parenthesizedLambda | LPAREN expression (COMMA 
            expression)* RPAREN
    ============================================================================
    @protected
    @self
    method parenthesizedExpression():ASTExpression? {
        def lambda := parenthesizedLambda()
        if lambda != null
            return lambda

        def start := expect(TokenType.LPAREN, "'('")
        if start = null
            return null
        def expressions := new Array<ASTExpression>()
        var expr := expression()
        if expr = null
            return null
        expressions.add(expr)
        while checkNext(TokenType.COMMA) != null {
            expr := expression()
            if expr = null
                return null
            expressions.add(expr)
        }
        if expect(TokenType.RPAREN, "')'") = null
            return null
        if expressions.length = 1 {
            -- basic parenthesized expression
            return expressions[0]
        }
        return new ASTTupleExpression(start.position, expressions)
    }

    ============================================================================
    classLiteral = CLASS LPAREN classType RPAREN
    ============================================================================
    @protected
    @self
    method classLiteral():ASTClassLiteral? {
        if expect(TokenType.CLASS, "'class'") = null
            return null
        if expect(TokenType.LPAREN, "'(' after 'class'") = null
            return null
        def t := classType()
        if t = null
            return null
        expect(TokenType.RPAREN, "')' after class name")
        return new ASTClassLiteral(t)
    }

    -- FIXME switch to built-in string parser when it exists
    @private
    @pre(base >= 2 & base <= 36)
    function parseInt(s:String, base:UInt):UInt64? {
        var result:UInt64 := 0
        constant DIGITS := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        constant DIGITS_LOWER := "0123456789abcdefghijklmnopqrstuvwxyz"
        for i in 0 .. s.length {
            var digit := DIGITS.indexOf(s[i])->(UInt?)
            if digit = null
                digit := DIGITS_LOWER.indexOf(s[i])->(UInt?)
            if digit = null | digit >= base
                return null
            result := result * base + digit
        }
        return result
    }
    
    @private
    @pre(t.type = TokenType.NUMBER)
    method parseNumericLiteral(t:Token):ASTExpression {
        def value:UInt64?
        if t.text.startsWith("0x") | t.text.startsWith("0X")
            value := parseInt(t.text[2..], 16)
        else if t.text.startsWith("0b") | t.text.startsWith("0B")
            value := parseInt(t.text[2..], 2)
        else
            value := t.text->>(UInt64?)
        if value != null
            return new ASTIntegerLiteral(t.position, value)
        else {
            def real := t.text->>(Real64?)
            if real != null
                return new ASTRealLiteral(t.position, real)
            else {
                error("invalid numeric literal", t.position)
                return new ASTIntegerLiteral(t.position, 0)
            }
        }
    }

    ============================================================================
    term = NUMBER | TRUE | FALSE | NULL | STRING | PLUGIN | IDENTIFIER | SELF |
            SUPER | CLASS | lambdaOrTuple | construct | arrayLiteral | 
            mapLiteral | methodValue | classLiteral | ATRETURN | PRE LPAREN 
            expression RPAREN | CONSTRUCTOR
    ============================================================================
    @protected
    @self
    method term():ASTExpression? {
        def t := nextToken()
        switch t.type {
            case TokenType.NUMBER:
                return parseNumericLiteral(t)
            case TokenType.TRUE:
                return new ASTBitLiteral(t.position, true)
            case TokenType.FALSE:
                return new ASTBitLiteral(t.position, false)
            case TokenType.NULL:
                return new ASTNullLiteral(t.position)
            case TokenType.STRING:
                return new ASTStringLiteral(t.position, 
                        t.text[1 .. t.text.length - 1])
            case TokenType.SELF:
                return new ASTSelf(t.position)
            case TokenType.SUPER:
                return new ASTSuper(t.position)
            case TokenType.PLUGIN:
                return new ASTPlugin(t.position, t.text[1 .. t.text.length - 1])
            case TokenType.IDENTIFIER: { 
                if !suppressLambdas {
                    -- check for a lambda
                    def p := peek().type
                    if p = TokenType.YIELDS | p = TokenType.COLON {
                        pushback(t)
                        return unparenthesizedLambda()
                    }
                }
                return new ASTIdentifier(t.position, t.text)
            }
            case TokenType.LPAREN: {
                pushback(t)
                return parenthesizedExpression()
            }
            case TokenType.ATRETURN:
                return new ASTAtReturn(t.position)
            case TokenType.PRE: {
                if expect(TokenType.LPAREN, "'(' following '@pre'") = null
                    return null
                def result := expression()
                if result = null
                    return null
                if expect(TokenType.RPAREN, "')' to complete @pre") = null
                    return null
                return new ASTPre(t.position, result)
            }
            case TokenType.NEW: {
                pushback(t)
                return construct()
            }
            case TokenType.LBRACKET: {
                pushback(t)
                return arrayLiteral()
            }
            case TokenType.FUNCTION,
                 TokenType.METHOD: {
                pushback(t)
                return methodValue()
            }
            case TokenType.CLASS: {
                if peek().type = TokenType.LPAREN {
                    pushback(t)
                    return classLiteral()
                }
                else {
                    return new ASTDotExpression(new ASTSelf(t.position), 
                            t.text)
                }
            }
            case TokenType.CONSTRUCTOR: {
                return new ASTDotExpression(new ASTSelf(t.position), 
                        t.text)
            }
            default: {
                error("expected an expression, but found '" + t + "'", t)
                return null
            }
        }
    }

    ============================================================================
    types = LPAREN (type (COMMA type)*)? RPAREN
    ============================================================================
    @protected
    @self
    method types():ListView<ASTType>? {
        def result := new Array<ASTType>()
        if expect(TokenType.LPAREN, "'(' to begin parameters") = null
            return null
        if checkNext(TokenType.RPAREN) = null {
            var t := type()
            if t = null
                return null
            result.add(t)
            while checkNext(TokenType.COMMA) != null {
                t := type()
                if t = null
                    return null
                result.add(t)
            }
            expect(TokenType.RPAREN, "')' to complete parameters")
        }
        return result
    }

    ============================================================================
    callExpression = term (parameters | 
                LBRACKET expression RBRACKET |
                DOT (IDENTIFIER | CLASS | CONSTRUCTOR) |
                MEMBER IDENTIFIER types? |
                ((INSTANCEOF | NINSTANCEOF | CAST | CONVERT) 
                        LPAREN type RPAREN)*
    ============================================================================
    @protected
    @self
    method callExpression():ASTExpression? {
        var result := term()
        if result = null
            return null
        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.LPAREN: {
                    pushback(t)
                    def p := parameters()
                    if p = null
                        return null
                    result := new ASTCallExpression(result, p)
                }
                case TokenType.LBRACKET: {
                    def index := expression()
                    if index = null
                        return null
                    expect(TokenType.RBRACKET, "']'")
                    result := new ASTIndex(result, index)
                }
                case TokenType.DOT: {
                    def next := nextToken()
                    if next.type != TokenType.IDENTIFIER & 
                            next.type != TokenType.CLASS &
                            next.type != TokenType.CONSTRUCTOR {
                        error("expected identifier, but found " + next.text,
                                next.position)
                        return null
                    }
                    result := new ASTDotExpression(result, next->>(String))
                }
                case TokenType.MEMBER: {
                    def right := methodName()
                    if right = null
                        return null
                    if peek().type = TokenType.LPAREN {
                        def types := types()
                        return new ASTMemberExpression(result, right, types)
                    }
                    return new ASTMemberExpression(result, right, null)
                }
                case TokenType.INSTANCEOF,
                        TokenType.NINSTANCEOF,
                        TokenType.CAST,
                        TokenType.CONVERT: {
                    expect(TokenType.LPAREN, "'(' after '\{t}'")
                    def right := type()
                    if right = null
                        return null
                    expect(TokenType.RPAREN, "')' after type name")
                    def arrowType:ArrowOperationType
                    switch t.type {
                        case TokenType.INSTANCEOF:  
                            arrowType := ArrowOperationType.INSTANCE_OF
                        case TokenType.NINSTANCEOF:
                            arrowType := ArrowOperationType.NOT_INSTANCE_OF
                        case TokenType.CAST:
                            arrowType := ArrowOperationType.CAST
                        case TokenType.CONVERT:
                            arrowType := ArrowOperationType.CONVERT
                        default:
                            unreachable
                    }
                    result := new ASTArrowExpression(arrowType, result, right)
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return result
    }

    ============================================================================
    exponentExpression = callExpression (POW callExpression)*
    ============================================================================
    @protected
    @self
    method exponentExpression():ASTExpression? {
        var result := callExpression()
        if result = null
            return null
        while checkNext(TokenType.POW) != null {
            def right := callExpression()
            if right = null
                return null
            result := new ASTBinaryExpression(BinaryOperationType.POWER, result, 
                    right)
        }
        return result
    }

    ============================================================================
    unaryExpression = unaryOperator? exponentExpression
    ============================================================================
    @protected
    @self
    method unaryExpression():ASTExpression? {
        def t := nextToken()
        switch t.type {
            case TokenType.SUB: {
                def value := exponentExpression()
                if value = null
                    return null
                return new ASTUnaryExpression(t.position, 
                        UnaryOperationType.MINUS, value)
            }
            case TokenType.NOT: {
                def value := exponentExpression()
                if value = null
                    return null
                return new ASTUnaryExpression(t.position, 
                        UnaryOperationType.NOT, value)
            }
            case TokenType.BITWISENOT: {
                def value := exponentExpression()
                if value = null
                    return null
                return new ASTUnaryExpression(t.position, 
                        UnaryOperationType.BITWISE_NOT, value)
            }
            default: {
                pushback(t)
                return exponentExpression()
            }
        }
    }

    ============================================================================
    Checks whether the character immediately following this token is a GT. See
    `multiplicativeExpression` for details.
    ============================================================================
    @private
    @self
    method nextIsGT(t:Token):Bit {
        def next := peek()
        if next.type = TokenType.GT {
            def p1 := t.position
            def p2 := next.position
            return p1.line = p2.line & p1.column + 1 = p2.column
        }
        return false
    }

    @private
    function getBinaryOperationType(t:TokenType):BinaryOperationType {
        switch t {
            case TokenType.ADD: return BinaryOperationType.ADD
            case TokenType.SUB: return BinaryOperationType.SUBTRACT
            case TokenType.MUL: return BinaryOperationType.MULTIPLY
            case TokenType.DIV: return BinaryOperationType.DIVIDE
            case TokenType.INTDIV: return BinaryOperationType.INT_DIVIDE
            case TokenType.REM: return BinaryOperationType.REMAINDER
            case TokenType.POW: return BinaryOperationType.POWER
            case TokenType.AND: return BinaryOperationType.AND
            case TokenType.OR:  return BinaryOperationType.OR
            case TokenType.XOR: return BinaryOperationType.XOR
            case TokenType.BITWISEAND: return BinaryOperationType.BITWISE_AND
            case TokenType.BITWISEOR:  return BinaryOperationType.BITWISE_OR
            case TokenType.BITWISEXOR: return BinaryOperationType.BITWISE_XOR
            case TokenType.SHIFTLEFT:   return BinaryOperationType.SHIFT_LEFT
            case TokenType.SHIFTRIGHT:  return BinaryOperationType.SHIFT_RIGHT
            case TokenType.EQ:  return BinaryOperationType.EQUAL
            case TokenType.NEQ: return BinaryOperationType.NOT_EQUAL
            case TokenType.IDENTITY:  return BinaryOperationType.IDENTITY
            case TokenType.NIDENTITY: return BinaryOperationType.NOT_IDENTITY
            case TokenType.GT:   return BinaryOperationType.GREATER_THAN
            case TokenType.GTEQ: return BinaryOperationType.GREATER_THAN_OR_EQUAL
            case TokenType.LT:   return BinaryOperationType.LESS_THAN
            case TokenType.LTEQ: return BinaryOperationType.LESS_THAN_OR_EQUAL
            default: unreachable
        }
    }

    @private
    function getBinaryOperationType(s:String):BinaryOperationType {
        switch s {
            case "+":   return BinaryOperationType.ADD
            case "-":   return BinaryOperationType.SUBTRACT
            case "*":   return BinaryOperationType.MULTIPLY
            case "/":   return BinaryOperationType.DIVIDE
            case "//":  return BinaryOperationType.INT_DIVIDE
            case "%":   return BinaryOperationType.REMAINDER
            case "^":   return BinaryOperationType.POWER
            case "&":   return BinaryOperationType.AND
            case "|":   return BinaryOperationType.OR
            case "~":   return BinaryOperationType.XOR
            case "&&":  return BinaryOperationType.BITWISE_AND
            case "||":  return BinaryOperationType.BITWISE_OR
            case "~~":  return BinaryOperationType.BITWISE_XOR
            case "<<":  return BinaryOperationType.SHIFT_LEFT
            case ">>":  return BinaryOperationType.SHIFT_RIGHT
            case "=":   return BinaryOperationType.EQUAL
            case "!=":  return BinaryOperationType.NOT_EQUAL
            case "==":  return BinaryOperationType.IDENTITY
            case "!==": return BinaryOperationType.NOT_IDENTITY
            case ">":   return BinaryOperationType.GREATER_THAN
            case ">=":  return BinaryOperationType.GREATER_THAN_OR_EQUAL
            case "<":   return BinaryOperationType.LESS_THAN
            case ">=":  return BinaryOperationType.LESS_THAN_OR_EQUAL
            default: unreachable
        }
    }    

    ============================================================================
    multiplicativeExpression = unaryExpression ((MUL | DIV | INTDIV | REM |
            SHIFTLEFT | SHIFTRIGHT | BITWISEAND | BITWISEXOR) unaryExpression)*
    Note that SHIFTRIGHT is handled specially, as the lexer only produces GT and
    we synthesize the SHIFTRIGHT token here.
    ============================================================================
    @protected
    @self
    method multiplicativeExpression():ASTExpression? {
        var result := unaryExpression()
        if result = null
            return null
        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.MUL, 
                        TokenType.DIV,
                        TokenType.INTDIV, 
                        TokenType.REM,
                        TokenType.SHIFTLEFT,
                        TokenType.BITWISEAND,
                        TokenType.BITWISEXOR: {
                    def right := unaryExpression()
                    if right = null
                        return null
                    result := new ASTBinaryExpression(getBinaryOperationType(
                            t.type), result, right)
                }
                case TokenType.GT: {
                    if nextIsGT(t) {
                        -- ">>"
                        nextToken() -- consume '>'
                        def right := unaryExpression()
                        if right = null
                            return null
                        result := new ASTBinaryExpression(
                                BinaryOperationType.SHIFT_RIGHT, result, right)
                    }
                    else {
                        -- just a plain ">", don't handle it here
                        pushback(t)
                        break
                    }
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return result
    }

    ============================================================================
    additiveExpression = multiplicativeExpression 
            ((ADD | SUB | BITWISEOR) multiplicativeExpression)*
    ============================================================================
    @protected
    @self
    method additiveExpression():ASTExpression? {
        var result := multiplicativeExpression()
        if result = null
            return result
    
        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.ADD, TokenType.SUB, TokenType.BITWISEOR: {
                    def right := multiplicativeExpression()
                    if right = null
                        return null
                    result := new ASTBinaryExpression(getBinaryOperationType(
                            t.type), result, right)
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return result
    }

    ============================================================================
    rangeExpression = additiveExpression ((DOTDOT | ELLIPSIS)
            additiveExpression? 
            (BY additiveExpression)?)?
    ============================================================================
    @protected
    @self
    method rangeExpression():ASTExpression? {
        var result:ASTExpression?
        var p := peek()
        def position := p.position
        if p.type = TokenType.DOTDOT | p.type = TokenType.ELLIPSIS
            result := null
        else {
            result := additiveExpression()
            if result = null
                return null
        }
        var range := checkNext(TokenType.DOTDOT)
        if range = null
            range := checkNext(TokenType.ELLIPSIS)
        if range != null {
            def next := peek().type
            def right:ASTExpression?
            if next = TokenType.NUMBER | next = TokenType.IDENTIFIER | 
                    next = TokenType.SUB | next = TokenType.BITWISENOT |
                    next = TokenType.STRING | next = TokenType.LPAREN
                right := additiveExpression()
            else
                right := null
            def step:ASTExpression?
            if checkNext(TokenType.BY) != null
                step := additiveExpression()
            else
                step := null
            result := new ASTRangeExpression(position, result, right, step, 
                    range = TokenType.ELLIPSIS)
        }
        return result
    }

    ============================================================================
    comparisonExpression = rangeExpression ((EQ | IDENTITY | NEQ | 
            NIDENTITY | LT | GT | LTEQ | GTEQ | IN) rangeExpression)*
    ============================================================================
    @protected
    @self
    method comparisonExpression():ASTExpression? {
        var result := rangeExpression()
        if result = null
            return null

        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.EQ, 
                        TokenType.IDENTITY,
                        TokenType.NEQ,
                        TokenType.NIDENTITY,
                        TokenType.LT,
                        TokenType.GT,
                        TokenType.LTEQ,
                        TokenType.GTEQ,
                        TokenType.IN: {
                    def right := rangeExpression()
                    if right = null
                        return null
                    result := new ASTBinaryExpression(
                            getBinaryOperationType(t.type), result, right)
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return result
    }

    ============================================================================
    andExpression = comparisonExpression ((AND | XOR) comparisonExpression)*
    ============================================================================
    @protected
    @self
    method andExpression():ASTExpression? {
        var result := comparisonExpression()
        if result = null
            return null

        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.AND, TokenType.XOR: {
                    def right := comparisonExpression()
                    if right = null
                        return null
                    result := new ASTBinaryExpression(
                            getBinaryOperationType(t.type), result, right)
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return result
    }

    ============================================================================
    orExpression = andExpression (OR andExpression)*
    ============================================================================
    @protected
    @self
    method orExpression():ASTExpression? {
        var result := andExpression()
        if result = null
            return null
        while checkNext(TokenType.OR) != null {
            def right := andExpression()
            if right = null
                return null
            result := new ASTBinaryExpression(BinaryOperationType.OR, result, 
                    right)
        }
        return result
    }

    ============================================================================
    expression = orExpression
    ============================================================================
    @protected
    @self
    method expression():ASTExpression? {
        return orExpression()
    }

    ============================================================================
    simpleStatement = assertStatement | varDeclaration | 
            anyLoop | expressionOrAssignment | ifStatement | switchStatement |
            tryStatement
    ============================================================================
    @protected
    @self
    method simpleStatement():ASTStatement? {
        var t := peek()
        switch t.type {
            case TokenType.ASSERT: 
                return assertStatement()
            case TokenType.VAR, TokenType.DEF, TokenType.CONSTANT: 
                return varDeclaration()
            case TokenType.IDENTIFIER: {
                t := nextToken()
                if peek().type = TokenType.COLON {
                    pushback(t)
                    return anyLoop()
                }
                else {
                    pushback(t)
                    return expressionOrAssignment()
                }
            }
            case TokenType.SELF,
                    TokenType.NEW,
                    TokenType.LBRACKET,
                    TokenType.SUPER,
                    TokenType.CONSTRUCTOR:
                return expressionOrAssignment()
            case TokenType.WHILE,
                    TokenType.FOR,
                    TokenType.DO,
                    TokenType.LOOP: 
                return anyLoop()
            case TokenType.IF: 
                return ifStatement()
            case TokenType.SWITCH: 
                return switchStatement()
            case TokenType.TRY: 
                return tryStatement()
            default: {
                -- consume the token so we don't keep re-erroring on it
                nextToken()
                switch t.type {
                    case TokenType.RETURN, TokenType.BREAK, TokenType.CONTINUE,
                            TokenType.THROW, TokenType.UNREACHABLE: {
                        error("'\{t}' must be the final statement of a block", 
                                t)
                        return null
                    }
                    default: {
                        error("syntax error, expected statement but found " +
                                "'\{t}'", t)
                        return null
                    }
                }
            }
        }
    }

    ============================================================================
    block = LBRACE statement* terminalStatement? RBRACE
    ============================================================================
    @protected
    @self
    method block():ASTBlock? {
        def start := expect(TokenType.LBRACE, "'{'")
        if start = null
            return null
        def statements := new Array<ASTStatement>()
        loop {
            def t := peek()
            switch t.type {
                case TokenType.RETURN, TokenType.BREAK, TokenType.CONTINUE,
                        TokenType.THROW, TokenType.UNREACHABLE: {
                    def st := terminalStatement()
                    if st = null
                        return null
                    statements.add(st)
                    expect(TokenType.RBRACE, "'}' to complete block")
                    break
                }
                case TokenType.RBRACE: {
                    expect(TokenType.RBRACE, "'}' to complete block")
                    break
                }
                default: {
                    def st := statement()
                    if st = null
                        return null
                    statements.add(st)
                }
            }
        }
        return new ASTBlock(start.position, statements)
    }

    ============================================================================
    statement = block | simpleStatement
    ============================================================================
    @protected
    @self
    method statement():ASTStatement? {
        if peek().type = TokenType.LBRACE
            return block()
        else
            return simpleStatement()
    }

    ============================================================================
    statementOrBlock = simpleStatement | block | terminalStatement
    ============================================================================
    @protected
    @self
    method statementOrBlock():ASTStatement? {
        def t := peek()
        switch t.type {
            case TokenType.RETURN,
                    TokenType.BREAK,
                    TokenType.CONTINUE,
                    TokenType.THROW,
                    TokenType.UNREACHABLE: 
                return terminalStatement()
            case TokenType.LBRACE: 
                return block()
            default: 
                return simpleStatement()
        }
    }

    ============================================================================
    assertStatement = ASSERT expression (COMMA expression)?
    ============================================================================
    @protected
    @self
    method assertStatement():ASTAssert? {
        def start := expect(TokenType.ASSERT, "'assert'")
        if start = null
            return null
        suppressLambdas := true
        def test := expression()
        if test = null
            return null
        suppressLambdas := false
        def error:ASTExpression?
        if checkNext(TokenType.COLON) != null {
            error := expression()
            if error = null
                return null
        }
        else
            error := null
        return new ASTAssert(start.position, test, error)
    }

    ============================================================================
    returnStatement = RETURN expression?
    only looks for expression if expectReturnValue is true
    ============================================================================
    @protected
    @self
    method returnStatement():ASTReturn? {
        def start := expect(TokenType.RETURN, "'return'")
        if start = null
            return null
        def value:ASTExpression?
        if expectReturnValue
            value := expression()
        else
            value := null
        return new ASTReturn(start.position, value)
    }

    ============================================================================
    breakStatement = BREAK IDENTIFIER?
    only picks up IDENTIFIER it it matches a previously-seen loop label
    ============================================================================
    @protected
    @self
    method breakStatement():ASTBreak? {
        def start := expect(TokenType.BREAK, "'break'")
        if start = null
            return null
        def t := peek()
        def label:String?
        if t.type = TokenType.IDENTIFIER {
            if loopLabels.contains(t.text)
                label := nextToken().text
            else
                label := null
        }
        else
            label := null
        return new ASTBreak(start.position, label)
    }

    ============================================================================
    continueStatement = CONTINUE IDENTIFIER?
    only picks up IDENTIFIER it it matches a previously-seen loop label
    ============================================================================
    @protected
    @self
    method continueStatement():ASTContinue? {
        def start := expect(TokenType.CONTINUE, "'continue'")
        if start = null
            return null
        def t := peek()
        def label:String?
        if t.type = TokenType.IDENTIFIER {
            if loopLabels.contains(t.text)
                label := nextToken().text
            else
                label := null
        }
        else
            label := null
        return new ASTContinue(start.position, label)
    }

    ============================================================================
    terminalStatement = returnStatement | breakStatement | continueStatement |
                        throwStatement | UNREACHABLE
    ============================================================================
    @protected
    @self
    method terminalStatement():ASTStatement? {
        switch peek().type {
            case TokenType.RETURN:
                return returnStatement()
            case TokenType.BREAK:
                return breakStatement()
            case TokenType.CONTINUE: 
                return continueStatement()
            case TokenType.THROW:
                return throwStatement()
            case TokenType.UNREACHABLE: 
                return new ASTUnreachable(nextToken().position)
            default:
                unreachable
        }
    }

    ============================================================================
    forTuple := LPAREN (IDENTIFIER | UNDERSCORE) typeDeclaration? (COMMA 
            (IDENTIFIER | UNDERSCORE) typeDeclaration)+ RPAREN
    ============================================================================
    @protected
    @self
    method forTuple():ListView<ASTTypedIdentifier>? {
        def result := new Array<ASTTypedIdentifier>()
        def start := expect(TokenType.LPAREN, "'('")
        if start = null
            return null
        var name := checkNext(TokenType.UNDERSCORE)
        if name = null {
            name := expect(TokenType.IDENTIFIER, 
                    "variable name (an identifier) after '(' in for-loop")
            if name = null
                return null
        }
        var type:ASTType?
        if peek().type = TokenType.COLON {
            type := typeDeclaration()
            if type = null
                return null
        }
        else
            type := null
        result.add(new ASTTypedIdentifier(name.position, name.text, type))
        while checkNext(TokenType.COMMA) != null {
            name := checkNext(TokenType.UNDERSCORE)
            if name = null {
                name := expect(TokenType.IDENTIFIER, 
                        "variable name (an identifier) after ',' in for-loop")
                if name = null
                    return null
            }
            if peek().type = TokenType.COLON {
                type := typeDeclaration()
                if type = null
                    return null
            }
            else
                type := null
            result.add(new ASTTypedIdentifier(name.position, name.text, type))
        }
        expect(TokenType.RPAREN, "')' after list of variables in for-loop")
        if result.length = 1 {
            error("expected at least two variables in for-loop tuple",
                    start.position)
        }
        return result
    }

    ============================================================================
    anyLoop = (IDENTIFIER COLON)? 
        (
            DO statementOrBlock WHILE expression |
            LOOP statementOrBlock |
            WHILE expression statementOrBlock |
            FOR (IDENTIFIER typeDeclaration? 
                (COMMA (IDENTIFIER typeDeclaration?) | forTuple)? |
                forTuple)  IN expression
        )
    ============================================================================
    @protected
    @self
    method anyLoop():ASTStatement? {
        def label:String?
        var t := nextToken()
        if t.type = TokenType.IDENTIFIER {
            -- label
            label := t.text
            loopLabels.add(label)
            if expect(TokenType.COLON, "':' after loop label") = null
                return null
            t := nextToken()
        }
        else
            label := null
        switch t.type {
            case TokenType.DO: {
                def st := statementOrBlock()
                if st = null
                    return null
                if expect(TokenType.WHILE, "'while'") = null
                    return null
                def expr := expression()
                if expr = null
                    return null
                return new ASTDo(t.position, label, expr, st)
            }
            case TokenType.LOOP: {
                def st := statementOrBlock()
                if st = null
                    return null
                return new ASTLoop(t.position, label, st)
            }
            case TokenType.WHILE: {
                def expr := expression()
                if expr = null
                    return null
                def st := statementOrBlock()
                if st = null
                    return null
                return new ASTWhile(t.position, label, expr, st)
            }
            case TokenType.FOR: {
                def indexVar:ASTTypedIdentifier?
                def vars:ListView<ASTTypedIdentifier>?
                if peek().type = TokenType.LPAREN {
                    indexVar := null
                    vars := forTuple()
                    if vars = null
                        return null
                }
                else {
                    def name := expect(TokenType.IDENTIFIER, 
                            "for-loop variable name (an identifier)")
                    if name = null
                        return null
                    def type:ASTType?
                    if peek().type = TokenType.COLON {
                        type := typeDeclaration()
                        if type = null
                            return null
                    }
                    else
                        type := null
                    if checkNext(TokenType.COMMA) != null {
                        indexVar := new ASTTypedIdentifier(name.position, 
                                name.text, type)
                        if peek().type = TokenType.LPAREN {
                            vars := forTuple()
                            if vars = null
                                return null
                        }
                        else {
                            def valueName := expect(TokenType.IDENTIFIER, 
                                    "for-loop variable name (an identifier)")
                            if valueName = null
                                return null
                            def valueType:ASTType?
                            if peek().type = TokenType.COLON {
                                valueType := typeDeclaration()
                                if valueType = null
                                    return null
                            }
                            else
                                valueType := null
                            def newVars := new Array<ASTTypedIdentifier>()
                            newVars.add(new ASTTypedIdentifier(
                                    valueName.position, valueName.text, 
                                    valueType))
                            vars := newVars
                        }
                    }
                    else {
                        indexVar := null
                        def newVars := new Array<ASTTypedIdentifier>()
                        newVars.add(new ASTTypedIdentifier(name.position, 
                                name.text, type))
                        vars := newVars
                    }
                }
                if expect(TokenType.IN, "'in' in for-loop") = null
                    return null
                def list := expression()
                if list = null
                    return null
                def st := statementOrBlock()
                if st = null
                    return null
                return new ASTFor(t.position, label, indexVar, vars, list, st)                
            }
            default: {
                error("expected 'for', 'while', 'do', or 'loop' after " +
                        "label", t.position)
                return null
            }
        }
    }

    ============================================================================
    ifStatement = IF expression statementOrBlock (ELSE statementOrBlock)?
    ============================================================================
    @protected
    @self
    method ifStatement():ASTIf? {
        def start := expect(TokenType.IF, "'if'")
        if start = null
            return null
        def test := expression()
        if test = null
            return null
        def thenStatement := statementOrBlock()
        if thenStatement = null
            return null
        def elseStatement:ASTStatement?
        if checkNext(TokenType.ELSE) != null {
            elseStatement := statementOrBlock()
            if elseStatement = null
                return null
        }
        else
            elseStatement := null
        return new ASTIf(start.position, test, thenStatement, elseStatement)
    }

    ============================================================================
    switchCase = CASE expression (COMMA expression)* COLON statementOrBlock
    ============================================================================
    @protected
    @self
    method switchCase():ASTSwitchCase? {
        def start := expect(TokenType.CASE, "'case'")
        if start = null
            return null
        suppressLambdas := true
        def values := new Array<ASTExpression>()
        var expr := expression()
        if expr = null
            return null
        values.add(expr)
        while checkNext(TokenType.COMMA) != null {
            expr := expression()
            if expr = null
                return null
            values.add(expr)
        }
        suppressLambdas := false
        if expect(TokenType.COLON, "':' after case value") = null
            return null
        def st := statementOrBlock()
        if st = null
            return null
        return new ASTSwitchCase(start.position, values, st)
    }

    ============================================================================
    switchStatement = SWITCH expression LBRACE switchCase* 
                      (DEFAULT statementOrBlock)* RBRACE
    ============================================================================
    @protected
    @self
    method switchStatement():ASTSwitch? {
        def start := expect(TokenType.SWITCH, "'switch'")
        if start = null
            return null
        def expr := expression()
        if expr = null
            return null
        if expect(TokenType.LBRACE, "'{' to begin switch body") = null
            return null
        def cases := new Array<ASTSwitchCase>()
        while peek().type = TokenType.CASE {
            def c := switchCase()
            if c = null
                return null
            cases.add(c)
        }
        def defaultClause:ASTStatement?
        if checkNext(TokenType.DEFAULT) != null {
            if expect(TokenType.COLON, "':'") = null
                return null
            defaultClause := statementOrBlock()
            if defaultClause = null
                return null
        }
        else
            defaultClause := null
        expect(TokenType.RBRACE, "'}' to complete switch body")
        return new ASTSwitch(start.position, expr, cases, defaultClause)
    }
    
    ============================================================================
    catchBlock = CATCH IDENTIFIER typeDeclaration IDENTIFIER statementOrBlock
    ============================================================================
    @protected
    @self
    method catchClause():ASTCatch? {
        if expect(TokenType.CATCH, "'catch'") = null
            return null
        def id := expect(TokenType.IDENTIFIER, 
                "error variable name for catch (an identifier)")
        if id = null
            return null
        def type := typeDeclaration()
        if type = null
            return null
        def st := statementOrBlock()
        if st = null
            return null
        return new ASTCatch(id.position, id.text, type, st)
    }
    
    ============================================================================
    tryStatement = TRY statementOrBlock ((catchClause+ (FINALLY STATEMENT)?) | 
            (FINALLY STATEMENT))
    ============================================================================
    @protected
    @self
    method tryStatement():ASTTry? {
        def start := expect(TokenType.TRY, "'try'")
        if start = null
            return null
        def st := statementOrBlock()
        if st = null
            return null
        def t := peek().type
        if t != TokenType.CATCH & t != TokenType.FINALLY
            error("try without catch or finally", start.position)
        def catches := new Array<ASTCatch>()
        while peek().type = TokenType.CATCH {
            def c := catchClause()
            if c = null
                return null
            catches.add(c)
        }
        def finallyClause:ASTStatement?
        if checkNext(TokenType.FINALLY) != null
            finallyClause := statementOrBlock()
        else
            finallyClause := null
        return new ASTTry(start.position, st, catches, finallyClause)
    }

    ============================================================================
    throwStatement = THROW expression
    ============================================================================
    @protected
    @self
    method throwStatement():ASTThrow? {
        def start := expect(TokenType.THROW, "'throw'")
        if start = null
            return null
        def error := expression()
        if error = null
            return null
        return new ASTThrow(start.position, error)
    }

    ============================================================================
    Returns `true` if the token ID is one of the assignment operators.
    ============================================================================
    @protected
    function isAssignmentOperator(type:TokenType):Bit {
        switch type {
            case TokenType.ASSIGNMENT, TokenType.ADDEQ, TokenType.SUBEQ,
                    TokenType.MULEQ, TokenType.DIVEQ, TokenType.INTDIVEQ,
                    TokenType.POWEQ, TokenType.REMEQ, TokenType.ANDEQ,
                    TokenType.BITWISEANDEQ, TokenType.OREQ, 
                    TokenType.BITWISEOREQ, TokenType.XOREQ,
                    TokenType.BITWISEXOREQ, TokenType.SHIFTLEFTEQ,
                    TokenType.SHIFTRIGHTEQ:
                return true
            default:
                return false
        }
    }

    ============================================================================
    expressionOrAssignment = expression ((COMMA expression)* assignmentOperator 
            expression)?
    ============================================================================
    @protected
    @self
    method expressionOrAssignment():ASTStatement? {
        def expressions := new Array<ASTExpression>()
        var expr := expression()
        if expr = null
            return null
        expressions.add(expr)
        while checkNext(TokenType.COMMA) != null {
            expr := expression()
            if expr = null
                return null
            expressions.add(expr)
        }
        def op := nextToken()
        if isAssignmentOperator(op.type) {
            expr := expression()
            if expr = null
                return null
            def operatorText := op.text
            assert operatorText.endsWith("=")
            def operationType:BinaryOperationType?
            if operatorText = ":="
                operationType := null
            else {
                operationType := getBinaryOperationType(operatorText[0 .. 
                        operatorText.length - 1])
            }
            return new ASTAssignment(expressions, operationType, expr)
        }
        else {
            pushback(op)
            if expressions.length > 1 {
                error("expected assignment operator after comma-separated " +
                        "expressions", op.position)
            }
            return new ASTExpressionStatement(expressions[0])
        }
    }
    
    @private
    method checkEnd(parsing:String) {
        def next := nextToken()
        if next.type != TokenType.EOF {
            throw new CompilerException("unexpected token after end of " +
                    parsing + ": '\{next.text}'", next.position)
        }
    }

    @self
    method parseFile(name:String, inStream:InputStream):ASTFile? {
        lexer := new PandaLexer(inStream, new Position(name, 1, 1))
        def result := file()
        checkEnd("file")
        return result
    }

    @self
    method parseFile(f:File):ASTFile? {
        return parseFile(f.name, f.openInputStream())
    }
    
    @self
    method parseType(s:String, start:Position):ASTType {
        lexer := new PandaLexer(s, start)
        def result := type()
        if result = null
            throw new CompilerException("FIXME make this return nullable")
        checkEnd("type")
        return result
    }

    @self
    method parseStatement(s:String, start:Position):ParseNode? {
        lexer := new PandaLexer(s, start)
        def result := statement()
        checkEnd("statement")
        return result
    }

    @self
    method parseMethodValue(s:String, start:Position):ParseNode? {
        lexer := new PandaLexer(s, start)
        def result := methodValue()
        checkEnd("method")
        return result
    }

    @self
    method parseBlock(s:String, start:Position):ParseNode? {
        lexer := new PandaLexer(s, start)
        def result := block()
        checkEnd("block")
        return result
    }

    @self
    method parseExpressionWithExtraText(s:String, start:Position):(ASTExpression?, 
            String) {
        lexer := new PandaLexer(s, start)
        suppressLambdas := true
        def result := expression()
        suppressLambdas := false
        def remaining := new MutableString()
        while pushbackBuffer.length > 0 {
            def next := nextToken()
            if next.type != TokenType.EOF
                remaining.append(next)
        }
        remaining.append(lexer.lex.source.readAsString())
        return (result, remaining->>(String))
    }

    @self
    method parseExpression(s:String, start:Position):ParseNode? {
        lexer := new PandaLexer(s, start)
        def result := expression()
        checkEnd("expression")
        return result
    }
}