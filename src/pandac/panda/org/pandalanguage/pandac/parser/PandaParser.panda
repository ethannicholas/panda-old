package org.pandalanguage.pandac.parser

uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.tree.Position

================================================================================
Recursive-descent parser which constructs a parse tree from Panda source code. 
The Panda grammar is *mostly* context-free LALR(1), but there are a couple spots 
where we require additional lookahead or a bit of context. I have done my best 
to keep the comments at the beginning of each method which formally describe the 
grammar accurate, but don't take them as gospel without looking at the code.
================================================================================
class PandaParser {
    ============================================================================
    The lexer we are using as a token source.
    ============================================================================
    @private
    var lexer:PandaLexer := new PandaLexer()
    
    ============================================================================
    Holds nodes inserted using `pushback()`. `nextToken()` will pull from here
    first.
    ============================================================================
    @private
    var pushbackBuffer := new PrimitiveArray<Token>()
    
    ============================================================================
    Current indentation level for debug output.
    ============================================================================
    @private
    var indent := 0
    
    ============================================================================
    True if we are currently in a method with a return type.
    ============================================================================
    @private
    var expectReturnValue:Bit
    
    ============================================================================
    True if we are currently in a 'case' or 'assert' (causes us to treat ':' as 
    ending the case / assert rather than beginning a typeDeclaration for a 
    lambda).

    Note that this is 100% ok in the case of 'case', but means that asserts may
    run into parse errors when including single-parameter explicitly-typed 
    lambdas. Including such a lambda in an assert is hopefully a 
    vanishingly-rare case, and fortunately there's an easy workaround: just put 
    parentheses around the parameter. I'd like to actually fix the parsing at
    some point, but I will probably wait until somebody actually runs into this
    in the wild.
    ============================================================================
    @private
    var suppressLambdas:Bit
    
    ============================================================================
    Loop labels we have encountered while parsing the current method.
    ============================================================================
    @private
    def loopLabels := new HashSet<String>()

    ============================================================================
    Returns the next token from the lexer.
    
    @return the next token in the input stream
    ============================================================================
    @protected
    method nextToken():Token {
        def result:Token
        if pushbackBuffer.length > 0 {
            result := pushbackBuffer[pushbackBuffer.length - 1]
            pushbackBuffer.length -= 1
        }
        else {
            do {
                result := lexer.next()
            }
            while result.type = TokenType.WHITESPACE | 
                    result.type = TokenType.LINECOMMENT | 
                    result.type = TokenType.BLOCKCOMMENT
            if result.type = TokenType.UNTERMINATED_STRING
                error("unterminated string literal", result)
        }
        return result
    }
    
    ============================================================================
    "Unreads" the specified token, pushing it back onto the stream so it will be
    the next token read.
    
    @param t the token to push back
    ============================================================================
    @protected
    method pushback(t:Token) {
        pushbackBuffer.append(t)
    }
    
    ============================================================================
    Returns the next token without consuming it.
    
    @return the next token from the lexer
    ============================================================================
    @protected
    method peek():Token {
        if pushbackBuffer.length = 0
            pushback(nextToken())
        return pushbackBuffer[pushbackBuffer.length - 1]
    }

    ============================================================================
    Peeks at the next token, and consumes it if it is of the specified type.
    Returns the token if it matches, or `null` otherwise.
    
    @param type the type of token to look for
    @return the matching token or `null`
    ============================================================================
    @protected
    method checkNext(type:TokenType, children:Array<ParseNode>):Token? {
        var t := nextToken()
        if t.type = type {
            children.add(new TokenNode(t))
            return t
        }
        else {
            pushback(t)
            return null
        }
    }

    ============================================================================
    Consumes the next token in the input stream, reporting a compile error if it
    is not of the expected type. Returns the consumed token whether or not it
    generated an error.
    
    @param type the expected type of token
    @return the next token
    ============================================================================
    @protected
    method expect(type:TokenType, message:String, 
            children:Array<ParseNode>):Token {
        var t := nextToken()
        children.add(new TokenNode(t))
        if t.type != type
            error("expected " + message + ", but found '" + t + "'", t)
        return t
    }

    @protected
    method error(s:String, t:Token) {
        error(s, t.position)
    }
    
    @protected
    method error(s:String, position:Position) {
        throw new CompilerException(s, position)
    }
    
    ============================================================================
    compilationUnit = bodyEntry* EOF
    ============================================================================
    @protected
    method compilationUnit():ParseNode {
        def children := new Array<ParseNode>()
        while peek().type != TokenType.EOF
            children.add(bodyEntry())
        return new ParseNode(ParseNodeType.COMPILATION_UNIT, children)
    }

    ============================================================================
    instanceDeclaration = INSTANCE type
    ============================================================================
    @protected
    method instanceDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.INSTANCE, "'@$instance'", children)
        children.add(type())
        return new ParseNode(ParseNodeType.INSTANCE_DECLARATION, children)
    }

    ============================================================================
    bodyEntry = (DOCCOMMENT? annotations (classDeclaration | 
                    interfaceDeclaration | enum | methodDeclaration) |
                packageDeclaration | usesStatement | instance | simpleStatement
    ============================================================================
    @protected
    method bodyEntry():ParseNode {
        def children := new Array<ParseNode>()
        var t := peek()
        switch t.type {
            case TokenType.DOCCOMMENT, TokenType.PROTECTED, TokenType.PRIVATE,
                    TokenType.ATCLASS, TokenType.FINAL, TokenType.ABSTRACT,
                    TokenType.EXTERNAL, TokenType.OVERRIDE, TokenType.READONLY, 
                    TokenType.MATH, TokenType.LIMITED, TokenType.SAFERETURN, 
                    TokenType.PRE, TokenType.WRAPPER_METHOD, TokenType.CLASS, 
                    TokenType.INTERFACE, TokenType.ENUM, TokenType.METHOD, 
                    TokenType.FUNCTION: {
                checkNext(TokenType.DOCCOMMENT, children)
                children.add(annotations())
                t := peek()
                switch t.type {
                    case TokenType.CLASS: 
                        children.add(classDeclaration())
                    case TokenType.INTERFACE: 
                        children.add(interfaceDeclaration())
                    case TokenType.METHOD, TokenType.FUNCTION:
                        children.add(methodDeclaration())
                    case TokenType.ENUM: 
                        children.add(enumeration())
                    default: {                    
                        children.add(new TokenNode(nextToken()))
                        error("expected 'class' or 'method', found '" + t.text + 
                                "' instead", t)
                    }
                }
            }
            case TokenType.PACKAGE: children.add(packageDeclaration())
            case TokenType.USES: children.add(usesStatement())
            case TokenType.INSTANCE: children.add(instanceDeclaration())
            default: children.add(simpleStatement())
        }
        return new ParseNode(ParseNodeType.BODY_ENTRY, children)
    }
    
    ============================================================================
    packageDeclaration = PACKAGE IDENTIFIER (DOT IDENTIFIER)*
    ============================================================================
    @protected
    method packageDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.PACKAGE, "'package'", children)
        expect(TokenType.IDENTIFIER, "package name", children)
        while checkNext(TokenType.DOT, children) != null {
            expect(TokenType.IDENTIFIER, "identifer as part of package name",
                    children)
        }
        return new ParseNode(ParseNodeType.PACKAGE_DECLARATION, children)
    }

    ============================================================================
    usesStatement = USES IDENTIFIER (DOT IDENTIFIER)* (DOT STAR)?
            (AS IDENTIFIER)?
    ============================================================================
    @protected
    method usesStatement():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.USES, "'uses'", children)
        expect(TokenType.IDENTIFIER, "class name", children)
        while checkNext(TokenType.DOT, children) != null {
            def token := nextToken()
            if token.type != TokenType.IDENTIFIER & token.type != TokenType.MUL
                throw new CompilerException("expected identifier or '*', " +
                        "found '" + token + "'", token.position)
            children.add(new TokenNode(token))
        }
        if checkNext(TokenType.AS, children) != null
            expect(TokenType.IDENTIFIER, "identifier", children)
        return new ParseNode(ParseNodeType.USES_STATEMENT, children)
    }

    ============================================================================
    interfaces = LPAREN TYPE (COMMA TYPE)* RPAREN
    ============================================================================
    @protected
    method interfaces():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LPAREN, "'('", children)
        children.add(type())
        while checkNext(TokenType.COMMA, children) != null
            children.add(type())
        expect(TokenType.RPAREN, "', children)' to complete interfaces", children)
        return new ParseNode(ParseNodeType.INTERFACES, children)
    }

    ============================================================================
    classMembers = classMemberDeclaration*
    ============================================================================
    @protected
    method classMembers():ParseNode {
        def children := new Array<ParseNode>()
        while peek().type != TokenType.RBRACE
            children.add(classMemberDeclaration())
        return new ParseNode(ParseNodeType.CLASS_MEMBERS, children)
    }

    ============================================================================
    classDeclaration = CLASS IDENTIFIER genericParametersDeclaration? 
            (COLON classType)? interfaces? LBRACE classMembers RBRACE
    ============================================================================
    @protected
    method classDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.CLASS, "'class'", children)
        expect(TokenType.IDENTIFIER, "class' name (an identifier)", children)
        if peek().type = TokenType.LT
            children.add(genericParametersDeclaration())
        if checkNext(TokenType.COLON, children) != null
            children.add(classType())
        if peek().type = TokenType.LPAREN
            children.add(interfaces())
        expect(TokenType.LBRACE, "'{' to begin class body", children)
        children.add(classMembers())
        expect(TokenType.RBRACE, "'}' to complete class body", children)
        return new ParseNode(ParseNodeType.CLASS_DECLARATION, children)
    }
    
    ============================================================================
    interfaceDeclaration = INTERFACE IDENTIFIER genericParametersDeclaration? 
            (COLON classType (COMMA classType)*)? LBRACE classMemberDeclaration* 
            RBRACE
    ============================================================================
    @protected
    method interfaceDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.INTERFACE, "'interface'", children)
        expect(TokenType.IDENTIFIER, "interface's name (an identifier)",
                children)
        if peek().type = TokenType.LT
            children.add(genericParametersDeclaration())
        if checkNext(TokenType.COLON, children) != null {
            children.add(classType())
            while checkNext(TokenType.COMMA, children) != null
                children.add(classType())
        }
        expect(TokenType.LBRACE, "'{' to begin interface body", children)
        children.add(classMembers())
        expect(TokenType.RBRACE, "'}' to complete interface body", children)
        return new ParseNode(ParseNodeType.INTERFACE_DECLARATION, children)
    }

    ============================================================================
    enum = ENUM LBRACE (DOCCOMMENT? IDENTIFIER (COMMA DOCCOMMENT? IDENTIFIER)*)? 
            RBRACE
    ============================================================================
    @protected
    method enumeration():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.ENUM, "'enum'", children)
        expect(TokenType.IDENTIFIER, "enum's name (an identifier)", children)
        expect(TokenType.LBRACE, "'{' to begin enum body", children)
        var t := nextToken()
        children.add(new TokenNode(t))
        if t.type = TokenType.DOCCOMMENT {
            t := nextToken()
            children.add(new TokenNode(t))
        }
        if t.type = TokenType.IDENTIFIER {
            while checkNext(TokenType.RBRACE, children) = null {
                expect(TokenType.COMMA, 
                        "',' or '}', to either continue or complete enum",
                        children)
                checkNext(TokenType.DOCCOMMENT, children)
                expect(TokenType.IDENTIFIER, "enum entry name (an identifier)",
                        children)
            }
        }
        else if t.type != TokenType.RBRACE {
            error("expected '}' to complete enum body, but found '" + t + "'", 
                    t)
        }
        return new ParseNode(ParseNodeType.ENUM, children)
    }
    
    ============================================================================
    classMemberDeclaration = invariant | 
            DOCCOMMENT? annotations (methodDeclaration | fieldDeclaration)
    ============================================================================
    @protected
    method classMemberDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        if peek().type = TokenType.INVARIANT
            children.add(invariant())
        else {
            checkNext(TokenType.DOCCOMMENT, children)
            children.add(annotations())
            switch peek().type {
                case TokenType.METHOD,
                        TokenType.FUNCTION,
                        TokenType.CONSTRUCTOR: 
                    children.add(methodDeclaration())
                case TokenType.VAR, TokenType.DEF, TokenType.PROPERTY, 
                        TokenType.CONSTANT: 
                    children.add(fieldDeclaration())
                default: {
                    def t := nextToken()
                    error("expected 'method', 'var', or 'constant', but " +
                        "found '\{t}'", t)
                }
            }
        }
        return new ParseNode(ParseNodeType.CLASS_MEMBER_DECLARATION, children)
    }
    
    ============================================================================
    methodName = IDENTIFIER | ADD | SUB | MUL | DIV | INTDIV | POW | EQ | GT | 
            LT | GTEQ | LTEQ | REM | AND | BITWISEAND | OR | BITWISEOR | XOR |
            BITWISEXOR | NOT | BITWISENOT | SHIFTLEFT | SHIFTRIGHT | 
            CONVERT | (LBRACKET (DOTDOT | ELLIPSIS)? RBRACKET ASSIGNMENT?)
    ============================================================================
    @protected
    method methodName():ParseNode {
        def children := new Array<ParseNode>()
        def t := nextToken()
        children.add(new TokenNode(t))
        switch t.type {
            case TokenType.IDENTIFIER:
                checkNext(TokenType.ASSIGNMENT, children)
            case TokenType.ADD,
                     TokenType.SUB,
                     TokenType.MUL,
                     TokenType.DIV,
                     TokenType.INTDIV,
                     TokenType.POW,
                     TokenType.EQ,
                     TokenType.GT,
                     TokenType.LT,
                     TokenType.GTEQ,
                     TokenType.LTEQ,
                     TokenType.REM,
                     TokenType.AND,
                     TokenType.BITWISEAND,
                     TokenType.OR,
                     TokenType.BITWISEOR,
                     TokenType.XOR,
                     TokenType.BITWISEXOR,
                     TokenType.NOT,
                     TokenType.BITWISENOT,
                     TokenType.SHIFTLEFT,
                     TokenType.SHIFTRIGHT,
                     TokenType.CONVERT: { }
            case TokenType.LBRACKET: {
                if checkNext(TokenType.DOTDOT, children) = null
                    checkNext(TokenType.ELLIPSIS, children)
                expect(TokenType.RBRACKET, "']'", children)
                checkNext(TokenType.ASSIGNMENT, children)
            }
            default: 
                error("'\{t}' is not a valid method name", t)
        }
        return new ParseNode(ParseNodeType.METHOD_NAME, children)
    }

    ============================================================================
    methodDeclaration = (METHOD | FUNCTION | CONSTRUCTOR) 
            (methodName if not constructor) 
            genericParametersDeclaration? formalParameterList 
            typeDeclaration? block? postcondition*
    ============================================================================
    @protected
    method methodDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        loopLabels.clear()
        def methodType := nextToken()
        children.add(new TokenNode(methodType))
        switch methodType.type {
            case TokenType.FUNCTION, TokenType.METHOD, TokenType.CONSTRUCTOR: { 
            }
            default: error("expected 'method', 'function', or 'constructor'",
                    methodType)
        }

        if methodType.type != TokenType.CONSTRUCTOR
            children.add(methodName())
        if peek().type = TokenType.LT
            children.add(genericParametersDeclaration())
        children.add(formalParameterList())
        if methodType.type = TokenType.FUNCTION | 
                peek().type = TokenType.COLON {
            expectReturnValue := true
            children.add(typeDeclaration())
        }
        else
            expectReturnValue := false
        if peek().type = TokenType.LBRACE
            children.add(block())
        while peek().type = TokenType.POST | peek().type = TokenType.POST_AND
            children.add(postcondition())
        return new ParseNode(ParseNodeType.METHOD_DECLARATION, children)
    }

    ============================================================================
    formalParameter = VAR? IDENTIFIER (COLON | CONVERT) type ELLIPSIS?
    ============================================================================
    @protected
    method formalParameter():ParseNode {
        def children := new Array<ParseNode>()
        checkNext(TokenType.VAR, children)
        expect(TokenType.IDENTIFIER, "parameter name (an identifier)", children)
        def t := nextToken()
        if t.type != TokenType.COLON & t.type != TokenType.CONVERT
            error("expected ':' or '->>' after parameter name", t)
        children.add(new TokenNode(t))
        children.add(type())
        checkNext(TokenType.ELLIPSIS, children)
        return new ParseNode(ParseNodeType.FORMAL_PARAMETER, children)
    }
    
    ============================================================================
    formalParameterList = LPAREN formalParameter (COMMA formalParameter)* RPAREN
    ============================================================================
    @protected
    method formalParameterList():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LPAREN, "'(' to begin parameter list", children)
        if peek().type != TokenType.RPAREN {
            children.add(formalParameter())
            while checkNext(TokenType.COMMA, children) != null
                children.add(formalParameter())
        }
        expect(TokenType.RPAREN, "', children)' to complete parameter list", 
                children)
        return new ParseNode(ParseNodeType.FORMAL_PARAMETER_LIST, children)
    }

    ============================================================================
    methodValue = (FUNCTION | METHOD) formalParameterList typeDeclaration? block
    ============================================================================
    @protected
    method methodValue():ParseNode {
        def children := new Array<ParseNode>()
        def t := nextToken()
        if t.type != TokenType.FUNCTION & t.type != TokenType.METHOD {
            throw new CompilerException("expected 'function' or 'method', " +
                    "but found '" + t + "'", t.position)
        }
        children.add(new TokenNode(t))
        children.add(formalParameterList())
        if peek().type = TokenType.COLON {
            children.add(typeDeclaration())
            expectReturnValue := true
        }
        else
            expectReturnValue := false
        children.add(block())
        return new ParseNode(ParseNodeType.METHOD_VALUE, children)
    }

    ============================================================================
    fieldDeclaration = (VAR | DEF | PROPERTY | CONSTANT) 
            (IDENTIFIER | UNDERSCORE) typeDeclaration? 
            (COMMA (IDENTIFIER | UNDERSCORE) typeDeclaration?)*
            (ASSIGNMENT expression)?
    ============================================================================
    @protected
    method fieldDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        if checkNext(TokenType.DEF, children) = null & 
                checkNext(TokenType.PROPERTY, children) = null &
                checkNext(TokenType.CONSTANT, children) = null
            expect(TokenType.VAR, "'var'", children)
        if checkNext(TokenType.UNDERSCORE, children) = null
            expect(TokenType.IDENTIFIER, "field name (an identifier)", children)
        if peek().type = TokenType.COLON
            children.add(typeDeclaration())
        while checkNext(TokenType.COMMA, children) != null {
            if checkNext(TokenType.UNDERSCORE, children) = null {
                expect(TokenType.IDENTIFIER, "field name (an identifier)", 
                        children)
            }
            if peek().type = TokenType.COLON
                children.add(typeDeclaration())
        }
        if checkNext(TokenType.ASSIGNMENT, children) != null
            children.add(expression())
        return new ParseNode(ParseNodeType.FIELD_DECLARATION, children)
    }
    
    ============================================================================
    typeDeclaration = COLON type
    ============================================================================
    @protected
    method typeDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.COLON, "':'", children)
        children.add(type())
        return new ParseNode(ParseNodeType.TYPE_DECLARATION, children)
    }

    ============================================================================
    varDeclaration = (VAR | DEF | CONSTANT) (IDENTIFIER | UNDERSCORE) 
            typeDeclaration? (COMMA (IDENTIFIER | UNDERSCORE) typeDeclaration?)* 
            (ASSIGNMENT expression)?
    ============================================================================
    @protected
    method varDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        if checkNext(TokenType.DEF, children) = null &
                checkNext(TokenType.CONSTANT, children) = null
            expect(TokenType.VAR, "'var'", children)
        if checkNext(TokenType.UNDERSCORE, children) = null {
            expect(TokenType.IDENTIFIER, "variable name (an identifier)", 
                    children)
        }
        if peek().type = TokenType.COLON
            children.add(typeDeclaration())
        while checkNext(TokenType.COMMA, children) != null {
            if checkNext(TokenType.UNDERSCORE, children) = null {
                expect(TokenType.IDENTIFIER, "variable name (an identifier)", 
                        children)
            }
            if peek().type = TokenType.COLON
                children.add(typeDeclaration())
        }
        if checkNext(TokenType.ASSIGNMENT, children) != null
            children.add(expression())
        return new ParseNode(ParseNodeType.VAR_DECLARATION, children)
    }
    
    ============================================================================
    genericParametersDeclaration = LT IDENTIFIER typeDeclaration? 
            (COMMA IDENTIFIER typeDeclaration?)? GT
    ============================================================================
    @protected
    method genericParametersDeclaration():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LT, "'<'", children)
        expect(TokenType.IDENTIFIER, "generic parameter name (an identifier)", 
                children)
        if peek().type = TokenType.COLON
            children.add(typeDeclaration())
        while checkNext(TokenType.COMMA, children) != null {
            expect(TokenType.IDENTIFIER, 
                    "generic parameter name (an identifier)", children)
            if peek().type = TokenType.COLON
                children.add(typeDeclaration())
        }
        expect(TokenType.GT, 
                "',' or '>', to continue or complete generic parameters",
                children)
        return new ParseNode(ParseNodeType.GENERIC_PARAMETERS_DECLARATION, 
                children)
    }

    ============================================================================
    genericParameters = LT type (COMMA type)? GT
    ============================================================================
    @protected
    method genericParameters():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LT, "'<'", children)
        children.add(type())
        while checkNext(TokenType.COMMA, children) != null
            children.add(type())
        expect(TokenType.GT, 
                "',' or '>', to continue or complete generic parameters",
                children)
        return new ParseNode(ParseNodeType.GENERIC_PARAMETERS, children)
    }
    
    ============================================================================
    annotations = PROTECTED | PRIVATE | ATCLASS | IMMUTABLE | SINGLETON |
            FINAL | ABSTRACT | NATIVE | OVERRIDE | WRAPPER_METHOD |
            mathAnnotation | precondition
    ============================================================================
    @protected
    method annotations():ParseNode {
        def children := new Array<ParseNode>()
        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.PROTECTED,
                         TokenType.PRIVATE,
                         TokenType.ATCLASS,
                         TokenType.THREAD,
                         TokenType.ABSTRACT,
                         TokenType.EXTERNAL,
                         TokenType.OVERRIDE,
                         TokenType.READONLY,
                         TokenType.LIMITED,
                         TokenType.ATSELF,
                         TokenType.SAFERETURN,
                         TokenType.UNSAFEFUNCTION,
                         TokenType.FINAL,
                         TokenType.WRAPPER_METHOD:
                    children.add(new TokenNode(t))
                case TokenType.MATH: {
                    pushback(t)
                    children.add(mathAnnotation())
                }
                case TokenType.PRE, TokenType.PRE_OR: {
                    pushback(t)
                    children.add(precondition())
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return new ParseNode(ParseNodeType.ANNOTATIONS, children)
    }
    
    ============================================================================
    mathAnnotation = MATH LPAREN OVERFLOW RPAREN
    ============================================================================
    @protected
    @self
    method mathAnnotation():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.MATH, "'@math'", children)
        expect(TokenType.LPAREN, "'(' for @math annotation", children)
        expect(TokenType.OVERFLOW, "'overflow' for @math annotation", children)
        expect(TokenType.RPAREN, "')' to complete @math annotation", children)
        return new ParseNode(ParseNodeType.MATH_ANNOTATION, children)
    }
    
    ============================================================================
    invariant = INVARIANT LPAREN expression RPAREN
    ============================================================================
    @protected
    @self
    method invariant():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.INVARIANT, "'@invariant'", children)
        expect(TokenType.LPAREN, "'(' for @invariant", children)
        children.add(expression())
        expect(TokenType.RPAREN, "')' to complete @invariant", children)
        return new ParseNode(ParseNodeType.INVARIANT, children)
    }
    
    ============================================================================
    precondition = PRE LPAREN expression RPAREN
    ============================================================================
    @protected
    @self
    method precondition():ParseNode {
        def children := new Array<ParseNode>()
        if checkNext(TokenType.PRE_OR, children) = null
            expect(TokenType.PRE, "'@pre'", children)
        expect(TokenType.LPAREN, "'(' for precondition", children)
        children.add(expression())
        expect(TokenType.RPAREN, "')' to complete precondition", children)
        return new ParseNode(ParseNodeType.PRECONDITION, children)
    }

    ============================================================================
    postcondition = POST LPAREN expression RPAREN
    ============================================================================
    @protected
    @self
    method postcondition():ParseNode {
        def children := new Array<ParseNode>()
        if checkNext(TokenType.POST_AND, children) = null
            expect(TokenType.POST, "'@post'", children)
        expect(TokenType.LPAREN, "'(' for postcondition", children)
        children.add(expression())
        expect(TokenType.RPAREN, "')' to complete postcondition", children)
        return new ParseNode(ParseNodeType.POSTCONDITION, children)
    }

    -- there's a bit of awkwardness here with how we handle the 
    -- ParseNodeType.TYPE. Basically there was a ton of code caring about the
    -- structure of a type node, but the structure has become more complex over
    -- time and updating the code to match the structure would be a lot of work.
    -- I decided to relax the requirements on having the parse tree exactly 
    -- match the grammar a bit. Therefore classType, simpleType, methodType, and 
    -- type all result in a single TYPE node being generated.

    ============================================================================
    className = IDENTIFIER (DOT IDENTIFIER)* genericParameters?
    ============================================================================
    @protected
    @self
    method className(children:Array<ParseNode>) {
        expect(TokenType.IDENTIFIER, "type name (an identifier)", children)
        while checkNext(TokenType.DOT, children) != null {
            expect(TokenType.IDENTIFIER, "identifier as part of type name", 
                    children)
        }
        if peek().type = TokenType.LT
            children.add(genericParameters())
    }

    ============================================================================
    classType = className
    ============================================================================
    @protected
    @self
    method classType():ParseNode {
        def children := new Array<ParseNode>()
        className(children)
        return new ParseNode(ParseNodeType.TYPE, children)
    }

    ============================================================================
    simpleType = className QUESTION?
    ============================================================================
    @protected
    @self
    method simpleType():ParseNode {
        def children := new Array<ParseNode>()
        className(children)
        checkNext(TokenType.QUESTION, children)
        return new ParseNode(ParseNodeType.TYPE, children)
    }

    ============================================================================
    methodOrTupleType = LPAREN (type (COMMA type)*)? RPAREN 
            ((YIELDS | YIELDS_METHOD | YIELDS_IMMUTABLE | 
            YIELDS_METHOD_IMMUTABLE) LPAREN type? RPAREN)? QUESTION?
    ============================================================================
    @protected
    @self
    method methodOrTupleType():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LPAREN, "'('", children)
        var t := nextToken()
        if t.type != TokenType.RPAREN {
            pushback(t)
            children.add(type())
            t := nextToken()
            children.add(new TokenNode(t))
            while t.type = TokenType.COMMA {
                children.add(type())
                t := nextToken()
                children.add(new TokenNode(t))
            }
        }
        else
            children.add(new TokenNode(t))
        def yields := peek().type
        if yields = TokenType.YIELDS |
                yields = TokenType.YIELDS_METHOD | 
                yields = TokenType.YIELDS_IMMUTABLE |
                yields = TokenType.YIELDS_METHOD_IMMUTABLE {
            children.add(new TokenNode(nextToken()))
            expect(TokenType.LPAREN, "'(' after '\{yields}' in method type", 
                    children)
            if checkNext(TokenType.RPAREN, children) = null {
                children.add(type())
                expect(TokenType.RPAREN, "')' to complete method type", 
                        children)
            }
        }
        checkNext(TokenType.QUESTION, children)
        return new ParseNode(ParseNodeType.TYPE, children)
    }

    ============================================================================
    type = methodOrTupleType | simpleType
    ============================================================================
    @protected
    @self
    method type():ParseNode {
        if peek().type = TokenType.LPAREN
            return methodOrTupleType()
        else
            return simpleType()
    }
    
    ============================================================================
    parameters = LPAREN (expression (COMMA expression)*)? RPAREN
    ============================================================================
    @protected
    @self
    method parameters():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LPAREN, "'(' to begin parameters", children)
        if checkNext(TokenType.RPAREN, children) = null {
            children.add(expression())
            while checkNext(TokenType.COMMA, children) != null
                children.add(expression())
            expect(TokenType.RPAREN, "')' to complete parameters", children)
        }
        return new ParseNode(ParseNodeType.PARAMETERS, children)
    }

    ============================================================================
    construct = NEW type parameters
    ============================================================================
    @protected
    @self
    method construct():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.NEW, "'new'", children)
        children.add(type())
        children.add(parameters())
        return new ParseNode(ParseNodeType.CONSTRUCT, children)
    }

    ============================================================================
    arrayLiteral = LBRACKET (expression (COMMA expression)*)? RBRACKET
    ============================================================================
    @protected
    @self
    method arrayLiteral():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LBRACKET, "'['", children)
        if checkNext(TokenType.RBRACKET, children) = null {
            children.add(expression())
            while checkNext(TokenType.COMMA, children) != null
                children.add(expression())
            expect(TokenType.RBRACKET, "',' or ']' to continue or " +
                    "complete array", children)
        }
        return new ParseNode(ParseNodeType.ARRAY_LITERAL, children)
    }

    ============================================================================
    mapLiteral = LBRACE (expression COLON expression 
            (COMMA expression COLON expression)*)? RBRACE
    ============================================================================
    @protected
    @self
    method mapLiteral():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LBRACE, "'{'", children)
        if checkNext(TokenType.RBRACE, children) = null {
            children.add(expression())
            expect(TokenType.COLON, "':'", children)
            children.add(expression())
            while checkNext(TokenType.COMMA, children) != null {
                children.add(expression())
                expect(TokenType.COLON, "':'", children)
                children.add(expression())
            }
            expect(TokenType.RBRACE, "',' or '}' to continue or " +
                    "complete map", children)
        }
        return new ParseNode(ParseNodeType.MAP_LITERAL, children)
    }

    -- uh oh! we ran into something that started out looking like a lambda but
    -- turned out not to be; undo it and treat it as a tuple instead. At some
    -- point I may end up having to do a general lookahead solution, but so far
    -- this is the only spot in the grammar requiring additional lookahead
    @private
    method rollbackLambda(children:ListView<ParseNode>):ListView<ParseNode> {
        -- push everything back
        for i in children.length - 1 ... 0 by -1
            pushback(children[i]->(TokenNode).token)
        def newChildren := new Array<ParseNode>()
        expect(TokenType.LPAREN, "'(' to begin tuple", newChildren)
        newChildren.add(expression())
        while checkNext(TokenType.COMMA, newChildren) != null
            newChildren.add(expression())
        expect(TokenType.RPAREN, "')' to complete tuple", newChildren)
        return newChildren
    }

    ============================================================================
    lambda = ((LPAREN ((IDENTIFIER typeDeclaration 
                    (COMMA IDENTIFIER typeDeclaration)*) | 
                    (IDENTIFIER (COMMA IDENTIFIER)*)) 
              RPAREN) | IDENTIFIER typeDeclaration?)
                YIELDS expression()

    Note that lambda can "backtrack" by realizing that it has, in fact, just
    encountered a tuple consisting of identifiers (which looks the same as the
    start of a lambda, e.g. "(x, y)"). It will therefore return either a lambda
    parse node or the sequence of parse nodes for a tuple.
    ============================================================================
    @protected
    @self
    method lambda():(ParseNode?, ListView<ParseNode>?) {
        def children := new Array<ParseNode>()
        var foundTypes := false
        if peek().type = TokenType.LPAREN {
            expect(TokenType.LPAREN, "'('", children)
            expect(TokenType.IDENTIFIER, "identifier for lambda parameter", 
                    children)
            if peek().type = TokenType.COLON {
                foundTypes := true
                children.add(typeDeclaration())
            }
            while checkNext(TokenType.COMMA, children) != null {
                if checkNext(TokenType.IDENTIFIER, children) = null
                    return (null, rollbackLambda(children))
                if foundTypes
                    children.add(typeDeclaration())
            }
            if checkNext(TokenType.RPAREN, children) = null
                return (null, rollbackLambda(children))
        }
        else {
            expect(TokenType.IDENTIFIER, "identifier for lambda parameter", 
                    children)
            if peek().type = TokenType.COLON {
                children.add(typeDeclaration())
                foundTypes := true
            }
        }
        if foundTypes | peek().type = TokenType.YIELDS {
            expect(TokenType.YIELDS, "'=>' after lambda parameters", children)
            children.add(expression())
            return (new ParseNode(ParseNodeType.LAMBDA, children), null)
        }
        else
            return (null, rollbackLambda(children))
    }

    ============================================================================
    classLiteral = CLASS LPAREN classType RPAREN
    ============================================================================
    @protected
    @self
    method classLiteral():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.CLASS, "'class'", children)
        expect(TokenType.LPAREN, "'(' after 'class'", children)
        children.add(classType())
        expect(TokenType.RPAREN, "')' after class name", children)
        return new ParseNode(ParseNodeType.CLASS_LITERAL, children)
    }

    ============================================================================
    term = NUMBER | TRUE | FALSE | NULL | STRING | PLUGIN | IDENTIFIER | SELF |
            SUPER | CLASS | LPAREN expression (COMMA expression)* RPAREN | 
            lambda | construct | arrayLiteral | mapLiteral | methodValue | 
            classLiteral | ATRETURN | PRE LPAREN expression RPAREN | 
    ============================================================================
    @protected
    @self
    method term():ParseNode {
        def children := new Array<ParseNode>()
        def t := nextToken()
        switch t.type {
            case TokenType.NUMBER,
                     TokenType.TRUE,
                     TokenType.FALSE,
                     TokenType.NULL,
                     TokenType.STRING,
                     TokenType.PLUGIN,
                     TokenType.SELF,
                     TokenType.SUPER: {
                children.add(new TokenNode(t))
            }
            case TokenType.IDENTIFIER: { 
                children.add(new TokenNode(t))
                if !suppressLambdas {
                    -- check for a lambda
                    def p := peek().type
                    if p = TokenType.COLON | p = TokenType.YIELDS {
                        pushback(t)
                        def lambda, tuple := lambda()
                        if lambda != null
                            children.add(lambda)
                        else {
                            assert tuple != null
                            children.addAll(tuple)
                        }
                    }
                }
            }
            case TokenType.LPAREN: {
                children.add(new TokenNode(t))
                -- figure out if we've got a parenthesized lambda, i.e.
                -- (x:Real, y:Real) => x + y
                var haveLambda := false
                var id := checkNext(TokenType.IDENTIFIER, children)
                if id != null {
                    def p := peek().type
                    pushback(id)
                    if p = TokenType.COLON | p = TokenType.COMMA {
                        pushback(t)
                        def lambda, tuple := lambda()
                        if lambda != null
                            children.add(lambda)
                        else {
                            assert tuple != null
                            children.addAll(tuple)
                        }
                        haveLambda := true
                    }
                }
                if !haveLambda {
                    children.add(expression())
                    while checkNext(TokenType.COMMA, children) != null
                        children.add(expression())
                    expect(TokenType.RPAREN, "')' to complete expression", 
                            children)
                }
            }
            case TokenType.ATRETURN:
                children.add(new TokenNode(t))
            case TokenType.PRE: {
                children.add(new TokenNode(t))
                expect(TokenType.LPAREN, "'(' following '@pre'", children)
                children.add(expression())
                expect(TokenType.RPAREN, "')' to complete @pre", children)
            }
            case TokenType.NEW: {
                pushback(t)
                children.add(construct())
            }
            case TokenType.LBRACKET: {
                pushback(t)
                children.add(arrayLiteral())
            }
            case TokenType.LBRACE: {
                pushback(t)
                children.add(mapLiteral())
            }
            case TokenType.FUNCTION,
                 TokenType.METHOD: {
                pushback(t)
                children.add(methodValue())
            }
            case TokenType.CLASS: {
                if peek().type = TokenType.LPAREN {
                    pushback(t)
                    children.add(classLiteral())
                }
                else
                    children.add(new TokenNode(t))
            }
            default:
                error("expected an expression, but found '" + t + "'", t)
        }
        return new ParseNode(ParseNodeType.TERM, children)
    }

    ============================================================================
    types = LPAREN (type (COMMA type)*)? RPAREN
    ============================================================================
    @protected
    @self
    method types():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LPAREN, "'(' to begin parameters", children)
        if checkNext(TokenType.RPAREN, children) = null {
            children.add(type())
            while checkNext(TokenType.COMMA, children) != null
                children.add(type())
            expect(TokenType.RPAREN, "')' to complete parameters", children)
        }
        return new ParseNode(ParseNodeType.TYPES, children)
    }

    ============================================================================
    callExpression = term (parameters | 
                LBRACKET (expression | (DOTDOT | ELLIPSIS) expression? 
                        (BY expression)?) RBRACKET |
                DOT (IDENTIFIER | CLASS | CONSTRUCTOR) |
                MEMBER IDENTIFIER types? |
                ((INSTANCEOF | NINSTANCEOF | CAST | CONVERT) 
                        LPAREN type RPAREN)*
    ============================================================================
    @protected
    @self
    method callExpression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(term())
        loop {
            var t := nextToken()
            switch t.type {
                case TokenType.LPAREN: {
                    pushback(t)
                    children.add(parameters())
                }
                case TokenType.LBRACKET: {
                    children.add(new TokenNode(t))
                    if peek().type != TokenType.DOTDOT & 
                            peek().type != TokenType.ELLIPSIS
                        children.add(expression())
                    if checkNext(TokenType.DOTDOT, children) != null |
                            checkNext(TokenType.ELLIPSIS, children) != null {
                        def p := peek().type
                        if p != TokenType.RBRACKET & p != TokenType.BY
                            children.add(expression())
                        if checkNext(TokenType.BY, children) != null
                            children.add(expression())
                    }
                    expect(TokenType.RBRACKET, "']'", children)
                }
                case TokenType.DOT: {
                    children.add(new TokenNode(t))
                    t := nextToken()
                    if t.type != TokenType.IDENTIFIER & 
                            t.type != TokenType.CLASS &
                            t.type != TokenType.CONSTRUCTOR
                        error("expected identifier, but found " + t.text, t)
                    children.add(new TokenNode(t))
                }
                case TokenType.MEMBER: {
                    children.add(new TokenNode(t))
                    children.add(methodName())
                    if peek().type = TokenType.LPAREN
                        children.add(types())
                }
                case TokenType.INSTANCEOF,
                        TokenType.NINSTANCEOF,
                        TokenType.CAST,
                        TokenType.CONVERT: {
                    children.add(new TokenNode(t))
                    expect(TokenType.LPAREN, "'(' after '" + t + "'", children)
                    children.add(type())
                    expect(TokenType.RPAREN, "')' after type name", children)
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return new ParseNode(ParseNodeType.CALL_EXPRESSION, children)
    }

    ============================================================================
    exponentExpression = callExpression (POW callExpression)*
    ============================================================================
    @protected
    @self
    method exponentExpression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(callExpression())

        while checkNext(TokenType.POW, children) != null
            children.add(callExpression())
        return new ParseNode(ParseNodeType.EXPONENT_EXPRESSION, children)
    }

    ============================================================================
    unaryOperator = SUB | NOT | BITWISENOT
    ============================================================================
    @protected
    @self
    method unaryOperator():ParseNode {
        def children := new Array<ParseNode>()
        def t := nextToken()
        if t.type != TokenType.SUB & t.type != TokenType.NOT & 
                t.type != TokenType.BITWISENOT
            error("expected '-', '!', or '!!", t)
        children.add(new TokenNode(t))
        return new ParseNode(ParseNodeType.UNARY_OPERATOR, children)
    }

    ============================================================================
    unaryExpression = unaryOperator? exponentExpression
    ============================================================================
    @protected
    @self
    method unaryExpression():ParseNode {
        def children := new Array<ParseNode>()
        def t := peek()
        switch t.type {
            case TokenType.SUB, TokenType.NOT, TokenType.BITWISENOT:
                children.add(unaryOperator())
        }
        children.add(exponentExpression())
        return new ParseNode(ParseNodeType.UNARY_EXPRESSION, children)
    }

    ============================================================================
    Checks whether the character immediately following this token is a GT. See
    `multiplicativeExpression` for details.
    ============================================================================
    @private
    @self
    method nextIsGT(t:Token):Bit {
        def next := peek()
        if next.type = TokenType.GT {
            def p1 := t.position
            def p2 := next.position
            return p1.line = p2.line & p1.column + 1 = p2.column
        }
        return false
    }


    ============================================================================
    multiplicativeExpression = unaryExpression ((MUL | DIV | INTDIV | REM |
            SHIFTLEFT | SHIFTRIGHT | BITWISEAND | BITWISEXOR) unaryExpression)*
    Note that SHIFTRIGHT is handled specially.
    Sequences of GTs can happen as part of generic parameters (e.g.
    Array<Array<String>>) and it is easier to combine separate GTs than it is to
    split apart SHIFTRIGHT. So here we lookahead after encountering a GT and 
    synthesize the shift right token if we encounter an additional GT.
    ============================================================================
    @protected
    @self
    method multiplicativeExpression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(unaryExpression())
    
        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.MUL, 
                        TokenType.DIV,
                        TokenType.INTDIV, 
                        TokenType.REM,
                        TokenType.SHIFTLEFT,
                        TokenType.BITWISEAND,
                        TokenType.BITWISEXOR: {
                    children.add(new TokenNode(t))
                    children.add(unaryExpression())
                }
                case TokenType.GT: {
                    if nextIsGT(t) {
                        -- ">>"
                        nextToken() -- consume '>'
                        children.add(new TokenNode(new Token(
                                TokenType.SHIFTRIGHT,
                                ">>", t.position)))
                        children.add(unaryExpression())
                    }
                    else {
                        -- just a plain ">", don't handle it here
                        pushback(t)
                        break
                    }
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return new ParseNode(ParseNodeType.MULTIPLICATIVE_EXPRESSION, children)
    }

    ============================================================================
    additiveExpression = multiplicativeExpression 
            ((ADD | SUB | BITWISEOR) multiplicativeExpression)*
    ============================================================================
    @protected
    @self
    method additiveExpression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(multiplicativeExpression())
    
        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.ADD, TokenType.SUB, TokenType.BITWISEOR: {
                    children.add(new TokenNode(t))
                    children.add(multiplicativeExpression())
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return new ParseNode(ParseNodeType.ADDITIVE_EXPRESSION, children)
    }

    ============================================================================
    rangeExpression = additiveExpression ((DOTDOT | ELLIPSIS)
            additiveExpression? 
            (BY additiveExpression)?)?
    ============================================================================
    @protected
    @self
    method rangeExpression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(additiveExpression())
        if checkNext(TokenType.DOTDOT, children) != null | 
                checkNext(TokenType.ELLIPSIS, children) != null {
            def p := peek().type
            if p = TokenType.NUMBER | p = TokenType.IDENTIFIER | 
                    p = TokenType.SUB | p = TokenType.BITWISENOT |
                    p = TokenType.STRING | p = TokenType.LPAREN
                children.add(additiveExpression())
            if checkNext(TokenType.BY, children) != null
                children.add(additiveExpression())
        }
        return new ParseNode(ParseNodeType.RANGE_EXPRESSION, children)
    }

    ============================================================================
    comparisonExpression = rangeExpression ((EQ | IDENTITY | NEQ | 
            NIDENTITY | LT | GT | LTEQ | GTEQ | IN) rangeExpression)*
    ============================================================================
    @protected
    @self
    method comparisonExpression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(rangeExpression())

        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.EQ, 
                        TokenType.IDENTITY,
                        TokenType.NEQ,
                        TokenType.NIDENTITY,
                        TokenType.LT,
                        TokenType.GT,
                        TokenType.LTEQ,
                        TokenType.GTEQ,
                        TokenType.IN: {
                    children.add(new TokenNode(t))
                    children.add(rangeExpression())
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return new ParseNode(ParseNodeType.COMPARISON_EXPRESSION, children)
    }

    ============================================================================
    andExpression = comparisonExpression ((AND | XOR) comparisonExpression)*
    ============================================================================
    @protected
    @self
    method andExpression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(comparisonExpression())

        loop {
            def t := nextToken()
            switch t.type {
                case TokenType.AND, TokenType.XOR: {
                    children.add(new TokenNode(t))
                    children.add(comparisonExpression())
                }
                default: {
                    pushback(t)
                    break
                }
            }
        }
        return new ParseNode(ParseNodeType.AND_EXPRESSION, children)
    }

    ============================================================================
    orExpression = andExpression (OR andExpression)*
    ============================================================================
    @protected
    @self
    method orExpression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(andExpression())

        while checkNext(TokenType.OR, children) != null
            children.add(andExpression())
        return new ParseNode(ParseNodeType.OR_EXPRESSION, children)
    }

    ============================================================================
    expression = orExpression
    ============================================================================
    @protected
    @self
    method expression():ParseNode {
        def children := new Array<ParseNode>()
        children.add(orExpression())
        return new ParseNode(ParseNodeType.EXPRESSION, children)
    }

    ============================================================================
    simpleStatement = assertStatement | varDeclaration | 
            anyLoop | callOrAssignment | ifStatement | switchStatement |
            tryStatement
    ============================================================================
    @protected
    @self
    method simpleStatement():ParseNode {
        def children := new Array<ParseNode>()
        var t := peek()
        switch t.type {
            case TokenType.ASSERT: 
                children.add(assertStatement())
            case TokenType.VAR, TokenType.DEF, TokenType.CONSTANT: 
                children.add(varDeclaration())
            case TokenType.IDENTIFIER: {
                t := nextToken()
                if peek().type = TokenType.COLON {
                    pushback(t)
                    children.add(anyLoop())
                }
                else {
                    pushback(t)
                    children.add(callOrAssignment())
                }
            }
            case TokenType.SELF,
                    TokenType.NEW,
                    TokenType.LBRACKET:
                children.add(callOrAssignment())
            case TokenType.SUPER,
                    TokenType.CONSTRUCTOR: 
                children.add(callOrAssignment())
            case TokenType.WHILE,
                    TokenType.FOR,
                    TokenType.DO,
                    TokenType.LOOP: 
                children.add(anyLoop())
            case TokenType.IF: 
                children.add(ifStatement())
            case TokenType.SWITCH: 
                children.add(switchStatement())
            case TokenType.TRY: 
                children.add(tryStatement())
            default: {
                -- consume the token so we don't keep re-erroring on it
                nextToken()
                switch t.type {
                    case TokenType.RETURN, TokenType.BREAK, TokenType.CONTINUE,
                            TokenType.THROW, TokenType.UNREACHABLE: {
                        error("'\{t}' must be the final statement of a block", 
                                t)
                    }
                    default: {
                        error("syntax error, expected statement but found " +
                                "'\{t}'", t)
                    }
                }
            }
        }
        return new ParseNode(ParseNodeType.SIMPLE_STATEMENT, children)
    }

    ============================================================================
    block = LBRACE statement* terminalStatement? RBRACE
    ============================================================================
    @protected
    @self
    method block():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LBRACE, "'{'", children)
        loop {
            def t := peek()
            switch t.type {
                case TokenType.RETURN, TokenType.BREAK, TokenType.CONTINUE,
                        TokenType.THROW, TokenType.UNREACHABLE: {
                    children.add(terminalStatement())
                    expect(TokenType.RBRACE, "'}' to complete block", children)
                    break
                }
                case TokenType.RBRACE: {
                    expect(TokenType.RBRACE, "'}' to complete block", children)
                    break
                }
                default:
                    children.add(statement())
            }
        }
        return new ParseNode(ParseNodeType.BLOCK, children)
    }

    ============================================================================
    statement = block | simpleStatement
    ============================================================================
    @protected
    @self
    method statement():ParseNode {
        def children := new Array<ParseNode>()
        if peek().type = TokenType.LBRACE
            children.add(block())
        else
            children.add(simpleStatement())
        return new ParseNode(ParseNodeType.STATEMENT, children)
    }

    ============================================================================
    statementOrBlock = simpleStatement | block | terminalStatement
    ============================================================================
    @protected
    @self
    method statementOrBlock():ParseNode {
        def children := new Array<ParseNode>()
        def t := peek()
        switch t.type {
            case TokenType.RETURN,
                    TokenType.BREAK,
                    TokenType.CONTINUE,
                    TokenType.THROW,
                    TokenType.UNREACHABLE: 
                children.add(terminalStatement())
            case TokenType.LBRACE: 
                children.add(block())
            default: 
                children.add(simpleStatement())
        }
        return new ParseNode(ParseNodeType.STATEMENT_OR_BLOCK, children)
    }

    ============================================================================
    assertStatement = ASSERT expression (COMMA expression)?
    ============================================================================
    @protected
    @self
    method assertStatement():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.ASSERT, "'assert'", children)
        suppressLambdas := true
        children.add(expression())
        suppressLambdas := false
        if checkNext(TokenType.COLON, children) != null
            children.add(expression())
        return new ParseNode(ParseNodeType.ASSERT_STATEMENT, children)
    }

    ============================================================================
    returnStatement = RETURN expression?
    only looks for expression if expectReturnValue is true
    ============================================================================
    @protected
    @self
    method returnStatement():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.RETURN, "'return'", children)
        if expectReturnValue
            children.add(expression())
        return new ParseNode(ParseNodeType.RETURN_STATEMENT, children)
    }

    ============================================================================
    breakStatement = BREAK IDENTIFIER?
    only picks up IDENTIFIER it it matches a previously-seen loop label
    ============================================================================
    @protected
    @self
    method breakStatement():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.BREAK, "'break'", children)
        def t := peek()
        if t.type = TokenType.IDENTIFIER {
            if loopLabels.contains(t.text)
                children.add(new TokenNode(nextToken()))
        }
        return new ParseNode(ParseNodeType.BREAK_STATEMENT, children)
    }

    ============================================================================
    continueStatement = CONTINUE IDENTIFIER?
    only picks up IDENTIFIER it it matches a previously-seen loop label
    ============================================================================
    @protected
    @self
    method continueStatement():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.CONTINUE, "'continue'", children)
        def t := peek()
        if t.type = TokenType.IDENTIFIER {
            if loopLabels.contains(t.text)
                children.add(new TokenNode(nextToken()))
        }
        return new ParseNode(ParseNodeType.CONTINUE_STATEMENT, children)
    }

    ============================================================================
    terminalStatement = returnStatement | breakStatement | continueStatement |
                        throwStatement | UNREACHABLE
    ============================================================================
    @protected
    @self
    method terminalStatement():ParseNode {
        def children := new Array<ParseNode>()
        switch peek().type {
            case TokenType.RETURN:
                children.add(returnStatement())
            case TokenType.BREAK:
                children.add(breakStatement())
            case TokenType.CONTINUE: 
                children.add(continueStatement())
            case TokenType.THROW:
                children.add(throwStatement())
            case TokenType.UNREACHABLE: 
                expect(TokenType.UNREACHABLE, "'unreachable'", children)
        }
        return new ParseNode(ParseNodeType.TERMINAL_STATEMENT, children)
    }

    ============================================================================
    forTuple := LPAREN (IDENTIFIER | UNDERSCORE) typeDeclaration? (COMMA 
            (IDENTIFIER | UNDERSCORE) typeDeclaration)+ RPAREN
    ============================================================================
    @protected
    @self
    method forTuple():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.LPAREN, "'('", children)
        if checkNext(TokenType.UNDERSCORE, children) = null {
            expect(TokenType.IDENTIFIER, "variable name (an identifier) after " + 
                "'(' in for-loop", children)
        }
        if peek().type = TokenType.COLON
            children.add(typeDeclaration())
        expect(TokenType.COMMA, 
                "',' to introduce a second variable in for-loop", 
                children)
        if checkNext(TokenType.UNDERSCORE, children) = null {
            expect(TokenType.IDENTIFIER, 
                    "variable name (an identifier, children) after ',' in " +
                    "for-loop", children)
        }
        if peek().type = TokenType.COLON
            children.add(typeDeclaration())
        while checkNext(TokenType.COMMA, children) != null {
            if checkNext(TokenType.UNDERSCORE, children) = null {
                expect(TokenType.IDENTIFIER, "variable name (an identifier) " +
                        "after ',' in for-loop", children)
            }
            if peek().type = TokenType.COLON
                children.add(typeDeclaration())
        }
        expect(TokenType.RPAREN, "')' after list of variables in for-loop", 
                children)
        return new ParseNode(ParseNodeType.FOR_TUPLE, children)
    }

    ============================================================================
    anyLoop = (IDENTIFIER COLON)? 
        (
            DO statementOrBlock WHILE expression |
            LOOP statementOrBlock |
            WHILE expression statementOrBlock |
            FOR (IDENTIFIER typeDeclaration? 
                (COMMA (IDENTIFIER typeDeclaration?) | forTuple)? |
                forTuple)  IN expression
        )
    ============================================================================
    @protected
    @self
    method anyLoop():ParseNode {
        def children := new Array<ParseNode>()
        var t := nextToken()
        children.add(new TokenNode(t))
        if t.type = TokenType.IDENTIFIER {
            -- label
            loopLabels.add(t.text)
            expect(TokenType.COLON, "':' after loop label", children)
            t := nextToken()
            children.add(new TokenNode(t))
        }
        switch t.type {
            case TokenType.DO: {
                children.add(statementOrBlock())
                expect(TokenType.WHILE, "'while'", children)
                children.add(expression())
            }
            case TokenType.LOOP:
                children.add(statementOrBlock())
            case TokenType.WHILE: {
                children.add(expression())
                children.add(statementOrBlock())
            }
            case TokenType.FOR: {
                if peek().type = TokenType.LPAREN
                    children.add(forTuple())
                else {
                    expect(TokenType.IDENTIFIER, 
                            "for-loop variable name (an identifier)", children)
                    if peek().type = TokenType.COLON
                        children.add(typeDeclaration())
                    if checkNext(TokenType.COMMA, children) != null {
                        if peek().type = TokenType.LPAREN
                            children.add(forTuple())
                        else {
                            expect(TokenType.IDENTIFIER, 
                                    "for-loop variable name (an identifier)",
                                    children)
                            if peek().type = TokenType.COLON
                                children.add(typeDeclaration())
                        }
                    }
                }
                expect(TokenType.IN, "'in' in for-loop", children)
                children.add(expression())
                children.add(statementOrBlock())
            }
        }
        return new ParseNode(ParseNodeType.ANY_LOOP, children)
    }

    ============================================================================
    ifStatement = IF expression statementOrBlock (ELSE statementOrBlock)?
    ============================================================================
    @protected
    @self
    method ifStatement():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.IF, "'if'", children)
        children.add(expression())
        children.add(statementOrBlock())
        if checkNext(TokenType.ELSE, children) != null
            children.add(statementOrBlock())
        return new ParseNode(ParseNodeType.IF, children)
    }

    ============================================================================
    switchCase = CASE expression (COMMA expression)* COLON statementOrBlock
    ============================================================================
    @protected
    @self
    method switchCase():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.CASE, "'case'", children)
        suppressLambdas := true
        children.add(expression())
        while checkNext(TokenType.COMMA, children) != null
            children.add(expression())
        suppressLambdas := false
        expect(TokenType.COLON, "':' after case value", children)
        children.add(statementOrBlock())
        return new ParseNode(ParseNodeType.SWITCH_CASE, children)
    }

    ============================================================================
    switchDefault = DEFAULT COLON statementOrBlock
    ============================================================================
    @protected
    @self
    method switchDefault():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.DEFAULT, "'default'", children)
        expect(TokenType.COLON, "':' after 'default'", children)
        children.add(statementOrBlock())
        return new ParseNode(ParseNodeType.SWITCH_DEFAULT, children)
    }
    
    ============================================================================
    switchStatement = SWITCH expression LBRACE switchCase* switchDefault* RBRACE
    ============================================================================
    @protected
    @self
    method switchStatement():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.SWITCH, "'switch'", children)
        children.add(expression())
        expect(TokenType.LBRACE, "'{' to begin switch body", children)
        while peek().type = TokenType.CASE
            children.add(switchCase())
        if peek().type = TokenType.DEFAULT
            children.add(switchDefault())
        expect(TokenType.RBRACE, "'}' to complete switch body", children)
        return new ParseNode(ParseNodeType.SWITCH_STATEMENT, children)
    }
    
    ============================================================================
    catchBlock = CATCH IDENTIFIER typeDeclaration IDENTIFIER block
    ============================================================================
    @protected
    @self
    method catchBlock():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.CATCH, "'catch'", children)
        expect(TokenType.IDENTIFIER, 
                "error variable name for catch (an identifier)", children)
        children.add(typeDeclaration())
        children.add(block())
        return new ParseNode(ParseNodeType.CATCH_BLOCK, children)
    }
    
    ============================================================================
    finallyBlock = FINALLY block
    ============================================================================
    @protected
    @self
    method finallyBlock():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.FINALLY, "'finally'", children)
        children.add(block())
        return new ParseNode(ParseNodeType.FINALLY_BLOCK, children)
    }

    ============================================================================
    tryStatement = TRY block ((catchBlock+ finallyBlock?) | finallyBlock)
    ============================================================================
    @protected
    @self
    method tryStatement():ParseNode {
        def children := new Array<ParseNode>()
        def tryToken := expect(TokenType.TRY, "'try'", children)
        children.add(block())
        def t := peek().type
        if t != TokenType.CATCH & t != TokenType.FINALLY
            error("try without catch or finally", tryToken)
        while peek().type = TokenType.CATCH
            children.add(catchBlock())
        if peek().type = TokenType.FINALLY
            children.add(finallyBlock())
        return new ParseNode(ParseNodeType.TRY_STATEMENT, children)
    }

    ============================================================================
    throwStatement = THROW expression
    ============================================================================
    @protected
    @self
    method throwStatement():ParseNode {
        def children := new Array<ParseNode>()
        expect(TokenType.THROW, "'throw'", children)
        children.add(expression())
        return new ParseNode(ParseNodeType.THROW_STATEMENT, children)
    }

    ============================================================================
    Returns `true` if the token ID is one of the assignment operators.
    ============================================================================
    @protected
    function isAssignmentOperator(type:TokenType):Bit {
        return(type = TokenType.ASSIGNMENT |
                type = TokenType.ADDEQ |
                type = TokenType.SUBEQ |
                type = TokenType.MULEQ |
                type = TokenType.DIVEQ |
                type = TokenType.INTDIVEQ |
                type = TokenType.POWEQ |
                type = TokenType.REMEQ |
                type = TokenType.ANDEQ |
                type = TokenType.BITWISEANDEQ |
                type = TokenType.OREQ |
                type = TokenType.BITWISEOREQ |
                type = TokenType.XOREQ |
                type = TokenType.BITWISEXOREQ |
                type = TokenType.SHIFTLEFTEQ |
                type = TokenType.SHIFTRIGHTEQ)
    }

    ============================================================================
    assignmentOperator = ASSIGNMENT | ADDEQ | SUBEQ | MULEQ | DIVEQ | INTDIVEQ |
            POWEQ | REMEQ | ANDEQ | BITWISEANDEQ | OREQ | BITWISEOREQ | XOREQ | 
            BITWISEXOREQ | SHIFTLEFTEQ | SHIFTRIGHTEQ
    ============================================================================
    @protected
    @self
    method assignmentOperator():ParseNode {
        def children := new Array<ParseNode>()
        def t := nextToken()
        if !isAssignmentOperator(t.type)
            error("expected assignment operator, found '" + t.text + "'", t)
        children.add(new TokenNode(t))
        return new ParseNode(ParseNodeType.ASSIGNMENT_OPERATOR, children)
    }

    ============================================================================
    lvalue = UNDERSCORE | ((IDENTIFIER | SELF | SUPER | CONSTRUCTOR | construct) 
            (DOT IDENTIFIER | 
                    parameters | 
                    LBRACKET (expression | (DOTDOT | ELLIPSIS) expression? 
                            (BY expression)?) RBRACKET | 
                    (CAST | CONVERT) LPAREN type RPAREN)*)
    Note that lvalue does not have its own parse node type; this was to prevent
    a lot of rewriting on the ASTGenerator side of things.
    ============================================================================
    @protected
    @self
    method lvalue(children:Array<ParseNode>) {
        if checkNext(TokenType.UNDERSCORE, children) != null
            return
        var t := nextToken()
        if t.type = TokenType.IDENTIFIER | t.type = TokenType.SELF |
                 t.type = TokenType.SUPER |t.type = TokenType.CONSTRUCTOR | 
                 t.type = TokenType.NEW {
            if t.type = TokenType.NEW {
                pushback(t)
                children.add(construct())
            }
            children.add(new TokenNode(t))
            loop {
                t := nextToken()
                switch t.type {
                    case TokenType.DOT: {
                        children.add(new TokenNode(t))
                        def next := nextToken()
                        if next.type != TokenType.IDENTIFIER &
                                next.type != TokenType.CONSTRUCTOR {
                            error("expected identifier, but found '\{next}'",
                                    next)
                        }
                        children.add(new TokenNode(t))
                    }
                    case TokenType.LPAREN: {
                        pushback(t)
                        children.add(parameters())
                    }
                    case TokenType.LBRACKET: {
                        children.add(new TokenNode(t))
                        def range := peek().type
                        if range != TokenType.DOTDOT & 
                                range != TokenType.ELLIPSIS
                            children.add(expression())
                        if checkNext(TokenType.DOTDOT, children) != null |
                                checkNext(TokenType.ELLIPSIS, children) != null {
                            def p := peek().type
                            if p != TokenType.RBRACKET & p != TokenType.BY
                                children.add(expression())
                            if checkNext(TokenType.BY, children) != null
                                children.add(expression())
                        }
                        expect(TokenType.RBRACKET, "']'", children)
                    }
                    case TokenType.CAST, TokenType.CONVERT: {
                        children.add(new TokenNode(t))
                        expect(TokenType.LPAREN, "'(' after '\{t}'", children)
                        children.add(type())
                        expect(TokenType.RPAREN, "')' after type name", children)
                    }
                    default: {
                        pushback(t)
                        break
                    }
                }
            }
        }
        else 
            error("expected identifier, but found '\{t}'", t)
    }

    ============================================================================
    callOrAssignment = (lvalue ((COMMA lvalue)* assignmentOperator expression)?)
            | (callExpression based on an PrimitiveArrayLiteral)
    ============================================================================
    @protected
    @self
    method callOrAssignment():ParseNode {
        def children := new Array<ParseNode>()
        if peek().type = TokenType.LBRACKET {
            children.add(callExpression())
        }
        else {
            lvalue(children)
            while checkNext(TokenType.COMMA, children) != null
                lvalue(children)
            if isAssignmentOperator(peek().type) {
                children.add(assignmentOperator())
                children.add(expression())
            }
        }
        return new ParseNode(ParseNodeType.CALL_OR_ASSIGNMENT, children)
    }
    
    @protected
    @self
    method writeTree(n:ParseNode) {
        Console.write(" " * indent)
        if n-?>(TokenNode)
            Console.write(n->(TokenNode).token.text)
        else
            Console.write(n.type)
        Console.writeLine()
        indent += 2
        for child in n
            writeTree(child)
        indent -= 2
    }
    
    @protected
    @self
    method dumpText(n:ParseNode) {
        Console.write(" " * indent)
        if n-?>(TokenNode) {
            Console.write(n->(TokenNode).token.text)
            Console.write(" ")
        }
        for child in n
            dumpText(child)
    }

    @private
    method checkEnd(parsing:String) {
        def next := nextToken()
        if next.type != TokenType.EOF {
            throw new CompilerException("unexpected token after end of " +
                    parsing + ": '\{next.text}'", next.position)
        }
    }

    @self
    method parseCompilationUnit(name:String, inStream:InputStream):ParseNode {
        lexer := new PandaLexer(inStream, new Position(name, 1, 1))
        def result := compilationUnit()
        checkEnd("compilation unit")
        return result
    }

    @self
    method parseCompilationUnit(f:File):ParseNode {
        return parseCompilationUnit(f.name, f.openInputStream())
    }
    
    @self
    method parseType(s:String, start:Position):ParseNode {
        lexer := new PandaLexer(s, start)
        def result := type()
        checkEnd("type")
        return result
    }

    @self
    method parseStatement(s:String, start:Position):ParseNode {
        lexer := new PandaLexer(s, start)
        def result := statement()
        checkEnd("statement")
        return result
    }

    @self
    method parseMethod(s:String, start:Position):ParseNode {
        lexer := new PandaLexer(s, start)
        def result := methodDeclaration()
        checkEnd("method")
        return result
    }

    @self
    method parseMethodValue(s:String, start:Position):ParseNode {
        lexer := new PandaLexer(s, start)
        def result := methodValue()
        checkEnd("method")
        return result
    }

    @self
    method parseExpressionWithExtraText(s:String, start:Position):(ParseNode, String) {
        lexer := new PandaLexer(s, start)
        suppressLambdas := true
        def result := expression()
        suppressLambdas := false
        def remaining := new MutableString()
        while pushbackBuffer.length > 0 {
            def next := nextToken()
            if next.type != TokenType.EOF
                remaining.append(next)
        }
        remaining.append(lexer.lex.source.readAsString())
        return (result, remaining->>(String))
    }

    @self
    method parseExpression(s:String, start:Position):ParseNode {
        lexer := new PandaLexer(s, start)
        def result := expression()
        checkEnd("expression")
        return result
    }

    @self
    method parseCallExpression(s:String, start:Position):ParseNode {
        lexer := new PandaLexer(s, start)
        def result := callExpression()
        checkEnd("expression")
        return result
    }

    @self
    method parseFormalParameterList(s:String, start:Position):ParseNode {
        lexer := new PandaLexer(s, start)
        def result := formalParameterList()
        checkEnd("parameters")
        return result
    }

    @self
    method parseTypes(s:String, start:Position):ParseNode {
        lexer := new PandaLexer(s, start)
        def result := types()
        checkEnd("types")
        return result
    }
}