package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.compiler.Dummy
uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.stubs.TypedMethodStub
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.WrapperType

================================================================================
Represents a value in an expression, such as `5` or `foo() * 6`.
================================================================================
@abstract
class Value : Node {
    def type:Type

    constructor(position:Position, type:Type) {
        super.constructor(position)
        self.type := type
    }
    
    constructor(position:Position, type:Type, child:Node) {
        super.constructor(position, child)
        self.type := type
    }

    constructor(position:Position, type:Type, children:ListView<Node>) {
        super.constructor(position, children)
        self.type := type
    }
    
    @final
    function preferredVariableType():Type {
        return preferredVariableType(false)
    }

    function preferredVariableType(preferImmutable:Bit):Type {
        return type
    }

    ============================================================================
    If this value is potentially usable, returns `null`. If this value is not
    and never will be valid, returns an error message.

    For instance, `value[5]` when `value` does not implement the `[]` operator
    will never be valid, because it is an invalid reference. We still
    need to be able to represent it as a value, because `value` might implement
    the `[]:=` operator and `value[5]` might be on the left-hand-side of a `:=`
    operator. So when processing `value[5] := 10`, we temporarily represent
    `value[5]` as a non-`valid()` value before replacing it with the final
    call to `[]:=()`.
    ============================================================================
    function checkValid():Message? {
        return null
    }

    @final
    @pre(checkValid = null)
    function canImplicitCastTo(context:Context, t:Type):Bit {
        return implicitCastCost(context, t) != null
    }

    @pre(checkValid = null)
    function implicitCastCost(context:Context, t:Type):Int? {
        return type.implicitCastCost(context, t)
    }

    @final
    function implicitCast(context:Context, t:Type):(Value, ListView<Message>?) {
        return implicitCast(position, context, t)
    }

    function implicitCast(position:Position, context:Context, t:Type):
            (Value, ListView<Message>?) {
        def check := checkValid
        if check != null {
            def messages := new Array<Message>()
            messages.add(check)
            return (new Dummy(position, t), messages)
        }
        if t = type
            return (self, null)
        if type.isPrimitive & !t.isPrimitive
            return wrapped(context, t)
        if type.isWrapper & t.isPrimitive
            return unwrap(context).implicitCast(position, context, t)
        if type.isNullable & !t.isNullable {
            def base := type->(NullableType).base
            if base != t {
                def nonNull, messages := implicitCast(position, context, base)
                assert messages = null : 
                        "couldn't remove nullability from \{type}: \{messages}"
                return nonNull.implicitCast(position, context, t)
            }
        }
        def result := new Cast(self, t, CastType.IMPLICIT)
        if implicitCastCost(context, t) != null
            return (result, null)
        else {
            def messages := new Array<Message>()
            messages.add(new Message("expected '\{t.displayName}', but " +
                    "found '\{type.displayName}'", position))
            return (result, messages)
        }
    }
    @post(@return[0].type = t)

    @pre(checkValid = null)
    function canExplicitCastTo(context:Context, t:Type):Bit {
        return type.canExplicitCastTo(context, t)
    }

    @pre(checkValid = null)
    function explicitCast(context:Context, t:Type):(Value, ListView<Message>?) {
        return explicitCast(position, context, t)
    }

    @pre(checkValid = null)
    function explicitCast(position:Position, context:Context, t:Type):
            (Value, ListView<Message>?) {
        if t = type
            return (self, null)
        if canImplicitCastTo(context, t) {
            def cast, messages := implicitCast(position, context, t)
            return (ASTGenerator.makeExplicit(cast), messages)
        }
        def result := new Cast(self, t, CastType.EXPLICIT)
        if canExplicitCastTo(context, t)
            return (result, null)
        else {
            def messages := new Array<Message>()
            messages.add(new Message("'\{t.displayName}' cannot possibly be " +
                    "an instance of '\{type.displayName}'", position))
            return (result, messages)
        }
    }
    @post(@return[0].type = t)

    @protected
    function findConverter(context:Context, t:Type):TypedMethodStub? {
        def stub := context.getStub(type->>(ClassType))
        for m in stub.instanceMethods(context.stubs) {
            if m.name = MethodNode.CONVERT_NAME & m.returnType = t
                return m
        }
        def targetStub := context.getStub(t->>(ClassType))
        var best := Int.MAX
        var bestMatch:TypedMethodStub? := null
        def params := new Array<Value>()
        params.add(self)
        for m in targetStub.methods {
            if m.annotations.isClass & canImplicitCastTo(context, 
                    m.parameters[0].type) {
                def score := context.matchCost(m, params)
                if score != null & score < best {
                    best := score
                    bestMatch := m
                }
            }
        }
        return bestMatch
    }
    @post(@return = null | @return.returnType = t)

    @pre(checkValid = null)
    function canConvertTo(context:Context, t:Type):Bit {
        return findConverter(context, t) != null
    }

    @pre(checkValid = null)
    function convert(context:Context, t:Type):(Value, ListView<Message>?) {
        def converter := findConverter(context, t)
        if converter != null {
            def params := new Array<Value>()
            def cast, messages := implicitCast(context, 
                    converter.parameters[0].type)
            params.add(cast)
            return (new MethodCall(position, converter, false, params), 
                    messages)
        }
        return (new Dummy(position, t), ASTGenerator.wrap(new Message(
                "cannot convert '\{type.displayName}' to \{t.displayName}",
                position)))
    }

    @private
    @pre(type.isPrimitive)
    function wrapped(context:Context, t:Type):(Value, ListView<Message>?) {
        def wrapper:WrapperType
        if t.isWrapper
            wrapper := t->>(WrapperType)
        else
            wrapper := type->>(WrapperType)
        def params := new Array<Value>()
        params.add(new Dummy(position, wrapper))
        def cast, messages := implicitCast(context, wrapper->>(PrimitiveType))
        assert messages = null :
                "wrapper cast failure \{messages}"
        params.add(cast)
        def constructorStub := context.getMethod(new ClassLiteral(position, 
                wrapper), MethodNode.CONSTRUCTOR_NAME, params)
        assert constructorStub != null : "could not find \{wrapper} " +
                "constructor for \{type}"
        def wrapperObject := new Construct(wrapper, new MethodCall(position, 
                constructorStub, false, params))
        return wrapperObject.implicitCast(position, context, t)
    }

    @private
    @pre(type.isWrapper)
    function unwrap(context:Context):Value {
        def wrapper, messages := 
                implicitCast(position, context, type->>(WrapperType))
        assert messages = null : messages->>(String)
        def wrapperStub := context.getStub(wrapper.type->(ClassType))
        def fields := wrapperStub.fields.filter(f => f.name = 'value')
        assert fields.length = 1 : 
                "expected exactly one field named 'value' in \{wrapperStub}"
        return new FieldReference(position, wrapper, fields.iterator.next())
    }

    ============================================================================
    Returns `true` if this value is in its final form and has a known type. Some
    expressions depend upon context for their interpretation; these are 
    represented by unresolved values until we have more information. For 
    example, when parsing the expression `array[5]`, we can't simply represent 
    this as a call of the `[]` method on `array` - what if the next token is 
    `:=`? In that case we should actually be calling the `[]:=` method instead.
    So we store this value as an `UnresolvedArray` until we are sure how it 
    needs to be handled.
    ============================================================================
    function isResolved():Bit {
        return true
    }
}