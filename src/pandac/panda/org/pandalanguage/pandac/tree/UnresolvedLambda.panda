package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.MethodType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

================================================================================
Represents a lambda which has not yet had its types determined. This will be 
turned into a `MethodValue` (or a compiler error) by the time we are done with 
AST generation.
================================================================================
class UnresolvedLambda : Value {
    constant UNRESOLVED_LAMBDA := new UnresolvedType("<lambda>")

    @final
    var context:Node

    @final
    var parameterNames:PrimitiveArray<ParseNode>

    @final
    var parameterTypes:PrimitiveArray<Type>?

    @final
    var expression:ParseNode

    -- number of types we tested this lambda against
    var checkCount:Int

    -- maps parameters (Array<Type>) to tuples describing errors trying to 
    -- interpret the lambda as that type
    def errors := new HashMap<PrimitiveArray<Type>, (String, Position?)>()

    constructor(context:Node, parameterNames:PrimitiveArray<ParseNode>, 
            parameterTypes:PrimitiveArray<Type>?, expression:ParseNode, 
            position:Position) {
        super.constructor(position, UNRESOLVED_LAMBDA)
        self.context := context
        self.parameterNames := parameterNames
        self.parameterTypes := parameterTypes
        self.expression := expression
    }

    @override
    method implicitCastCost(t:Type):Int {
        if t.isMethod {
            var m := t.unwrapNullable->(MethodType)
            if !m.isFunction
                return Type.NO_MATCH
            if m.methodParameters.length = parameterNames.length {
                var cost := 0
                if parameterTypes != null {
                    for i, p in m.methodParameters {
                        var paramCost := parameterTypes[i].implicitCastCost(p)
                        if paramCost = Type.NO_MATCH
                            return Type.NO_MATCH
                        cost += paramCost
                    }
                }
                def returnType := determineReturnType(m.methodParameters)
                if returnType = null
                    return Type.NO_MATCH
                def returnCost := returnType.implicitCastCost(m.returnType)
                if returnCost = Type.NO_MATCH {
                    errors[m.methodParameters->>(PrimitiveArray<Type>)] := ("lambda evaluated " +
                            "to '\{returnType.displayName}', which cannot be used where " +
                            "'\{m.returnType.displayName}' is expected",
                            position)->((String, Position?))
                    return Type.NO_MATCH
                }
                cost += returnCost
                if t.isNullable
                    cost += NullableType.TO_NULLABLE_CAST_COST
                return cost
            }
            else
                return Type.NO_MATCH
        }
        else
            return ClassType.METHOD().implicitCastCost(t)
    }

    @override
    method canExplicitCastTo(t:Type):Bit {
        return canImplicitCastTo(t)
    }

    @override
    method findConverterTo(t:Type):MethodNode? {
        return variableType().findConverterTo(t)
    }

    @private
    method determineReturnType(proposedParameterTypes->>PrimitiveArray<Type>):Type? {
        def ast := new ASTGenerator()
        var parent:SymbolTable? := null
        def stack := new PrimitiveArray<Node>()
        var node:Node? := context
        while node != null {
            stack.append(node)
            node := node.parent
        }
        for i in stack.length - 1 ... 0 by -1 {
            ast.nodeStack.push(stack[i])
            if parent = null & stack[i]-?>(Block)
                parent := stack[i]->(Block).symbolTable
        }
        assert parent != null
        def symbolTable := new SymbolTable(self, parent)
        for i, name in parameterNames  {
            symbolTable.putVariable(new Parameter(name->>(String),
                    proposedParameterTypes[i]))
        }
        def b := new Block(expression.position, symbolTable)
        b.parent := ast.currentMethod
        ast.nodeStack.push(b)
        try {
            checkCount += 1
            var expr := ast.convertExpression(expression)
            expr := new ASTGenerator().resolveUnresolvedConstructs(expr)
            return expr.type
        }
        catch e:CompilerException {
            errors[proposedParameterTypes[..]] := (e.message, e.position)
            return null
        }
    }

    method reportErrors() {
        if errors.length = 1 {
            def error := errors.values.iterator.next()
            def position := error[1]
            if position != null
                throw new CompilerException(error[0], position)
            else
                throw new CompilerException(error[0])
        }
        else if errors.length > 1
            throw new CompilerException(errors->>(String), position)
    }

    @override
    method variableType(preferImmutable:Bit):Type {
        if parameterTypes = null {
            throw new CompilerException("lambda type cannot be determined " +
                    "from context", position)
        }
        def stack := new PrimitiveArray<Node>()
        var node:Node? := context
        while node != null {
            stack.append(node)
            node := node.parent
        }
        def result := new MutableString("(")
        for i, t in parameterTypes {
            if i != 0
                result.append(",")
            result.append(t.name)
        }
        result.append(")=>(")
        def returnType := determineReturnType(parameterTypes)
        if returnType = null {
            reportErrors()
            unreachable
        }
        result.append(returnType.name)
        result.append(")")
        return SymbolTable.master.getType(expression.position, 
                result->>(String))
    }
}