package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.InternalCompilerException
uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.Type

enum BinaryOperationType {
    ADD,
    SUBTRACT,
    MULTIPLY,
    DIVIDE,
    INT_DIVIDE,
    REMAINDER,
    POWER,
    AND,
    OR,
    XOR,
    BITWISE_AND,
    BITWISE_OR,
    BITWISE_XOR,
    SHIFT_LEFT,
    SHIFT_RIGHT,
    EQUAL,
    NOT_EQUAL,
    IDENTITY,
    NOT_IDENTITY,
    GREATER_THAN,
    GREATER_THAN_OR_EQUAL,
    LESS_THAN,
    LESS_THAN_OR_EQUAL
}

class BinaryOperation : Value {
    def operation:BinaryOperationType

    def permitOverflow:Bit

    @pre(left.type = right.type)
    constructor(position:Position, operation:BinaryOperationType, left:Value, 
            right:Value) {
        super.constructor(position, getType(operation, left.type), 
                wrap(left, right))
        self.operation := operation
    }

    @class
    function getType(operation:BinaryOperationType, operandType:Type):Type {
        return operandType
    }

    @class
    function operandType(operation:BinaryOperationType, left:Value, 
            right:Value):Type? {
        return IntType.INT32
    }

    @class
    function operatorSymbol(operation:BinaryOperationType):String {
        switch operation {
            case BinaryOperationType.ADD:                   return "+"
            case BinaryOperationType.SUBTRACT:              return "-"
            case BinaryOperationType.MULTIPLY:              return "*"
            case BinaryOperationType.DIVIDE:                return "/"
            case BinaryOperationType.INT_DIVIDE:            return "//"
            case BinaryOperationType.REMAINDER:             return "%"
            case BinaryOperationType.POWER:                 return "^"
            case BinaryOperationType.AND:                   return "&"
            case BinaryOperationType.OR:                    return "|"
            case BinaryOperationType.XOR:                   return "~"
            case BinaryOperationType.BITWISE_AND:           return "&&"
            case BinaryOperationType.BITWISE_OR:            return "||"
            case BinaryOperationType.BITWISE_XOR:           return "~~"
            case BinaryOperationType.SHIFT_LEFT:            return "<<"
            case BinaryOperationType.SHIFT_RIGHT:           return ">>"
            case BinaryOperationType.EQUAL:                 return "="
            case BinaryOperationType.NOT_EQUAL:             return "!="
            case BinaryOperationType.IDENTITY:              return "=="
            case BinaryOperationType.NOT_IDENTITY:          return "!=="
            case BinaryOperationType.GREATER_THAN:          return ">="
            case BinaryOperationType.GREATER_THAN_OR_EQUAL: return ">="
            case BinaryOperationType.LESS_THAN:             return "<"
            case BinaryOperationType.LESS_THAN_OR_EQUAL:    return "<="
            default: throw new InternalCompilerException(
                    "unsupported binary operator")
        }
    }

    @class
    function signMatters(operation:BinaryOperationType):Bit {
        return true
    }

    @private
    @class
    -- FIXME will be unnecessary once the array syntax is fixed
    function wrap(left:Value, right:Value):ListView<Node> {
        def result := new Array<Node>()
        result.add(left)
        result.add(right)
        return result
    }

    function left():Value {
        return self[0]->(Value)
    }

    function right():Value {
        return self[1]->(Value)
    }

    @override
    function format(fmt:String):String {
        return "(\{left} \{operatorSymbol(operation)} \{right})"
    }
}