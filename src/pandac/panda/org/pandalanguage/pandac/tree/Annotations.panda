package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.parser.ParseNode

@private
enum AnnotationType {
    PRIVATE,
    PROTECTED,
    ABSTRACT,
    CLASS,
    THREAD,
    EXTERNAL,
    OVERRIDE,
    OVERFLOW,
    FINAL,
    READONLY,
    PRE,
    POST,
    INVARIANT,
    LIMITED,
    SELF,
    SAFERETURN,
    UNSAFEFUNCTION,
    -- private annotations used internally by the compiler --
    SYNTHETIC,  -- marks things generated by the compiler
    UNSPECIFIED, -- For classes, a generic class which has not had its types 
                 -- specified yet. For methods, a method which refers to 
                 -- unspecified generic types from its containing class. For 
                 -- fields, a field whose type refers to an unspecified generic
                 -- type from its containing class.
    GENERIC_METHOD, -- a method with its own generic types. Generic methods
                    -- remain generic even if their containing class is fully
                    -- specified. Generic methods may or may not also be
                    -- unspecified.
    PROPERTY, -- marks vars created by the property keyword
    WRAPPER_METHOD -- marks a wrapper method for which 'self' should have the 
                   -- primitive type rather than the wrapper type
}

================================================================================
The annotations attached to a class, method, or field.
================================================================================
class Annotations {
    constant annotationNames := new ImmutableHashMap<AnnotationType, String>(
        [
            AnnotationType.PRIVATE,
            AnnotationType.PROTECTED,
            AnnotationType.ABSTRACT,
            AnnotationType.CLASS,
            AnnotationType.THREAD,
            AnnotationType.EXTERNAL,
            AnnotationType.OVERRIDE,
            AnnotationType.OVERFLOW,
            AnnotationType.FINAL,
            AnnotationType.READONLY,
            AnnotationType.LIMITED,
            AnnotationType.SELF,   
            AnnotationType.SAFERETURN,
            AnnotationType.UNSAFEFUNCTION
        ],
        [
            "@private",
            "@protected",
            "@abstract",
            "@class",
            "@thread",
            "@external",
            "@override",
            "@math(overflow)",
            "@final",
            "@readonly",
            "@limited",
            "@self",
            "@safeReturn",
            "@unsafeFunction"
        ]
    )

    @readonly
    var position:Position

    @readonly
    var pre:PrimitiveArray<ParseNode> := []

    @readonly
    var post:PrimitiveArray<ParseNode> := []

    @readonly
    var invariants:PrimitiveArray<ParseNode> := []

    @private
    var bits:Int

    constructor() {
        constructor(Position.INTERNAL)
    }

    constructor(position:Position) {
        self.position := position
    }

    constructor(annotations:PrimitiveArray<AnnotationType>) {
        constructor(Position.INTERNAL, annotations)
    }

    constructor(position:Position, annotations:PrimitiveArray<AnnotationType>) {
        constructor(position)
        for a in annotations
            set(a, true)
    }

    ============================================================================
    Returns a list of all annotation types present in this object.
    ============================================================================
    -- FIXME for right this second, just returning AnnotationTypes, but at some 
    -- point probably want to introduce an Annotation and return those
    function all():PrimitiveArray<AnnotationType> {
        var result:PrimitiveArray<AnnotationType> := []
        for i in 0 ... bits.length - 1 {
            if bits[i]
                result.append(i->>(AnnotationType))
        }
        if pre.length > 0
            result.append(AnnotationType.PRE)
        if post.length > 0
            result.append(AnnotationType.POST)
        if invariants.length > 0
            result.append(AnnotationType.INVARIANT)
        return result
    }

    function isPrivate():Bit {
        return bits[AnnotationType.PRIVATE->>(Int)]
    }

    @self
    method isPrivate:=(b:Bit) {
        set(AnnotationType.PRIVATE, b)
    }

    function isProtected():Bit {
        return bits[AnnotationType.PROTECTED->>(Int)]
    }

    @self
    method isProtected:=(b:Bit) {
        set(AnnotationType.PROTECTED, b)
    }

    function isClass():Bit {
        return bits[AnnotationType.CLASS->>(Int)]
    }

    @self
    method isClass:=(b:Bit) {
        set(AnnotationType.CLASS, b)
    }

    function isThread():Bit {
        return bits[AnnotationType.THREAD->>(Int)]
    }

    @self
    method isThread:=(b:Bit) {
        set(AnnotationType.THREAD, b)
    }

    function isAbstract():Bit {
        return bits[AnnotationType.ABSTRACT->>(Int)]
    }

    @self
    method isAbstract:=(b:Bit) {
        set(AnnotationType.ABSTRACT, b)
    }

    function isExternal():Bit {
        return bits[AnnotationType.EXTERNAL->>(Int)]
    }

    @self
    method isExternal:=(b:Bit) {
        set(AnnotationType.EXTERNAL, b)
    }

    function isOverflow():Bit {
        return bits[AnnotationType.OVERFLOW->>(Int)]
    }

    @self
    method isOverflow:=(b:Bit) {
        set(AnnotationType.OVERFLOW, b)
    }

    function isReadOnly():Bit {
        return bits[AnnotationType.READONLY->>(Int)]
    }

    @self
    method isReadOnly:=(b:Bit) {
        set(AnnotationType.READONLY, b)
    }

    function isOverride():Bit {
        return bits[AnnotationType.OVERRIDE->>(Int)]
    }
    
    @self
    method isOverride:=(b:Bit) {
        set(AnnotationType.OVERRIDE, b)
    }

    function isFinal():Bit {
        return bits[AnnotationType.FINAL->>(Int)]
    }
    
    @self
    method isFinal:=(b:Bit) {
        set(AnnotationType.FINAL, b)
    }

    function isLimited():Bit {
        return bits[AnnotationType.LIMITED->>(Int)]
    }
    
    @self
    method isLimited:=(b:Bit) {
        set(AnnotationType.LIMITED, b)
    }

    function isSelf():Bit {
        return bits[AnnotationType.SELF->>(Int)]
    }
    
    @self
    method isSelf:=(b:Bit) {
        set(AnnotationType.SELF, b)
    }

    function isSafeReturn():Bit {
        return bits[AnnotationType.SAFERETURN->>(Int)]
    }
    
    @self
    method isSafeReturn:=(b:Bit) {
        set(AnnotationType.SAFERETURN, b)
    }

    function isSynthetic():Bit {
        return bits[AnnotationType.SYNTHETIC->>(Int)]
    }

    @self
    method isSynthetic:=(b:Bit) {
        set(AnnotationType.SYNTHETIC, b)
    }

    function isUnspecified():Bit {
        return bits[AnnotationType.UNSPECIFIED->>(Int)]
    }

    @self
    method isUnspecified:=(b:Bit) {
        set(AnnotationType.UNSPECIFIED, b)
    }

    function isUnsafeFunction():Bit {
        return bits[AnnotationType.UNSAFEFUNCTION->>(Int)]
    }

    @self
    method isUnsafeFunction:=(b:Bit) {
        set(AnnotationType.UNSAFEFUNCTION, b)
    }

    function isProperty():Bit {
        return bits[AnnotationType.PROPERTY->>(Int)]
    }

    @self
    method isProperty:=(b:Bit) {
        set(AnnotationType.PROPERTY, b)
    }

    function isWrapperMethod():Bit {
        return bits[AnnotationType.WRAPPER_METHOD->>(Int)]
    }

    @self
    method isWrapperMethod:=(b:Bit) {
        set(AnnotationType.WRAPPER_METHOD, b)
    }

    function isGenericMethod():Bit {
        return bits[AnnotationType.GENERIC_METHOD->>(Int)]
    }

    @self
    method isGenericMethod:=(b:Bit) {
        set(AnnotationType.GENERIC_METHOD, b)
    }

    @private
    method set(ann:AnnotationType, b:Bit) {
        var mask := 1 << ann->>(Int)
        if b & (bits && mask != 0) {
            var name := annotationNames[ann]
            if name = null
                name := ann->>(String)
            PandaCompiler.reportError("'" + name + 
                    "' was specified twice", position)
        }
        if b
            bits ||= mask
        else
            bits &&= !!mask
    }

    @private
    @class
    @limited
    method addString(s:String, result:MutableString) {
        if result.length > 0
            result.append(" ")
        result.append(s)
    }

    @private
    @class
    @limited
    method addString(bits:Int, ann:AnnotationType, s:String, 
            result:MutableString) {
        if bits[ann->>(Int)] 
            addString(s, result)
    }

    function copy():Annotations {
        var result := new Annotations()
        result.bits := bits
        result.pre := pre[..]
        result.post := post[..]
        result.invariants := invariants[..]
        return result
    }

    @override
    function format(fmt:String):String {
        var result := new MutableString()
        addString(bits, AnnotationType.PROTECTED, "@protected", result)
        addString(bits, AnnotationType.ABSTRACT, "@abstract", result)
        addString(bits, AnnotationType.PRIVATE, "@private", result)
        addString(bits, AnnotationType.CLASS, "@class", result)
        addString(bits, AnnotationType.THREAD, "@thread", result)
        addString(bits, AnnotationType.EXTERNAL, "@external", result)
        addString(bits, AnnotationType.OVERRIDE, "@override", result)
        addString(bits, AnnotationType.OVERFLOW, "@math(overflow)", result)
        addString(bits, AnnotationType.FINAL, "@final", result)
        addString(bits, AnnotationType.READONLY, "@readonly", result)
        addString(bits, AnnotationType.LIMITED, "@limited", result)
        addString(bits, AnnotationType.SELF, "@self", result)
        addString(bits, AnnotationType.SAFERETURN, "@safeReturn", result)
        addString(bits, AnnotationType.UNSAFEFUNCTION, "@unsafeFunction", 
                result)
        addString(bits, AnnotationType.WRAPPER_METHOD, "@$wrapperMethod", 
                result)
        for p in pre {
            if isOverride
                addString("@preOr(" + p + ")", result)
            else
                addString("@pre(" + p + ")", result)
        }
        return result->>(String)
   }
}