package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.parser.ParseNode

@private
enum AnnotationType {
    PRIVATE,
    PROTECTED,
    ABSTRACT,
    CLASS,
    THREAD,
    EXTERNAL,
    OVERRIDE,
    OVERFLOW,
    FINAL,
    READONLY,
    PRE,
    POST,
    INVARIANT,
    LIMITED,
    SELF,
    SAFERETURN,
    UNSAFEFUNCTION,
    -- private annotations used internally by the compiler --
    SYNTHETIC,  -- marks things generated by the compiler
    UNSPECIFIED, -- For classes, a generic class which has not had its types 
                 -- specified yet. For methods, a method which refers to 
                 -- unspecified generic types from its containing class. For 
                 -- fields, a field whose type refers to an unspecified generic
                 -- type from its containing class.
    GENERIC_METHOD, -- a method with its own generic types. Generic methods
                    -- remain generic even if their containing class is fully
                    -- specified. Generic methods may or may not also be
                    -- unspecified.
    PROPERTY, -- marks vars created by the property keyword
    WRAPPER_METHOD -- marks a wrapper method for which 'self' should have the 
                   -- primitive type rather than the wrapper type
}

================================================================================
The annotations attached to a class, method, or field.
================================================================================
class Annotations : Immutable {
    constant NAMES := new ImmutableHashMap<AnnotationType, String>(
        [
            AnnotationType.PRIVATE,
            AnnotationType.PROTECTED,
            AnnotationType.ABSTRACT,
            AnnotationType.CLASS,
            AnnotationType.THREAD,
            AnnotationType.EXTERNAL,
            AnnotationType.OVERRIDE,
            AnnotationType.OVERFLOW,
            AnnotationType.FINAL,
            AnnotationType.READONLY,
            AnnotationType.LIMITED,
            AnnotationType.SELF,   
            AnnotationType.SAFERETURN,
            AnnotationType.UNSAFEFUNCTION
        ],
        [
            "@private",
            "@protected",
            "@abstract",
            "@class",
            "@thread",
            "@external",
            "@override",
            "@math(overflow)",
            "@final",
            "@readonly",
            "@limited",
            "@self",
            "@safeReturn",
            "@unsafeFunction"
        ]
    )

    def position:Position

    def pre:ImmutableArray<ParseNode>

    def post:ImmutableArray<ParseNode>

    def invariants:ImmutableArray<ParseNode>

    @private
    def bits:Int

    constructor(position:Position, annotations:ListView<AnnotationType>) {
        constructor(position, annotations, new Array<ParseNode>(), 
                new Array<ParseNode>(), new Array<ParseNode>())
    }

    constructor(position:Position, annotations:ListView<AnnotationType>,
            pre:ListView<ParseNode>, post:ListView<ParseNode>, 
            invariants:ListView<ParseNode>) {
        self.position := position
        var bits := 0
        for a in annotations {
            def mask := 1 << a->>(Int)
            if bits && mask != 0 {
                var name := NAMES[a]
                if name = null
                    name := a->>(String)
                PandaCompiler.reportError("'\{name}' was specified twice", 
                        position)
            }
            bits ||= mask
        }
        self.bits := bits
        self.pre := new ImmutableArray<ParseNode>(pre)
        self.post := new ImmutableArray<ParseNode>(post)
        self.invariants := new ImmutableArray<ParseNode>(invariants)
    }

    @private
    constructor(position:Position, bits:Int, pre:ListView<ParseNode>, 
            post:ListView<ParseNode>, invariants:ListView<ParseNode>) {
        self.position := position
        self.bits := bits
        self.pre := new ImmutableArray<ParseNode>(pre)
        self.post := new ImmutableArray<ParseNode>(post)
        self.invariants := new ImmutableArray<ParseNode>(invariants)
    }


    ============================================================================
    Returns a list of all annotation types present in this object.
    ============================================================================
    -- FIXME for right this second, just returning AnnotationTypes, but at some 
    -- point probably want to introduce an Annotation and return those
    function all():PrimitiveArray<AnnotationType> {
        var result:PrimitiveArray<AnnotationType> := []
        for i in 0 ... bits.length - 1 {
            if bits[i]
                result.append(i->>(AnnotationType))
        }
        if pre.length > 0
            result.append(AnnotationType.PRE)
        if post.length > 0
            result.append(AnnotationType.POST)
        if invariants.length > 0
            result.append(AnnotationType.INVARIANT)
        return result
    }

    function isPrivate():Bit {
        return bits[AnnotationType.PRIVATE->>(Int)]
    }

    function isProtected():Bit {
        return bits[AnnotationType.PROTECTED->>(Int)]
    }

    function isClass():Bit {
        return bits[AnnotationType.CLASS->>(Int)]
    }

    function isThread():Bit {
        return bits[AnnotationType.THREAD->>(Int)]
    }

    function isAbstract():Bit {
        return bits[AnnotationType.ABSTRACT->>(Int)]
    }

    function isExternal():Bit {
        return bits[AnnotationType.EXTERNAL->>(Int)]
    }

    function isOverflow():Bit {
        return bits[AnnotationType.OVERFLOW->>(Int)]
    }

    function isReadOnly():Bit {
        return bits[AnnotationType.READONLY->>(Int)]
    }

    function isOverride():Bit {
        return bits[AnnotationType.OVERRIDE->>(Int)]
    }
    
    function isFinal():Bit {
        return bits[AnnotationType.FINAL->>(Int)]
    }
    
    function isLimited():Bit {
        return bits[AnnotationType.LIMITED->>(Int)]
    }
    
    function isSelf():Bit {
        return bits[AnnotationType.SELF->>(Int)]
    }
    
    function isSafeReturn():Bit {
        return bits[AnnotationType.SAFERETURN->>(Int)]
    }
    
    function isSynthetic():Bit {
        return bits[AnnotationType.SYNTHETIC->>(Int)]
    }

    function isUnspecified():Bit {
        return bits[AnnotationType.UNSPECIFIED->>(Int)]
    }

    function isUnsafeFunction():Bit {
        return bits[AnnotationType.UNSAFEFUNCTION->>(Int)]
    }

    function isProperty():Bit {
        return bits[AnnotationType.PROPERTY->>(Int)]
    }

    function isWrapperMethod():Bit {
        return bits[AnnotationType.WRAPPER_METHOD->>(Int)]
    }

    function isGenericMethod():Bit {
        return bits[AnnotationType.GENERIC_METHOD->>(Int)]
    }

    @private
    @class
    @limited
    method addString(s:String, result:MutableString) {
        if result.length > 0
            result.append(" ")
        result.append(s)
    }

    @private
    @class
    @limited
    method addString(bits:Int, ann:AnnotationType, s:String, 
            result:MutableString) {
        if bits[ann->>(Int)] 
            addString(s, result)
    }

    function +(a:AnnotationType):Annotations {
        def newAnnotations := bits || 1 << a->>(Int)
        return new Annotations(position, newAnnotations, pre, post, invariants)
    }

    function -(a:AnnotationType):Annotations {
        def newAnnotations := bits && !!(1 << a->>(Int))
        return new Annotations(position, newAnnotations, pre, post, invariants)
    }

    @override
    function format(fmt:String):String {
        var result := new MutableString()
        addString(bits, AnnotationType.PROTECTED, "@protected", result)
        addString(bits, AnnotationType.ABSTRACT, "@abstract", result)
        addString(bits, AnnotationType.PRIVATE, "@private", result)
        addString(bits, AnnotationType.CLASS, "@class", result)
        addString(bits, AnnotationType.THREAD, "@thread", result)
        addString(bits, AnnotationType.EXTERNAL, "@external", result)
        addString(bits, AnnotationType.OVERRIDE, "@override", result)
        addString(bits, AnnotationType.OVERFLOW, "@math(overflow)", result)
        addString(bits, AnnotationType.FINAL, "@final", result)
        addString(bits, AnnotationType.READONLY, "@readonly", result)
        addString(bits, AnnotationType.LIMITED, "@limited", result)
        addString(bits, AnnotationType.SELF, "@self", result)
        addString(bits, AnnotationType.SAFERETURN, "@safeReturn", result)
        addString(bits, AnnotationType.UNSAFEFUNCTION, "@unsafeFunction", 
                result)
        addString(bits, AnnotationType.WRAPPER_METHOD, "@$wrapperMethod", 
                result)
        for p in pre {
            if isOverride
                addString("@preOr(" + p + ")", result)
            else
                addString("@pre(" + p + ")", result)
        }
        return result->>(String)
   }
}