package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.ast.ASTNode
uses org.pandalanguage.pandac.compiler.PandaCompiler

================================================================================
The annotations attached to a class, method, or field.
================================================================================
class Annotations : Immutable {
    @private
    choice Kind {
        PRIVATE,
        PROTECTED,
        ABSTRACT,
        CLASS,
        THREAD,
        EXTERNAL,
        OVERRIDE,
        OVERFLOW,
        FINAL,
        READONLY,
        PRE,
        POST,
        INVARIANT,
        LIMITED,
        SELF,
        SAFERETURN,
        UNSAFEFUNCTION,
        -- private annotations used internally by the compiler --
        SYNTHETIC,  -- marks things generated by the compiler
        UNSPECIFIED, -- For classes, a generic class which has not had its types 
                     -- specified yet. For methods, a method which refers to 
                     -- unspecified generic types from its containing class. For 
                     -- fields, a field whose type refers to an unspecified 
                     -- generic type from its containing class.
        SPECIALIZE, -- temporary
        WRAPPER_METHOD -- marks a wrapper method for which 'self' should have the 
                       -- primitive type rather than the wrapper type
    }

    constant NAMES := ImmutableHashMap<Kind, String>(
        [
            Kind.PRIVATE,
            Kind.PROTECTED,
            Kind.ABSTRACT,
            Kind.CLASS,
            Kind.THREAD,
            Kind.EXTERNAL,
            Kind.OVERRIDE,
            Kind.OVERFLOW,
            Kind.FINAL,
            Kind.READONLY,
            Kind.LIMITED,
            Kind.SELF,   
            Kind.SAFERETURN,
            Kind.UNSAFEFUNCTION
        ],
        [
            "@private",
            "@protected",
            "@abstract",
            "@class",
            "@thread",
            "@external",
            "@override",
            "@math(overflow)",
            "@final",
            "@readonly",
            "@limited",
            "@self",
            "@safeReturn",
            "@unsafeFunction"
        ]
    )

    def position:Position

    def pre:ImmutableArray<ASTNode>

    def post:ImmutableArray<ASTNode>

    def invariants:ImmutableArray<ASTNode>

    @private
    def bits:Int

    init(position:Position) {
        init(position, Array<Kind>(), 
                Array<ASTNode>(), Array<ASTNode>(), 
                Array<ASTNode>())
    }

    init(position:Position, annotations:ListView<Kind>) {
        init(position, annotations, Array<ASTNode>(), 
                Array<ASTNode>(), Array<ASTNode>())
    }

    init(position:Position, annotations:ListView<Kind>,
            pre:ListView<ASTNode>, post:ListView<ASTNode>, 
            invariants:ListView<ASTNode>) {
        self.position := position
        var bits := 0
        for a in annotations {
            def mask := 1 << a.convert()->Int
            if bits && mask != 0 {
                var name := NAMES[a]
                if name = null
                    name := a.convert()
            }
            bits ||= mask
        }
        self.bits := bits
        self.pre := ImmutableArray<ASTNode>(pre)
        self.post := ImmutableArray<ASTNode>(post)
        self.invariants := ImmutableArray<ASTNode>(invariants)
    }

    @private
    init(position:Position, bits:Int, pre:ListView<ASTNode>, 
            post:ListView<ASTNode>, invariants:ListView<ASTNode>) {
        self.position := position
        self.bits := bits
        self.pre := ImmutableArray<ASTNode>(pre)
        self.post := ImmutableArray<ASTNode>(post)
        self.invariants := ImmutableArray<ASTNode>(invariants)
    }


    ============================================================================
    Returns a list of all annotation types present in this object.
    ============================================================================
    -- FIXME for right this second, just returning Kinds, but at some 
    -- point probably want to introduce an Annotation and return those
    function all():ListView<Kind> {
        var result := Array<Kind>()
        for i in 0 .. bits.length {
            if bits[i]
                result.add(Kind.fromInt(i))
        }
        if pre.count > 0
            result.add(Kind.PRE)
        if post.count > 0
            result.add(Kind.POST)
        if invariants.count > 0
            result.add(Kind.INVARIANT)
        return result
    }

    property isPrivate:Bit

    @private
    function get_isPrivate():Bit {
        return bits[Kind.PRIVATE.convert()]
    }

    property isProtected:Bit

    @private
    function get_isProtected():Bit {
        return bits[Kind.PROTECTED.convert()]
    }

    property isClass:Bit

    @private
    function get_isClass():Bit {
        return bits[Kind.CLASS.convert()]
    }

    property isThread:Bit

    @private
    function get_isThread():Bit {
        return bits[Kind.THREAD.convert()]
    }

    property isAbstract:Bit

    @private
    function get_isAbstract():Bit {
        return bits[Kind.ABSTRACT.convert()]
    }

    property isExternal:Bit

    @private
    function get_isExternal():Bit {
        return bits[Kind.EXTERNAL.convert()]
    }

    property isOverflow:Bit

    @private
    function get_isOverflow():Bit {
        return bits[Kind.OVERFLOW.convert()]
    }

    property isReadOnly:Bit

    @private
    function get_isReadOnly():Bit {
        return bits[Kind.READONLY.convert()]
    }

    property isOverride:Bit

    @private
    function get_isOverride():Bit {
        return bits[Kind.OVERRIDE.convert()]
    }
    
    property isFinal:Bit

    @private
    function get_isFinal():Bit {
        return bits[Kind.FINAL.convert()]
    }

    property isLimited:Bit
    
    @private
    function get_isLimited():Bit {
        return bits[Kind.LIMITED.convert()]
    }

    property isSelf:Bit
    
    @private
    function get_isSelf():Bit {
        return bits[Kind.SELF.convert()]
    }

    property isSafeReturn:Bit
    
    @private
    function get_isSafeReturn():Bit {
        return bits[Kind.SAFERETURN.convert()]
    }

    property isSynthetic:Bit
    
    @private
    function get_isSynthetic():Bit {
        return bits[Kind.SYNTHETIC.convert()]
    }

    property isUnspecified:Bit

    @private
    function get_isUnspecified():Bit {
        return bits[Kind.UNSPECIFIED.convert()]
    }

    property isUnsafeFunction:Bit

    @private
    function get_isUnsafeFunction():Bit {
        return bits[Kind.UNSAFEFUNCTION.convert()]
    }

    property isWrapperMethod:Bit

    @private
    function get_isWrapperMethod():Bit {
        return bits[Kind.WRAPPER_METHOD.convert()]
    }

    property isSpecialize:Bit

    @private
    function get_isSpecialize():Bit {
        return bits[Kind.SPECIALIZE.convert()]
    }

    @private
    @class
    @limited
    method addString(s:String, result:MutableString) {
        if result.count > 0
            result.append(" ")
        result.append(s)
    }

    @private
    @class
    @limited
    method addString(bits:Int, ann:Kind, s:String, 
            result:MutableString) {
        if bits[ann.convert()->Int] 
            addString(s, result)
    }

    function +(a:Kind):Annotations {
        def newAnnotations := bits || 1 << a.convert()->Int
        return Annotations(position, newAnnotations, pre, post, invariants)
    }

    function -(a:Kind):Annotations {
        def newAnnotations := bits && !!(1 << a.convert()->Int)
        return Annotations(position, newAnnotations, pre, post, invariants)
    }

    @override
    function convert():String {
        var result := MutableString()
        addString(bits, Kind.PROTECTED, "@protected", result)
        addString(bits, Kind.ABSTRACT, "@abstract", result)
        addString(bits, Kind.PRIVATE, "@private", result)
        addString(bits, Kind.CLASS, "@class", result)
        addString(bits, Kind.THREAD, "@thread", result)
        addString(bits, Kind.EXTERNAL, "@external", result)
        addString(bits, Kind.OVERRIDE, "@override", result)
        addString(bits, Kind.OVERFLOW, "@math(overflow)", result)
        addString(bits, Kind.FINAL, "@final", result)
        addString(bits, Kind.READONLY, "@readonly", result)
        addString(bits, Kind.LIMITED, "@limited", result)
        addString(bits, Kind.SELF, "@self", result)
        addString(bits, Kind.SAFERETURN, "@safeReturn", result)
        addString(bits, Kind.UNSAFEFUNCTION, "@unsafeFunction", 
                result)
        addString(bits, Kind.SPECIALIZE, "@specialize", result)
        addString(bits, Kind.WRAPPER_METHOD, "@$wrapperMethod", 
                result)
        for p in pre {
            if isOverride
                addString("@preOr(" + p + ")", result)
            else
                addString("@pre(" + p + ")", result)
        }
        return result.convert()
   }
}