package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.ast.ASTNode
uses org.pandalanguage.pandac.compiler.PandaCompiler

@private
choice AnnotationType {
    PRIVATE,
    PROTECTED,
    ABSTRACT,
    CLASS,
    THREAD,
    EXTERNAL,
    OVERRIDE,
    OVERFLOW,
    FINAL,
    READONLY,
    PRE,
    POST,
    INVARIANT,
    LIMITED,
    SELF,
    SAFERETURN,
    UNSAFEFUNCTION,
    -- private annotations used internally by the compiler --
    SYNTHETIC,  -- marks things generated by the compiler
    UNSPECIFIED, -- For classes, a generic class which has not had its types 
                 -- specified yet. For methods, a method which refers to 
                 -- unspecified generic types from its containing class. For 
                 -- fields, a field whose type refers to an unspecified generic
                 -- type from its containing class.
    GENERIC_METHOD, -- a method with its own generic types. Generic methods
                    -- remain generic even if their containing class is fully
                    -- specified. Generic methods may or may not also be
                    -- unspecified.
    PROPERTY, -- marks vars created by the property keyword
    WRAPPER_METHOD -- marks a wrapper method for which 'self' should have the 
                   -- primitive type rather than the wrapper type
}

================================================================================
The annotations attached to a class, method, or field.
================================================================================
class Annotations : Immutable {
    constant NAMES := ImmutableHashMap<AnnotationType, String>(
        [
            AnnotationType.PRIVATE,
            AnnotationType.PROTECTED,
            AnnotationType.ABSTRACT,
            AnnotationType.CLASS,
            AnnotationType.THREAD,
            AnnotationType.EXTERNAL,
            AnnotationType.OVERRIDE,
            AnnotationType.OVERFLOW,
            AnnotationType.FINAL,
            AnnotationType.READONLY,
            AnnotationType.LIMITED,
            AnnotationType.SELF,   
            AnnotationType.SAFERETURN,
            AnnotationType.UNSAFEFUNCTION
        ],
        [
            "@private",
            "@protected",
            "@abstract",
            "@class",
            "@thread",
            "@external",
            "@override",
            "@math(overflow)",
            "@final",
            "@readonly",
            "@limited",
            "@self",
            "@safeReturn",
            "@unsafeFunction"
        ]
    )

    def position:Position

    def pre:ImmutableArray<ASTNode>

    def post:ImmutableArray<ASTNode>

    def invariants:ImmutableArray<ASTNode>

    @private
    def bits:Int

    init(position:Position) {
        init(position, Array<AnnotationType>(), 
                Array<ASTNode>(), Array<ASTNode>(), 
                Array<ASTNode>())
    }

    init(position:Position, annotations:ListView<AnnotationType>) {
        init(position, annotations, Array<ASTNode>(), 
                Array<ASTNode>(), Array<ASTNode>())
    }

    init(position:Position, annotations:ListView<AnnotationType>,
            pre:ListView<ASTNode>, post:ListView<ASTNode>, 
            invariants:ListView<ASTNode>) {
        self.position := position
        var bits := 0
        for a in annotations {
            def mask := 1 << a.convert()->Int
            if bits && mask != 0 {
                var name := NAMES[a]
                if name = null
                    name := a.convert()
            }
            bits ||= mask
        }
        self.bits := bits
        self.pre := ImmutableArray<ASTNode>(pre)
        self.post := ImmutableArray<ASTNode>(post)
        self.invariants := ImmutableArray<ASTNode>(invariants)
    }

    @private
    init(position:Position, bits:Int, pre:ListView<ASTNode>, 
            post:ListView<ASTNode>, invariants:ListView<ASTNode>) {
        self.position := position
        self.bits := bits
        self.pre := ImmutableArray<ASTNode>(pre)
        self.post := ImmutableArray<ASTNode>(post)
        self.invariants := ImmutableArray<ASTNode>(invariants)
    }


    ============================================================================
    Returns a list of all annotation types present in this object.
    ============================================================================
    -- FIXME for right this second, just returning AnnotationTypes, but at some 
    -- point probably want to introduce an Annotation and return those
    function all():ListView<AnnotationType> {
        var result := Array<AnnotationType>()
        for i in 0 .. bits.length {
            if bits[i]
                result.add(AnnotationType.fromInt(i))
        }
        if pre.count > 0
            result.add(AnnotationType.PRE)
        if post.count > 0
            result.add(AnnotationType.POST)
        if invariants.count > 0
            result.add(AnnotationType.INVARIANT)
        return result
    }

    property isPrivate:Bit

    @private
    function get_isPrivate():Bit {
        return bits[AnnotationType.PRIVATE.convert()]
    }

    property isProtected:Bit

    @private
    function get_isProtected():Bit {
        return bits[AnnotationType.PROTECTED.convert()]
    }

    property isClass:Bit

    @private
    function get_isClass():Bit {
        return bits[AnnotationType.CLASS.convert()]
    }

    property isThread:Bit

    @private
    function get_isThread():Bit {
        return bits[AnnotationType.THREAD.convert()]
    }

    property isAbstract:Bit

    @private
    function get_isAbstract():Bit {
        return bits[AnnotationType.ABSTRACT.convert()]
    }

    property isExternal:Bit

    @private
    function get_isExternal():Bit {
        return bits[AnnotationType.EXTERNAL.convert()]
    }

    property isOverflow:Bit

    @private
    function get_isOverflow():Bit {
        return bits[AnnotationType.OVERFLOW.convert()]
    }

    property isReadOnly:Bit

    @private
    function get_isReadOnly():Bit {
        return bits[AnnotationType.READONLY.convert()]
    }

    property isOverride:Bit

    @private
    function get_isOverride():Bit {
        return bits[AnnotationType.OVERRIDE.convert()]
    }
    
    property isFinal:Bit

    @private
    function get_isFinal():Bit {
        return bits[AnnotationType.FINAL.convert()]
    }

    property isLimited:Bit
    
    @private
    function get_isLimited():Bit {
        return bits[AnnotationType.LIMITED.convert()]
    }

    property isSelf:Bit
    
    @private
    function get_isSelf():Bit {
        return bits[AnnotationType.SELF.convert()]
    }

    property isSafeReturn:Bit
    
    @private
    function get_isSafeReturn():Bit {
        return bits[AnnotationType.SAFERETURN.convert()]
    }

    property isSynthetic:Bit
    
    @private
    function get_isSynthetic():Bit {
        return bits[AnnotationType.SYNTHETIC.convert()]
    }

    property isUnspecified:Bit

    @private
    function get_isUnspecified():Bit {
        return bits[AnnotationType.UNSPECIFIED.convert()]
    }

    property isUnsafeFunction:Bit

    @private
    function get_isUnsafeFunction():Bit {
        return bits[AnnotationType.UNSAFEFUNCTION.convert()]
    }

    property isProperty:Bit

    @private
    function get_isProperty():Bit {
        return bits[AnnotationType.PROPERTY.convert()]
    }

    property isWrapperMethod:Bit

    @private
    function get_isWrapperMethod():Bit {
        return bits[AnnotationType.WRAPPER_METHOD.convert()]
    }

    property isGenericMethod:Bit

    @private
    function get_isGenericMethod():Bit {
        return bits[AnnotationType.GENERIC_METHOD.convert()]
    }

    @private
    @class
    @limited
    method addString(s:String, result:MutableString) {
        if result.count > 0
            result.append(" ")
        result.append(s)
    }

    @private
    @class
    @limited
    method addString(bits:Int, ann:AnnotationType, s:String, 
            result:MutableString) {
        if bits[ann.convert()->Int] 
            addString(s, result)
    }

    function +(a:AnnotationType):Annotations {
        def newAnnotations := bits || 1 << a.convert()->Int
        return Annotations(position, newAnnotations, pre, post, invariants)
    }

    function -(a:AnnotationType):Annotations {
        def newAnnotations := bits && !!(1 << a.convert()->Int)
        return Annotations(position, newAnnotations, pre, post, invariants)
    }

    @override
    function convert():String {
        var result := MutableString()
        addString(bits, AnnotationType.PROTECTED, "@protected", result)
        addString(bits, AnnotationType.ABSTRACT, "@abstract", result)
        addString(bits, AnnotationType.PRIVATE, "@private", result)
        addString(bits, AnnotationType.CLASS, "@class", result)
        addString(bits, AnnotationType.THREAD, "@thread", result)
        addString(bits, AnnotationType.EXTERNAL, "@external", result)
        addString(bits, AnnotationType.OVERRIDE, "@override", result)
        addString(bits, AnnotationType.OVERFLOW, "@math(overflow)", result)
        addString(bits, AnnotationType.FINAL, "@final", result)
        addString(bits, AnnotationType.READONLY, "@readonly", result)
        addString(bits, AnnotationType.LIMITED, "@limited", result)
        addString(bits, AnnotationType.SELF, "@self", result)
        addString(bits, AnnotationType.SAFERETURN, "@safeReturn", result)
        addString(bits, AnnotationType.UNSAFEFUNCTION, "@unsafeFunction", 
                result)
        addString(bits, AnnotationType.WRAPPER_METHOD, "@$wrapperMethod", 
                result)
        for p in pre {
            if isOverride
                addString("@preOr(" + p + ")", result)
            else
                addString("@pre(" + p + ")", result)
        }
        return result.convert()
   }
}