package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.parser.ParseNode

@private
enum AnnotationType {
    PRIVATE,
    PROTECTED,
    ABSTRACT,
    CLASS,
    THREAD,
    EXTERNAL,
    OVERRIDE,
    OVERFLOW,
    STATIC,
    READONLY,
    PRE,
    POST,
    INVARIANT,
    LIMITED,
    SELF,
    SAFERETURN,
    UNSAFEFUNCTION,
    -- private annotations used internally by the compiler --
    SYNTHETIC,  -- marks things generated by the compiler
    UNSPECIFIED, -- generic class which has not had its types specified yet
    PROPERTY, -- marks vars created by the property keyword
    WRAPPER_METHOD -- marks a wrapper method for which 'self' should have the 
                   -- primitive type rather than the wrapper type
}

================================================================================
The annotations attached to a class, method, or field.
================================================================================
class Annotations {
    constant annotationNames := {
        AnnotationType.PRIVATE:        "@private",
        AnnotationType.PROTECTED:      "@protected",
        AnnotationType.ABSTRACT:       "@abstract",
        AnnotationType.CLASS:          "@class",
        AnnotationType.THREAD:         "@thread",
        AnnotationType.EXTERNAL:       "@external",
        AnnotationType.OVERRIDE:       "@override",
        AnnotationType.OVERFLOW:       "@math(overflow)",
        AnnotationType.STATIC:         "@static",
        AnnotationType.READONLY:       "@readonly",
        AnnotationType.LIMITED:        "@limited",
        AnnotationType.SELF:           "@self",
        AnnotationType.SAFERETURN:     "@safeReturn",
        AnnotationType.UNSAFEFUNCTION: "@unsafeFunction"
    }->>(ImmutableHashMap)

    @readonly
    var position:Position

    @readonly
    var pre:Array<ParseNode> := []

    @readonly
    var post:Array<ParseNode> := []

    @readonly
    var invariants:Array<ParseNode> := []

    @private
    var bits:Int

    constructor() {
        constructor(Position.INTERNAL)
    }

    constructor(position:Position) {
        self.position := position
    }

    constructor(annotations:Array<AnnotationType>) {
        constructor(Position.INTERNAL, annotations)
    }

    constructor(position:Position, annotations:Array<AnnotationType>) {
        constructor(position)
        for a in annotations
            set(a, true)
    }

    ============================================================================
    Returns a list of all annotation types present in this object.
    ============================================================================
    -- FIXME for right this second, just returning AnnotationTypes, but at some 
    -- point probably want to introduce an Annotation and return those
    function all():Array<AnnotationType> {
        var result:Array<AnnotationType> := []
        for i in 0 ... bits.length - 1 {
            if bits[i]
                result.append(i->>(AnnotationType))
        }
        if pre.length > 0
            result.append(AnnotationType.PRE)
        if post.length > 0
            result.append(AnnotationType.POST)
        if invariants.length > 0
            result.append(AnnotationType.INVARIANT)
        return result
    }

    function isPrivate():Bit {
        return bits[AnnotationType.PRIVATE->>(Int)]
    }

    @self
    method isPrivate:=(b:Bit) {
        set(AnnotationType.PRIVATE, b)
    }

    function isProtected():Bit {
        return bits[AnnotationType.PROTECTED->>(Int)]
    }

    @self
    method isProtected:=(b:Bit) {
        set(AnnotationType.PROTECTED, b)
    }

    function isClass():Bit {
        return bits[AnnotationType.CLASS->>(Int)]
    }

    @self
    method isClass:=(b:Bit) {
        set(AnnotationType.CLASS, b)
    }

    function isThread():Bit {
        return bits[AnnotationType.THREAD->>(Int)]
    }

    @self
    method isThread:=(b:Bit) {
        set(AnnotationType.THREAD, b)
    }

    function isAbstract():Bit {
        return bits[AnnotationType.ABSTRACT->>(Int)]
    }

    @self
    method isAbstract:=(b:Bit) {
        set(AnnotationType.ABSTRACT, b)
    }

    function isExternal():Bit {
        return bits[AnnotationType.EXTERNAL->>(Int)]
    }

    @self
    method isExternal:=(b:Bit) {
        set(AnnotationType.EXTERNAL, b)
    }

    function isOverflow():Bit {
        return bits[AnnotationType.OVERFLOW->>(Int)]
    }

    @self
    method isOverflow:=(b:Bit) {
        set(AnnotationType.OVERFLOW, b)
    }

    function isReadOnly():Bit {
        return bits[AnnotationType.READONLY->>(Int)]
    }

    @self
    method isReadOnly:=(b:Bit) {
        set(AnnotationType.READONLY, b)
    }

    function isOverride():Bit {
        return bits[AnnotationType.OVERRIDE->>(Int)]
    }
    
    @self
    method isOverride:=(b:Bit) {
        set(AnnotationType.OVERRIDE, b)
    }

    function isStatic():Bit {
        return bits[AnnotationType.STATIC->>(Int)]
    }
    
    @self
    method isStatic:=(b:Bit) {
        set(AnnotationType.STATIC, b)
    }

    function isLimited():Bit {
        return bits[AnnotationType.LIMITED->>(Int)]
    }
    
    @self
    method isLimited:=(b:Bit) {
        set(AnnotationType.LIMITED, b)
    }

    function isSelf():Bit {
        return bits[AnnotationType.SELF->>(Int)]
    }
    
    @self
    method isSelf:=(b:Bit) {
        set(AnnotationType.SELF, b)
    }

    function isSafeReturn():Bit {
        return bits[AnnotationType.SAFERETURN->>(Int)]
    }
    
    @self
    method isSafeReturn:=(b:Bit) {
        set(AnnotationType.SAFERETURN, b)
    }

    function isSynthetic():Bit {
        return bits[AnnotationType.SYNTHETIC->>(Int)]
    }

    @self
    method isSynthetic:=(b:Bit) {
        set(AnnotationType.SYNTHETIC, b)
    }

    function isUnspecified():Bit {
        return bits[AnnotationType.UNSPECIFIED->>(Int)]
    }

    @self
    method isUnspecified:=(b:Bit) {
        set(AnnotationType.UNSPECIFIED, b)
    }

    function isUnsafeFunction():Bit {
        return bits[AnnotationType.UNSAFEFUNCTION->>(Int)]
    }

    @self
    method isUnsafeFunction:=(b:Bit) {
        set(AnnotationType.UNSAFEFUNCTION, b)
    }

    function isProperty():Bit {
        return bits[AnnotationType.PROPERTY->>(Int)]
    }

    @self
    method isProperty:=(b:Bit) {
        set(AnnotationType.PROPERTY, b)
    }

    function isWrapperMethod():Bit {
        return bits[AnnotationType.WRAPPER_METHOD->>(Int)]
    }

    @self
    method isWrapperMethod:=(b:Bit) {
        set(AnnotationType.WRAPPER_METHOD, b)
    }

    @private
    method set(ann:AnnotationType, b:Bit) {
        var mask := 1 << ann->>(Int)
        if b & (bits && mask != 0) {
            var name := annotationNames[ann]
            if name = null
                name := ann->>(String)
            PandaCompiler.reportError("'" + name + 
                    "' was specified twice", position)
        }
        if b
            bits ||= mask
        else
            bits &&= !!mask
    }

    @private
    @class
    @limited
    method addString(s:String, result:MutableString) {
        if result.length > 0
            result.append(" ")
        result.append(s)
    }

    @private
    @class
    @limited
    method addString(bits:Int, ann:AnnotationType, s:String, 
            result:MutableString) {
        if bits[ann->>(Int)] 
            addString(s, result)
    }

    function copy():Annotations {
        var result := new Annotations()
        result.bits := bits
        result.pre := pre[..]
        result.post := post[..]
        result.invariants := invariants[..]
        return result
    }

    @override
    function format(fmt:String):String {
        var result := new MutableString()
        addString(bits, AnnotationType.PROTECTED, "@protected", result)
        addString(bits, AnnotationType.ABSTRACT, "@abstract", result)
        addString(bits, AnnotationType.PRIVATE, "@private", result)
        addString(bits, AnnotationType.CLASS, "@class", result)
        addString(bits, AnnotationType.THREAD, "@thread", result)
        addString(bits, AnnotationType.EXTERNAL, "@external", result)
        addString(bits, AnnotationType.OVERRIDE, "@override", result)
        addString(bits, AnnotationType.OVERFLOW, "@math(overflow)", result)
        addString(bits, AnnotationType.STATIC, "@static", result)
        addString(bits, AnnotationType.READONLY, "@readonly", result)
        addString(bits, AnnotationType.LIMITED, "@limited", result)
        addString(bits, AnnotationType.SELF, "@self", result)
        addString(bits, AnnotationType.SAFERETURN, "@safeReturn", result)
        addString(bits, AnnotationType.UNSAFEFUNCTION, "@unsafeFunction", 
                result)
        addString(bits, AnnotationType.WRAPPER_METHOD, "@$wrapperMethod", 
                result)
        for p in pre {
            if isOverride
                addString("@preOr(" + p + ")", result)
            else
                addString("@pre(" + p + ")", result)
        }
        return result->>(String)
   }
}