package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.compiler.Dummy
uses org.pandalanguage.pandac.types.ArrayType
uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.UnresolvedType

class UnresolvedRange : Value {
    @readonly
    var left:Value?

    @readonly
    var right:Value?

    @readonly
    var step:Value?

    @readonly
    var endInclusive:Bit
    
    constructor(position:Position, left:Value?, right:Value?, step:Value?,
            endInclusive:Bit) {
        super.constructor(position, unresolvedType(left, right, step,
                endInclusive))
        self.left  := left
        self.right := right
        self.step  := step
        self.endInclusive := endInclusive
    }

    function unresolvedType(left:Value?, right:Value?, step:Value?,
            endInclusive:Bit):Type {
        def name := new MutableString("<range: ")
        if left != null
            name.append(left.type.displayName + " ")
        if endInclusive
            name.append("...")
        else
            name.append("..")
        if right != null
            name.append(" " + right.type.displayName)
        if step != null
            name.append(" by " + step.type.displayName)
        name.append(">")
        return new UnresolvedType(name->>(String))
    }

    @override
    method implicitCastCost(t:Type):Int {
        if t.isArray {
            def elementType := t->(ArrayType).elementType
            var cost := 0
            if left != null {
                if !left.type.isPrimitive & !left.type.isWrapper
                    return Type.NO_MATCH
                cost := left.implicitCastCost(elementType)
                if cost = Type.NO_MATCH
                    return Type.NO_MATCH
            }
            if right != null {
                if !right.type.isPrimitive & !right.type.isWrapper
                    return Type.NO_MATCH
                def rightCost := right.implicitCastCost(elementType)
                if rightCost = Type.NO_MATCH
                    return Type.NO_MATCH
                cost += rightCost
            }
            if step != null & !step.type.isNumber
                return Type.NO_MATCH
            return cost
        }
        return variableType().implicitCastCost(t)
    }

    @override
    method canExplicitCastTo(t:Type):Bit {
        return canImplicitCastTo(t)
    }

    @override
    method findConverterTo(t:Type):MethodNode? {
        return variableType().findConverterTo(t)
    }

    @override
    method variableType(preferImmutable:Bit):Type {
        var type:Type? := null
        if left != null & right != null {
            type := left->(Value).type
            if type.variableType() = CharType.CHAR &
                    right->(Value).type.variableType() = CharType.CHAR &
                    (step = null | step->(Value).type.isInteger)
                type := CharType.CHAR
            else {
                type := new Add().getOperandType(left->(Value), right->(Value),
                        true)
                if type != null & step != null {
                    type := new Add().getOperandType(new Dummy(type), 
                            step->(Value), true)
                }
            }
        }
        if type = null {
            throw new CompilerException("range operator cannot operate " +
                    "on these types", position)
        }
        type := type.variableType()
        return SymbolTable.master.getType(Position.INTERNAL, 
                class(Array).name + "<" + type.name + ">")
    }
}