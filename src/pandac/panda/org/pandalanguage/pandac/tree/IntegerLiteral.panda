package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.types.CharType
uses org.pandalanguage.pandac.types.IntType
uses org.pandalanguage.pandac.types.Type

================================================================================
Represents a literal integer appearing in the source code. Note that a leading
minus sign is *not* considered to be part of the literal itself; that is a
`UnaryMinus` operator acting on an `IntegerLiteral`. Thus all `IntegerLiterals`
are naturally unsigned, but given Panda's bias towards signed types they will
prefer to be treated as signed types when possible.
================================================================================
class IntegerLiteral : Value {
    var value:UInt64
    var typeForced:Bit
    
    constructor(value:UInt64) {
        constructor(value, getType(value))
        typeForced := false
    }
    
    @pre(type.isInteger | type = CharType.CHAR)
    constructor(value:UInt64, type:Type) {
        super.constructor(type)
        self.value := value
        typeForced := true
    }

    constructor(position:Position, value:UInt64) {
        constructor(position, value, getType(value))
        typeForced := false
    }
    
    @pre(type.isInteger | type = CharType.CHAR)
    constructor(position:Position, value:UInt64, type:Type) {
        super.constructor(position, type)
        self.value := value
        typeForced := true
    }

    @override
    method implicitCastCost(t:Type):Int {
        if typeForced
            return type.implicitCastCost(t)
        var unwrapped := t.unwrapWrapper
        if unwrapped-?>(IntType) {
            var srcType := getType(unwrapped->(IntType).signed)
            if srcType = null
                return Type.NO_MATCH
            var result := srcType.implicitCastCost(t)
            if result != Type.NO_MATCH & !unwrapped->(IntType).signed
                result += 1
            return result
        }
        return super.implicitCastCost(t)
    }

    @class
    function getType(value:UInt64):Type {
        if value <= Int8.MAX->(UInt64)
            return IntType.INT8
        if value <= Int16.MAX->(UInt64)
            return IntType.INT16
        if value <= Int32.MAX->(UInt64)
            return IntType.INT32
        if value <= Int64.MAX->(UInt64)
            return IntType.INT64
        return IntType.UINT64
    }

    ============================================================================
    Returns the preferred type for this literal in a signed / unsigned context.
    ============================================================================
    function getType(signed:Bit):Type? {
        if typeForced {
            if type->(IntType).signed = signed
                return type
            return null
        }
        if signed {
            if value <= Int8.MAX->(UInt64)
                return IntType.INT8
            if value <= Int16.MAX->(UInt64)
                return IntType.INT16
            if value <= Int32.MAX->(UInt64)
                return IntType.INT32
            if value <= Int64.MAX->(UInt64)
                return IntType.INT64
            return null
        }
        else {
            if value <= UInt8.MAX
                return IntType.UINT8
            if value <= UInt16.MAX
                return IntType.UINT16
            if value <= UInt32.MAX
                return IntType.UINT32
            return IntType.UINT64
        }
    }

    @override
    function format(fmt:String):String {
        return value->>(String)
    }
}