package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericParameterType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

enum ClassNodeState {
    ============================================================================
    The class name was referenced, but the class definition has not yet been
    processed.
    ============================================================================
    UNKNOWN,

    ============================================================================
    The class definition has been parsed.
    ============================================================================
    DEFINED,

    ============================================================================
    The class was defined in a plink file.
    ============================================================================
    EXTERNALLY_DEFINED,

    ============================================================================
    The class is an array or generic instance which was referenced by an
    @$instance declaration in a plink file. The class has not yet been fully
    initialized; it will transition to EXTERNALLY_DEFINED on initialization.
    ============================================================================
    EXTERNAL_INSTANCE
}


================================================================================
Represents a parsed class. `ClassNode` should always be the child of a 
`CompilationUnit`. There is a guaranteed one-to-one correspondence between 
`ClassNode` and `ClassType`; one will never exist without the other.
================================================================================
class ClassNode : Node {
    constant DEFAULT_IMPORTS := ["panda.core", "panda.collections", "panda.io", 
            "panda.math", "panda.threads"]

    constant CORE := "panda.core."

    constant COLLECTIONS := "panda.collections."

    constant OBJECT_NAME          := CORE + "Object"
                                 
    constant CLASS_NAME           := CORE + "Class"
                                 
    constant ARRAY_NAME           := COLLECTIONS + "Array"
                                 
    constant IMMUTABLE_ARRAY_NAME := COLLECTIONS + "ImmutableArray"
                                 
    constant STRING_NAME          := CORE + "String"
                                 
    constant PRIMITIVE_NAME       := CORE + "Primitive"
                                 
    constant NUMBER_NAME          := CORE + "Number"
                                 
    constant PANDA_NAME           := CORE + "Panda"
                                 
    constant IMMUTABLE_NAME       := CORE + "Immutable"
    
    constant ERROR_NAME           := CORE + "Error"
                                 
    constant EXCEPTION_NAME       := CORE + "Exception"

    constant INT8WRAPPER_NAME     := CORE + "Int8Wrapper"

    constant INT16WRAPPER_NAME    := CORE + "Int16Wrapper"

    constant INT32WRAPPER_NAME    := CORE + "Int32Wrapper"

    constant INT64WRAPPER_NAME    := CORE + "Int64Wrapper"

    constant REAL32WRAPPER_NAME   := CORE + "Real32Wrapper"

    constant REAL64WRAPPER_NAME   := CORE + "Real64Wrapper"

    constant BITWRAPPER_NAME      := CORE + "BitWrapper"

    constant CHARWRAPPER_NAME     := CORE + "CharWrapper"

    constant HASHMAP_NAME         := COLLECTIONS + "HashMap"

    constant IMMUTABLE_HASHMAP_NAME := COLLECTIONS + "ImmutableHashMap"

    constant TUPLE_NAME           := COLLECTIONS + "Tuple"

    constant IMMUTABLE_TUPLE_NAME := COLLECTIONS + "ImmutableTuple"

    ============================================================================
    The current state of the class.
    ============================================================================
    var state:ClassNodeState := ClassNodeState.UNKNOWN

    ============================================================================
    The fully-qualified name of this class.
    ============================================================================
    var name:String := "undefined"

    ============================================================================
    The parent class. Object (and only Object) has a null superclass.
    ============================================================================
    property supertype:ClassType?

    ============================================================================
    Interfaces implemented by this class.
    ============================================================================
    @readonly
    var interfaces := new Array<ClassType>()
    
    ============================================================================
    The annotations attached to this method.
    ============================================================================
    var annotations := new Annotations()
    
    ============================================================================
    The raw (unspecified) generic parameters attached to this class. If the
    class is an instantiation of a generic type (e.g. 
    panda.collections.Map<String, Object>, as opposed to panda.collections.Map)
    its generic parameters are available from its corresponding `GenericType`.
    ============================================================================
    var genericParameterTypes := new Array<GenericParameterType>()

    var isInterface:Bit

    ============================================================================
    The contents of the doccomment attached to the class, or `null` if none.
    ============================================================================
    var doccomment:String?

    ============================================================================
    The class's symbol table, which contains all of its fields and methods. The
    class's symbol table will have the `CompilationUnit`'s symbol table as a 
    parent.
    ============================================================================
    var symbolTable:SymbolTable

    var containingClass:ClassNode?
    
    ============================================================================
    Creates a new `ClassNode`.
    
    @param name the fully-qualified name of the class
    @param parentSymbolTable the symbol table of the `CompilationUnit` to which
           this class belongs
    ============================================================================
    @pre(!name.contains(" ") & !name.endsWith("?") & 
            name != Type.UNRESOLVED.name)
    constructor(name:String, parentSymbolTable:SymbolTable) {
        constructor(Position.INTERNAL, name, parentSymbolTable)
    }

    @pre(!name.contains(" ") & !name.endsWith("?") & 
            name != Type.UNRESOLVED.name)
    constructor(position:Position, name:String, 
                parentSymbolTable:SymbolTable) {
        super.constructor(position)
        self.name := name
        symbolTable := new SymbolTable(self, parentSymbolTable)
    }
    
    function size():Int {
        assert state != ClassNodeState.UNKNOWN
        var size:Int
        var sc := superclass
        if sc != null
            size := sc.size
        else
            size := 0
        for child in children {
            if child-?>(FieldNode) &
                     !child->(FieldNode).annotations.isClass {
                var fieldSize := child->(FieldNode).type.size
                var align := size % fieldSize
                if align != 0
                    size += fieldSize - align
                assert size % fieldSize = 0
                size += fieldSize
            }
        }
        return size
    }
    
    method type():ClassType {
        return SymbolTable.master.getType(position, name)->(ClassType)
    }

    function fields():Array<FieldNode> {
        def result := new Array<FieldNode>()
        for child in children {
            if child-?>(FieldNode)
                result.append(child->(FieldNode))
        }
        return result
    }

    function getField(name:String):FieldNode? {
        for field in fields {
            if field.name = name
                return field
        }
        return null
    }

    function methods():Array<MethodNode> {
        def result := new Array<MethodNode>()
        for child in children {
            if child-?>(MethodNode)
                result.append(child->(MethodNode))
        }
        return result
    }

    ============================================================================
    Returns the set of all of the interfaces directly or indirectly implemented
    by this class.
    ============================================================================
    -- FIXME use an actual Set
    method allInterfaces():Array<ClassNode> {
        var result:Array<ClassNode>
        var sc := superclass
        if sc != null & sc.name != type().baseName
            result := sc.allInterfaces()
        else
            result := []
        if isInterface
            result.append(self)
        for intf in interfaces {
            for i in intf.classNode.allInterfaces() {
                if !result.contains(i)
                    result.append(i)
            }
        }
        return result
    }
    
    ============================================================================
    Returns an Array of all of the virtual methods in this class. Methods which
    are inherited or overridden from parent classes appear in this array in the 
    same index in which they were present in the parent class, and new methods
    will appear at the end of the array.
    ============================================================================
    @safeReturn
    function virtualMethods():Array<MethodNode> {
        var result:Array<MethodNode>? := null
        -- get the base set of methods from our parent
        var sc := superclass
        if sc != null {
            if !sc.annotations.isUnspecified()
                result := sc.virtualMethods
        }
        if result = null
            result := new Array<MethodNode>()

        -- find any methods which override already-existing methods
        for child in children {
            if child-?>(MethodNode) {
                var m := child->(MethodNode)
                if m.isDeclaredVirtual {
                    var found := false
                    for j in 0 ... result.length - 1 {
                        if m.isOverrideOf(result[j]) {
                            -- this method overrides the corresponding method
                            -- in the parent
                            result[j] := m
                            found := true
                            break
                        }
                    }
                    -- if !found, it's a new method that wasn't present in the
                    -- base class
                    if !found
                        result.append(m)
                }
            }
        }
        return result
    }

    ============================================================================
    Returns an Array of all of the interface methods in this class corresponding
    to a particular interface. The order of methods in the resulting array is 
    consistent across all classes implementing this interface.
    ============================================================================
    @safeReturn
    function interfaceMethods(intf:ClassNode):Array<MethodNode> {
        var result:Array<MethodNode>? := null
        -- get the base set of methods from our parent
        var sc := superclass
        if sc != null {
            if !sc.annotations.isUnspecified()
                result := sc.interfaceMethods(intf)
        }
        if result = null
            result := intf.virtualMethods[..]
        -- find overridden implementations
        for child in children {
            if child-?>(MethodNode) {
                var m := child->(MethodNode)
                if m.isDeclaredVirtual {
                    var found := false
                    for j in 0 ... result.length - 1 {
                        if m.isOverrideOf(result[j]) {
                            -- this method overrides the corresponding method
                            -- in the parent
                            result[j] := m
                            found := true
                            break
                        }
                    }
                }
            }
        }
        return result
    }

    @safeReturn
    function unifiedFields():Array<FieldNode> {
        var result := new Array<FieldNode>()
        var sc := superclass
        if sc != null {
            if !sc.annotations.isUnspecified()
                result.appendAll(sc.unifiedFields)
        }
        for child in children {
            if child-?>(FieldNode) & 
                    !child->(FieldNode).annotations.isClass &
                    !child->(FieldNode).annotations.isThread
                result.append(child->(FieldNode))
        }
        return result
    }
    
    @self
    method supertype:=(supertype:ClassType?) {
        self._supertype := supertype
        if supertype != null
        if supertype != null & supertype-!>(UnresolvedType)
            symbolTable.parent := supertype.classNode.symbolTable
    }
    
    function packageName():String? {
        var lt := name.indexOf("<")
        if lt = null
            lt := name.length - 1
        var dot := name.lastIndexOf(".", lt)
        if dot != null
            return name[0 .. dot]
        return null
    }

    function simpleName():String {
        var lt := name.indexOf("<")
        if lt = null
            lt := name.length - 1
        var dot := name.lastIndexOf(".", lt)
        if dot != null
            return name[dot + 1..]
        return name
    }

    function superclass():ClassNode? {
        var supertype := self.supertype
        if supertype != null
            return supertype.classNode
        return null
    }

    method isArray():Bit {
        return type().isArray
    }

    method isTuple():Bit {
        return type().isTuple
    }

    function isEnumeration():Bit {
        var sc := superclass
        return sc != null & sc.name = class(Enumeration).name
    }

    @override
    method markLive() {
        if !live {
            super.markLive()
            var sc := superclass
            if sc != null
                sc.markLive()
            for child in children {
                if child-?>(MethodNode) & 
                        child->(MethodNode).name = MethodNode.CLASS_INIT_NAME
                    child.markLive()
            }
        }
    }

    @override
    function format(fmt:String):String {
        return "class " + name
    }
}