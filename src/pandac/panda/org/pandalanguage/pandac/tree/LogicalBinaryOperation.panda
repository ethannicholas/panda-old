package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.types.BitType
uses org.pandalanguage.pandac.types.NativePointerType
uses org.pandalanguage.pandac.types.NullType
uses org.pandalanguage.pandac.types.RealType
uses org.pandalanguage.pandac.types.RealLiteralType
uses org.pandalanguage.pandac.types.Type

@abstract
class LogicalBinaryOperation : BinaryOperation {
    constructor() {
        super.constructor()
    }
    
    constructor(position:Position) {
        super.constructor(position)
    }

    @protected
    @override
    method determineType() {
        type := BitType.BIT
    }
   
    @override
    method getOperandType(leftValue:Value, rightValue:Value, strict:Bit):Type? {
        var left := leftValue.type
        var right := rightValue.type
        if left = NativePointerType.NATIVE_POINTER | 
                right = NativePointerType.NATIVE_POINTER
            return NativePointerType.NATIVE_POINTER
        if left = NullType.NULL {
            if strict & !right.isNullable() {
                PandaCompiler.reportError("value cannot possibly be null",
                        rightValue.position)
            }
            return right.getNullableVersion()
        }
        if right = NullType.NULL {
            if strict & !left.isNullable() {
                PandaCompiler.reportError("value cannot possibly be null",
                        leftValue.position)
            }
            return left.getNullableVersion()
        }
        if left.isWrapper
            left := left.unwrapWrapper
        if right.isWrapper
            right := right.unwrapWrapper
        if left = BitType.BIT & right = BitType.BIT
            return BitType.BIT
        var result := super.getOperandType(leftValue, rightValue, strict)
        -- FIXME null check shouldn't be necessary
        if result != null & result = RealLiteralType.REAL_LITERAL
            result := RealType.REAL64
        return result
    }
}
