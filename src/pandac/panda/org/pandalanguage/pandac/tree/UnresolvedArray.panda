package org.pandalanguage.pandac.tree

uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.types.ClassType
uses org.pandalanguage.pandac.types.GenericType
uses org.pandalanguage.pandac.types.NullableType
uses org.pandalanguage.pandac.types.PrimitiveArrayType
uses org.pandalanguage.pandac.types.StringOrCharType
uses org.pandalanguage.pandac.types.Type
uses org.pandalanguage.pandac.types.UnresolvedType

================================================================================
Represents an array created with the array literal syntax, e.g. `[1, 2, 3]`.
`UnresolvedArray` is turned into a concrete array value once its type is 
determined.
================================================================================
class UnresolvedArray : UnresolvedValue {
    def values:List<Value>

    constructor(context:Context, position:Position, values:ListView<Value>) {
        super.constructor(position, "<array>", getValue(context, position,
        		values))
        self.values := new Array<Value>(values)
    }

    @class
    method getValue(context:Context, position:Position, 
    		values:ListView<Value>):Value {
        var elementType:Type
        if values.length = 0
        	elementType := NullableType.ANY
        else {
        	elementType := values[0].type
        	for i in 1 .. values.length
        		elementType := Type.union(context, elementType, values[i].type)
        }
        def typeList := new Array<Type>()
        typeList.add(elementType)
        def type := new GenericType(ClassType.ARRAY, typeList)
        return context.createArrayLiteral(position, type, values)
    }

    @override
    function implicitCastCost(context:Context, t:Type):Int? {
        if !t.isPrimitive {
            var stub := context.getStub(t->>(ClassType))
            loop {
                if stub.type-?>(GenericType) {
                    def g := stub.type->(GenericType).base
                    if g = ClassType.ARRAY |  
                            g = ClassType.IMMUTABLE_ARRAY {
                        return 0
                    }
                }
                def parent := stub.superclass
                if parent != null
                    stub := context.getStub(parent)
                else
                    break
            }
        }
        return value->(Value).type.implicitCastCost(context, t)
    }

    @override
    method implicitCast(position:Position, context:Context, t:Type):Value {
        if !t.isPrimitive {
            var stub := context.getStub(t->>(ClassType))
            loop {
                if stub.type-?>(GenericType) {
                    def g := stub.type->(GenericType).base
                    if g = ClassType.ARRAY |  
                            g = ClassType.IMMUTABLE_ARRAY {
                        def elementType := 
                                stub.type->(GenericType).parameters[0]
                        def casted := new Array<Value>()
                        for v in values {
                            casted.add(v.implicitCast(position, context, 
                                    elementType))
                        }
                        return context.createArrayLiteral(position, 
                                stub.type->(GenericType), casted)
                    }
                }
                def parent := stub.superclass
                if parent != null
                    stub := context.getStub(parent)
                else
                    break
            }
        }
        return value->(Value).implicitCast(position, context, t)
    }

    @override
    method reportError(context:Context) {
    	unreachable
    }
}