package org.pandalanguage.pandac.transformers

uses org.pandalanguage.pandac.analysis.CFGGenerator
uses org.pandalanguage.pandac.analysis.DataFlowAnalyzer
uses org.pandalanguage.pandac.analysis.MethodAnalysis
uses org.pandalanguage.pandac.analysis.ControlNode
uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.Try

================================================================================
Abstract superclass of all optimizer passes that modify methods. IMPORTANT: you
*must* perform modifications of the tree using the methods in this class, as
opposed to modifying the node structure directly. These methods keep the CFG and 
dataflow analysis up to date, whereas direct modifications to the tree will not.
================================================================================
@abstract
class MethodTransformer {
    @protected
    var ast:ASTGenerator

    @protected
    var cfg:CFGGenerator

    @protected
    var dfa:DataFlowAnalyzer

    constructor(ast:ASTGenerator, cfg:CFGGenerator, dfa:DataFlowAnalyzer) {
        self.ast := ast
        self.cfg := cfg
        self.dfa := dfa
    }

    @abstract
    method transform(m:MethodNode, analysis:MethodAnalysis)

    @protected
    method replace(m:MethodNode, analysis:MethodAnalysis, original:Node, 
            replacement:Node) {
        def controlNode := cfg.getContainingControlNode(original)
        original.replace(replacement)
        cfg.activeNodes := controlNode.entrances[..]
        cfg.rescan(analysis, replacement)
        dfa.incrementalAnalysis(m, cfg.getContainingControlNode(replacement))
    }

    ============================================================================
    Adds a new statement before an existing statement.
    ============================================================================
    @protected
    method insertBefore(analysis:MethodAnalysis, statement:Statement, 
            before:Statement) {
        var block := before.parent->(Block)
        if block.length > 0
            block.children.append(block[block.length - 1])
        for i in block.length - 1 ... 1 by -1 {
            block[i] := block[i - 1]
            if block[i] = before {
                block[i - 1] := statement
                statement.parent := block
                rescan(analysis, block)
                return
            }
        }
        unreachable
    }

    ============================================================================
    Adds a new statement at the beginning of a block.
    ============================================================================
    @protected
    method insertAtBeginning(analysis:MethodAnalysis, statement:Statement, 
            block:Block) {
        if block.length > 0
            insertBefore(analysis, statement, block[0]->(Statement))
        else
            block.add(statement)
        rescan(analysis, block)
    }

    ============================================================================
    Adds a new statement after an existing statement, compiling it from a 
    string.
    ============================================================================
    @protected
    method insertAfter(analysis:MethodAnalysis, statement:Statement, 
            var after:Statement) {
        if after.parent-?>(Try)
            after := after.parent->(Try)
        var block:Block
        if after-?>(Block) {
            block := after->(Block)
            assert !block.endsInBranch
            block.add(statement)
        }
        else {
            block := after.parent->(Block)
            block.add(statement)
            var index:Int := 0
            while block[index] != after
                index += 1
            index += 1
            def s := block[block.length - 1]
            for j in block.length - 1 ... index + 1 by -1
                block[j] := block[j - 1]
            block[index] := s
        }
        rescan(analysis, block)
    }

    @private
    method rescan(analysis:MethodAnalysis, node:Node) {
        var m := node
        while m-!>(MethodNode)
            m := m.parent->(Node)
        def controlNode := cfg.getContainingControlNode(node)
        controlNode.nodes[..] := [node]
        cfg.activeNodes := controlNode.entrances[..]
        cfg.rescan(analysis, node)
        dfa.incrementalAnalysis(m->(MethodNode), controlNode)
    }
}