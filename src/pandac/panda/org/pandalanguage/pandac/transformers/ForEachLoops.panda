package org.pandalanguage.pandac.transformers

uses org.pandalanguage.pandac.analysis.CFGGenerator
uses org.pandalanguage.pandac.analysis.DataFlowAnalyzer
uses org.pandalanguage.pandac.analysis.MethodAnalysis
uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Break
uses org.pandalanguage.pandac.tree.ForEach
uses org.pandalanguage.pandac.tree.GreaterThanOrEqual
uses org.pandalanguage.pandac.tree.If
uses org.pandalanguage.pandac.tree.IndexValue
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.LoopWithContinueBlock
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.Node
uses org.pandalanguage.pandac.tree.ReusedValueDefinition
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.Variable
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.types.Type

================================================================================
Converts for-each loops into simpler loops, as for-each loops are not handled by 
the code generators.
================================================================================
class ForEachLoops : MethodTransformer {
    constructor(ast:ASTGenerator, cfg:CFGGenerator, dfa:DataFlowAnalyzer) {
        super.constructor(ast, cfg, dfa)
    }

    method transform(ast:ASTGenerator, m:MethodNode, analysis:MethodAnalysis,
            var node:Node) {
        if node-?>(ForEach) {
            def f := node->(ForEach)
            def parent := f.parent
            assert parent-?>(Block)
            def b := new Block(f.position, parent->(Block).symbolTable)
            var indexVariable := f.indexVariable
            if indexVariable = null {
                indexVariable := new LocalVariable(f.position, "$loopIndex", 
                        Type.INDEX_TYPE)
                m.localVariables.append(indexVariable)
            }
            b.add(new ValueStatement(new VariableAssignment(indexVariable,
                    new IntegerLiteral(0, indexVariable.type))))
            def fList := f.list
            def fBlock := f.block
            fList.removeFromParent()
            fBlock.removeFromParent()
            def list := new ReusedValueDefinition(fList)
            b.add(new ValueStatement(list))
            def length := ast.resolve(ast.getField(f.position, 
                    list.createReference(), "length"))
            length.markLive()
            def end := new ReusedValueDefinition(length)
            b.add(new ValueStatement(end))
            def l := new LoopWithContinueBlock(f.position, f.label)
            def lBlock := new Block(f.position, b.symbolTable)
            l.add(lBlock)
            def test := new GreaterThanOrEqual(f.position)
            test.add(new VariableReference(f.position, indexVariable))
            test.add(end.createReference())
            def breakIf := new If(f.position, test)
            lBlock.add(breakIf)
            def breakBlock := new Block(f.position, b.symbolTable)
            breakIf.add(breakBlock)
            breakBlock.add(new Break(f.position))
            lBlock.add(new ValueStatement(new VariableAssignment(f.loopVariable, 
                    new IndexValue(list.createReference(), 
                    new VariableReference(indexVariable)))))
            lBlock.add(fBlock)
            def continueBlock := new Block(f.position, b.symbolTable)
            def add := new Add(f.position)
            add.add(new VariableReference(indexVariable))
            add.add(new IntegerLiteral(1, indexVariable.type))
            continueBlock.add(new ValueStatement(new VariableAssignment(indexVariable,
                    add)))
            l.add(continueBlock)
            b.add(l)
            replace(m, analysis, f, b)
            node := b
        }
        for child in node.children {
            if child-?>(Statement)
                transform(ast, m, analysis, child)
        }
    }

    @override
    method transform(m:MethodNode, analysis:MethodAnalysis) {
        for node in m.children
            transform(ast, m, analysis, node)
    }    
}