package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.ast.ASTAnnotation
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTFile
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSimpleAnnotation
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.compiler.IRGenerator
uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.compiler.LookupContext
uses org.pandalanguage.pandac.compiler.OrderedMap
uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.compiler.StubGenerator
uses org.pandalanguage.pandac.compiler.SymbolTable
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.Statement
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference
uses org.pandalanguage.pandac.tree.VariableType
uses org.pandalanguage.pandac.types.IntType

================================================================================
A primitive array (mutable or immutable) of another type.
================================================================================
class PrimitiveArrayType : GenericType {
    -- all statically-allocated types must be added to the MutableTypeMap 
    -- constructor
    constant IMMUTABLE_CHAR_ARRAY := new PrimitiveArrayType(
            ClassType.IMMUTABLE_PRIMITIVE_ARRAY, CharType.CHAR)

    @pre(arrayClass = ClassType.PRIMITIVE_ARRAY | 
            arrayClass = ClassType.IMMUTABLE_PRIMITIVE_ARRAY)
    constructor(arrayClass:ClassType, elementType:Type) {
        super.constructor(arrayClass, FIXMEwrap(elementType))
    }

    -- ugh I can't wait until I have the array syntax wired up properly
    function FIXMEwrap(t:Type):Array<Type> {
        def a := new Array<Type>()
        a.add(t)
        return a
    }

    @override
    function simpleName():String {
        -- FIXME we should be using elementType.simpleName here, but leaving it
        -- as-is for backwards compatibility until new compiler is finished
        return base.simpleName + "<" + elementType.name + ">"
    }

    function elementType():Type {
        return parameters[0]
    }

    @override
    function isPrimitiveArray():Bit {
        return true
    }

    method createStub(unspecified:Bit, external:Bit, 
            context:Context):ClassStub {
        def position := new Position(name, -1, -1)
        def final := [AnnotationType.FINAL]
        def length := new FieldNode(position, self, "$length", 
                new Annotations(position, final), VariableType.DEF, 
                IntType.INT32, null, null)
        def maxLength := new FieldNode(position, self, "$maxLength",
                new Annotations(position, final), VariableType.DEF, 
                 IntType.INT32, null, null)
        def elements := new FieldNode(position, self, FieldNode.ELEMENTS_NAME, 
                new Annotations(position, final), VariableType.DEF,
                elementType, null, null)
        def symbols := new OrderedMap<String, Symbol>()
        addSymbol(length, symbols)
        addSymbol(maxLength, symbols)
        addSymbol(elements, symbols)
        def classAnnotations := new Array<AnnotationType>()
        if unspecified
            classAnnotations.add(AnnotationType.UNSPECIFIED)
        if external
            classAnnotations.add(AnnotationType.EXTERNAL)

        def lengthParameters := new Array<FormalParameter>()
        def lengthStatements := new Array<ASTStatement>()
        lengthStatements.add(new ASTReturn(position, new ASTIdentifier(position,
                length.name)))
        def lengthBody := new ASTBlock(position, lengthStatements)
        def lengthFunction := new MethodStub(position, "length", 
                new Annotations(position, new Array<AnnotationType>()),
                MethodNodeType.FUNCTION, new Array<FormalParameter>(),
                IntType.INT32, lengthBody, self)
        addSymbol(lengthFunction, symbols)

        def annotations := new Array<ASTAnnotation>()
        annotations.add(new ASTSimpleAnnotation(position, "synthetic"))
        annotations.add(new ASTSimpleAnnotation(position, "safeReturn"))
        def parser := new PandaParser(new FatalErrorReporter())
        def immutable := 
                name.startsWith(class(ImmutablePrimitiveArray).name)
        def mutableVersion:String
        if immutable {
            mutableVersion := class(PrimitiveArray).name + 
                    name[name.indexOf("<")->(Int)..]
        }
        else
            mutableVersion := name
        def convert:String
        if immutable
            convert := "->>(\{name})"
        else
            convert := ""
        def sle1 := parser.parseMethodDeclaration(
                "function [..](left:panda.core.Int32," +
                "right:panda.core.Int32):\{name} {\n" +
                "var result := new \{mutableVersion}(right - left)\n" +
                "for i, v in left .. right\n" +
                "    result[i] := self[v]\n" +
                "return result\{convert}\n" +
                "}", null, annotations, position)
        assert sle1 != null
        addSymbol(context.stubGenerator.convertMethod(false, sle1, self, 
                symbols)->(MethodStub), symbols)

        def sle2 := parser.parseMethodDeclaration(
                "function [..](rawLeft:panda.core.Int32?," +
                "rawRight:panda.core.Int32?):\{name} {\n" +
                "def left:panda.core.Int32\n" +
                "if rawLeft = null\n" +
                "    left := 0\n" +
                "else\n" +
                "    left := rawLeft\n" +
                "def right:panda.core.Int32\n" +
                "if rawRight = null\n" +
                "    right := length\n" +
                "else\n" +
                "    right := rawRight\n" +
                "var result := new \{mutableVersion}(right - left)\n" +
                "for i, v in left .. right\n" +
                "    result[i] := self[v]\n" +
                "return result\{convert}\n" +
                "}", null, annotations, position)
        assert sle2 != null
        addSymbol(context.stubGenerator.convertMethod(false, sle2, self, 
                symbols)->(MethodStub), symbols)

        def sli1 := parser.parseMethodDeclaration(
                "function [...](left:panda.core.Int32," +
                "right:panda.core.Int32):\{name} {\n" +
                "var result := new \{mutableVersion}(right - left + 1)\n" +
                "for i, v in left ... right\n" +
                "    result[i] := self[v]\n" +
                "return result\{convert}\n" +
                "}", null, annotations, position)
        assert sli1 != null
        addSymbol(context.stubGenerator.convertMethod(false, sli1, self, 
                symbols)->(MethodStub), symbols)

        def sli2 := parser.parseMethodDeclaration(
                "function [...](rawLeft:panda.core.Int32?," +
                "rawRight:panda.core.Int32?):\{name} {\n" +
                "def left:panda.core.Int32\n" +
                "if rawLeft = null\n" +
                "    left := 0\n" +
                "else\n" +
                "    left := rawLeft\n" +
                "def right:panda.core.Int32\n" +
                "if rawRight = null\n" +
                "    right := length - 1\n" +
                "else\n" +
                "    right := rawRight\n" +
                "var result := new \{mutableVersion}(right - left + 1)\n" +
                "for i, v in left ... right\n" +
                "    result[i] := self[v]\n" +
                "return result\{convert}\n" +
                "}", null, annotations, position)
        assert sli2 != null
        addSymbol(context.stubGenerator.convertMethod(false, sli2, self, 
                symbols)->(MethodStub), symbols)

        -- FIXME: remove this convert method when new compiler is finished, it's
        -- only necessary for legacy varargs
        def oldConvertAnnotations := new Array<ASTAnnotation>()
        oldConvertAnnotations.add(new ASTSimpleAnnotation(position, "class"))
        def oldCnv := parser.parseMethodDeclaration(
            "function ->>(arr:panda.collections.Array<\{elementType.name}>):\{name} {\n" +
            "    def result := new \{name}(arr.length)\n" +
            "    for i, v in arr result[i] := v\n" +
            "    return result\n" +
            "}", null, oldConvertAnnotations, position)
        assert oldCnv != null
        addSymbol(context.stubGenerator.convertMethod(false, oldCnv, self, 
                symbols)->(MethodStub), symbols)

        if !immutable {
            def immutableVersion := class(ImmutablePrimitiveArray).name + 
                    name[name.indexOf("<")->(Int)..]
            def cnv := parser.parseMethodDeclaration(
                "function ->>():\{immutableVersion} {\n" +
                "    return new \{immutableVersion}(self)\n" +
                "}", null, annotations, position)
            assert cnv != null
            addSymbol(context.stubGenerator.convertMethod(false, cnv, self, 
                    symbols)->(MethodStub), symbols)
        }
        else {
            -- HACK, leaving this in only until new compiler is finished
            def convertAnnotations := new Array<ASTAnnotation>()
            convertAnnotations.add(new ASTSimpleAnnotation(position, "class"))
            def immutableVersion := class(ImmutablePrimitiveArray).name + 
                    name[name.indexOf("<")->(Int)..]
            def cnv := parser.parseMethodDeclaration(
                "function ->>(arr:\{mutableVersion}):\{name} {\n" +
                "    return new \{name}(arr)\n" +
                "}", null, convertAnnotations, position)
            assert cnv != null
            addSymbol(context.stubGenerator.convertMethod(false, cnv, self, 
                    symbols)->(MethodStub), symbols)
        }

        def superclass:ClassType
        if immutable
            superclass := ClassType.IMMUTABLE_PRIMITIVE_ARRAY
        else
            superclass := ClassType.PRIMITIVE_ARRAY
        return new ClassStub(position, self, false, 
                new Annotations(position, classAnnotations), 
                superclass, new Array<ClassType>(), symbols, 
                new LookupContext(), new Array<ASTInvariant>(), null, false,
                null)
    }

    @override
    function ->>():PrimitiveArrayType {
        return self
    }
}
