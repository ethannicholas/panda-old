package org.pandalanguage.pandac.types

================================================================================
The four `Int` types.
================================================================================
class IntType : PrimitiveType {
    constant REAL_CAST_COST := 4

    constant INT8 := new IntType(1)

    constant INT16 := new IntType(2)
                         
    constant INT32 := new IntType(4)
                         
    constant INT64 := new IntType(8)
    
    constant UINT8 := new IntType(1, false)

    constant UINT16 := new IntType(2, false)
                         
    constant UINT32 := new IntType(4, false)
                         
    constant UINT64 := new IntType(8, false)

    def signed:Bit
    
    @private
    constructor(size:Int) {
        constructor(size, true)
    }

    @private
    constructor(size:Int, signed:Bit) {
        super.constructor(getName(size, signed), size)
        self.signed := signed
    }

    @private
    @class
    function getName(size:Int, signed:Bit):String {
        var prefix:String
        if signed
            prefix := "Int"
        else
            prefix := "UInt"
        return "panda.core." + prefix + size * 8            
    }

    @override
    function isNumeric():Bit {
        return true
    }

    @override
    function isNumber():Bit {
        return true
    }

    @override
    function isInteger():Bit {
        return true
    }

    @override
    function canExplicitCastTo(target:Type):Bit {
        if target.isPrimitive
            return target.isNumeric
        --return wrapperVersion().canExplicitCastTo(target)
        throw new NotSupportedException()
    }

    @override
    function implicitCastCost(target:Type):Int? {
        if target.isNumber {
            if target->>(PrimitiveType).size < size
                return null
            var s := size
            var result := 0
            if target-?>(IntType) {
                if signed & !target->(IntType).signed
                    return null
                if !signed & target->(IntType).signed { 
                    if s = target->(IntType).size
                        return null
                    result += 1
                }
            }
            while s < target->(PrimitiveType).size {
                s *= 2
                result += 1
            }
            if target.isReal
                result += REAL_CAST_COST
            return result
        }
        else if target.isWrapper {
            var result := implicitCastCost(target->>(PrimitiveType))
            if result != null & target.isNullable
                result += NullableType.TO_NULLABLE_CAST_COST
            return result
        }
--        if !target.unwrapWrapper.isPrimitive
--            return wrapperVersion().implicitCastCost(target)
--        return null
        throw new NotSupportedException()
    }

    @override
    function preferredVariableType():Type {
        switch self {
            case INT8: return INT32
            case INT16: return INT32
            case INT32: return INT32
            case INT64: return INT64
            case UINT8: return INT32
            case UINT16: return INT32
            case UINT32: return INT64
            case UINT64: return UINT64
            default: unreachable
        }
    }
}
