package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.types.UnresolvedType

================================================================================
A type with generic parameters, such as 
`panda.collections.HashMap<panda.core.String, panda.core.Object>`. See
`GenericParameterType` for a more thorough discussion of how types are handled
with respect to generics.
================================================================================
class GenericType : ClassType {
    def base:ClassType
    def parameters:ImmutableArray<Type>

    constructor(base:ClassType, 
            parameters:ListView<Type>) {
        super.constructor(getName(base, parameters))
        self.base := base
        self.parameters := new ImmutableArray<Type>(parameters)
    }

    @private
    @class
    function getName(base:ClassType, parameters:ListView<Type>):String {
        var result := base.name->>(MutableString)
        result.append("<")
        for i, p in parameters {
            if i > 0
                result.append(",")
            result.append(p.name)
        }
        result.append(">")
        return result->>(String)
    }

    @override
    function baseName():String {
        return base.baseName
    }

    @override
    function isUnspecified():Bit {
        for p in parameters {
            if p.isUnspecified
                return true
        }
        return false
    }

    @override
    function isImmutable():Bit {
        return base.isImmutable
    }

    @override
    function subtypes():ImmutablePrimitiveArray<Type> {
        throw new NotSupportedException()
    }

    @private
    @class
    function simpleName(name:String):String {
        def pos := name.lastIndexOf(".")
        if pos = null
            return name
        return name[pos + 1..]
    }
}
