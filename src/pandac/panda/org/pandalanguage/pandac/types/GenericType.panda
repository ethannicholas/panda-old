package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.types.UnresolvedType

================================================================================
A type with generic parameters, such as 
`panda.collections.HashMap<panda.core.String, panda.core.Object>`. See
`GenericParameterType` for a more thorough discussion of how types are handled
with respect to generics.
================================================================================
class GenericType : ClassType {
    def position:Position
    def base:ClassType
    def parameters:ImmutableArray<Type>

    @private
    constructor(position:Position, base:ClassType, 
            parameters:ImmutableArray<Type>) {
        super.constructor(getName(base, parameters))
        for p in parameters
            assert p-!>(UnresolvedType) : "parameter \{p} of \{self} is uninitialized"
        self.position := position
        self.base := base
        self.parameters := parameters
    }

    @private
    @class
    function getName(base:ClassType, parameters:ImmutableArray<Type>):String {
        var result := base.name->>(MutableString)
        result.append("<")
        for i, p in parameters {
            if i > 0
                result.append(",")
            result.append(p.name)
        }
        result.append(">")
        return result->>(String)
    }

    @override
    function baseName():String {
        return base.baseName
    }

    @override
    function isUnspecified():Bit {
        for p in parameters {
            if p.isUnspecified
                return true
        }
        return false
    }

    @override
    method unwrapGenerics():Type {
        def result := new MutableString(base.name)
        result.append("<")
        for i, p in parameters {
            if i > 0
                result.append(",")
            result.append(p.unwrapGenerics().name)
        }
        result.append(">")
        return SymbolTable.master.getType(Position.INTERNAL, result->>(String))
    }

    @override
    function subtypes():ImmutableArray<Type> {
        return parameters
    }

    @class
    method mapType(symbolTable:SymbolTable, t:Type) {
        symbolTable.types[t.name] := t
        for child in t.subtypes
            mapType(symbolTable, child)
    }

    ============================================================================
    Given a raw type possibly containing generics, such as `Array<Array<T>>`,
    and a list of generic parameters and their corresponding concrete types,
    returns the actual types represented. For instance, given `Array<Array<T>>`,
    with `T` as a generic parameter and `String` as the concrete type, would
    return `Array<Array<String>>`.
    ============================================================================
    @class
    method replaceGenerics(position:Position, symbolTable:SymbolTable, raw:Type, 
            genericParameters:Array<GenericParameterType>,
            concreteTypes:ImmutableArray<Type>):Type {
        -- Past Me was an idiot. This is so much simpler than what I was doing
        -- before.
        def result := symbolTable.getType(position, raw.name)
        Console.writeLine("replaceGenerics mapped \{raw} to \{result}")
        return result
    }

    @override
    method performBasicClassInitialization() {
        classNode.isInterface := base.classNode.isInterface
        classNode.annotations := base.classNode.annotations.copy
        if parameters.filter(p => p.isUnspecified).length = 0
            classNode.annotations.isUnspecified := false
        for i, p in base.classNode.genericParameterTypes {
            Console.writeLine("mapping \{p.name} to \{parameters[i]} in \{self}")
            classNode.symbolTable.types[p.name] := parameters[i]
            mapType(classNode.symbolTable, parameters[i])
        }
    }

    @private
    method instantiateField(f:FieldNode) {
        def finalType := replaceGenerics(
                        classNode.position, classNode.symbolTable, 
                            f.type, base.classNode.genericParameterTypes, 
                            parameters)
        def newField := new FieldNode(f.position, f.name, finalType)
        Console.writeLine("field type is: " + finalType)
        newField.annotations := f.annotations.copy
        classNode.add(newField)
        classNode.symbolTable.putVariable(newField)
    }

    @private
    method instantiateMethod(m:MethodNode, linkageOnly:Bit) {
    Console.writeLine("instantiating \{m} into \{self}")
        if m.annotations.isClass
            return
        def genericClass := classNode
        def code := new MutableString()
        switch m.methodType {
            case MethodNodeType.CONSTRUCTOR: code.append("constructor(")
            case MethodNodeType.METHOD:      code.append("method \{m.name}(")
            case MethodNodeType.FUNCTION:    code.append("function \{m.name}(")
        }
        def start := 1
        for i, p in m.parameters[start..] {
            if i > 0
                code.append(", ")
            def finalType := replaceGenerics(
                    genericClass.position, genericClass.symbolTable, 
                        p.type, base.classNode.genericParameterTypes, 
                        parameters)
            code.append("\{p.name}:\{finalType.name}")
        }
        code.append(")")
        if m.returnType != VoidType.VOID {
            def finalType := replaceGenerics(
                    genericClass.position, genericClass.symbolTable, 
                        m.returnType, base.classNode.genericParameterTypes, 
                        parameters)
            code.append(":\{finalType.name}")
        }
        def body := m.parseNode
        if body != null
            code.append(body)
        else if !linkageOnly
            return
        def annotations := m.annotations.copy
        if !annotations.isAbstract & body = null
            annotations.isAbstract := true
        def ast := new ASTGenerator()
        ast.strictTypeChecking := false
        Console.writeLine("compiling \{code} in \{self}")
        ast.compileMethod(genericClass, code->>(String), 
                annotations,
                new Position(genericClass.name, m.position.line, 
                    m.position.column), linkageOnly)
    }

    @override
    method performFinalClassInitialization() {
        if classNode.state = ClassNodeState.DEFINED 
            return
        classNode.state := ClassNodeState.DEFINED
        for i, p in base.classNode.genericParameterTypes {
            Console.writeLine("checking parameter \{i}: \{parameters[i]} against \{p} ")
            if !parameters[i].canImplicitCastTo(p) {
                throw new CompilerException("'\{base.displayName}' generic " +
                        "parameter \{i + 1} must be compatible with " +
                        "'\{p.bound.displayName}', but found " +
                        "'\{parameters[i].displayName}'", position)
            }
        }
        Console.writeLine("passed")
        classNode.supertype := replaceGenerics(
                classNode.position, classNode.symbolTable, 
                base.classNode.supertype->(ClassType), 
                base.classNode.genericParameterTypes, parameters)->(ClassType)
        for intf in base.classNode.interfaces {
            def finalIntf := replaceGenerics(
                    classNode.position, classNode.symbolTable, 
                    intf, 
                    base.classNode.genericParameterTypes, parameters)->(ClassType)
            classNode.interfaces.append(finalIntf)
            classNode.symbolTable.interfaces.append(
                    finalIntf.classNode.symbolTable)
        }
        for f in base.classNode.fields
            instantiateField(f)
        for m in base.classNode.methods
            instantiateMethod(m, true)
    }

    method compilePhase2() {
        for m in base.classNode.methods
            instantiateMethod(m, false)
    }
}
