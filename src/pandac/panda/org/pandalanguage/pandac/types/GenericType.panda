package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.compiler.LookupContext
uses org.pandalanguage.pandac.compiler.Message
uses org.pandalanguage.pandac.compiler.MessageProcessor
uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.compiler.TypeMap
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.parser.ParseNode
uses org.pandalanguage.pandac.stubs.TypedClassStub
uses org.pandalanguage.pandac.stubs.TypedFormalParameter
uses org.pandalanguage.pandac.stubs.TypedMethodStub
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.types.UnresolvedType

================================================================================
A concrete instantiation of a type with generic parameters, such as 
`panda.collections.HashMap<panda.core.String, panda.core.Object>`. See
`GenericParameterType` for a more thorough discussion of how types are handled
with respect to generics (note in particular that `HashMap<K, V>` is *not* a 
`GenericType`).
================================================================================
class GenericType : ClassType (MessageProcessor) {
    def base:ClassType
    def parameters:ImmutableArray<Type>

    constructor(base:ClassType, 
            parameters:ListView<Type>) {
        super.constructor(getName(base, parameters))
        self.base := base
        self.parameters := new ImmutableArray<Type>(parameters)
    }

    @private
    @class
    function getName(base:ClassType, parameters:ListView<Type>):String {
        var result := base.name->>(MutableString)
        result.append("<")
        for i, p in parameters {
            if i > 0
                result.append(",")
            result.append(p.name)
        }
        result.append(">")
        return result->>(String)
    }

    @private
    function parseType(name:String):ParseNode {
        return new PandaParser().parseType(name, new Position(name, -1, -1))
    }

    @private
    function getType(type:Type, typeMap:TypeMap, 
            lookupContext:LookupContext):Type {
        if type = VoidType.VOID | type-?>(UnresolvedType)
            return type
        def result, messages := typeMap.getType(parseType(type.name), 
                lookupContext)
        assert result != null : "failed to find type '\{type}'"
        assert messages = null : 
                "unexpected messages resolving type: \{messages}"
        return result
    }

    @private
    method instantiateField(f:FieldNode, typeMap:TypeMap,
            lookupContext:LookupContext):FieldNode {
        return new FieldNode(f.position, self, f.name, f.annotations, f.varType,
                getType(f.type, typeMap, lookupContext), f.initialValue, 
                f.tuplePosition)
    }

    @private
    method instantiateMethod(m:TypedMethodStub, typeMap:TypeMap, 
            lookupContext:LookupContext):TypedMethodStub {
        def parameters := new Array<TypedFormalParameter>()
        for p in m.parameters {
            def type:Type
            if p.name = Parameter.SELF_NAME
                type := self
            else
                type := getType(p.type, typeMap, lookupContext)
            parameters.add(new TypedFormalParameter(p.position, p.name, 
                    type, p.isFinal, p.isConvert, p.isVarArg))
        }
        return new TypedMethodStub(m.position, m.name, m.annotations,
                m.methodType, parameters, getType(m.returnType, typeMap,
                    lookupContext), 
                m.block, self)
    }

    method createStub(typeMap:TypeMap, baseStub:TypedClassStub,
            parameterStubs:ListView<TypedClassStub?>):
            (TypedClassStub, ListView<Message>?) {
        var messages:ListView<Message>? := null
        def baseParameters := baseStub.genericParameters
        assert baseParameters != null : 
                "base class (\{baseStub.name}) is not generic"
        assert baseParameters.length = parameters.length : 
                "parameter mismatch (\{baseParameters} vs. \{parameters})"
        def position := new Position(name, -1, -1)
        def aliases := new HashMap<String, String>(
                baseStub.lookupContext.classAliases)
        for i, p in parameters {
            aliases[baseParameters[i].name] := p.name
            aliases[baseParameters[i].simpleName] := p.name
        }
        def lookupContext := new LookupContext(
                baseStub.lookupContext.packageUses, aliases)
        def fields := new Array<FieldNode>()
        fields.addAll(baseStub.fields.filter(f => f.annotations.isClass |
                f.annotations.isThread))
        for f in baseStub.fields.filter(f => !f.annotations.isClass &
                !f.annotations.isThread)
            fields.add(instantiateField(f, typeMap, lookupContext))
        def methods := new Array<TypedMethodStub>()
        for m in baseStub.methods.filter(m => !m.annotations.isClass)
            methods.add(instantiateMethod(m, typeMap, lookupContext))
        var superclass := baseStub.superclass
        var submessages:ListView<Message>?
        if superclass != null {
            def resolved:Type?
            resolved, submessages := typeMap.getType(parseType(
                    superclass.name), lookupContext)
            messages := addMessages(messages, submessages)
            superclass := resolved->(ClassType)
        }
        else
            superclass := null
        def interfaces := new Array<ClassType>()
        for intf in baseStub.interfaces {
            var type:Type?
            type, submessages := typeMap.getType(parseType(intf.name), 
                    lookupContext)
            messages := addMessages(messages, submessages)
            if type != null
                interfaces.add(type->>(ClassType))
        }
        var annotations := baseStub.annotations - AnnotationType.UNSPECIFIED
        for i, p in parameters {
            var unspecified := p-?>(GenericParameterType)
            def stub := parameterStubs[i]
            unspecified |= stub != null & stub.annotations.isUnspecified
            if unspecified {
                annotations += AnnotationType.UNSPECIFIED
                break
            }
        }
        return (new TypedClassStub(position, name, baseStub.isInterface, 
                annotations, lookupContext, superclass, interfaces, methods, 
                fields, baseStub.invariants, null, baseStub.isExternal), 
                messages)
    }    
}
