package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.tree.ClassNode

================================================================================
Represents a method type, with a list of parameters and return type (which may
be `void`).
================================================================================
class MethodType : ClassType {
    def methodParameters:ImmutableArray<Type>
    
    def returnType:Type

    def isFunction:Bit

    def immutableMethod:Bit

    constructor(methodParameters:ListView<Type>, returnType:Type, 
            isFunction:Bit, isImmutable:Bit) {
        super.constructor(getName(methodParameters, returnType, isFunction,
                isImmutable))
        self.methodParameters := new ImmutableArray<Type>(methodParameters)
        self.returnType := returnType
        self.isFunction := isFunction
        self.immutableMethod := isImmutable
    }

    @private
    @class
    function getName(parameterTypes:ListView<Type>, returnType:Type, 
            isFunction:Bit, isImmutable:Bit):String {
        var parameters := new MutableString()
        for i, p in parameterTypes {
            if i > 0
                parameters.append(",")
            parameters.append(p.name)
        }
        var yields:String
        if isFunction
            yields := "=>"
        else
            yields := "=&>"
        if isImmutable
            yields += "*"
        if returnType = VoidType.VOID
            return "(" + parameters + ")" + yields + "()"
        else
            return "(" + parameters + ")" + yields + "(" + returnType.name + ")"
    }

    @override
    function simpleName():String {
        def result := new MutableString("(")
        for i, p in methodParameters {
            if i > 0
                result.append(",")
            result.append(p.simpleName)
        }
        result.append(")=")
        if !isFunction
            result.append("&")
        result.append(">")
        if immutableMethod
            result.append("*")
        result.append("(")
        if returnType != VoidType.VOID
            result.append(returnType.simpleName)
        result.append(")")
        return result->>String
    }

    @override
    function displayName():String {
        def result := new MutableString("(")
        for i, p in methodParameters {
            if i > 0
                result.append(", ")
            result.append(p.displayName)
        }
        result.append(")=")
        if !isFunction
            result.append("&")
        result.append(">")
        if immutableMethod
            result.append("*")
        result.append("(")
        if returnType != VoidType.VOID
            result.append(returnType.displayName)
        result.append(")")
        return result->>String
    }

    @override
    function isMethod():Bit {
        return true
    }

    @override
    method isImmutable(context:Context):Bit {
        return immutableMethod
    }

    @override
    @unsafeFunction
    function implicitCastCost(context:Context, var target:Type):Int? {
        if !immutableMethod & target.isImmutable(context)
            return null
        var result := 0
        if target.isNullable {
            target := target.unwrapNullable
            result += NullableType.TO_NULLABLE_CAST_COST
        }
        if self = target
            return result
        if target.isMethod {
            def m := target->MethodType
            if m.isFunction & !isFunction
                return null
            else if isFunction & !m.isFunction
                result += 1
            if methodParameters.length != m.methodParameters.length
                return null
            for i, p in methodParameters {
                if p != m.methodParameters[i]
                    return null
            }
            if returnType != m.returnType
                return null
            return result
        }
        return self->>ClassType.implicitCastCost(context, target)
    }

    @override
    function ->>():MethodType {
        return self
    }

    @override
    function ->>():ClassType {
        if immutableMethod
            return ClassType.METHOD
        else
            return ClassType.MUTABLE_METHOD
    }
}
