package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.ASTGenerator
uses org.pandalanguage.pandac.compiler.CompilerException
uses org.pandalanguage.pandac.compiler.PandaCompiler
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.tree.Add
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.BitLiteral
uses org.pandalanguage.pandac.tree.Block
uses org.pandalanguage.pandac.tree.Cast
uses org.pandalanguage.pandac.tree.CastType
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.ClassNodeState
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.FieldReference
uses org.pandalanguage.pandac.tree.IntegerLiteral
uses org.pandalanguage.pandac.tree.IndexedAssignment
uses org.pandalanguage.pandac.tree.LocalVariable
uses org.pandalanguage.pandac.tree.MethodCall
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.Return
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.tree.Value
uses org.pandalanguage.pandac.tree.ValueStatement
uses org.pandalanguage.pandac.tree.VariableAssignment
uses org.pandalanguage.pandac.tree.VariableReference

================================================================================
An array (mutable or immutable) of another type.
================================================================================
class PrimitiveArrayType : GenericType {
    @class
    method ARRAY_ANY():PrimitiveArrayType {
        return SymbolTable.master.getType(Position.INTERNAL, 
                class(PrimitiveArray<Object?>).name)->(PrimitiveArrayType)
    }

    @class
    method ARRAY_STRING():PrimitiveArrayType {
        return SymbolTable.master.getType(Position.INTERNAL, 
                class(PrimitiveArray<String>).name)->(PrimitiveArrayType)
    }

    @class
    method IMMUTABLE_ARRAY_ANY():PrimitiveArrayType {
        return SymbolTable.master.getType(Position.INTERNAL, 
                class(ImmutablePrimitiveArray<Immutable?>).name)->(PrimitiveArrayType)
    }

    constructor(arrayClass:ClassType, elementType:Type) {
        super.constructor(Position.INTERNAL, arrayClass, [elementType])
    }

    @override
    function elementType():Type {
        return parameters[0]
    }

    @override
    function isPrimitiveArray():Bit {
        return true
    }

    @override
    function simpleName():String {
        def base := super.simpleName
        return base[..base.indexOf("<")] + "<" + elementType.simpleName + ">"
    }

    @override
    method performBasicClassInitialization() {
        classNode.annotations.isFinal := true

        GenericType.mapType(classNode.symbolTable, elementType)

        def immutable := name.startsWith(ClassNode.IMMUTABLE_PRIMITIVE_ARRAY_NAME)
        if immutable {
            classNode.supertype := SymbolTable.master.getType(
                    classNode.position, 
                    ClassNode.IMMUTABLE_PRIMITIVE_ARRAY_NAME)->(ClassType)
        }
        else {
            classNode.supertype := SymbolTable.master.getType(
                    classNode.position, 
                    ClassNode.PRIMITIVE_ARRAY_NAME)->(ClassType)
        }
        var dedupLine := 0
        var length := new FieldNode(new Position(displayName, dedupLine, 0), 
                "$length", Type.INDEX_TYPE)
        dedupLine += 1
        length.annotations.isReadOnly := true
        if immutable
            length.annotations.isFinal := true
        classNode.add(length)
        classNode.symbolTable.putVariable(length)

        var selfParam := new Parameter("self", self)
        var parameters := new PrimitiveArray<Parameter>(selfParam)
        var lengthMethod := new MethodNode(new Position(displayName + ":length", 
                dedupLine, 0), "length", MethodNodeType.FUNCTION,
                parameters)
        dedupLine += 1
        lengthMethod.returnType := IntType.INT32
        var block := new Block(classNode.symbolTable)
        block.add(new Return(new FieldReference(new VariableReference(selfParam),
                length)))
        lengthMethod.add(block)
        lengthMethod.annotations.isFinal := true
        classNode.add(lengthMethod)
        classNode.symbolTable.putMethod(lengthMethod)
    }

    @override
    method performFinalClassInitialization() {
        def arrayClass := classNode
        if arrayClass.state = ClassNodeState.DEFINED | 
                arrayClass.state = ClassNodeState.EXTERNALLY_DEFINED
            return

        if !classNode.annotations.isUnspecified
            classNode.annotations.isUnspecified := isUnspecified

        def name:String
        def displayName:String
        if isImmutable {
            name := "\{class(ImmutablePrimitiveArray).name}<\{elementType.name}>"
            displayName := "\{class(ImmutablePrimitiveArray).name}<\{elementType.displayName}>"
        }
        else {
            name := "\{class(PrimitiveArray).name}<\{elementType.name}>"
            displayName := "\{class(PrimitiveArray).name}<\{elementType.displayName}>"
        }
        if isImmutable & !elementType.isImmutable {
            PandaCompiler.reportError(new CompilerException(
                    "immutable array may not have mutable element type '\{elementType.name}'",
                    classNode.position))
        }

        -- FIXME HACK uggghhhh long past time for this to die. ASTGenerator
        -- relies on the node's position to match the same entities up between
        -- passes, so we need to ensure these fields and methods have different 
        -- positions
        var dedupLine := 2
        if arrayClass.state = ClassNodeState.EXTERNAL_INSTANCE
            arrayClass.state := ClassNodeState.EXTERNALLY_DEFINED
        else
            arrayClass.state := ClassNodeState.DEFINED
        def immutable := 
                name.startsWith(ClassNode.IMMUTABLE_PRIMITIVE_ARRAY_NAME)
        def supertype := arrayClass.supertype
        assert supertype != null
        def position := arrayClass.position
        def maxLength := new FieldNode(new Position(displayName, 
                dedupLine, 0), "$maxLength", Type.INDEX_TYPE)
        dedupLine += 1
        if immutable
            maxLength.annotations.isFinal := true
        maxLength.annotations.isPrivate := true
        arrayClass.add(maxLength)
        arrayClass.symbolTable.putVariable(maxLength)
        def element := new FieldNode(new Position(displayName, 
                dedupLine, 0), FieldNode.ELEMENTS_NAME, elementType)
        if immutable
            element.annotations.isFinal := true
        dedupLine += 1
        arrayClass.add(element)
        arrayClass.symbolTable.putVariable(element)

        new ASTGenerator().compileMethod(arrayClass, 
                "function join(del:panda.core.String):panda.core.String {\n" +
                "var result := new panda.core.MutableString()\n" +
                "for i, v in self {\n" + 
                "   if i > 0\n" +
                "       result.append(del)\n" +
                "   result.append(v)\n" +
                "}\n" +
                "return result->>(panda.core.String)\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC]), 
                    new Position(displayName + ":join", dedupLine, 0))
        dedupLine += 1

        def formatPosition := new Position(displayName + "->>(String)", 
                dedupLine, 0)
        def formatAnnotations := new Annotations([AnnotationType.SYNTHETIC, 
                AnnotationType.OVERRIDE])
        formatAnnotations.pre.append(new PandaParser().parseExpression("true", 
                formatPosition))
        new ASTGenerator().compileMethod(arrayClass, 
                "function format(fmt:String):panda.core.String {\n" +
                "var result := '['->>(MutableString)\n" +
                "for i, v in self {\n" +
                "if i > 0 result.append(', ')\n" +
                "result.append(panda.core.Panda.format(v, fmt)) }\n" +
                "result.append(']')\n" +
                "return result->>(String)" +
                "}", formatAnnotations, formatPosition)
        dedupLine += 1

        var mutableVersion := name
        if immutable {
            mutableVersion := class(PrimitiveArray).name + 
                    mutableVersion[name.indexOf("<")->(Int)..]
            new ASTGenerator().compileMethod(arrayClass, 
                    "function ->>():" + mutableVersion + " {\n" +
                    "var result := new " + mutableVersion + "()\n" +
                    "for v in self { result.append(v) }\n" +
                    "return result\n" +
                    "}", new Annotations([AnnotationType.SYNTHETIC]), 
                    new Position(displayName + ":->>(" + 
                            mutableVersion + ")", dedupLine, 0))
            dedupLine += 1
            new ASTGenerator().compileMethod(arrayClass, 
                    "function ->>(src:" + mutableVersion + "):" + name + 
                    " {\n" +
                    "return new " + name + "(src, 0, src.length)\n" +
                    "}", new Annotations([AnnotationType.SYNTHETIC, 
                        AnnotationType.CLASS]), 
                    new Position(displayName + ":->>(" + displayName + ")", 
                    dedupLine, 0))
            dedupLine += 1
        }
        else {
            -- setLength
            -- for internal use only. equivalent to length:=, but allows the 
            -- array to get longer even when its element type is non-nullable
            new ASTGenerator().compileMethod(arrayClass, 
                    "method setLength(length:panda.core.Int32) {\n" +
                    "    setLength(self, \{elementType.size}, true, length)\n" +
                    "}", new Annotations([AnnotationType.SYNTHETIC,
                        AnnotationType.SELF, AnnotationType.PRIVATE]), 
                    new Position(displayName + ":setLength()", dedupLine, 0))
            dedupLine += 1

            -- length:=
            def lengthPosition := new Position(displayName + ":length:=()", 
                    dedupLine, 0)
            dedupLine += 1
            def lengthAnnotations := new Annotations([AnnotationType.SYNTHETIC,
                    AnnotationType.SELF])
            if !elementType.isPrimitive & !elementType.isNullable {
                lengthAnnotations.pre.append(new PandaParser().parseExpression(
                        "length <= self.length", lengthPosition))
            }
            new ASTGenerator().compileMethod(arrayClass, 
                    "method length:=(length:Int) {\n" +
                    "    setLength(length)\n" +
                    "}", lengthAnnotations, lengthPosition)
            def setLength := arrayClass[arrayClass.length - 1]->(MethodNode)

            -- append
            new ASTGenerator().compileMethod(arrayClass, 
                    "method append(e:\{elementType.name}) {\n" +
                    "    def l := $length\n" +
                    "    setLength(l + 1)\n" +
                    "    self[l] := e\n" +
                    "}", new Annotations([AnnotationType.SYNTHETIC,
                        AnnotationType.SELF]), 
                    new Position(displayName + ":append()", dedupLine, 0))
            dedupLine += 1

            -- appendAll
            new ASTGenerator().compileMethod(arrayClass, 
                    "method appendAll(src:" + name + ") {\n" +
                    "for v in src append(v)\n" +
                    "}", new Annotations([AnnotationType.SYNTHETIC,
                        AnnotationType.SELF]), 
                    new Position(displayName + ":appendAll", dedupLine, 0))
            dedupLine += 1
        }

        var convert := ""
        if immutable
            convert := "->>(" + name + ")"
        new ASTGenerator().compileMethod(arrayClass, 
                "function [..](left:panda.core.Int32," +
                "right:panda.core.Int32):" + name + " {\n" +
                "var result := new " + mutableVersion + "()\n" +
                "for i in left .. right\n" +
                "    result.append(self[i])" +
                "return result" + convert + "\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC, 
                    AnnotationType.SAFERETURN]),
                new Position(displayName + ":[..]1", dedupLine, 0))
        dedupLine += 1
        new ASTGenerator().compileMethod(arrayClass, 
                "function [..](var left:panda.core.Int32?," +
                "var right:panda.core.Int32?):" + name + " {\n" +
                "if left = null\n" +
                "    left := 0\n" +
                "if right = null" +
                "    right := length\n" +
                "var result := new " + mutableVersion + "()\n" +
                "for i in left .. right\n" +
                "    result.append(self[i])" +
                "return result" + convert + "\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC, 
                    AnnotationType.SAFERETURN]),
                new Position(displayName + ":[..]2", dedupLine, 0))
        dedupLine += 1
        new ASTGenerator().compileMethod(arrayClass,
                "function [..](var left:panda.core.Int32?," +
                "var right:panda.core.Int32?, step:panda.core.Int32):" + name + 
                " {\n" +
                "if left = null {\n" +
                "    if step > 0\n" +
                "        left := 0\n" +
                "    else\n" +
                "        left := length - 1\n" +
                "}\n" +
                "if right = null {" +
                "    if step > 0\n" +
                "        right := length\n" +
                "    else\n" +
                "        right := -1" +
                "}\n" +
                "var result := new " + mutableVersion + "()\n" +
                "for i in left .. right by step\n" +
                "    result.append(self[i])" +
                "return result" + convert + "\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC,
                    AnnotationType.SAFERETURN]),
                new Position(displayName + ":[..]3", dedupLine, 0))
        dedupLine += 1

        new ASTGenerator().compileMethod(arrayClass, 
                "function [...](left:panda.core.Int32," +
                "right:panda.core.Int32):" + name + " {\n" +
                "var result := new " + mutableVersion + "()\n" +
                "for i in left ... right\n" +
                "    result.append(self[i])" +
                "return result" + convert + "\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC, 
                    AnnotationType.SAFERETURN]),
                new Position(displayName + ":[...]1", dedupLine, 0))
        dedupLine += 1
        new ASTGenerator().compileMethod(arrayClass, 
                "function [...](var left:panda.core.Int32?," +
                "var right:panda.core.Int32?):" + name + " {\n" +
                "if left = null\n" +
                "    left := 0\n" +
                "if right = null" +
                "    right := length - 1\n" +
                "var result := new " + mutableVersion + "()\n" +
                "for i in left ... right\n" +
                "    result.append(self[i])" +
                "return result" + convert + "\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC, 
                    AnnotationType.SAFERETURN]),
                new Position(displayName + ":[...]2", dedupLine, 0))
        dedupLine += 1
        new ASTGenerator().compileMethod(arrayClass,
                "function [...](var left:panda.core.Int32?," +
                "var right:panda.core.Int32?, step:panda.core.Int32):" + name + 
                " {\n" +
                "if left = null {\n" +
                "    if step > 0\n" +
                "        left := 0\n" +
                "    else\n" +
                "        left := length - 1\n" +
                "}\n" +
                "if right = null {" +
                "    if step > 0\n" +
                "        right := length - 1\n" +
                "    else\n" +
                "        right := 0" +
                "}\n" +
                "var result := new " + mutableVersion + "()\n" +
                "for i in left ... right by step\n" +
                "    result.append(self[i])" +
                "return result" + convert + "\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC,
                    AnnotationType.SAFERETURN]),
                new Position(displayName + ":[..]3", dedupLine, 0))
        dedupLine += 1
        if !immutable {
            new ASTGenerator().compileMethod(arrayClass,
                "method [..]:=(var start:panda.core.Int32?, " +
                    "var end:panda.core.Int32?, " +
                    "step:panda.core.Int32, s->>" + name + ") {\n" +
                    "if start = null {\n" +
                        "if step > 0\n" +
                            "start := 0\n" +
                        "else\n" + 
                            "start := length - 1\n" +
                    "}\n" +
                    "if end = null {\n" +
                        "if step > 0\n" +
                            "end := length\n" +
                        "else\n" +
                            "end := -1\n" +
                    "}\n" + 
                    "if step = 1 {\n" +
                        "var oldLength := end - start\n" +
                        "var newLength := s.length\n" + 
                        "if oldLength > newLength {\n" +
                            "var copyDest := start + newLength\n" +
                            "var delta := end - start - s.length\n" +
                            "for i in copyDest .. copyDest + length - end\n" +
                                "self[i] := self[i + delta]\n" +
                            "setLength(length + newLength - oldLength)\n" +
                        "}\n" +
                        "else {\n" +
                            "var originalPrimitiveArrayLength := length\n" +
                            "setLength(length + newLength - oldLength)\n" +
                            "var copyDest := start + newLength\n" +
                            "var delta := end - start - s.length\n" +
                            "for i in copyDest + originalPrimitiveArrayLength - end - 1 .. copyDest - 1" +
                                    "by -1\n"+
                                "self[i] := self[i + delta]\n" +
                        "}\n" +
                        "for i in start .. start + s.length\n" +
                            "self[i] := s[i - start]\n" +
                    "}\n" +
                    "else {\n" +
                        "var src := 0\n" +
                        "for dest in start .. end by step {\n" +
                            "self[dest] := s[src]\n" +
                            "src += 1\n" +
                        "}\n" +
                        "if src != s.length\n" +
                            "throw new SafetyError(\n" +
                                    "'slice source and destination " +
                                    "lengths do not match')\n" +
                    "}\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC,
                    AnnotationType.SELF]),
                new Position(displayName + ":[..]:=", dedupLine, 0))
            dedupLine += 1
            new ASTGenerator().compileMethod(arrayClass,
                "method [...]:=(var start:panda.core.Int32?, " +
                    "var end:panda.core.Int32?, " +
                    "step:panda.core.Int32, s->>" + name + ") {\n" +
                    "if start = null {\n" +
                        "if step > 0\n" +
                            "start := 0\n" +
                        "else\n" + 
                            "start := length - 1\n" +
                    "}\n" +
                    "if end = null {\n" +
                        "if step > 0\n" +
                            "end := length - 1\n" +
                        "else\n" +
                            "end := 0\n" +
                    "}\n" + 
                    "if step = 1 {\n" +
                        "var oldLength := end - start + 1\n" +
                        "var newLength := s.length\n" + 
                        "if oldLength > newLength {\n" +
                            "var copyDest := start + newLength\n" +
                            "var delta := end - start - s.length\n" +
                            "for i in copyDest .. copyDest + length - end\n" +
                                "self[i] := self[i + delta]\n" +
                            "setLength(length + newLength - oldLength)\n" +
                        "}\n" +
                        "else {\n" +
                            "var originalPrimitiveArrayLength := length\n" +
                            "setLength(length + newLength - oldLength)\n" +
                            "var copyDest := start + newLength - 1\n" +
                            "var delta := end - start + 1 - s.length\n" +
                            "for i in copyDest + originalPrimitiveArrayLength - end - 1 .. copyDest - 1" +
                                    "by -1\n"+
                                "self[i] := self[i + delta]\n" +
                        "}\n" +
                        "for i in start .. start + s.length\n" +
                            "self[i] := s[i - start]\n" +
                    "}\n" +
                    "else {\n" +
                        "var src := 0\n" +
                        "for dest in start ... end by step {\n" +
                            "self[dest] := s[src]\n" +
                            "src += 1\n" +
                        "}\n" +
                        "if src != s.length\n" +
                            "throw new SafetyError(\n" +
                                    "'slice source and destination " +
                                    "lengths do not match')\n" +
                    "}\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC,
                    AnnotationType.SELF]),
                new Position(displayName + ":[...]:=", dedupLine, 0))
            dedupLine += 1
        }

        new ASTGenerator().compileMethod(arrayClass, 
                "function filter(f:(\{elementType.name})=>(panda.core.Bit)):\{name} {\n" +
                "def result := new \{mutableVersion}()\n" +
                "for v in self\n" +
                "    if f(v) result.append(v)\n" +
                "return result" + convert + "\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC, 
                        AnnotationType.SAFERETURN]),
                new Position(displayName + ":filter", dedupLine, 0))
        dedupLine += 1

        def foldPosition := new Position(displayName + ":fold1", dedupLine, 0)
        def foldAnnotations := new Annotations([AnnotationType.SYNTHETIC, 
                AnnotationType.SAFERETURN])
        foldAnnotations.pre.append(new PandaParser().parseExpression(
                "length > 0", formatPosition))
        new ASTGenerator().compileMethod(arrayClass, 
                "function fold(f:(\{elementType.name},\{elementType.name})=>(\{elementType.name})):\{elementType.name} {\n" +
                "var result:\{elementType.name} := self[0]\n" +
                "for i in 1 .. length\n" +
                "    result := f(result, self[i])\n" +
                "return result\n" +
                "}", foldAnnotations, foldPosition)
        dedupLine += 1

        new ASTGenerator().compileMethod(arrayClass, 
                "function fold(f:(\{elementType.name},\{elementType.name})=>(\{elementType.name}), identity:\{elementType.name}):\{elementType.name} {\n" +
                "var result:\{elementType.name} := identity\n" +
                "for v in self\n" +
                "    result := f(result, v)\n" +
                "return result\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC, 
                        AnnotationType.SAFERETURN]),
                new Position(displayName + ":fold2", dedupLine, 0))
        dedupLine += 1

        new ASTGenerator().compileMethod(arrayClass, 
                "method apply(f:(\{elementType.name})=&>()) {\n" +
                "for v in self\n" +
                "    f(v)\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC]),
                new Position(displayName + ":apply", dedupLine, 0))
        dedupLine += 1

        new ASTGenerator().compileMethod(arrayClass, 
                "function contains(needle:\{elementType.name}):Bit {\n" +
                "for v in self\n" +
                "    if v = needle return true\n" +
                "return false\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC]),
                new Position(displayName + ":in", dedupLine, 0))
        dedupLine += 1

        new ASTGenerator().compileMethod(arrayClass, 
                "function =(o:Object):Bit {\n" +
                "if o-!>(\{name})\n" +
                "    return false\n" +
                "def other := o->(\{name})\n" +
                "if length != other.length return false\n" +
                "for i, v in self\n" +
                "    if v != other[i] return false\n" +
                "return true\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC, 
                    AnnotationType.OVERRIDE]),
                new Position(displayName + ":=", dedupLine, 0))
        dedupLine += 1

        constant MULTIPLIER := 53
        new ASTGenerator().compileMethod(arrayClass, 
                "function hash():Int {\n" +
                "var result := 0\n" +
                "for v in self\n" +
                "    result := result * \{MULTIPLIER} + v.hash\n" +
                "return result\n" +
                "}", new Annotations([AnnotationType.SYNTHETIC,
                    AnnotationType.OVERRIDE, AnnotationType.OVERFLOW]),
                new Position(displayName + ":hash", dedupLine, 0))
        dedupLine += 1
    }

    @override
    method compilePhase2() {
    }
}
