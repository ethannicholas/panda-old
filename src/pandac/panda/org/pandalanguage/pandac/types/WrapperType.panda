package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.compiler.InternalCompilerException
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.compiler.SymbolTable

================================================================================
A wrapper for a primitive type.
================================================================================
class WrapperType : ClassType {
    constant SUFFIX := "Wrapper"

    constant INT8_WRAPPER   := new WrapperType(IntType.INT8)
    constant INT16_WRAPPER  := new WrapperType(IntType.INT16)
    constant INT32_WRAPPER  := new WrapperType(IntType.INT32)
    constant INT64_WRAPPER  := new WrapperType(IntType.INT64)
    constant UINT8_WRAPPER  := new WrapperType(IntType.UINT8)
    constant UINT16_WRAPPER := new WrapperType(IntType.UINT16)
    constant UINT32_WRAPPER := new WrapperType(IntType.UINT32)
    constant UINT64_WRAPPER := new WrapperType(IntType.UINT64)
    constant REAL32_WRAPPER := new WrapperType(RealType.REAL32)
    constant REAL64_WRAPPER := new WrapperType(RealType.REAL64)
    constant BIT_WRAPPER    := new WrapperType(BitType.BIT)
    constant CHAR_WRAPPER   := new WrapperType(CharType.CHAR)

    @private
    def base:PrimitiveType

    constructor(base:PrimitiveType) {
        super.constructor(base.name + SUFFIX)
        self.base := base
    }

    @override
    function displayName():String {
        assert name.endsWith(SUFFIX)
        return name[..name.length - SUFFIX.length]
    }

    @override
    function simpleName():String {
        assert name.endsWith(SUFFIX)
        return name[name.lastIndexOf(".")->(Int) + 1 .. 
                name.length - SUFFIX.length]
    }

    @override
    function isWrapper():Bit {
        return true
    }

    @override
    function implicitCastCost(context:Context, target:Type):Int? {
        if target.isNullable {
            def result := implicitCastCost(context, target.unwrapNullable)
            if result != null
                return result + NullableType.TO_NULLABLE_CAST_COST
            return null
        }
        if target.isWrapper | target.isPrimitive {
            return self->>(PrimitiveType).implicitCastCost(context,
                    target->>(PrimitiveType))
        }
        return super.implicitCastCost(context, target)
    }

    @override
    function canExplicitCastTo(context:Context, target:Type):Bit {
        if self->>(PrimitiveType).canExplicitCastTo(context, target)
            return true
        return super.canExplicitCastTo(context, target)
    }

    @override
    function ->>():PrimitiveType {
        return base
    }

    @override
    function ->>():WrapperType {
        return self
    }
}
