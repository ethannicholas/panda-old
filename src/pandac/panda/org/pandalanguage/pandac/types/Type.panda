package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.compiler.TypeMap
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.tree.Position

================================================================================
Represents a Panda type. This includes class types (`panda.core.Object`),
primitive types (`Int32`), nullable types (`panda.core.Object?`), and special
types (`STRING_OR_CHAR`, `REAL_LITERAL`), among others.

Each type has two names: the `name` property, which is the actual, internal name
of the type, and the `displayName` property, which is the user-visible name of
the type that should be reported in error messages. `displayName` is not unique,
as e.g. the types `panda.core.Int32` and `panda.core.Int32Wrapper` both get
displayed as `panda.core.Int32`. To avoid mistakes relating to `name` vs.
`displayName`, `Type` deliberately has a useless convert-to-string operator
which forces you to pick one or the other name property.
================================================================================
@abstract
class Type : Immutable {
    def name:String

    @protected
    @pre(!name.contains(" "))
    constructor(name:String) {
        self.name := name
    }

    function displayName():String {
        return name
    }

    function simpleName():String {
        return name
    }

    function preferredVariableType():Type {
        return self
    }

    function implicitCastCost(t:Type):Int? {
        if self = t
            return 0
        return null
    }

    function canExplicitCastTo(t:Type):Bit {
        return self = t
    }

    function isPrimitive():Bit {
        return false
    }

    function isPrimitiveArray():Bit {
        return false
    }

    function isWrapper():Bit {
        return false
    }

    function isNullable():Bit {
        return false
    }

    function isMethod():Bit {
        return false
    }

    function isTuple():Bit {
        return false
    }

    function isNumber():Bit {
        return false
    }

    function isNumeric():Bit {
        return false
    }

    function isInteger():Bit {
        return false
    }

    function isReal():Bit {
        return false
    }

    @override
    function format(fmt:String):String {
        return "\{class.simpleName}<\{name}:\{hash}>"
    }

    function unwrapNullable():Type {
        return self
    }

    method nullableVersion(context:Context):Type {
        if isNullable
            return self
        assert !name.endsWith("?")
        def result, messages := context.typeMap.getType(
                new PandaParser().parseType(name + "?", Position.INTERNAL),
                context.lookupContext)
        assert result != null : "could not find nullable version of \{self}"
        assert messages != null : messages->>(String)
        return result
    }

    function ->>():PrimitiveType {
        throw new NotSupportedException("\{self} is not a wrapper")
    }

    function ->>():ClassType {
        throw new NotSupportedException("\{self} is not a class")
    }

    function ->>():WrapperType {
        throw new NotSupportedException("\{self} is not primitive")
    }

    function ->>():TupleType {
        throw new NotSupportedException("\{self} is not a tuple")
    }

    function ->>():PrimitiveArrayType {
        throw new NotSupportedException("\{self} is not a primitive array")
    }
}
