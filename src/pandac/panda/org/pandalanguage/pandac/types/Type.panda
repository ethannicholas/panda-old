package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.parser.PandaParser
uses org.pandalanguage.pandac.tree.Position

================================================================================
Represents a Panda type. This includes class types (`panda.core.Object`),
primitive types (`Int32`), nullable types (`panda.core.Object?`), and special
types (`STRING_OR_CHAR`, `REAL_LITERAL`), among others.

Each type has two names: the `name` property, which is the actual, internal name
of the type, and the `displayName` property, which is the user-visible name of
the type that should be reported in error messages. `displayName` is not unique,
as e.g. the types `panda.core.Int32` and `panda.core.Int32Wrapper` both get
displayed as `panda.core.Int32`. To avoid mistakes relating to `name` vs.
`displayName`, `Type` deliberately has a useless convert-to-string operator
which forces you to pick one or the other name property.

With only a few exceptions (primitive types, special internal-only types) types 
represent classes and have associated `TypedClassStub`s. To get actual 
information about the type (what methods it contains, etc.) you will need access
to its corresponding class stub; the `Type` by itself is primarily just a key
uniquely identifying the type.
================================================================================
@abstract
class Type : Immutable {
    def name:String

    @protected
    constructor(name:String) {
        self.name := name
    }

    function displayName():String {
        return name
    }

    function simpleName():String {
        def index := name.lastIndexOf(".")
        if index != null
            return name[index + 1..]
        return name
    }

    function preferredVariableType():Type {
        return self
    }

    @final
    function canImplicitCastTo(context:Context, t:Type):Bit {
        return implicitCastCost(context, t) != null
    }

    function implicitCastCost(context:Context, t:Type):Int? {
        if self = t
            return 0
        return null
    }

    function canExplicitCastTo(context:Context, t:Type):Bit {
        return implicitCastCost(context, t) != null
    }

    function isPrimitive():Bit {
        return false
    }

    function isPrimitiveArray():Bit {
        return false
    }

    function isWrapper():Bit {
        return false
    }

    function isNullable():Bit {
        return false
    }

    function isMethod():Bit {
        return false
    }

    function isTuple():Bit {
        return false
    }

    function isNumber():Bit {
        return false
    }

    function isNumeric():Bit {
        return false
    }

    function isInteger():Bit {
        return false
    }

    function isReal():Bit {
        return false
    }

    @override
    function format(fmt:String):String {
        return "\{class.simpleName}<\{name}>"
    }

    function unwrapNullable():Type {
        return self
    }

    method nullableVersion(context:Context):Type {
        if isNullable
            return self
        assert !name.endsWith("?")
        def result, messages := context.typeMap.getType(
                new PandaParser().parseType(name + "?", Position.INTERNAL),
                context.lookupContext)
        assert result != null : "could not find nullable version of \{self}"
        assert messages = null : messages->>(String)
        return result
    }

    @override
    @final
    function hash():Int {
        return name.hash
    }

    @override
    @final
    function =(o:Object):Bit {
        if o-!>(Type)
            return false
        return name = o->(Type).name
    }

    function ->>():PrimitiveType {
        throw new NotSupportedException("\{self} is not a wrapper")
    }

    function ->>():ClassType {
        throw new NotSupportedException("\{self} is not a class")
    }

    function ->>():WrapperType {
        throw new NotSupportedException("\{self} is not primitive")
    }

    function ->>():TupleType {
        throw new NotSupportedException("\{self} is not a tuple")
    }

    function ->>():PrimitiveArrayType {
        throw new NotSupportedException("\{self} is not a primitive array")
    }

    function ->>():MethodType {
        throw new NotSupportedException("\{self} is not a method")
    }
}
