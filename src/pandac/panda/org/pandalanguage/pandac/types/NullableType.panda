package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.compiler.SymbolTable

================================================================================
A nullable version of a `ClassType`.
================================================================================
class NullableType : Type {
    constant TO_NULLABLE_CAST_COST := 1
    constant FROM_NULLABLE_CAST_COST := 2

    @private
    def base:Type

    constructor(base:Type) {
        super.constructor(base.name + "?")
        self.base := base
    }

    @override
    method canExplicitCastTo(target:Type):Bit {
        return base.canExplicitCastTo(target)
    }

    @override
    method implicitCastCost(target:Type):Int {
        if target.isNullable {
            return unwrapNullable.implicitCastCost(
                    target.unwrapNullable)
        }
        var result := unwrapNullable.implicitCastCost(target)
        if result != NO_MATCH
            result += FROM_NULLABLE_CAST_COST
        return result
    }

    @override
    method findConverterTo(target:Type):MethodNode? {
        return base.findConverterTo(target)
    }

    function nonNullableVersion():Type {
        return base
    }

    @override
    method getNullableVersion():NullableType {
        return self
    }

    @override
    function isNullable():Bit {
        return true
    }

    @override
    function isImmutable():Bit {
        return base.isImmutable()
    }

    @override
    function isUnspecified():Bit {
        return base.isUnspecified
    }

    @override
    function isWrapper():Bit {
        return base.isWrapper
    }

    @override
    function isPrimitiveArray():Bit {
        return base.isPrimitiveArray
    }

    @override
    function classNode():ClassNode {
        return base.classNode
    }

    @override
    function elementType():Type {
        return base.elementType
    }

    @override
    function isMethod():Bit {
        return base.isMethod
    }

    @override
    function isTuple():Bit {
        return base.isTuple
    }

    @override
    function methodParameters():ListView<Type> {
        return base.methodParameters
    }

    @override
    function returnType():Type? {
        return base.returnType
    }

    @override
    function baseName():String {
        return base.baseName
    }

    @override
    function displayName():String {
        return base.displayName + "?"
    }

    @override
    function simpleName():String {
        return base.simpleName + "?"
    }

    @override
    function unwrapNullable():Type {
        -- it is possible for our base to also be nullable -- consider the
        -- case of class Foo<T> { var t:T? }. The bound of T is Object?, which
        -- means that the type T? is basically Object??.
        return base.unwrapNullable()
    }

    @override
    function unwrapWrapper():Type {
        return base.unwrapWrapper()
    }

    @override
    method unwrapGenerics():Type {
        throw new NotSupportedException()
    }
}
