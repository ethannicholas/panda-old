package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.SymbolTable
uses org.pandalanguage.pandac.types.Type

================================================================================
A type corresponding to one of the formal generic parameters on a class, 
interface, or method. In the class `panda.collections.HashMap<K, V>`:

* `panda.collections.HashMap` is a `ClassNode` (and corresponding `ClassType`), 
  with two `genericParameterTypes`. This `ClassNode` will have the 
  automatically-added `@unspecified` annotation, indicating that it cannot be 
  used without specifying generic parameters.
* `K` and `V` are `GenericParameterTypes`. They have their own entries in the
  type table, as well as appearing in the `genericParameterTypes` property of
  `panda.collections.HashMap`.
* A specific instantiation of this class, such as 
  `panda.collections.HashMap<panda.core.String, panda.core.Object>`, would be a 
  new `GenericType` with corresponding `ClassNode`.
================================================================================
class GenericParameterType : Type {
    def owner:ClassType

    constructor(owner:ClassType, name:String, bound:Type) {
        super.constructor(name)
        self.owner := owner
        SymbolTable.master.bounds[self] := bound
    }

    function bound():Type {
        return SymbolTable.master.bounds[self]->(Type)
    }

    @override
    function classNode():ClassNode {
        return bound.classNode
    }

    @override
    function unwrapGenerics():Type {
        return bound
    }

    @override
    function isNullable():Bit {
        return bound.isNullable
    }

    @override
    function isImmutable():Bit {
        return bound.isImmutable
    }

    @override
    function unwrapNullable():Type {
        return bound.unwrapNullable
    }

    @override
    method getNullableVersion():Type {
        def nullable := owner.classNode.symbolTable.getType(Position.INTERNAL,
                name + "?")
        return nullable
    }

    @override
    function isUnspecified():Bit {
        return true
    }

    @override
    function isPrimitive():Bit {
        return false
    }

    @override
    function simpleName():String {
        return name[name.lastIndexOf(".")->(Int) + 1..]
    }

    @override
    method markLive() {
    }

    @override
    method implicitCastCost(target:Type):Int {
        return bound.implicitCastCost(target)
    }

    @override
    method canExplicitCastTo(target:Type):Bit {
        return bound.canExplicitCastTo(target)
    }

    @override
    method findConverterTo(target:Type):MethodNode? {
        return bound.findConverterTo(target)
    }
}