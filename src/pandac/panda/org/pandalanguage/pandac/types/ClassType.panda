package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.tree.ClassNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.Position

================================================================================
A type representing a class, such as `panda.lang.String`. `ClassType`s are 
always resolved; a reference to something that looks like a class in the code, 
but a name which hasn't actually been encountered yet, will be handled as an
`UnresolvedType` until the name is either resolved or an 
`UnresolvedTypeException` is thrown.
================================================================================
class ClassType : Type {
    -- all statically-allocated types must be added to the MutableTypeMap 
    -- constructor
    constant CLASS := new ClassType(class(Class).name)
    constant OBJECT := new ClassType(class(Object).name)
    constant STRING := new ClassType(class(String).name)
    constant ERROR := new ClassType(class(Error).name)
    constant METHOD := new ClassType(class(Method).name)
    constant SAFETY_ERROR := new ClassType(class(SafetyError).name)
    constant PRIMITIVE_ARRAY := new ClassType(class(PrimitiveArray).name)
    constant IMMUTABLE_PRIMITIVE_ARRAY := new ClassType(
            class(ImmutablePrimitiveArray).name)
    constant PANDA := new ClassType(class(Panda).name)

    constructor(name:String) {
        super.constructor(name)
    }

    @override
    function implicitCastCost(context:Context, target:Type):Int? {
        if self = target
            return 0
        if target = NativePointerType.NATIVE_POINTER
            return null
        if target.isNullable {
            var result := implicitCastCost(context, target.unwrapNullable)
            if result != null
                result += NullableType.TO_NULLABLE_CAST_COST
            return result
        }
        assert !target.isNullable
        var targetClass:ClassStub
        if target.isPrimitive
            targetClass := context.getStub(target->>(WrapperType))
        else {
            if target-!>(ClassType)
                return null
            targetClass := context.getStub(target->(ClassType))
        }
        def myClass := context.getStub(self)
        def parent:ClassType? := myClass.superclass
        var best:Int? := null
        if parent != null {
            var result := parent.implicitCastCost(context, target)
            if result != null {
                result += 1
                if best != null
                    best := best.min(result)
                else
                    best := result
            }
        }
        for intf in myClass.interfaces {
            var result := intf.implicitCastCost(context, target)
            if result != null {
                result += 1
                if best != null
                    best := best.min(result)
                else
                    best := result
            }
        }
        return best
    }

    @override
    function canExplicitCastTo(context:Context, var target:Type):Bit {
        if target.isWrapper
            target := target->>(PrimitiveType)
        if canImplicitCastTo(context, target)
            return true
        if !target.isPrimitive & context.getStub(target->>(ClassType)).isInterface & 
                !context.getStub(self).annotations.isFinal {
            -- as long as this class isn't final, we could be dealing with a
            -- subclass that potentially implements any interface
            return true
        }
        return target.canImplicitCastTo(context, self)
    }


    @override
    function ->>():ClassType {
        return self
    }
}