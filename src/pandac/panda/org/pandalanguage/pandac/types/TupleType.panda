package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.ast.ArrowOperationType
uses org.pandalanguage.pandac.ast.ASTArrowExpression
uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBinaryExpression
uses org.pandalanguage.pandac.ast.ASTBitLiteral
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTCallExpression
uses org.pandalanguage.pandac.ast.ASTClassLiteral
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTExpressionStatement
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTIf
uses org.pandalanguage.pandac.ast.ASTIndex
uses org.pandalanguage.pandac.ast.ASTIntegerLiteral
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTNew
uses org.pandalanguage.pandac.ast.ASTNullLiteral
uses org.pandalanguage.pandac.ast.ASTReturn
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTSwitch
uses org.pandalanguage.pandac.ast.ASTSwitchCase
uses org.pandalanguage.pandac.ast.ASTTypedIdentifier
uses org.pandalanguage.pandac.ast.ASTUnreachable
uses org.pandalanguage.pandac.ast.ASTStringLiteral
uses org.pandalanguage.pandac.ast.ASTVarDeclaration
uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.compiler.IRGenerator
uses org.pandalanguage.pandac.compiler.LookupContext
uses org.pandalanguage.pandac.compiler.OrderedMap
uses org.pandalanguage.pandac.compiler.SymbolTable
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.BinaryOperationType
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.VariableType

================================================================================
A tuple; there is a `TupleType` for each different combination of types. Tuples
must have at least two values.
================================================================================
class TupleType : ClassType {
    constant FIELD_PREFIX := "$field"

    def types:ImmutableArray<Type>

    @pre(types.length > 1)
    constructor(types:ListView<Type>) {
        super.constructor(getName(types))
        self.types := new ImmutableArray<Type>(types)
    }

    @private
    function getName(types:ListView<Type>):String {
        def result := "("->>MutableString
        for (i, t) in types.enumeration() {
            if i > 0
                result.append(",")
            result.append(t.displayName)
        }
        result.append(")")
        return result->>String
    }

    @override
    function isTuple():Bit {
        return true
    }

    @override
    function ->>():TupleType {
        return self
    }

    @override
    function implicitCastCost(context:Context, target:Type):Int? {
        if target.isNullable {
            def result := implicitCastCost(context, target.unwrapNullable)
            if result != null
                return result + NullableType.TO_NULLABLE_CAST_COST
            else
                return null
        }
        if target-?>TupleType {
            def tuple := target->TupleType
            if tuple.types.length != types.length
                return null
            var total := 0
            for (i, t) in types.enumeration() {
                def cost := t.implicitCastCost(context, tuple.types[i])
                if cost = null
                    return null
                total += cost
            }
            return total
        }
        return super.implicitCastCost(context, target)
    }

    @private
    method createConstructor():MethodStub {
        def position := Position.INTERNAL
        def parameters := new Array<FormalParameter>()
        def statements := new Array<ASTStatement>()
        for (i, type) in types.enumeration() {
            def name := FIELD_PREFIX + i
            parameters.add(new FormalParameter(position, name, type, 
                    false, false, false))

            def targets := new Array<ASTExpression>()
            targets.add(new ASTDotExpression(new ASTSelf(position), name))
            statements.add(new ASTAssignment(targets, null, new ASTIdentifier(
                    position, name)))
        }
        def body := new ASTBlock(position, statements)
        return new MethodStub(position, MethodNode.CONSTRUCTOR_NAME, 
                new Annotations(position, []), MethodNodeType.CONSTRUCTOR, 
                parameters, VoidType.VOID, body, self)
    }

    @private
    method createEquals(context:Context):MethodStub {
        def position := Position.INTERNAL
        def parameters := [new FormalParameter(position, "o", ClassType.OBJECT, 
                false, false, false)]
        def statements := new Array<ASTStatement>()
        def cl := new ASTDotExpression(new ASTIdentifier(position, "o"), 
                "$class")
        statements.add(new ASTIf(position, new ASTBinaryExpression(
                    BinaryOperationType.NOT_EQUAL, cl, 
                    new ASTIdentifier(position, "$class")), 
                new ASTReturn(position, new ASTBitLiteral(position, false)),
                null))
        statements.add(new ASTVarDeclaration(position, VariableType.DEF, 
                [new ASTTypedIdentifier(position, "cast", null)], 
                new ASTArrowExpression(ArrowOperationType.CAST,
                    new ASTIdentifier(position, "o"), 
                    IRGenerator.toASTType(position, self))))
        for (i, type) in types.enumeration() {
            def selfField := new ASTIndex(new ASTSelf(position), 
                    new ASTIntegerLiteral(position, i->UInt64))
            def otherField := new ASTIndex(new ASTIdentifier(position, "cast"), 
                    new ASTIntegerLiteral(position, i->UInt64))
            statements.add(new ASTIf(position, new ASTBinaryExpression(
                        BinaryOperationType.NOT_EQUAL, selfField, otherField), 
                    new ASTReturn(position, new ASTBitLiteral(position, false)),
                    null))
        }
        statements.add(new ASTReturn(position, new ASTBitLiteral(position, 
                true)))
        def body := new ASTBlock(position, statements)
        return new MethodStub(position, "=", 
                new Annotations(position, [AnnotationType.OVERRIDE]), 
                MethodNodeType.FUNCTION, parameters, BitType.BIT, body, self)
    }

    @private
    method createIndex(context:Context):MethodStub {
        def position := Position.INTERNAL
        def parameters := [new FormalParameter(position, "i", IntType.INT32, 
                false, false, false)]
        def statements := new Array<ASTStatement>()
        def cases := new Array<ASTSwitchCase>()
        var returnType := types[0]
        for (i, type) in types.enumeration() {
            cases.add(new ASTSwitchCase(position, 
                    [new ASTIntegerLiteral(position, i->UInt64)],
                    new ASTReturn(position, new ASTIndex(new ASTSelf(position), 
                        new ASTIntegerLiteral(position, i->UInt64)))))
            if i > 0
                returnType := Type.union(context, returnType, type)
        }
        statements.add(new ASTSwitch(position, new ASTIdentifier(position, "i"),
                cases, new ASTUnreachable(position)))
        def body := new ASTBlock(position, statements)
        return new MethodStub(position, "[]", 
                new Annotations(position, []), 
                MethodNodeType.FUNCTION, parameters, returnType, body, self)
    }

    @private
    method createConvert():MethodStub {
        def position := Position.INTERNAL
        def statements := new Array<ASTStatement>()
        statements.add(new ASTVarDeclaration(position, VariableType.DEF, 
                [new ASTTypedIdentifier(position, "result", null)], 
                new ASTNew(position,
                    IRGenerator.toASTType(position, ClassType.MUTABLE_STRING),
                    [new ASTStringLiteral(position, "(")])))
        for (i, type) in types.enumeration() {
            if i > 0 {
                statements.add(new ASTExpressionStatement(
                        new ASTCallExpression(new ASTDotExpression(
                            new ASTIdentifier(position, "result"), "append"),
                            [new ASTStringLiteral(position, ", ")])))
            }
            def converted := new ASTArrowExpression(ArrowOperationType.CONVERT,
                    new ASTIndex(new ASTSelf(position), 
                    new ASTIntegerLiteral(position, i->UInt64)), 
                    IRGenerator.toASTType(position, ClassType.STRING))
            if type.isNullable {
                statements.add(new ASTIf(position, new ASTBinaryExpression(
                        BinaryOperationType.EQUAL, 
                        new ASTIndex(new ASTSelf(position), 
                            new ASTIntegerLiteral(position, i->UInt64)),
                        new ASTNullLiteral(position)),
                        new ASTExpressionStatement(
                            new ASTCallExpression(new ASTDotExpression(
                            new ASTIdentifier(position, "result"), "append"),
                            [new ASTStringLiteral(position, "null")])),
                        new ASTExpressionStatement(
                            new ASTCallExpression(new ASTDotExpression(
                            new ASTIdentifier(position, "result"), "append"),
                            [converted]))))
            }
            else {
                statements.add(new ASTExpressionStatement(
                        new ASTCallExpression(new ASTDotExpression(
                            new ASTIdentifier(position, "result"), "append"),
                            [converted])))
            }
        }
        statements.add(new ASTExpressionStatement(
                new ASTCallExpression(new ASTDotExpression(
                    new ASTIdentifier(position, "result"), "append"),
                    [new ASTStringLiteral(position, ")")])))
        statements.add(new ASTReturn(position, 
                new ASTArrowExpression(ArrowOperationType.CONVERT,
                    new ASTIdentifier(position, "result"), 
                    IRGenerator.toASTType(position, ClassType.STRING))))
        def body := new ASTBlock(position, statements)
        return new MethodStub(position, "->>", 
                new Annotations(position, [AnnotationType.OVERRIDE]), 
                MethodNodeType.FUNCTION, [], ClassType.STRING, body, 
                self)
    }

    @private
    method addMethod(m:MethodStub, symbols:OrderedMap<String, Symbol>) {
        assert symbols[m.name] = null
        symbols[m.name] := new Methods(m)
    }

    method createStub(unspecified:Bit, external:Bit, 
            context:Context):ClassStub {
        var isImmutable := true
        for t in types {
            if !t.isImmutable(context) {
                isImmutable := false
                break
            }
        }
        def superclass:ClassType
        if isImmutable
            superclass := ClassType.IMMUTABLE_TUPLE
        else
            superclass := ClassType.TUPLE
        def classAnnotations := [AnnotationType.FINAL]
        if unspecified
            classAnnotations.add(AnnotationType.UNSPECIFIED)
        def position := Position.INTERNAL
        def fieldAnnotations := new Annotations(position, 
                [AnnotationType.FINAL])
        def symbols := new OrderedMap<String, Symbol>()
        for (i, type) in types.enumeration() {
            def field := new FieldNode(position, self, FIELD_PREFIX + i, 
                    fieldAnnotations, VariableType.DEF, type, null, null)
            symbols[field.name] := field
        }
        addMethod(createConstructor(), symbols)
        addMethod(createConvert(), symbols)
        addMethod(createEquals(context), symbols)
        addMethod(createIndex(context), symbols)
        return new ClassStub(position, self, false, new Annotations(position, 
                    classAnnotations), 
                superclass, new Array<ClassType>(), symbols,
                new LookupContext(), new Array<ASTInvariant>(), null, external,
                null)
    }    
}
