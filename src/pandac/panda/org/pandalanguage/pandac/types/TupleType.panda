package org.pandalanguage.pandac.types

uses org.pandalanguage.pandac.ast.ASTAssignment
uses org.pandalanguage.pandac.ast.ASTBlock
uses org.pandalanguage.pandac.ast.ASTDotExpression
uses org.pandalanguage.pandac.ast.ASTExpression
uses org.pandalanguage.pandac.ast.ASTIdentifier
uses org.pandalanguage.pandac.ast.ASTInvariant
uses org.pandalanguage.pandac.ast.ASTSelf
uses org.pandalanguage.pandac.ast.ASTStatement
uses org.pandalanguage.pandac.compiler.Context
uses org.pandalanguage.pandac.compiler.LookupContext
uses org.pandalanguage.pandac.compiler.OrderedMap
uses org.pandalanguage.pandac.compiler.SymbolTable
uses org.pandalanguage.pandac.stubs.ClassStub
uses org.pandalanguage.pandac.stubs.FormalParameter
uses org.pandalanguage.pandac.stubs.MethodStub
uses org.pandalanguage.pandac.stubs.Methods
uses org.pandalanguage.pandac.stubs.Symbol
uses org.pandalanguage.pandac.tree.Annotations
uses org.pandalanguage.pandac.tree.AnnotationType
uses org.pandalanguage.pandac.tree.FieldNode
uses org.pandalanguage.pandac.tree.MethodNode
uses org.pandalanguage.pandac.tree.MethodNodeType
uses org.pandalanguage.pandac.tree.Parameter
uses org.pandalanguage.pandac.tree.Position
uses org.pandalanguage.pandac.tree.VariableType

================================================================================
A tuple; there is a `TupleType` for each different combination of types. Tuples
must have at least two values.
================================================================================
class TupleType : ClassType {
    constant FIELD_PREFIX := "$field"

    def types:ImmutableArray<Type>

    constructor(types:ListView<Type>) {
        super.constructor(getName(types))
        self.types := new ImmutableArray<Type>(types)
    }

    @private
    function getName(types:ListView<Type>):String {
        def result := "("->>(MutableString)
        for i, t in types {
            if i > 0
                result.append(",")
            result.append(t.displayName)
        }
        result.append(")")
        return result->>(String)
    }

    @override
    function isTuple():Bit {
        return true
    }

    @override
    function ->>():TupleType {
        return self
    }

    @override
    function implicitCastCost(context:Context, target:Type):Int? {
        if target.isNullable {
            def result := implicitCastCost(context, target.unwrapNullable)
            if result != null
                return result + NullableType.TO_NULLABLE_CAST_COST
            else
                return null
        }
        if target-?>(TupleType) {
            def tuple := target->(TupleType)
            var total := 0
            for i, t in types {
                def cost := t.implicitCastCost(context, tuple.types[i])
                if cost = null
                    return null
                total += cost
            }
            return total
        }
        return super.implicitCastCost(context, target)
    }

    method createStub(elementStubs:Array<ClassStub?>, 
            context:Context):ClassStub {
        var isImmutable := true
        for t in types {
            if !t.isImmutable(context) {
                isImmutable := false
                break
            }
        }
        def superclass:ClassType
        if isImmutable
            superclass := ClassType.IMMUTABLE_TUPLE
        else
            superclass := ClassType.TUPLE
        def classAnnotations := new Array<AnnotationType>()
        classAnnotations.add(AnnotationType.FINAL)
        for st in elementStubs {
            if st != null & st.annotations.isUnspecified
                classAnnotations.add(AnnotationType.UNSPECIFIED)
        }
        def position := Position.INTERNAL
        def symbols := new OrderedMap<String, Symbol>()
        def finalAnnotation := new Array<AnnotationType>()
        finalAnnotation.add(AnnotationType.FINAL)
        def finalAnnotations := new Annotations(position, finalAnnotation)
        def parameters := new Array<FormalParameter>()
        def statements := new Array<ASTStatement>()
        for i, type in types {
            def field := new FieldNode(position, self, FIELD_PREFIX + i, 
                    finalAnnotations, VariableType.DEF, type, null, null)
            symbols[field.name] := field

            parameters.add(new FormalParameter(position, field.name, field.type, 
                    false, false, false))

            def targets := new Array<ASTExpression>()
            targets.add(new ASTDotExpression(new ASTSelf(position), field.name))
            statements.add(new ASTAssignment(targets, null, new ASTIdentifier(
                    position, field.name)))
        }
        def methods := new Array<MethodStub>()
        def body := new ASTBlock(position, statements)
        methods.add(new MethodStub(position, MethodNode.CONSTRUCTOR_NAME, 
                new Annotations(position, new Array<AnnotationType>()),
                MethodNodeType.CONSTRUCTOR, parameters, VoidType.VOID, body,
                self))
        symbols[MethodNode.CONSTRUCTOR_NAME] := new Methods(methods)
        return new ClassStub(position, self, false, new Annotations(position, 
                    classAnnotations), 
                superclass, new Array<ClassType>(), symbols,
                new LookupContext(), new Array<ASTInvariant>(), null, false,
                null)
    }    
}
