package panda.io

================================================================================
A source of data from which `Int8`s or `Chars` may be read. `InputStream`
contains a pair of methods, `readInt8()` and `readUInt8()`, at least one of
which must be overridden to create a working `InputStream`. All other methods 
are ultimately implemented in terms of these two methods, and so a functional 
`InputStream` can be created by overriding one method. However, better 
performance may generally be achieved by also overriding the bulk read methods.
================================================================================
@abstract 
class InputStream {
    @private
    constant BUFFER_SIZE := 2048
    
    ============================================================================
    `true` if this stream has been closed.
    ============================================================================
    @readonly
    var closed:Bit
    
    ============================================================================
    Reads a single `Int8` from the stream.

    The default implementation calls `readUInt8()` and converts its result to an
    `Int8`.
    
    @returns the `Int8` read, or `null` if the end of the stream has been
            reached
    ============================================================================
    @pre(!closed)
    method readInt8():Int8? {
        var result := readUInt8()
        if result != null
            return result->>(Int8)
        return null
    }
    
    ============================================================================
    Reads a single `UInt8` from the stream.
    
    The default implementation calls `readInt8()` and converts its result to a
    `UInt8`.
    
    @returns the `UInt8` read, or `null` if the end of the stream has been
            reached
    ============================================================================
    @pre(!closed)
    method readUInt8():UInt8? {
        var result := readInt8()
        if result != null
            return result->>(UInt8)
        return null
    }

    ============================================================================
    Reads a number of `Int8`s, appending them to a [ListWriter]. This method 
    will block until at least one byte becomes available for reading. The 
    maximum number of bytes read is defined by `max`. 
    
    @param bytes the read destination
    @param max the maximum number of bytes to read
    @returns the number of `UInt8`s actually read, or `null` if the end of the
            stream has been reached
    ============================================================================
    @pre(!closed)
    method read(bytes:ListWriter<Int8>, max:Int):Int? {
        var index := 0
        while index < bytes.length {
            var b:Int8? := readInt8()
            if b = null
                break
            bytes.add(b)
            index += 1
        }
        if index > 0
            return index
        else
            return null
    }
    @post(@return = null | @return <= bytes.length)

    ============================================================================
    Reads a number of `UInt8`s, appending them to a [ListWriter]. This method 
    will block until at least one byte becomes available for reading. The 
    maximum number of bytes read is defined by `max`. 
    
    @param bytes the read destination
    @param max the maximum number of bytes to read
    @returns the number of `UInt8`s actually read, or `null` if the end of the
            stream has been reached
    ============================================================================
    @pre(!closed)
    method read(bytes:ListWriter<UInt8>, max:Int):Int? {
        var index := 0
        while index < bytes.length {
            var b:UInt8? := readUInt8()
            if b = null
                break
            bytes.add(b)
            index += 1
        }
        if index > 0
            return index
        else
            return null
    }
    @post(@return = null | @return <= bytes.length)
    
    ============================================================================
    Reads a single `Char` from the stream. There is not necessarily a
    one-to-one correspondence between bytes and `Char`s; the exact mapping
    depends upon the stream's encoding.

    **IMPLEMENTATION NOTE**: Unicode support isn't in yet, therefore this just
    returns a UInt8 zero-extended to a Char.
    
    @returns the Char read, or `null` if the end of the stream has been reached
    ============================================================================
    @pre(!closed)
    method readChar():Char? {
        var i := readUInt8()
        if i != null
            return i->(Char) 
        else
            return null
    }
    
    ============================================================================
    Reads a number of `Char`s, appending them to a [ListWriter]. This method 
    will block until at least one character becomes available for reading. The 
    maximum number of characters read is defined by `max`. 
    
    **IMPLEMENTATION NOTE**: Unicode support isn't in yet, therefore this just
    zero-extends Int8s to Chars.

    @param chars the read destination
    @param max the maximum number of characters to read
    @returns the number of `Char`s actually read, or `null` if the end of the
            stream has been reached
    ============================================================================
    @pre(!closed)
    method read(chars:ListWriter<Char>, max:Int):Int? {
        var index := 0
        while index < chars.length {
            var c := readChar()
            if c = null
                break
            chars.add(c)
            index += 1
        }
        if index > 0
            return index
        else
            return null
    }
    @post(@return = null | @return >= 0 & @return <= max)

    ============================================================================
    Reads a complete line from the stream.
    
    @returns the next line, or `null` if the end of the stream has been reached
    ============================================================================
    @pre(!closed)
    method readLine():String? {
        var result := new MutableString()
        loop {
            var c:Char? := readChar()
            if c = null {
                if result.length = 0
                    return null
                break
            }
            if c->(Int) = 10
                break
            result.append(c->(Char) )
        }
        return result->>(String)
    }
    
    ============================================================================
    Returns the contents of the file broken up into lines.

    **IMPLEMENTATION NOTE:** In the future this will return an iterator which 
    actually reads the stream one line at a time. Right this second we just 
    slurp the whole stream into memory.

    @returns the lines of the file
    ============================================================================
    method lines():Iterator<String> {
        return readAsString().split(#/\r?\n/#).iterator
    }
    
    ============================================================================
    Closes the input stream. Once a stream has been closed, it is an error to
    attempt to read from it.
    ============================================================================
    @pre(!closed)
    method close() {
        closed := true
    }
    @post(closed)
    
    ============================================================================
    Reads the entire contents of this `InputStream`, sending it to the specified
    `OutputStream` as it is read. Once the end of the stream is reached, the
    `InputStream` is automatically closed.

    @param o the `OutputStream` to which to write
    ============================================================================
    @final
    @pre(!closed)
    method sendTo(o:OutputStream) {
        def buffer := new Array<UInt8>()
        loop {
            constant BUFFER_SIZE := 8192
            def c := read(buffer, BUFFER_SIZE)
            if c = null
                break
            o.write(buffer)
            buffer.clear()
        }
        close()
    }
    @post(closed)

    ============================================================================
    Reads the entire contents of this `InputStream`, returning it as a string.
    As streams can provide a very large or even infinite amount of data, you 
    should exercise caution when using this method.

    @returns the contents of this stream
    ============================================================================
    method readAsString():String {
        var buffer := new MemoryOutputStream()
        sendTo(buffer)
        return buffer->>(String)
    }

    ============================================================================
    Reads the entire contents of this `InputStream`, returning it as an
    `Array<Int8>`. As streams can provide a very large or even infinite amount 
    of data, you should exercise caution when using this method.

    @returns the contents of this stream
    ============================================================================
    method readAsInt8Array():Array<Int8> {
        var buffer := new MemoryOutputStream()
        sendTo(buffer)
        return buffer->>(Array<Int8>)
    }

    ============================================================================
    Reads the entire contents of this `InputStream`, returning it as an
    `Array<UInt8>`. As streams can provide a very large or even infinite amount 
    of data, you should exercise caution when using this method.

    @returns the contents of this stream
    ============================================================================
    method readAsUInt8Array():Array<UInt8> {
        var buffer := new MemoryOutputStream()
        sendTo(buffer)
        return buffer->>(Array<UInt8>)
    }
}