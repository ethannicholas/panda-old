package panda.io

================================================================================
A stream of data to which `Int8`s or `Chars` may be written. `OutputStream`
contains a pair of methods, [write(Int8)] and [write(UInt8)], at least one of 
which must be overridden in order to create a working `OutputStream`. All other 
methods are ultimately implemented in terms of these two methods, and so a 
functional `OutputStream` can be created by overriding one method. However, 
better performance may generally be achieved by also overriding the bulk write 
methods.
================================================================================
@abstract 
class OutputStream {
    ============================================================================
    `true` if this stream has been closed.
    ============================================================================
    @protected
    var closed:Bit
    
    ============================================================================
    Writes a single `Int8` to the stream.

    The default implementation converts its parameter to a `UInt8` and calls
    `write(UInt8)`.
    
    @param b the `Int8` to write
    ============================================================================
    @pre(!closed)
    method write(b:Int8) {
        write(b->>(UInt8))
    }
    
    ============================================================================
    Writes a single `UInt8` to the stream.

    The default implementation converts its parameter to an `Int8` and calls
    `write(Int8)`.
    
    @param b the `UInt8` to write
    ============================================================================
    @pre(!closed)
    method write(b:UInt8) {
        write(b->>(Int8))
    }
    
    ============================================================================
    Writes an array of `Int8`s to the stream.
    
    @param b the `Int8`s to write
    ============================================================================
    @pre(!closed)
    method write(b:Array<Int8>) {
        write(b, 0, b.length)
    }
    
    ============================================================================
    Writes a portion of an array of `Int8`s to the stream.
    
    @param b the `Int8`s to write
    @param offset the starting index
    @param length the number of `Int8`s to write
    ============================================================================
    @pre(!closed)
    method write(b:Array<Int8>, offset:Int, length:Int) {
        for i in offset ... offset + length - 1
            write(b[i])
    }

    ============================================================================
    Writes an array of `UInt8`s to the stream.
    
    @param b the `UInt8`s to write
    ============================================================================
    @pre(!closed)
    method write(b:Array<UInt8>) {
        write(b, 0, b.length)
    }
    
    ============================================================================
    Writes a portion of an array of `UInt8`s to the stream.
    
    @param b the `UInt8`s to write
    @param offset the starting index
    @param length the number of `UInt8`s to write
    ============================================================================
    @pre(!closed)
    method write(b:Array<UInt8>, offset:Int, length:Int) {
        for i in offset ... offset + length - 1
            write(b[i])
    }

    ============================================================================
    Writes an array of `Int8`s to the stream.
    
    @param b the `Int8`s to write
    ============================================================================
    @pre(!closed)
    method write(b:ImmutableArray<Int8>) {
        write(b, 0, b.length)
    }
    
    ============================================================================
    Writes a portion of an array of `Int8`s to the stream.
    
    @param b the `Int8`s to write
    @param offset the starting index
    @param length the number of `Int8`s to write
    ============================================================================
    @pre(!closed)
    method write(b:ImmutableArray<Int8>, offset:Int, length:Int) {
        for i in offset ... offset + length - 1
            write(b[i])
    }

    ============================================================================
    Writes an array of `UInt8`s to the stream.
    
    @param b the `UInt8`s to write
    ============================================================================
    @pre(!closed)
    method write(b:ImmutableArray<UInt8>) {
        write(b, 0, b.length)
    }
    
    ============================================================================
    Writes a portion of an array of `UInt8`s to the stream.
    
    @param b the `UInt8`s to write
    @param offset the starting index
    @param length the number of `UInt8`s to write
    ============================================================================
    @pre(!closed)
    method write(b:ImmutableArray<UInt8>, offset:Int, length:Int) {
        for i in offset ... offset + length - 1
            write(b[i])
    }

    ============================================================================
    Writes a single character to the stream.
    
    **IMPLEMENTATION NOTE**: Unicode support isn't in yet, therefore this just
    truncates the `Char` down to a single byte.

    @param c the `Char` to write
    ============================================================================
    @pre(!closed)
    method write(c:Char) {
        write(c->>(UInt8))
    }
    
    ============================================================================
    Writes an array of `Char`s to the stream. As `c` is a *convert* parameter,
    any type which can be converted to `Array<Char>` (such as `String`) may be
    written.

    **IMPLEMENTATION NOTE**: Unicode support isn't in yet, therefore this just
    truncates each `Char` down to a single byte.
    
    @param c the `Char` to write
    ============================================================================
    @pre(!closed)
    method write(c->>Array<Char>) {
        write(c, 0, c.length)
    }
    
    ============================================================================
    Writes a portion of an array of `Char`s to the stream. As `c` is a
    *convert* parameter, any type which can be converted to `Array<Char>` (such
    as `String`) may be written.
    
    **IMPLEMENTATION NOTE**: Unicode support isn't in yet, therefore this just
    truncates each `Char` down to a single byte.

    @param c the `Char`s to write
    @param offset the starting index
    @param length the number of `Char`s to write
    ============================================================================
    @pre(!closed)
    @pre(offset + length <= c.length)
    method write(c->>Array<Char>, offset:Int, length:Int) {
        var bytes := new Array<Int8>(length)
        for i in offset ... offset + length - 1
            bytes[i - offset] := c[i]->>(Int8)
        write(bytes)
    }
    
    ============================================================================
    Writes a string to the stream. As `s` is a *convert* parameter, any type 
    which can be converted to `String` (such as `Int`) may be written.
    
    **IMPLEMENTATION NOTE**: Unicode support isn't in yet, therefore this just
    truncates each `Char` down to a single byte.

    @param s the `String` to write
    ============================================================================
    @pre(!closed)
    method write(s->>String) {
        write(s->>(Array<Char>))
    }

    @private
    method digit(c:Char):Int {
        switch c {
            case "0": return 0
            case "1": return 1
            case "2": return 2
            case "3": return 3
            case "4": return 4
            case "5": return 5
            case "6": return 6
            case "7": return 7
            case "8": return 8
            case "9": return 9
            default: return -1
        }
    }

    @private
    function processField(s:String, field:String):String {
        var params := field.parse(#/([\s\S]?)([<>^])(\d+)/#)
        if params = null {
            throw new ParameterError(String.format(
                    "invalid field specification: '{0}'", field))
        }
        var width := params[2]->>(Int?)
        assert width != null
        var fill:Char
        if params[0] != ""
            fill := params[0][0]
        else
            fill := " "
        switch params[1] {
            case "<": return s.left(width, fill)
            case ">": return s.right(width, fill)
            case "^": return s.center(width, fill)
            default: throw new ParameterError(String.format(
                    "invalid field specification: '{0}'", field))
        }
    }

    ============================================================================
    Writes formatted output to the stream. The string `s` is a string consisting
    of both literal data to output and embedded references to parameters in the
    `params` array. The simplest form of reference is of the form `{0}`, which
    embeds a reference to the specified parameter. For example, the call:
    
        outputStream.write("The answer is: {0}!", 42)
    
    would output the text "The answer is 42!". Individual arguments are 
    formatted by calling their [format(String)](Object::format(String)) method. 
    References may also include "format strings" to be passed to as parameters 
    to the format method, in the form `{0:format}`, which in this case would 
    result in the call `format("format")` on parameter `0`. If no format string 
    is specified, the `format` method is called with the empty string as a 
    parameter.

    If you omit the parameter number (e.g. `{}` or `{:long}`), the reference is
    auto-numbered. The first such reference refers to parameter 0, the second to
    parameter 1, and so forth (even if other, specifically-numbered references
    occur in between them). The previous example could have been expressed as:

        outputStream.write("The answer is: {}!", 42)
    
    with the same results.

    In addition to format strings on individual parameter references, each
    parameter reference may include a "field specifier" which dictates the width
    and alignment of the output. The field specifier has the form 
    `[<fill>]<alignment><width>`, where the optional `fill` parameter is a 
    single character to fill extra space with, `alignment` is either `<` (left), 
    `>` (right), or `^` (center), and `width` is the minimum width of this 
    field. If no fill character is specified, the space character (`" "`) is 
    assumed. The field specifier is separated from the parameter index by a 
    comma, so the entire parameter reference is formatted as:

        {[<index>][,[<fill>]<alignment><width>][:<format>]}

    Braces may be escaped using a backslash. The backslash must be part of the
    string itself, which means that in Panda source code you will need to use
    two backslashes in a row (the first backslash escapes the second backslash,
    allowing it to appear literally in the format string). The backslash
    character is recognized when it appears before a left brace, right brace, 
    colon, or backslash, causing these characters to be output literally instead 
    of interpreted, and causes a `ParameterError` before any other character.

    Examples:

        write("The {1} {0}!", "attacks", "goblin") => "The goblin attacks!"
        write("You are customer #{,0>6}", 15) => "You are customer #000015"
        write("${0:,.2}", 1234567) => "$1,234,567.00"
        write("\\{{}}", "brace yourself!") => "{brace yourself!}"

    @param s the format string
    @param params parameters to be formatted
    @throws ParameterError if the format string is invalid
    ============================================================================
    @pre(!closed)
    method write(s:String, params:Object...) {
        var i := 0
        var auto := 0
        while i < s.length {
            var c := s[i]
            i += 1
            switch c {
                case "{": {
                    var value := 0
                    var found := false
                    loop {
                        var d := digit(s[i])
                        if d = -1
                            break
                        i += 1
                        found := true
                        value := value * 10 + d
                    }
                    if !found {
                        value := auto
                        auto += 1
                    }
                    var field:MutableString? := null
                    if s[i] = "," {
                        field := new MutableString()
                        i += 1
                        c := s[i]
                        while c != ":" & c != "}" {
                            if c = "\\" {
                                i += 1
                                c := s[i]
                                if i >= s.length {
                                    throw new ParameterError(
                                            "unexpected end of string after " +
                                            "backslash")
                                }
                                switch c {
                                    case "}", "{", ":", "\\": field.append(c)
                                    default: {
                                        throw new ParameterError(
                                            "invalid format escape sequence '\\" + c + "'")
                                    }
                                }
                            }
                            else
                                field.append(c)
                            i += 1
                            c := s[i]
                        }
                    }
                    var format := new MutableString()
                    if s[i] = ":" {
                        i += 1
                        c := s[i]
                        while c != ":" & c != "}" {
                            if c = "\\" {
                                i += 1
                                c := s[i]
                                if i >= s.length {
                                    throw new ParameterError(
                                            "unexpected end of string after " +
                                            "backslash")
                                }
                                switch c {
                                    case "}", "{", ":", "\\": format.append(c)
                                    default: {
                                        throw new ParameterError(
                                            "invalid format escape sequence '\\" + c + "'")
                                    }
                                }
                            }
                            else
                                format.append(c)
                            i += 1
                            c := s[i]
                        }
                    }
                    if s[i] != "}" {
                        throw new ParameterError(
                                "error parsing format string at character " + 
                                    i + ", expected '}' but found '" + s[i] + 
                                    "'")
                    }
                    i += 1
                    var formatted := params[value].format(format->>(String))
                    if field != null
                        formatted := processField(formatted, field->>(String))
                    write(formatted)
                }
                case "\\": {
                    if i >= s.length {
                        throw new ParameterError(
                                "unexpected end of string after backslash")
                    }
                    c := s[i]
                    switch c {
                        case "}", "{", ":", "\\": write(c)
                        default: {
                            throw new ParameterError(
                                "invalid format escape sequence '\\" + c + "'")
                        }
                    }
                    i += 1
                }
                default:   write(c)
            }
        }
    }
    
    @pre(!closed)
    method writeLine(s:String, params:Object...) {
        write(s, params...)
        writeLine()
    }

    ============================================================================
    Writes a newline to the stream.
    ============================================================================
    @pre(!closed)
    method writeLine() {
        write("\n")
    }
    
    ============================================================================
    Writes a `Char` followed by a newline to the stream.
    
    @param c the `Char` to write
    ============================================================================
    @pre(!closed)
    method writeLine(c:Char) {
        write(c)
        write("\n")
    }

    ============================================================================
    Writes an array of `Chars` followed by a newline to the stream. As `c` is a
    *convert* parameter, any type which can be converted to `Array<Char>` (such
    as `String`) may be written.
    
    @param c the `Char`s to write
    ============================================================================
    @pre(!closed)
    method writeLine(c->>Array<Char>) {
        write(c)
        write("\n")
    }
        
    ============================================================================
    Writes a portion of an array of `Char`s followed by a newline to the stream. 
    As `c` is a *convert* parameter, any type which can be converted to 
    `Array<Char>` (such as `String`) may be written.
    
    @param c the `Char`s to write
    @param offset the starting index
    @param length the number of `Char`s to write
    ============================================================================
    @pre(!closed)
    @pre(offset + length <= c.length)
    method writeLine(c->>Array<Char>, offset:Int, length:Int) {
        write(c, offset, length)
        write("\n")
    }

    ============================================================================
    Writes a string followed by a newline to the stream. As `s` is a *convert* 
    parameter, any type which can be converted to `String` (such as `Int`) may 
    be written.
    
    @param s the `String` to write
    ============================================================================
    @pre(!closed)
    method writeLine(s->>String) {
        writeLine(s->>(Array<Char>))
    }

    ============================================================================
    Ensures that all data being held in buffers has been flushed to the 
    underlying output device.
    ============================================================================
    method flush() {
    }

    ============================================================================
    Closes the stream, flushing any data still remaining in buffers and
    releasing any native resources associated with the stream. Closed streams
    may no longer be written to.
    
    The default implementation simply marks the stream invalid, such that
    further writes will generate errors. This implementation must be called by
    any subclass overrides of `close()`.
    ============================================================================
    @pre(!closed)
    method close() {
        closed := true
    }
    @post(closed)
}