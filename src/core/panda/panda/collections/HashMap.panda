package panda.collections

================================================================================
A single key/value pair from a `HashMap`.

@hidden
================================================================================
class MutableMapEntry (MapEntry) {
    ============================================================================
    The entry's key.
    ============================================================================
    @private
    var _key:Object?

    @override
    function key():Object? {
        return _key
    }
    
    ============================================================================
    The entry's value.
    ============================================================================
    @private
    var _value:Object?
    
    @override
    function value():Object? {
        return _value
    }
    
    @private 
    var next:MutableMapEntry?
    
    @private
    constructor(key:Object?, value:Object?) {
        self._key := key
        self._value := value
    }
}

================================================================================
Standard implementation of the `Map` interface, which associates keys with 
values. An arbitrary number of values can be stored in a `HashMap` and then
retrieved in constant time:

    var alignment := new HashMap()
    alignment["human"]  := "good"
    alignment["orc"]    := "evil"
    alignment["dragon"] := "neutral"
    Console.writeLine(alignment["human"])

This will display the value `"good"`.
================================================================================
class HashMap (Map) {
    @private
    constant LOAD_FACTOR := 0.75

    @readonly
    property length:Int32

    @private 
    -- length must be a power of 2 (see indexFor)
    var contents:Array<MutableMapEntry?>
    
    @private 
    var threshold:Int32
    
    ============================================================================
    Creates a new, empty `HashMap`.
    ============================================================================
    constructor() {
        clear()
    }
    
    ============================================================================
    Creates a new `HashMap` with an initial set of keys and values. The first
    entry in the `keys` array will be paired with the first entry in the 
    `values` array, and so on.
    ============================================================================
    @pre(keys.length = values.length)
    constructor(keys:Array<Object?>, values:Array<Object?>) {
        constructor()
        for i, key in keys
            self[key] := values[i]
    }

    ============================================================================
    Creates a new `HashMap`, copying its keys and values from an existing
    `Map`.
    ============================================================================
    constructor(map:MapView) {
        constructor()
        for (key, value) in map.entries
            self[key] := value
    }

    ============================================================================
    Given a key, returns the bucket in which the key's entry should be stored.
    ============================================================================
    @private
    @math(overflow)
    function indexFor(key:Object?):Int32 {
        var h:Int32
        if key = null
            h := 0
        else
            h := key.hash
        -- supplemental hash function to defend against poor hash codes, 
        -- as we do not use a prime table length
        h ~~= (h >> 20) ~~ (h >> 12) ~~ (h >> 7) ~~ (h >> 4)
        -- the bitwise and below is equivalent to mod if length is a power 
        -- of 2, which is why we require that
        return h && (contents.length - 1)
    }
    
    @override
    function [](key:Object?):Object? {
        var index := indexFor(key)
        var e := contents[index]
        while e != null & e.key != key
            e := e.next
        if e != null
            return e.value
        else
            return null
    }
    
    @override
    function contains(key:Object?):Bit {
        var index := indexFor(key)
        var e := contents[index]
        while e != null & e.key != key
            e := e.next
        return e != null
    }

    @override
    @self
    method []:=(key:Object?, value:Object?) {
        var index := indexFor(key)
        var e := contents[index]
        while e != null & e.key != key
            e := e.next
        if e = null {
            var old := contents[index]
            e := new MutableMapEntry(key, value)
            e.next := old
            contents[index] := e
            assert contents[index] == e
            incrementLength()
        }
        else
            e._value := value
    }
    
    @override
    @self
    method remove(key:Object?):Bit {
        var index := indexFor(key)
        var e := contents[index]
        if e = null
            return false
        if e.key = key {
            contents[index] := e.next
            _length -= 1
            return true
        }
        loop {
            var next := e.next
            if next = null
                break
            if next.key = key
                break
            e := next
        }
        if e != null {
            var next := e.next
            assert next != null
            e.next := next.next
            _length -= 1
            return true
        }
        return false
    }

    @override
    @self
    method clear() {
        _length := 0
        contents := new Array<MutableMapEntry?>(16)
        threshold := (contents.length * LOAD_FACTOR)->>(Int32)
    }
    
    -- FIXME: replace this with a lazy collection when those are available
    @override
    function entries():Array<(Object?, Object?)> {
        var result := new Array<(Object?, Object?)>()
        for e in contents {
            var current := e
            while current != null {
                result.append((current.key, current.value))
                current := current.next
            }
        }
        return result
    }

    -- FIXME: replace this with a lazy collection when those are available
    @override
    function keys():Array<Object?> {
        var result := new Array<Object?>()
        for e in contents {
            var current := e
            while current != null {
                result.append(current.key)
                current := current.next
            }
        }
        return result
    }
    
    -- FIXME: replace this with a lazy collection when those are available
    @override
    function values():Array<Object?> {
        var result := new Array<Object?>()
        for e in contents {
            var current := e
            while current != null {
                result.append(current.value)
                current := current.next
            }
        }
        return result
    }
    
    @override
    @self
    method addAll(m:MapView) {
        for (key, value) in m.entries
            self[key] := value
    }

    ============================================================================
    Doubles the size of the `contents` array, rehashing all of its entries.
    ============================================================================
    @private
    method incrementLength() {
        _length += 1
        if length >= threshold {
            _length := 0
            var oldContents := contents
            contents := new Array<MutableMapEntry?>(contents.length * 2)
            threshold *= 2
            for i in oldContents.length - 1 ... 0 by -1 {
                var e := oldContents[i]
                while e != null {
                    self[e.key] := e.value
                    e := e.next
                }
            }
        }
    }
    
    ============================================================================
    Returns `true` if `o` is a Map containing the same key/value pairs as this
    map.

    @param o the object to compare against
    ============================================================================
    @override
    function =(o:Object):Bit {
        if o-!>(MapView)
            return false
        var m := o->(MapView)
        if length != m.length
            return false
        for (key, value) in entries {
            if value != m[key]
                return false
        }
        return true
    }

    ============================================================================
    Formats the map as a string. If the format string is empty, returns the 
    same string as `->>(String)`. If the format string is `"panda"`, each
    key and value in the map will be formatted using the format string 
    `"panda"` (which may cause errors if they do not support this option).
    ============================================================================
    @override
    @preOr(fmt = "" | fmt = "panda")
    function format(fmt:String):String {
        def result := new MutableString()
        result.append("{")
        var first := true
        for (key, value) in entries {
            if !first
                result.append(", ")
            else
                first := false
            if key != null
                result.append(key.format(fmt))
            else
                result.append("null")
            result.append(": ")
            if value != null
                result.append(value.format(fmt))
            else
                result.append("null")
        }
        result.append("}")
        return result->>(String)
    }
}

package panda.collections

================================================================================
A single key/value pair from an `ImmutableHashMap`.

@hidden
================================================================================
class ImmutableMapEntry : Immutable (MapEntry) {
    ============================================================================
    The entry's key.
    ============================================================================
    @private
    var _key:Immutable?

    @override
    function key():Immutable? {
        return _key
    }
    
    ============================================================================
    The entry's value.
    ============================================================================
    @private
    var _value:Immutable?
    
    @override
    function value():Immutable? {
        return _value
    }
    
    @private 
    var next:ImmutableMapEntry?

    constructor(key:Immutable?, value:Immutable?, next:ImmutableMapEntry?) {
        self._key := key
        self._value := value
        self.next := next
    }
}

class ImmutableHashMap : Immutable (MapView) {
    @readonly
    property length:Int32
    
    @private 
    var contents:ImmutableArray<ImmutableMapEntry?> 
    -- length must be a power of 2 (see indexFor)
    
    @private
    constructor(h:HashMap) {
        var contentsTemp := new Array<ImmutableMapEntry?>()
        for e in h.contents
            contentsTemp.append(copy(e))
        contents := new ImmutableArray<ImmutableMapEntry?>(contentsTemp, 0, 
                contentsTemp.length)
        _length := h.length
    }
    
    constructor(keys:Array<Immutable?>, 
            values:Array<Immutable?>) {
        -- FIXME remove copies once we have proper generics
        constructor(new HashMap(copy(keys), copy(values)))
    }

    @private
    function copy(a:Array<Immutable?>):Array<Object?> {
        var result := new Array<Object?>()
        for e in a
            result.append(e)
        return result
    }
    
    @private
    function copy(m:MutableMapEntry?):ImmutableMapEntry? {
        if m = null
            return null
        return new ImmutableMapEntry(m.key->(Immutable?), m.value->(Immutable?),
                copy(m.next))
    }
    
    @private
    @math(overflow)
    function indexFor(key:Object?):Int32 {
        var h:Int32
        if key = null
            h := 0
        else
            h := key.hash
        -- supplemental hash function to defend against poor hash codes, 
        -- as we do not use a prime table length
        h ~~= (h >> 20) ~~ (h >> 12) ~~ (h >> 7) ~~ (h >> 4)
        -- the bitwise and below is equivalent to mod if length is a power 
        -- of 2, which is why we require that
        return h && (contents.length - 1)
    }

    @override
    function [](key:Object?):Immutable? {
        var index := indexFor(key)
        var e := contents[index]
        while e != null & e.key != key {
            e := e.next
        }
        if e != null
            return e.value
        else
            return null
    }
    
    @override
    function contains(key:Object?):Bit {
        var index := indexFor(key)
        var e := contents[index]
        while e != null & e.key != key
            e := e.next
        return e != null
    }
    
    -- FIXME: replace this with a lazy collection when those are available
    @override
    function entries():Array<(Object?, Object?)> {
        var result := new Array<(Object?, Object?)>()
        for e in contents {
            var current := e
            while current != null {
                result.append((e.key, e.value))
                current := current.next
            }
        }
        return result
    }

    -- FIXME: replace this with a lazy collection when those are available
    @override
    function keys():Array<Object?> {
        var result := new Array<Object?>()
        for e in contents {
            var current := e
            while current != null {
                result.append(e.key)
                current := current.next
            }
        }
        return result
    }
    
    -- FIXME: replace this with a lazy collection when those are available
    @override
    function values():Array<Object?> {
        var result := new Array<Object?>()
        for e in contents {
            var current := e
            while current != null {
                result.append(current.value)
                current := current.next
            }
        }
        return result
    }

    @class
    function ->>(h:HashMap):ImmutableHashMap {
        return new ImmutableHashMap(h)
    }

    ============================================================================
    Formats the map as a string. If the format string is empty, returns the same 
    string as `->>(String)`. If the format string is `"panda"`, each key and 
    value in the map will be formatted using the format string `"panda"` (which 
    may cause errors if they do not support this option).
    ============================================================================
    @override
    @preOr(fmt = "" | fmt = "panda")
    function format(fmt:String):String {
        var result := new MutableString()
        result.append("{")
        var first := true
        for e in contents {
            var current := e
            while current != null {
                if !first
                    result.append(", ")
                else
                    first := false
                var key := current.key
                if key != null
                    result.append(key.format(fmt))
                else
                    result.append("null")
                result.append(": ")
                var value := current.value
                if value != null
                    result.append(value.format(fmt))
                else
                    result.append("null")
                current := current.next
            }
        }
        result.append("}")
        return result->>(String)
    }
}