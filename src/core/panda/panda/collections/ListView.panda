package panda.collections

@private
class ListIterator<T> (Iterator<T>) {
    def list:ListView<T>
    var index := 0

    constructor(list:ListView<T>) {
        self.list := list
    }

    @override
    function done():Bit {
        return index >= list.length
    }

    @override
    @self
    method next():T {
        def result := list[index]
        index += 1
        return result
    }
}

interface ListView<T> : CollectionView<T> {
    function [](i:Int):T

    function [..](start:Int, var end:Int?, step:Int):ListView<T> {
        if end = null {
            if step > 0
                end := length
            else
                end := -1
        }
        return self[start .. end->(Int) by step]
    }

    function [..](start:Int, end:Int, step:Int):ListView<T> {
        def result := new Array<T>()
        for i in start .. end by step
            result.add(self[i])
        return result
    }

    function [...](start:Int, var end:Int?, step:Int):ListView<T> {
        if end = null {
            if step > 0
                end := length - 1
            else
                end := 0
        }
        return self[start ... end->(Int) by step]
    }

    function [...](start:Int, end:Int, step:Int):ListView<T> {
        def result := new Array<T>()
        for i in start ... end by step
            result.add(self[i])
        return result
    }

    @override
    @safeReturn
    function iterator():Iterator<T> {
        return new ListIterator<T>(self)
    }

    function join(delimiter:String):String {
        def result := new MutableString()
        for i, v in self {
            if i > 0
                result.append(delimiter)
            result.append(v)
        }
        return result->>(String)
    }
}

-*
    function <T2> map(f:(T)=>(T2)):ListView<T2> {
        def result := new PrimitiveArray<T2>()
        for v in self
            result.append(f(v))
        return result
    }

    @pre(length = list.length)
    function <T2> combine(list:ListView<T2>):ListView<(T, T2)> {
        return combine(list, (x, y) => (x, y))
    }

    @pre(length = list.length)
    function <T2, T3> combine(list:ListView<T2>, f:(T, T2)=>(T3)):ListView<T3> {
        def result := new PrimitiveArray<T3>()
        for i, v in list
            result.append(f(v, list[i]))
        return result
    }

    @pre(length = list.length)
    function <T2, T3> combine(list1:ListView<T2>,
            list2:ListView<T3>):ListView<(T, T2, T3)> {
        return combine(list1, list2, (x, y, z) => (x, y, z))
    }

    @pre(length = list.length)
    function <T2, T3, T4> combine(list1:ListView<T2>, list2:ListView<T3>, 
            f:(T, T2, T3)=>(T4)):ListView<T4> {
        def result := new PrimitiveArray<T4>()
        for i, v in list
            result.append(f(v, list1[i], list2[i]))
        return result
    }
}

*-