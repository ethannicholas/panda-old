package panda.collections

interface ListView<T> {
    function [](i:Int):T

    function length():Int
}

-*
    function =(o:Object):Bit {
        if o-!>(ListView<T>)
            return false
        def list := o->(ListView)
        if length != list.length
            return false
        for i, v in self {
            if v != list[v]
                return false
        }
        return true
    }

    @math(overflow)
    function hash():Int {
        var result := 0
        constant MULTIPLIER := 53
        for v in self
            result := result * MULTIPLIER + v.hash
    }

    @pre(length > 0)
    function fold(f:(T, T)=>(T)):T {
        def result := self[0]
        for i in 2 .. length
            result := f(result, self[i])
        return result
    }

    function fold(f:(T, T)=>(T), start:T):T {
        def result := T
        for v in self
            result := f(result, v)
        return result
    }

    function <T2> map(f:(T)=>(T2)):ListView<T2> {
        def result := new Array<T2>()
        for v in self
            result.append(f(v))
        return result
    }

    function filter(f:(T)=>(Bit)):ListView<T> {
        def result := new Array<T>()
        for v in self {
            if f(v)
                result.append(v)
        }
        return result
    }

    function join(delimiter:String):String {
        def result := new MutableString()
        for i, v in self {
            if i > 0
                result.append(delimiter)
            result.append(v)
        }
        return result
    }

    @pre(length = list.length)
    function <T2> combine(list:ListView<T2>):ListView<(T, T2)> {
        return combine(list, (x, y) => (x, y))
    }

    @pre(length = list.length)
    function <T2, T3> combine(list:ListView<T2>, f:(T, T2)=>(T3)):ListView<T3> {
        def result := new Array<T3>()
        for i, v in list
            result.append(f(v, list[i]))
        return result
    }

    @pre(length = list.length)
    function <T2, T3> combine(list1:ListView<T2>,
            list2:ListView<T3>):ListView<(T, T2, T3)> {
        return combine(list1, list2, (x, y, z) => (x, y, z))
    }

    @pre(length = list.length)
    function <T2, T3, T4> combine(list1:ListView<T2>, list2:ListView<T3>, 
            f:(T, T2, T3)=>(T4)):ListView<T4> {
        def result := new Array<T4>()
        for i, v in list
            result.append(f(v, list1[i], list2[i]))
        return result
    }

    method apply(m:(T)=&>()) {
        for v in self
            m(v)
    }
}

*-