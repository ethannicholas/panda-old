package panda.core

================================================================================
An immutable sequence of characters. String literals appearing in Panda code are
represented at runtime by instances of the `String` class.
================================================================================
@final
class String : Value (Formattable) {
    property length:Int

    property characters:ImmutableArray<Char>

    ============================================================================
    The characters of the string.
    ============================================================================
    @private
    def chars:ImmutablePrimitiveArray<Char>

    ============================================================================
    Creates a new `String` initialized with characters from an immutable 
    character array.
    
    @param chars the String's characters
    ============================================================================
    init(chars:ImmutablePrimitiveArray<Char>) {
        self.chars := chars
    }

    ============================================================================
    Creates a new `String` initialized with characters from a character array.
    The `String` and character array do not share state, and the array may
    subsequently be modified without affecting the `String`.

    @param chars the character array to copy from
    ============================================================================
    init(chars:PrimitiveArray<Char>) {
        init(ImmutablePrimitiveArray<Char>(chars))
    }

    ============================================================================
    Creates a new `String` initialized with characters from a character array.
    The `String` and character array do not share state, and the array may
    subsequently be modified without affecting the `String`.

    @param chars the character array to copy from
    ============================================================================
    init(chars:ListView<Char>) {
        def a := PrimitiveArray<Char>(chars.count)
        for i in 0 .. chars.count
            a[i] := chars[i]
        self.chars := ImmutablePrimitiveArray<Char>(a)
    }

    ============================================================================
    Creates a new `String` initialized with an array of UTF-8 bytes. The 
    `String` and array do not share state, and the array may subsequently be 
    modified without affecting the `String`.

    @param bytes the UTF-8 array to copy from
    ============================================================================
    init(bytes:ListView<UInt8>) {
        def a := PrimitiveArray<Char>(bytes.count)
        for i in 0 .. bytes.count
            a[i] := bytes[i].convert()
        self.chars := ImmutablePrimitiveArray<Char>(a)
    }

    ============================================================================
    Returns the length of this string.
    
    @returns the length of this string
    ============================================================================
    @override
    function get_length():Int {
        return chars.length()
    }

    ============================================================================
    Returns a single character from the string.
    
    @param i the index of the character to return
    @returns the character at the specified index
    ============================================================================
    @override
    function [](i:Int):Char {
        return chars[i]
    }

    ============================================================================
    Returns the substring of this string prior to the first occurrence of 
    `needle`, or `null` if `needle` does not occur within this string.
    ============================================================================
    function substringBefore(needle:String):String? {
        def index := indexOf(needle)
        if index != null
            return self[..index]
        return null
    }

    ============================================================================
    Returns the substring of this string prior to the last occurrence of 
    `needle`, or `null` if `needle` does not occur within this string.
    ============================================================================
    function substringBeforeLast(needle:String):String? {
        def index := lastIndexOf(needle)
        if index != null
            return self[..index]
        return null
    }

    ============================================================================
    Returns the substring of this string following the first occurrence of 
    `needle`, or `null` if `needle` does not occur within this string.
    ============================================================================
    function substringAfter(needle:String):String? {
        def index := indexOf(needle)
        if index != null
            return self[index + needle.length..]
        return null
    }

    ============================================================================
    Returns the substring of this string following the last occurrence of 
    `needle`, or `null` if `needle` does not occur within this string.
    ============================================================================
    function substringAfter(needle:String):String? {
        def index := lastIndexOf(needle)
        if index != null
            return self[index + needle.length..]
        return null
    }

    ============================================================================
    Splits this string into tokens separated by a delimiter. At most
    `maxResults` different strings will be returned; any additional delimiters
    beyond that point will be ignored. For instance, 
    `"This is a long string".split(" ", 3)` yields `"This"`, `"is"`, and
    `"a long string"`.
    
    @param delimiter the token delimiter
    @param maxResults the maximum number of results to return
    @returns the split tokens
    ============================================================================
    @safeReturn
    @pre(maxResults > 0)
    function split(delimiter:String, maxResults:Int):ListView<String> {
        def result := Array<String>()
        var index := 0
        loop {
            def nextIndex:Int?
            if delimiter.length = 0
                nextIndex := index + 1
            else
                nextIndex := indexOf(delimiter, index)
            if nextIndex = null | result.count = maxResults - 1 {
                result.add(self[index..])
                break
            }
            result.add(self[index .. nextIndex])
            index := nextIndex + delimiter.length
        }
        return result
    }
    
    ============================================================================
    Splits this string into tokens separated by a delimiter. For instance, 
    `"This is a long string".split(" ")` yields `"This"`, `"is"`, `"a"`,
    `"long"`, and `"string"`.
    
    @param delimiter the token delimiter
    @returns the split tokens
    ============================================================================
    @safeReturn
    function split(delimiter:String):ListView<String> {
        return split(delimiter, Int32.MAX)
    }
    
    ============================================================================
    Splits this string into tokens separated by a delimiter. At most
    `maxResults` different strings will be returned; any additional delimiters
    beyond that point will be ignored. For instance, 
    `"This is a long string".split(/\s+/, 3)` yields `"This"`, `"is"`, and
    `"a long string"`.
    
    @param delimiter the token delimiter
    @param maxResults the maximum number of results to return
    @returns the split tokens
    ============================================================================
    @safeReturn
    @pre(maxResults > 0)
    function split(delimiter:RegularExpression, 
            maxResults:Int):ListView<String> {
        def result := Array<String>()
        def matcher := delimiter.matcher(self)
        var index := 0
        loop {
            def found := matcher.find()
            if !found | result.count = maxResults - 1 {
                result.add(self[index..])
                break
            }
            def start := matcher.start
            result.add(self[index .. start])
            index := start.max(matcher.end)
        }
        return result
    }
    
    ============================================================================
    Splits this string into tokens separated by a delimiter. For instance, 
    `"This  is a    long    string".split(/\s+/)` yields `"This"`, `"is"`,
    `"a"`, `"long"`, and `"string"`.
    
    @param delimiter the token delimiter
    @returns the split tokens
    ============================================================================
    @safeReturn
    function split(delimiter:RegularExpression):ListView<String> {
        return split(delimiter, Int32.MAX)
    }

    ============================================================================
    Returns `true` if this string matches the given regular expression. The
    regular expression must match the entire string.
    
    @param regex the regular expression to compare against
    @returns `true` if the string matches
    ============================================================================
    function matches(regex:RegularExpression):Bit {
        return regex.matcher(self).matches()
    }
    
    ============================================================================
    Returns `true` if this string contains a match for the given regular 
    expression. The regular expression may match zero or more characters of the
    string, starting at any point.
    
    @param needle the regular expression to search for
    @returns `true` if the string contains a match
    ============================================================================
    function contains(needle:RegularExpression):Bit {
        return needle.matcher(self).find()
    }

    ============================================================================
    Matches the string against the given regular expression, returning an array
    of its capture groups. Group 0, the group containing the entire string, is
    not returned. If the string does not match the regular expression, returns
    `null`. For example, `"1,2,34".parse(/(\d+),(\d+),(\d+)/)` will return an
    array consisting of `"1"`, `"2"`, and `"34"`.
    
    @param regex the regular expression to parse against
    @returns an array of the capture groups, or `null`
    ============================================================================
    @safeReturn
    function parse(regex:RegularExpression):ListView<String>? {
        def matcher := regex.matcher(self)
        if matcher.matches() {
            def result := Array<String>()
            for i in 1 .. matcher.groupCount
                result.add(matcher.group(i))
            return result
        }
        return null
    }
    
    ============================================================================
    Returns a new string with every occurrence of `search` replaced with
    `replacement`.
    
    @param search the string to search for
    @param replacement the replacement text
    @returns a string with all matches replaced
    ============================================================================
    @pre(search.length > 0)
    function replace(search:String, replacement:String):String {
        def result := MutableString()
        var index := 0
        loop {
            def nextIndex := indexOf(search, index)
            if nextIndex = null {
                result.append(self[index..])
                break
            }
            result.append(self[index .. nextIndex])
            result.append(replacement)
            index := nextIndex + search.length
        }
        return result.convert()
    }

    ============================================================================
    Returns a new string with every match of `search` replaced with
    `replacement`. The replacement string may contain `$1`-style regular 
    expression group references; for instance `s.replace(regex, "$1")` will
    replace every occurrence of the regex with the contents of its first group.
    
    @param search the regular expression to search for
    @param replacement the replacement text
    @returns a string with all matches replaced
    ============================================================================
    function replace(search:RegularExpression, replacement:String):String {
        return replace(search, replacement, true)
    }

    ============================================================================
    As [replace(RegularExpression, String)], but allows the interpretation of 
    `$1`-style group references to be controlled. With `allowGroupReferences`
    set to `false`, the replacement string is treated literally, with no special 
    handling for `$1`-style sequences.

    @param search the regular expression to search for
    @param replacement the replacement text
    @param allowGroupReferences if false, `$1`-style group references are 
           ignored
    @returns a string with all matches replaced
    ============================================================================
    function replace(search:RegularExpression, replacement:String,
            allowGroupReferences:Bit):String {
        def result := MutableString()
        def matcher := search.matcher(self)
        while matcher.find()
            matcher.appendReplacement(result, replacement, allowGroupReferences)
        matcher.appendTail(result)
        return result.convert()
    }

    ============================================================================
    Searches the string for a regular expression, replacing occurrences of the
    regular expression with new text determined by a function. For instance,
    given:

        "This is a test!".replace(/\w+/, word => word.length)

    The regular expression `/\w+/` matches sequences of one or more word
    characters; in other words, it matches all words occurring in the string.
    The replacement function `word => word.length.convert()` replaces each
    matched sequence with the number of characters in the sequence, resulting in
    the text:

        4 2 1 4!

    @param search the regular expression to match the string with
    @param replacement a function generating the replacement text
    @returns a new string with all occurrences of the regular expression 
            replaced
    ============================================================================
    function replace(search:RegularExpression, 
            replacement:(String)=>(Object)):String {
        def result := MutableString()
        def matcher := search.matcher(self)
        while matcher.find() {
            matcher.appendReplacement(result, 
                    replacement(matcher.group(0)).convert(), false)
        }
        matcher.appendTail(result)
        return result.convert()
    }

    ============================================================================
    As [replace(RegularExpression, (String)=>(Object))], but the replacement
    function receives the capture groups from the regular expression rather than
    the raw matched text. The groups array includes the special whole-match 
    group at index `0`, with the first set of parentheses in the regular 
    expression corresponding to array index `1`.

    @param search the regular expression to match the string with
    @param replacement a function generating the replacement text
    @returns a new string with all occurrences of the regular expression 
            replaced
    ============================================================================
    function replace(search:RegularExpression, 
            replacement:(ListView<String>)=>(Object)):String {
        def result := MutableString()
        def matcher := search.matcher(self)
        while matcher.find() {
            def groups := Array<String>()
            for i in 0 .. matcher.groupCount
                groups.add(matcher.group(i))
            matcher.appendReplacement(result, replacement(groups).convert(), 
                    false)
        }
        matcher.appendTail(result)
        return result.convert()
    }

    ============================================================================
    Returns a copy of this string with leading and trailing whitespace
    characters removed.
    
    @returns a trimmed version of this string
    ============================================================================
    function trim():String {
        if length = 0
            return self
        var start := 0
        while start < length & self[start].isWhitespace
            start += 1

        var end := length - 1
        while end >= start & self[end].isWhitespace
            end -= 1
            
        return self[start ... end]
    }
    
    ============================================================================
    Returns `true` if this string begins with the substring `s`.
    
    @param s the string to compare against
    @returns `true` if this string begins with the substring `s`
    ============================================================================
    function startsWith(s:String):Bit {
        if length < s.length        
            return false
        for i in 0 .. s.length {
            if self[i] != s[i]
                return false
        }
        return true
    }

    ============================================================================
    Returns `true` if this string begins with the character `c`.
    
    @param c the character to compare against
    @returns `true` if this string begins with the character `c`
    ============================================================================
    function startsWith(c:Char):Bit {
        return length > 0 & self[0] = c
    }

    ============================================================================
    Returns `true` if this string ends with the substring `s`.
    
    @param s the string to compare against
    @returns `true` if this string ends with the substring `s`
    ============================================================================
    function endsWith(s:String):Bit {
        if length < s.length
            return false
        def start := length - s.length
        for i in 0 .. s.length {
            if self[i + start] != s[i]
                return false
        }
        return true
    }
    
    ============================================================================
    Returns `true` if this string ends with the character `c`.
    
    @param c the character to compare against
    @returns `true` if this string ends with the character `c`
    ============================================================================
    function endsWith(c:Char):Bit {
        return length > 0 & self[self.length - 1] = c
    }

    function indexOf(needle:Char):Int? {
        for i in 0 .. length {
            if self[i] = needle
                return i
        }
        return null
    }

    function lastIndexOf(needle:Char):Int? {
        for i in length - 1 ... 0 by -1 {
            if self[i] = needle
                return i
        }
        return null
    }

    ============================================================================
    Returns `true` if this string contains the specified substring.
    
    @param needle the string to search for
    @returns `true` if the substring was found
    ============================================================================
    function contains(needle:String):Bit {
        return indexOf(needle) != null
    }

    ============================================================================
    Returns `true` if this string contains the specified character.
    
    @param needle the character to search for
    @returns `true` if the character was found
    ============================================================================
    @override
    function contains(needle:Char):Bit {
        return indexOf(needle) != null
    }

    ============================================================================
    Returns the number of times the given character appears in this string.
    
    @param needle the character to search for
    @returns the number of copies found
    ============================================================================
    @override
    function matchCount(needle:Char):Int {
        var count := 0
        for i in 0 .. length {
            if self[i] = needle
                count += 1
        }
        return count
    }

    ============================================================================
    Returns the number of times the given string appears, non-overlapping, in 
    this string.
    
    @param needle the string to search for
    @returns the number of copies found
    ============================================================================
    @override
    function matchCount(needle:String):Int {
        return matchCount(needle, false)
    }

    ============================================================================
    Returns the number of times the given string appears in this string. The
    `overlapping` parameter controls whether overlapping instances are counted.
    
    @param needle the string to search for
    @param `true` if overlapping instances are permitted
    @returns the number of copies found
    ============================================================================
    @override
    function matchCount(needle:String, overlapping:Bit):Int {
        var count := 0
        var i := 0
        while i <= length - needle.length.max(1) {
            i := indexOf(needle, i)
            if i = null
                break
            count += 1
            if overlapping
                i += 1 -- obviously not the fastest way to do this
            else
                i += needle.length.max(1)
        }
        return count
    }

    ============================================================================
    Returns the number of times the given regex appears, non-overlapping, in 
    this string.
    
    @param needle the regex to search for
    @returns the number of copies found
    ============================================================================
    @override
    function matchCount(needle:RegularExpression):Int {
        return matchCount(needle, false)
    }

    ============================================================================
    Returns the number of times the given string appears in this string. The
    `overlapping` parameter controls whether overlapping instances are counted.
    
    @param needle the string to search for
    @param `true` if overlapping instances are permitted
    @returns the number of copies found
    ============================================================================
    @override
    function matchCount(needle:RegularExpression, overlapping:Bit):Int {
        var count := 0
        var i := 0
        def matcher := needle.matcher(self)
        while i < length & matcher.find(i) {
            count += 1
            if overlapping
                i := matcher.start + 1
            else
                i := matcher.end.max(i + 1)
        }
        return count
    }

    ============================================================================
    Returns the index of the first occurrence of the string `s` within this
    string, or `null` if not found.
    
    @param s the string to search for
    @returns the index of the match, or `null` if not found
    ============================================================================
    function indexOf(s:String):Int? {
        return indexOf(s, 0)
    }

    ============================================================================
    Returns the index of the first occurrence of the string `s` within this
    string, starting from the specified `index`, or `null` if not found.
    
    @param s the string to search for
    @param start the index to begin searching from
    @returns the index of the match, or `null` if not found
    ============================================================================
    @pre(start >= 0)
    @pre(start <= length)
    function indexOf(s:String, start:Int):Int? {
        if length < s.length
            return null
        outer: for i in start ... length - s.length {
            for j in 0 .. s.length {
                if self[i + j] != s[j]
                    continue outer
            }
            return i
        }
        return null
    }
    @post(@return = null | @return < length)

    ============================================================================
    Returns the index of the last occurrence of the string `s` within this
    string, or `null` if not found.
    
    @param s the string to search for
    @returns the index of the match, or `null` if not found
    ============================================================================
    function lastIndexOf(s:String):Int? {
        return lastIndexOf(s, length - 1)
    }

    ============================================================================
    Returns the index of the last occurrence of the string `s` within this
    string, starting from the specified `index`, or `null` if not found.
    
    @param s the string to search for
    @param start the index to begin searching from
    @returns the index of the match, or `null` if not found
    ============================================================================
    @pre(start >= 0)
    @pre(start <= length)
    function lastIndexOf(s:String, start:Int):Int? {
        if length < s.length
            return null
        outer: for i in start ... s.length by -1 {
            for j in 0 .. s.length {
                if self[i - j] != s[s.length - 1 - j]
                    continue outer
            }
            return i
        }
        return null
    }
    @post(@return = null | @return < length)

    ============================================================================
    Returns a substring of this string from `start` to the end of the string.

    @param start the first character index to return
    @returns a substring of this string
    ============================================================================
    function [..](start:Int):String {
        return self[start .. length]
    }

    ============================================================================
    Returns a substring of this string from `start` (inclusive) to `end`
    (exclusive).

    @param start the first character index to return
    @param end index after the last character to return
    @returns a substring of this string
    ============================================================================
    function [..](start:Int, end:Int):String {
        def result := PrimitiveArray<Char>(end - start)
        for i in start .. end
            result[i - start] := chars[i]
        return String(result)
    }

    ============================================================================
    Returns a substring of this string from `start` (inclusive) to `end`
    (exclusive). If `start` is `null`, it defaults to the beginning of the 
    string. If `end` is `null`, it defaults to the end of the string.

    @param start the first character index to return
    @param end index after the last character to return
    @returns a substring of this string
    ============================================================================
    function [..](var start:Int?, var end:Int?):String {
        if start = null
            start := 0
        if end = null
            end := length
        return self[start->Int .. end->Int]
    }

    ============================================================================
    Returns a substring of this string from `start` (inclusive) to `end`
    (exclusive), counting by `step`.

    @param start the first character index to return
    @param end index after the last character to return
    @param step the step value
    @returns a substring of this string
    ============================================================================
    @override
    function [..](start:Int, end:Int, step:Int):String {
        def chars := Array<Char>()
        for i in start .. end by step
            chars.add(self[i])
        return String(chars)
    }

    ============================================================================
    Returns a substring of this string from `start` (inclusive) to `end`
    (exclusive), counting by `step`. If `start` is `null`, it defaults to the 
    beginning (for positive `step`) or end (for negative `step`) of the string. 
    If `end` is `null`, it defaults to the end (for positive `step`) or 
    beginning (for negative `step`) of the string.

    @param start the first character index to return
    @param end index after the last character to return
    @param step the step value
    @returns a substring of this string
    ============================================================================
    @override
    function [..](var start:Int?, var end:Int?, step:Int):String {
        def chars := Array<Char>()
        if start = null {
            if step > 0
                start := 0
            else
                start := length - 1
        }
        if end = null {
            if step > 0
                end := length
            else
                end := -1
        }
        for i in start .. end by step
            chars.add(self[i])
        return String(chars)
    }

    ============================================================================
    Returns a substring of this string from `start` to the end of the string.

    @param start the first character index to return
    @returns a substring of this string
    ============================================================================
    function [...](start:Int):String {
        return self[start ... length]
    }

    ============================================================================
    Returns a substring of this string from `start` to `end`, inclusive.

    @param start the first character index to return
    @param end the last character index to return
    @returns a substring of this string
    ============================================================================
    function [...](start:Int, end:Int):String {
        def result := PrimitiveArray<Char>(end - start + 1)
        for i in start ... end
            result[i - start] := chars[i]
        return String(result)    }

    ============================================================================
    Returns a substring of this string from `start` to `end`, inclusive. If 
    `start` is `null`, it defaults to the beginning of the string. If `end` is 
    `null`, it defaults to the end of the string.

    @param start the first character index to return
    @param end the last character index to return
    @returns a substring of this string
    ============================================================================
    function [...](var start:Int?, var end:Int?):String {
        if start = null
            start := 0
        if end = null
            end := length - 1
        return self[start->Int ... end->Int]
    }

    ============================================================================
    Returns a substring of this string from `start` to `end`, inclusive, 
    counting by `step`.

    @param start the first character index to return
    @param end the last character index to return
    @param step the step value
    @returns a substring of this string
    ============================================================================
    @override
    function [...](start:Int, end:Int, step:Int):String {
        def chars := Array<Char>()
        for i in start ... end by step
            chars.add(self[i])
        return String(chars)
    }

    ============================================================================
    Returns a substring of this string from `start` to `end`, inclusive, 
    counting by `step`. If `start` is `null`, it defaults to the beginning (for
    positive `step`) or end (for negative `step`) of the string. If `end` is 
    `null`, it defaults to the end (for positive `step`) or beginning (for
    negative `step`) of the string.

    @param start the first character index to return
    @param end the last character index to return
    @param step the step value
    @returns a substring of this string
    ============================================================================
    @override
    function [...](var start:Int?, var end:Int?, step:Int):String {
        def chars := Array<Char>()
        if start = null {
            if step > 0
                start := 0
            else
                start := length - 1
        }
        if end = null {
            if step > 0
                end := length
            else
                end := -1
        }
        for i in start ... end by step
            chars.add(self[i])
        return String(chars)
    }

    @override
    function filter(f:(Char)=>(Bit)):String {
        def result := MutableString()
        for c in characters {
            if f(c)
                result.append(c)
        }
        return result.convert()
    }

    ============================================================================
    Returns a new string consisting of this string left-justified in a field of
    at least `width` characters. If this string has a length greater than or
    equal to `width`, this string is returned. If this string is shorter than 
    `width`, space characters are appended until the resulting string is `width`
    characters long.

    @param width the minimum width of the string
    @returns a string at least `width` characters long
    ============================================================================
    function left(width:Int):String {
        return left(width, " ")
    }

    ============================================================================
    Returns a new string consisting of this string left-justified in a field of
    at least `width` characters, filled with the specified character. If this 
    string has a length greater than or equal to `width`, this string is 
    returned. If this string is shorter than `width`, `fill` characters are 
    appended until the resulting string is `width` characters long.

    @param width the minimum width of the string
    @param fill the fill character
    @returns a string at least `width` characters long
    ============================================================================
    function left(width:Int, fill:Char):String {
        if length >= width
            return self
        return self + fill * (width - length)
    }
    @post(@return.length >= width)

    ============================================================================
    Returns a new string consisting of this string right-justified in a field of
    at least `width` characters. If this string has a length greater than or
    equal to `width`, this string is returned. If this string is shorter than 
    `width`, space characters are prepended until the resulting string is 
    `width` characters long.

    @param width the minimum width of the string
    @returns a string at least `width` characters long
    ============================================================================
    function right(width:Int):String {
        return right(width, " ")
    }

    ============================================================================
    Returns a new string consisting of this string right-justified in a field of
    at least `width` characters, filled with the specified character. If this 
    string has a length greater than or equal to `width`, this string is 
    returned. If this string is shorter than `width`, `fill` characters are 
    prepended until the resulting string is `width` characters long.

    @param width the minimum width of the string
    @param fill the fill character
    @returns a string at least `width` characters long
    ============================================================================
    function right(width:Int, fill:Char):String {
        if length >= width
            return self
        return fill * (width - length) + self
    }
    @post(@return.length >= width)

    ============================================================================
    Returns a new string consisting of this string centered in a field of at 
    least `width` characters. If this string has a length greater than or equal 
    to `width`, this string is returned. If this string is shorter than 
    `width`, space characters are added as equally as possible to the left and
    right until the resulting string is `width` characters long. If the number
    of characters to be added is odd, the right side of the string will receive 
    one more space than the left side.

    @param width the minimum width of the string
    @returns a string at least `width` characters long
    ============================================================================
    function center(width:Int):String {
        return center(width, " ")
    }

    ============================================================================
    Returns a new string consisting of this string centered in a field of at 
    least `width` characters, filled with the specified character. If this 
    string has a length greater than or equal to `width`, this string is 
    returned. If this string is shorter than `width`, `fill` characters are 
    added as equally as possible to the left and right until the resulting 
    string is `width` characters long. If the number of characters to be added 
    is odd, the right side of the string will receive one more `fill` character 
    than the left side.

    @param width the minimum width of the string
    @param fill the fill character
    @returns a string at least `width` characters long
    ============================================================================
    function center(width:Int, fill:Char):String {
        if length >= width
            return self
        def pad := width - length
        def left := pad // 2
        def right := pad - left
        return fill * left + self + fill * right
    }
    @post(@return.length >= width)    

    @override
    @math(overflow)
    function get_hash():Int32 {
        var result := 0
        for i in 0 .. length
            result := result * 101 + self[i].convert()->Int8
        return result
    }

    @override
    function =(o:Object):Bit {
        if length = 1 & o.class = Char & self[0] = o->Char 
            return true
        if o.class != String
            return false
        def s := o->String
        if length != s.length
            return false
        for i in 0 .. length {
            if self[i] != s[i]
                return false
        }
        return true
    }

    ============================================================================
    Returns `true` if this string is lexicographically greater than the string 
    `s`.
    
    @param s the string to compare against
    @returns `true` if this string is greater
    ============================================================================
    function >(s:String):Bit {
        for i in 0 .. length.min(s.length) {
            if self[i]->UInt16 > s[i]->UInt16
                return true
            if self[i]->UInt16 < s[i]->UInt16
                return false
        }
        return length > s.length
    }

    ============================================================================
    Returns `true` if this string is lexicographically greater than or equal to
    the string `s`.
    
    @param s the string to compare against
    @returns `true` if this string is greater than or equal
    ============================================================================
    function >=(s:String):Bit {
        return self = s | self > s
    }

    ============================================================================
    Returns `true` if this string is lexicographically less than the string 
    `s`.
    
    @param s the string to compare against
    @returns `true` if this string is less
    ============================================================================
    function <(s:String):Bit {
        return !(self >= s)
    }

    ============================================================================
    Returns `true` if this string is lexicographically less than or equal to the 
    string `s`.
    
    @param s the string to compare against
    @returns `true` if this string is less than or equal
    ============================================================================
    function <=(s:String):Bit {
        return !(self > s)
    }

    ============================================================================
    Concatenates two strings.
    
    @example "Hello, " + "World!" = "Hello, World!"
    @param s1 the first string
    @param s2 the second string
    @returns a new string consisting of s1 + s2
    ============================================================================
    @class 
    function +(s1:String, s2:String):String {
        def l1 := s1.length
        def l2 := s2.length
        def result := PrimitiveArray<Char>(l1 + l2)
        for i in 0 .. l1
            result[i] := s1[i]
        for i in 0 .. l2
            result[i + l1] := s2[i]
        return String(result)
    }
    @post(@return.length = s1.length + s2.length)

    @class 
    function +(s1:Object, s2:String):String {
        return s1.convert() + s2
    }

    @class 
    function +(s1:String, s2:Object):String {
        return s1 + s2.convert()
    }

    ============================================================================
    Concatenates a string against itself repeatedly.
    
    @example "Hello" * 3 = "HelloHelloHello"
    @param count the number of repetitions
    @returns a new string containing repeated copies of this string
    ============================================================================
    @pre(count >= 0)
    function *(count:Int):String {
        -- using a naive algorithm here. An adaptation of the binary squaring
        -- power algorithm would do this in fewer steps, but would also require
        -- more allocations. For small n (which is what we expect here) I expect 
        -- this linear algorithm is actually faster, but I haven't tested it.
        def result := Array<Char>()
        for i in 0 .. count {
            for c in characters
                result.add(c)
        }
        return String(result)
    }
    @post(@return.count = length * count)

    ============================================================================
    Concatenates a string against itself repeatedly.
    
    @example 3 * "Hello" = "HelloHelloHello"
    @param count the number of repetitions
    @param s the string to concatenate
    @returns a new string containing repeated copies of `s`
    ============================================================================
    @class
    @pre(count >= 0)
    function *(count:Int, s:String):String {
        return s * count
    }

    ============================================================================
    Returns an uppercased version of this string. Note that uppercasing an
    entire string is not necessarily the same as uppercasing every character of
    the string; more context is available, and thus more complex Unicode rules 
    are used. You should always operate on entire strings when possible, as 
    opposed to character-by-character.
    ============================================================================
    @external
    function toUppercase():String

    ============================================================================
    Returns a lowercased version of this string. Note that lowercasing an
    entire string is not necessarily the same as lowercasing every character of
    the string; more context is available, and thus more complex Unicode rules 
    are used. You should always operate on entire strings when possible, as 
    opposed to character-by-character.
    ============================================================================
    @external
    function toLowercase():String

    ============================================================================
    Returns a titlecased version of this string. Note that titlecasing an
    entire string is not necessarily the same as titlecasing every character of
    the string; more context is available, and thus more complex Unicode rules 
    are used. You should always operate on entire strings when possible, as 
    opposed to character-by-character.
    ============================================================================
    @external
    function toTitlecase():String

    ============================================================================
    Returns the string itself.
    
    @returns this string
    ============================================================================
    @override
    function convert():String {
        return self
    }

    ============================================================================
    Returns a formatted representation of this string. With an empty format
    string, the raw string is returned. With the format string `"panda"`, a
    representation of the string as it would appear in Panda source code is
    returned.

    @param fmt the format string
    @returns a formatted string
    ============================================================================
    @override
    @pre(fmt = "panda")
    function format(fmt:String):String {
        def result := MutableString('"')
        for i in 0 .. length {
            def c := self[i]
            switch c {
                case '"': result.append('\\"')
                case "\\": result.append("\\\\")
                case "\n": result.append("\\n")
                case "\r": result.append("\\r")
                case "\t": result.append("\\t")
                default:
                    if c->Int >= 32 & c->Int <= 126
                        result.append(c)
                    else -- FIXME add unicode escape
                        result.append("?")
            }
        }
        result.append('"')
        return result.convert()
    }

    function get_characters():ImmutableArray<Char> {
        return convert()
    }

    ============================================================================
    Converts this string to an array of characters.
    
    @returns the characters of the string
    ============================================================================
    @override
    function convert():Array<Char> {
        def result := Array<Char>(length)
        for i in 0 .. length
            result.add(self[i])
        return result
    }
    @postAnd(@return.length = length)

    ============================================================================
    Converts this string to an immutable array of characters.
    
    @returns the characters of the string
    ============================================================================
    @override
    function convert():ImmutableArray<Char> {
        return ImmutableArray<Char>(convert()->Array<Char>)
    }
    @postAnd(@return.length = length)

    ============================================================================
    Converts this string to a UTF-8 sequence of bytes.

    **IMPLEMENTATION NOTE:** Unicode support isn't actually in yet, therefore
    this conversion is broken.
    
    @returns the UTF-8 encoded bytes
    ============================================================================
    function convert():Array<UInt8> {
        -- FIXME not actually doing UTF-8 encoding, just spitting out bytes
        def result := Array<UInt8>(length)
        for c in characters
            result.add(c.convert())
        return result
    }
    @post(@return.length = length)

    ============================================================================
    Converts this string to a UTF-8 sequence of bytes.

    **IMPLEMENTATION NOTE:** Unicode support isn't actually in yet, therefore
    this conversion is broken.
    
    @returns the UTF-8 encoded bytes
    ============================================================================
    function convert():ImmutableArray<UInt8> {
        return ImmutableArray<UInt8>(convert()->Array<UInt8>)
    }
    @post(@return.length = length)

    ============================================================================
    Converts a single-character string to a `Char`.
    
    @returns the character it contains
    ============================================================================
    @pre(length = 1)
    function convert():Char {
        return self[0]
    }

    ============================================================================
    Returns `true` if the string is equal to `"true"`, `false` otherwise.
    
    @returns the `Bit` representation of this string
    ============================================================================
    function convert():Bit {
        return self = "true"
    }

    function convert():Bit {
        return self = "true"
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits, optionally preceded by a minus sign (`-`), whose numeric
    representation can fit into an `Int64`. Returns `null` if the conversion
    fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():Int64? {
        if length = 0
            return null
        var result:Int64 := 0
        var start:Int
        if self[0] = "-"
            start := 1
        else
            start := 0
        for i:Int32 in start .. length {
            def digit := self[i]->Int32 - 48
            if digit < 0 | digit > 9
                return null
            result := result * 10 + digit
        }
        if self[0] = "-"
            result := -result
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits, optionally preceded by a minus sign (`-`), whose numeric
    representation can fit into an `Int64`. Throws `ParseException` if the
    conversion fails.
    
    @returns this string converted to a number
    @throws ParseException if the conversion fails
    ============================================================================
    function convert():Int64 {
        def result:Int64? := convert()
        if result = null
            throw ParseException(self)
        return result
    }
    
    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits, optionally preceded by a minus sign (`-`), whose numeric
    representation can fit into an `Int32`. Returns `null` if the conversion
    fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():Int32? {
        def result:Int64? := convert()
        if result != null
            return result->Int32
        else
            return null
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits, optionally preceded by a minus sign (`-`), whose numeric
    representation can fit into an `Int32`. Throws `ParseException` if the
    conversion fails.
    
    @returns this string converted to a number
    @throws ParseException if the conversion fails
    ============================================================================
    function convert():Int32 {
        def result:Int32? := convert()
        if result = null
            throw ParseException(self)
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits, optionally preceded by a minus sign (`-`), whose numeric
    representation can fit into an `Int16`. Returns `null` if the conversion
    fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():Int16? {
        def result:Int64? := convert()
        if result-?>Int16
            return result->Int16
        else
            return null
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits, optionally preceded by a minus sign (`-`), whose numeric
    representation can fit into an `Int16`. Throws `ParseException` if the
    conversion fails.
    
    @returns this string converted to a number
    @throws ParseException if the conversion fails
    ============================================================================
    function convert():Int16 {
        def result:Int16? := convert()
        if result = null
            throw ParseException(self)
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits, optionally preceded by a minus sign (`-`), whose numeric
    representation can fit into an `Int8`. Returns `null` if the conversion
    fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():Int8? {
        def result:Int64? := convert()
        if result-?>Int8
            return result->Int8
        else
            return null
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits, optionally preceded by a minus sign (`-`), whose numeric
    representation can fit into an `Int8`. Throws `ParseException` if the
    conversion fails.
    
    @returns this string converted to a number
    @throws ParseException if the conversion fails
    ============================================================================
    function convert():Int8 {
        def result:Int8? := convert()
        if result = null
            throw ParseException(self)
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits whose numeric representation can fit into a `UInt64`. Returns `null` 
    if the conversion fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():UInt64? {
        if length = 0
            return null
        var result:UInt64 := 0
        for i:Int32 in 0 .. length {
            def digit := self[i]->UInt16 - 48
            if digit < 0 | digit > 9
                return null
            result := result * 10 + digit->UInt64
        }
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits whose numeric representation can fit into a `UInt64`. Throws 
    `ParseException` if the conversion fails.
    
    @returns this string converted to a number
    @throws ParseException if the conversion fails
    ============================================================================
    function convert():UInt64 {
        def result:UInt64? := convert()
        if result = null
            throw ParseException(self)
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits whose numeric representation can fit into a `UInt32`. Returns `null` 
    if the conversion fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():UInt32? {
        def result:UInt64 := convert()
        if result-?>UInt32
            return result->UInt32
        else
            return null
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits whose numeric representation can fit into a `UInt32`. Throws 
    `ParseException` if the conversion fails.
    
    @returns this string converted to a number
    @throws ParseException if the conversion fails
    ============================================================================
    function convert():UInt32 {
        def result:UInt32? := convert()
        if result = null
            throw ParseException(self)
        return result
    }


    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits whose numeric representation can fit into a `UInt16`. Returns `null` 
    if the conversion fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():UInt16? {
        def result:UInt64? := convert()
        if result-?>UInt16
            return result->UInt16
        else
            return null
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits whose numeric representation can fit into a `UInt16`. Throws 
    `ParseException` if the conversion fails.
    
    @returns this string converted to a number
    @throws ParseException if the conversion fails
    ============================================================================
    function convert():UInt16 {
        def result:UInt16? := convert()
        if result = null
            throw ParseException(self)
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits whose numeric representation can fit into a `UInt8`. Returns `null` 
    if the conversion fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():UInt8? {
        def result:UInt64? := convert()
        if result-?>UInt8
            return result->UInt8
        else
            return null
    }

    ============================================================================
    Converts this string to a number. The string must be a sequence of decimal
    digits whose numeric representation can fit into a `UInt8`. Throws 
    `ParseException` if the conversion fails.
    
    @returns this string converted to a number
    @throws ParseException if the conversion fails
    ============================================================================
    function convert():UInt8 {
        def result:UInt8? := convert()
        if result = null
            throw ParseException(self)
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be in the format of a 
    Panda `Real32` literal. Returns `null` if the conversion fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():Real32? {
        def result := pandaStringToReal32(self)
        if result.isNaN
            return null
        else
            return result
    }

    ============================================================================
    Converts this string to a number. The string must be in the format of a 
    Panda `Real32` literal. Throws a `ParseError` if the conversion fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():Real32 {
        def result:Real32? := convert()
        if result = null
            throw ParseException(self)
        return result
    }

    ============================================================================
    Converts this string to a number. The string must be in the format of a 
    Panda `Real64` literal. Returns `null` if the conversion fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():Real64? {
        def result := pandaStringToReal64(self)
        if result.isNaN
            return null
        else
            return result
    }
        
    ============================================================================
    Converts this string to a number. The string must be in the format of a 
    Panda `Real64` literal. Throws a `ParseError` if the conversion fails.
    
    @returns this string converted to a number, or `null`
    ============================================================================
    function convert():Real64 {
        def result:Real64? := convert()
        if result = null
            throw ParseException(self)
        return result
    }

    ============================================================================
    Formats a string for display purposes, exactly as if by
    [OutputStream.write(String, ListView<Object>)].

    @param s the format string
    @param params the format string parameters
    @returns a formatted string
    ============================================================================
    @class
    function format(s:String, params:Object...):String {
        def buffer := MemoryOutputStream()
        buffer.write(s, params...)
        return buffer.convert()
    }

    -- FIXME remove these and move the external code directly to the convert
    -- methods
    @private
    @class
    @external
    function pandaStringToReal32(s:String):Real32

    @private
    @class
    @external
    function pandaStringToReal64(s:String):Real64
}