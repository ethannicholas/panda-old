package panda.core

================================================================================
A 16 bit Unicode code point, representing a character in the Basic Multilingual
Plane.
================================================================================
@static
class CharWrapper : Primitive {
    constant MIN := 0->(Char)

    constant MAX := 0xFFFF->(Char)

    var value:Char

    ============================================================================
    Creates a slice of the chars: an array ranging from `left` (inclusive) to
    `right` (exclusive).
    ============================================================================
    @class
    function [..](left:Char, right:Char):Array<Char> {
        def result := new Array<Char>()
        for v:Char in left .. right
            result.append(v)
        return result
    }

    ============================================================================
    Creates a slice of the chars: an array ranging from `left` (inclusive) to
    `right` (exclusive), counting by `step`.
    ============================================================================
    @class
    function [..](left:Char, right:Char, step:Int16):Array<Char> {
        def result := new Array<Char>()
        for v:Char in left .. right by step
            result.append(v)
        return result
    }

    @class 
    function [...](left:Char):Array<Char> {
        throw new UnimplementedException()
    }
    
    ============================================================================
    Creates a slice of the chars: an array ranging from `left` to `right` 
    (inclusive).
    ============================================================================
    @class
    function [...](left:Char, right:Char):Array<Char> {
        var result := new Array<Char>()
        for v:Char in left ... right
            result.append(v)
        return result
    }

    ============================================================================
    Creates a slice of the chars: an array ranging from `left` to `right` 
    (inclusive), counting by `step`.
    ============================================================================
    @class
    function [...](left:Char, right:Char, step:Int16):Array<Char> {
        def result := new Array<Char>()
        for v:Char in left ... right by step
            result.append(v)
        return result
    }

    constructor(value:Char) {
        self.value := value
    }

    -- FIXME do this for real when we have Unicode support
    function isWhitespace():Bit {
        return "\n\r\t ".contains(value)
    }

    @class
    function *(c:Char, i:Int):String {
        return c->>(String) * i
    }
        
    @class
    function *(i:Int, c:Char):String {
        return c->>(String) * i
    }

    @override
    function =(o:Object):Bit {
        return o-?>(CharWrapper) & value = o->(CharWrapper).value |
                o-?>(String) & value->>(String) = o
    }

    ============================================================================
    Returns a single-character string containing this character.
    ============================================================================
    @override
    function ->>():String {
        return value->>(String)
    }
      
    function ->>():Char {
        return value
    }

    @override
    @preOr(fmt = "" | fmt = "panda")
    function format(fmt:String):String {
        if fmt = ""
            return value->>(String)
        else
            return value->>(String).format(fmt)
    }
}