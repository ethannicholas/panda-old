package panda.core

================================================================================
An 8 bit signed integer, capable of representing numbers in the range -128 to 
127.

`Int8`s are created automatically as the result of integer literals (numbers 
appearing directly in the source code) and as the result of mathematical 
expressions.
================================================================================
@static
class Int8Wrapper : SignedInteger {
    ============================================================================
    The minimum value representable by an `Int8`.
    ============================================================================
    constant MIN:Int8 := -128
    
    ============================================================================
    The maximum value representable by an `Int8`.
    ============================================================================
    constant MAX:Int8 := 127

    ============================================================================
    The number of bits in an `Int8`.
    ============================================================================
    constant BITS := 8

    ============================================================================
    @hidden
    ============================================================================
    def value:Int8
    
    ============================================================================
    Creates a slice of the integers: an array ranging from `left` (inclusive) to
    `right` (exclusive).
    ============================================================================
    @class
    function [..](left:Int8, right:Int8):Array<Int8> {
        def result := new Array<Int8>()
        for v:Int8 in left .. right
            result.append(v)
        return result
    }

    ============================================================================
    Creates a slice of the integers: an array ranging from `left` (inclusive) to
    `right` (exclusive), counting by `step`.
    ============================================================================
    @class
    function [..](left:Int8, right:Int8, step:Int8):Array<Int8> {
        def result := new Array<Int8>()
        for v:Int8 in left .. right by step
            result.append(v)
        return result
    }

    @class 
    function [...](left:Int8):Array<Int8> {
        throw new UnimplementedException()
    }
    
    ============================================================================
    Creates a slice of the integers: an array ranging from `left` to `right` 
    (inclusive).
    ============================================================================
    @class
    function [...](left:Int8, right:Int8):Array<Int8> {
        var result := new Array<Int8>()
        for v:Int8 in left ... right
            result.append(v)
        return result
    }

    ============================================================================
    Creates a slice of the integers: an array ranging from `left` to `right` 
    (inclusive), counting by `step`.
    ============================================================================
    @class
    function [...](left:Int8, right:Int8, step:Int8):Array<Int8> {
        def result := new Array<Int8>()
        for v:Int8 in left ... right by step
            result.append(v)
        return result
    }

    constructor(value:Int8) {
        self.value := value
    }

    -- The operators below are *not actually used* by naive code; i.e. x * y
    -- will never call Int8::* (which is why none of these end up causing
    -- infinite recursion). They are specifically filtered out by 
    -- ASTGenerator::callOverloadedOperator, and defined here purely for
    -- convenience so that they can be accessed like "Int8::*".

    @$wrapperMethod
    function +(x:Int8):Int8 {
        try {
            return (self + x)->(Int8)
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function -(x:Int8):Int8 {
        try {
            return (self - x)->(Int8)
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function *(x:Int8):Int8 {
        try {
            return (self * x)->(Int8)
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function /(x:Int8):Real32 {
        try {
            return self / x
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function //(x:Int8):Int8 {
        try {
            return (self // x)->(Int8)
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function ^(x:UInt8):Int8 {
        try {
            return (self ^ x)->(Int8)
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function ^(x:Real32):Real32 {
        try {
            return self ^ x
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function ||(x:Int8):Int8 {
        try {
            return (self || x)->(Int8)
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function &&(x:Int8):Int8 {
        try {
            return (self && x)->(Int8)
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function ~~(x:Int8):Int8 {
        try {
            return (self ~~ x)->(Int8)
        }
        catch e:CastError {
            throw new OverflowError(e.message)
        }
    }

    @$wrapperMethod
    function !!():Int8 {
        return (!!self)->>(Int8)
    }

    @$wrapperMethod
    function >(x:Int8):Bit {
        return self > x
    }

    @$wrapperMethod
    function >=(x:Int8):Bit {
        return self >= x
    }

    @$wrapperMethod
    function <(x:Int8):Bit {
        return self < x
    }

    @$wrapperMethod
    function <=(x:Int8):Bit {
        return self <= x
    }

    ============================================================================
    Returns the greater (closer to positive infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the maximum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function max(other:Int32):Int32 {
        if self > other
            return self
        else
            return other
    }

    ============================================================================
    Returns the greater (closer to positive infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the maximum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function max(other:Int64):Int64 {
        if self > other
            return self
        else
            return other
    }

    ============================================================================
    Returns the greater (closer to positive infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the maximum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function max(other:UInt32):UInt32 {
        if self < 0
            return other
        if self->(UInt32) > other
            return self->(UInt32)
        else
            return other
    }

    ============================================================================
    Returns the greater (closer to positive infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the maximum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function max(other:UInt64):UInt64 {
        if self < 0
            return other
        if self->(UInt64) > other
            return self->(UInt64)
        else
            return other
    }

    ============================================================================
    Returns the greater (closer to positive infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the maximum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function max(other:Real32):Real32 {
        if self > other
            return self
        else
            return other
    }

    ============================================================================
    Returns the greater (closer to positive infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the maximum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function max(other:Real64):Real64 {
        if self > other
            return self
        else
            return other
    }

    ============================================================================
    Returns the lesser (closer to negative infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the minimum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function min(other:Int32):Int32 {
        if self < other
            return self
        else
            return other
    }

    ============================================================================
    Returns the lesser (closer to negative infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the minimum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function min(other:Int64):Int64 {
        if self < other
            return self
        else
            return other
    }

    ============================================================================
    Returns the lesser (closer to negative infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the minimum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function min(other:UInt32):Int8 {
        if self < 0
            return self
        if (self->(UInt32)) < self
            return self
        else
            return other->(Int8)
    }

    ============================================================================
    Returns the lesser (closer to negative infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the minimum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function min(other:UInt64):Int8 {
        if self < 0
            return self
        if (self->(UInt64)) < other
            return self
        else
            return other->(Int8)
    }

    ============================================================================
    Returns the lesser (closer to negative infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the minimum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function min(other:Real32):Real32 {
        if self < other
            return self
        else
            return other
    }

    ============================================================================
    Returns the lesser (closer to negative infinity) of itself and its 
    parameter.

    @param other the number to compare against
    @returns the minimum of itself and the other number
    ============================================================================
    @$wrapperMethod
    function min(other:Real64):Real64 {
        if self < other
            return self
        else
            return other
    }

    @$wrapperMethod
    function sign():Int {
        if self > 0
            return 1
        else if self < 0
            return -1
        return 0
    }

    @$wrapperMethod
    function sqrt():Real {
        return self->>(Real).sqrt
    }

    @$wrapperMethod
    function sin():Real {
        return self->>(Real).sin
    }

    @$wrapperMethod
    function cos():Real {
        return self->>(Real).cos
    }

    @$wrapperMethod
    function tan():Real {
        return self->>(Real).tan
    }

    @$wrapperMethod
    function abs():Int8 {
        if self < 0
            return -self
        return self
    }

    ============================================================================
    Returns a single `Bit` from this integer. Index `0` is the least significant
    bit, and index `7` is the most significant bit.

    @param index the index of the bit to return
    @returns `true` if the bit is set
    ============================================================================
    @pre(index >= 0 & index < BITS)
    @$wrapperMethod
    function [](index:Int):Bit {
        return self >> index && 1 = 1
    }

    ============================================================================
    Returns a slice of this integer's bit representation. Index `0` is the least 
    significant bit, and index `7` is the most significant bit. The sliced bits
    are returned packed in a new `Int8` value. For example:

        var value := -1
        Console.writeLine(value[4 .. 8])

    This selects the four most significant bits of `value`. Since `value` is
    `-1`, and the binary representation of `-1` has all bits set, the resulting
    slice also has all four of its bits set, resulting in the value `15`.
    
    @param index the index of the bit to return
    @returns `true` if the bit is set
    ============================================================================
    @$wrapperMethod
    @pre(left >= 0 & left < BITS & right >= 0 & right < BITS & step != 0)
    function [..](var left:Int?, var right:Int?, step:Int):Int8 {
        if left = null {
            if step > 0
                left := 0
            else
                left := BITS - 1
        }
        if right = null {
            if step > 0
                right := BITS
            else
                right := -1
        }
        if step = 1 {
            var mask := (-1)->>(UInt8) >> (BITS - (right - left))
            return (self >> left && mask)->(Int8)
        }
        var count := 0
        var result := 0
        for i in left ... right by step {
            var bit := self[i]
            if bit
                result ||= 1 << count
            count += 1
        }
        return result->(Int8)
    }

    ============================================================================
    Returns the number of bits necessary to represent this number. For instance,
    the number `19` has binary representation `10011`, therefore `19.length` has
    the value `5`. Negative numbers always have their most significant bit set
    and thus a length equal to `BITS`, and `0` reports a length of `0`.
    ============================================================================
    @$wrapperMethod
    @external
    function length():Int

    ============================================================================
    @hidden
    ============================================================================
    @protected
    @override
    function convertToString(thousandsSeparator:Char?):String {
        return convertToString(value, thousandsSeparator)
    }
    
    @override
    function =(o:Object):Bit {
        if o-?>(Integer)
            return value = o->(Number)->>(Int64)
        else if o-?>(RealNumber)
            return value = o->(Number)->>(Real64)
        else
            return false
    }
        
    @override
    function ->>():Int8 {
        return value
    }

    @override
    function ->>():Int16 {
        return value
    }

    @override
    function ->>():Int32 {
        return value
    }

    @override
    function ->>():Int64 {
        return value
    }

    @override
    function ->>():UInt8 {
        return value->>(UInt8)
    }

    @override
    function ->>():UInt16 {
        return value->>(UInt16)
    }

    @override
    function ->>():UInt32 {
        return value->>(UInt32)
    }

    @override
    function ->>():UInt64 {
        return value->>(UInt64)
    }

    @override
    function ->>():Real32 {
        return value
    }

    @override
    function ->>():Real64 {
        return value
    }

    @override
    function ->>():String {
        return value->>(String)
    }
}