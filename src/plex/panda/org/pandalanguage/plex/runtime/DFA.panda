package org.pandalanguage.plex.runtime

class DFA {
    def transitions:ImmutableArray<ImmutableArray<Int>>

    def accepts:ImmutableArray<Int>

    var rawToken := new RawToken()

    var pushback := new PushbackInputStream(new MemoryInputStream("this is a test (there's nothing here)"))

    property source:LineNumberInputStream := new LineNumberInputStream(pushback)

    var text := new MutableString()

    var line := 1

    var column := 1

    constructor(transitions:ImmutableArray<ImmutableArray<Int>>,
            accepts:ImmutableArray<Int>) {
        self.transitions := transitions
        self.accepts := accepts
    }

    @self
    method source:=(source:InputStream) {
        self.pushback := new PushbackInputStream(source)
        self._source := new LineNumberInputStream(pushback)
        assert self.source.line = 1 & self.source.column = 1
    }

    method next():RawToken {
        var currentState := 1
        var hitEOF := false
        rawToken.startLine := source.line
        rawToken.startColumn := source.column
        var lastLine := -1
        var lastColumn := -1
        var lastAccept := -1
        var lastAcceptPosition := -1
        loop {
            def c := source.readChar()
            if c = null {
                hitEOF := true
                break
            }
            if c->(Int) >= transitions.length {
                Console.writeLine("invalid token (" + c->(Int) + " > " + transitions.length + ") at " + source.line + ", " + source.column)
                throw new TokenException("invalid token", source.line, 
                        source.column)
            }
            currentState := transitions[c->(Int)][currentState]
            if currentState != 0 {
                text.append(c)
                var newAccept := accepts[currentState]
                if newAccept != -1 {
                    lastAccept := newAccept
                    lastAcceptPosition := text.length
                    lastLine := source.line
                    lastColumn := source.column
                }
            }
            else {
                pushback.pushback(c)
                break
            }
        }
        if text.length > 0 {
            if lastAccept != -1 {
                pushback.pushback(text[lastAcceptPosition..])
                text.remove(lastAcceptPosition, text.length)
                source.line := lastLine
                source.column := lastColumn
                rawToken.type := lastAccept
                rawToken.text := text->>(String)
                text.clear()
                return rawToken
            }
        }
        else if hitEOF {
            rawToken.type := 0
            rawToken.text := "<EOF>"
            return rawToken
        }
                Console.writeLine("invalid token (fail) at " + rawToken.startLine + ", " + rawToken.startColumn)
        throw new TokenException("invalid token", rawToken.startLine, 
                rawToken.startColumn)
    }    
}