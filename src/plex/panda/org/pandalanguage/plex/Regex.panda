package org.pandalanguage.plex

uses org.pandalanguage.plex.AcceptState
uses org.pandalanguage.plex.AnyState
uses org.pandalanguage.plex.NFA
uses org.pandalanguage.plex.RemappedState
uses org.pandalanguage.plex.SingleCharState
uses org.pandalanguage.plex.State
uses org.pandalanguage.plex.TableState

@abstract
class Node {
    @abstract
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int>

    @abstract
    @override
    function ->>():String
}

class Set : Node {
    var inverse := false

    @readonly
    var contents := new Array<Object>()

    @class
    method set(table:List<Bit>, c:Char) {
        var i := c->(Int)
        while table.length <= i
            table.add(false)
        table[i] := true
    }

    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        def table := new Array<Bit>()
        for i in 0 .. contents.length {
            if contents[i]-?>(SingleChar)
                set(table, contents[i]->(SingleChar).value)
            else {
                var r := contents[i]->(CharSet)
                for j in 0 .. r.contents.length
                    set(table, r.contents[j])
            }
        }
        return Regex.singleton(context.addState(new TableState(inverse, 
                new ImmutableArray<Bit>(table), accept)))
    }

    @override
    function ->>():String {
        var result := new MutableString()
        result.append("[")
        for i in 0 ... contents.length - 1
            result.append(contents[i])
        result.append("]")
        return result->>(String)
    }
}

class Star : Node {
    @readonly
    var contents:Node

    constructor(contents:Node) {
        self.contents := contents
    }

    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        def next := new Array<Int>(accept)
        def stateId := context.addState(new RemappedState(new ImmutableArray<Int>([])))
        next.add(stateId)
        def start := contents.makeStartStates(context, next)
        for state in accept
            start.add(state)
        def newStates := new Array<State>(context.states)
        newStates[stateId] := new RemappedState(new ImmutableArray<Int>(start))
        context.states := new ImmutableArray<State>(newStates)
        return start
    }    

    @override
    function ->>():String {
        return contents + "*"
    }
}

class Plus : Node {
    @readonly
    var contents:Node

    constructor(contents:Node) {
        self.contents := contents
    }

    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        -- a lot of ugliness has crept in here over time, largely due to
        -- having to work around the immutability of various objects when these
        -- objects were not originally built as immutable and I didn't want to
        -- have to completely rewrite everything. Probably should have.
        def next := new Array<Int>()
        for state in accept
            next.add(state)
        def dummy := new RemappedState()
        def index := context.addState(dummy)
        next.add(index)
        def start := contents.makeStartStates(context, next)
        def remapped := new RemappedState(new ImmutableArray<Int>(start))
        def newStates := new Array<State>(context.states[0 .. index])
        newStates.add(remapped)
        newStates.addAll(new Array<State>(context.states[index + 1..]))
        context.states := new ImmutableArray<State>(newStates)
        return start
    }    

    @override
    function ->>():String {
        return contents + "+"
    }
}

class Option : Node {
    @readonly
    var contents:Node

    constructor(contents:Node) {
        self.contents := contents
    }

    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        var states := new Array<Int>()
        for i in 0 .. accept.length
            states.add(accept[i])
        var start := contents.makeStartStates(context, accept)
        for i in 0 .. start.length
            states.add(start[i])
        return states
    }    

    @override
    function ->>():String {
        return contents + "?"
    }
}

class Union : Node {
    @readonly
    var left:Node

    @readonly
    var right:Node

    constructor(left:Node, right:Node) {
        self.left := left
        self.right := right
    }

    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        def result := new Array<Int>()
        result.addAll(left.makeStartStates(context, accept))
        result.addAll(right.makeStartStates(context, accept))
        return result
    }    

    @override
    function ->>():String {
        return left + "|" + right
    }
}

class SingleChar : Node {
    @readonly
    var value:Char

    constructor(value:Char) {
        self.value := value
    }

    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        return Regex.singleton(context.addState(new SingleCharState(value, 
                new ImmutableArray<Int>(accept))))
    }    

    @override
    function ->>():String {
        return value->>(String)
    }
}

class CharSet : Node {
    def contents:ListView<Char>

    constructor(a:Char, b:Char) {
        def contents := new Array<Char>()
        for c in a ... b
            contents.add(c)
        self.contents := contents
    }

    constructor(contents:String) {
        self.contents := contents->>(Array<Char>)
    }

    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        def table := new Array<Bit>()
        for c in contents
            Set.set(table, c)
        return Regex.singleton(context.addState(new TableState(false, 
                new ImmutableArray<Bit>(table), accept)))
    }    

    @override
    function ->>():String {
        return new String(contents)
    }
}


class Any : Node {
    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        return Regex.singleton(context.addState(new AnyState(new ImmutableArray<Int>(accept))))
    }    

    @override
    function ->>():String {
        return "."
    }
}

class Concat : Node {
    @readonly
    var left:Node

    @readonly
    var right:Node

    constructor(left:Node, right:Node) {
        self.left := left
        self.right := right
    }

    @override
    method makeStartStates(context:NFA, accept:ListView<Int>):Array<Int> {
        var rightStates := right.makeStartStates(context, accept)
        return left.makeStartStates(context, rightStates)
    }

    @override
    function ->>():String {
        return "(" + left + right + ")"
    }
}

class Regex {
    constant EOF := 0->(Char) 

    def stack := new Stack<Node>()
    var source:String
    var index := 0
    var regexNode:Node

    constructor(source:String) {
        self.source := source
        regex()
        self.regexNode := stack.pop()
    }

    @private
    function peek():Char {
        if index = source.length
            return EOF
        return source[index]
    }

    @private
    method expect(c:Char) {
        if peek != c
            throw new ParseException("expected '" + c + "' at index " + index)
        index += 1
    }

    @private
    method elementary() {
        switch peek {
            case "(": group()
            case "[": set()
            case ".": any()
            default: char()
        }
    }

    @private
    method basic() {
        elementary()
        switch peek {
            case "*": {
                stack.push(new Star(stack.pop()))
                index += 1
            }
            case "+": {
                stack.push(new Plus(stack.pop()))
                index += 1
            }
            case "?": {
                stack.push(new Option(stack.pop()))
                index += 1
            }
        }
    }

    @private
    method simple() {
        basic()
        loop {
            switch peek {
                case "|", ")", EOF: break
                default: {
                    simple()
                    var b := stack.pop()
                    var a := stack.pop()
                    stack.push(new Concat(a, b))
                }
            }
        }
    }

    @private
    method getEscape(c:Char):Node {
        switch c {
            case "s": return new CharSet(" \t\n\r")
            case "n": return new SingleChar("\n")
            case "t": return new SingleChar("\t")
            case "r": return new SingleChar("\r")
            default: return new SingleChar(c)
        }
    }

    @private
    method char() {
        var c := peek
        switch c {
            case "(", ")", "+", "*", ".", "|": return
            case "\\": {
                index += 1
                stack.push(getEscape(peek))
                index += 1
            }
            default: {
                stack.push(new SingleChar(c))
                index += 1
            }
        }
    }

    @private
    method any() {
        expect(".")
        stack.push(new Any())
    }

    @private
    method group() {
        expect("(")
        regex()
        expect(")")
    }

    @private
    method setChar() {
        var c := peek
        switch c {
            case "]": return
            case "\\": {
                index += 1
                stack.push(getEscape(peek))
                index += 1
            }
            default: {
                stack.push(new SingleChar(c))
                index += 1
            }
        }
    }

    @private
    method setItem() {
        setChar()
        if peek = "-" {
            expect("-")
            if peek = "]" {
                index -= 1
                setChar()
                assert peek = "]"
            }
            else {
                setChar()
                var b := stack.pop()->(SingleChar).value
                var a := stack.pop()->(SingleChar).value
                stack.push(new CharSet(a, b))
            }
        }
    }

    @private
    method setItems() {
        setItem()
        if peek != "]"
            setItems()
    }

    @private
    method set() {
        expect("[")
        def MARKER := new SingleChar("!")
        stack.push(MARKER)
        var set := new Set()
        if peek = "^" {
            index += 1
            set.inverse := true
        }
        setItems()
        var item := stack.pop()
        while item != MARKER {
            set.contents.add(item)
            item := stack.pop()
        }
        stack.push(set)
        expect("]")
    }

    @class
    function singleton(i:Int):Array<Int> {
        var result := new Array<Int>()
        result.add(i)
        return result
    }

    @private
    method regex() {
        simple()
        switch peek {
            case "|": {
                expect("|")
                regex()
                var b := stack.pop()
                var a := stack.pop()
                stack.push(new Union(a, b))
            }
            case EOF: return
        }
    }

    method addToNFA(context:NFA, accept:Int):Array<Int> {
        return regexNode.makeStartStates(context, singleton(accept))
    }
}