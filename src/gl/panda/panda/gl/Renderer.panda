package panda.gl

uses panda.gl.images.Image
uses panda.gl.shapes.Shape
uses panda.gl.shapes.Rectangle

class Renderer {
    ============================================================================
    Color used for fill operations.
    ============================================================================
    property paint:Paint := Color.WHITE

    ============================================================================
    Compositing rule, which controls how source pixels are combined with
    destination pixels.
    ============================================================================
    property composite:Composite := new IdentityComposite()

    ============================================================================
    Transform which controls how user-space points are mapped onto device
    coordinates.
    ============================================================================
    property transform:Transform := Transform.IDENTITY

    @private
    def stack := new Stack<Paint, Composite, Transform>()
    
    @private
	var native:$NativePointer

	@private
	constructor() {
	}

    method save() {
        stack.push((paint, composite, transform))
        _save()
    }

    @private
    @external
    method _save()

    method restore() {
        _restore()
        paint, composite, transform := stack.pop()
    }

    @private
    @external
    method _restore()

    ============================================================================
    Intersects the currect clip region with the specified shape to create a new
    clip region.

    @param clip the new clipping region
    ============================================================================
    @self
    @external
    method clip(clip:Shape)

    @self
    method translate(x:Real, y:Real) {
        transform *= Transform.translation(x, y)
    }

    @self
    method rotate(angle:Real) {
        transform *= Transform.rotation(angle)
    }

    @self
    method rotate(angle:Real, axis:Point) {
        transform *= Transform.rotation(angle, axis)
    }

    @self
    method scale(scale:Real) {
        transform *= Transform.scale(scale)
    }

    @self
    method scale(sx:Real, sy:Real) {
        transform *= Transform.scale(sx, sy)
    }

    @private
    @self
    method transform:=(transform:Transform) {
        self._transform := transform
        setTransform(transform)
    }

    @private
    @external
    method setTransform(transform:Transform)

    @self
    method paint:=(paint:Paint) {
        self._paint := paint
        setPaint(paint)
    }

    @private
    @external
    method setPaint(paint:Paint)

    ============================================================================
    Fills the entire drawable area with the current paint.
    ============================================================================
    @external
    method clear()

    ============================================================================
    Fills the given shape with the current paint.
    ============================================================================
    @external
    method fill(shape:Shape)

    @external
    method stroke(shape:Shape)

    @external
    method drawImage(image:Image, bounds:Rectangle)

    ============================================================================
    Notifies the rendering engine that drawing is complete and the frame is
    ready to be displayed. This method is called automatically during a Window's
    render loop, but if you are not using `Window.startRenderLoop()` you will
    need to call it manually at the end of every frame.
    ============================================================================
    @external
    method present()

    @private
    @external
    method close() 

    @override
    method finalize() {
        close()
    }
}